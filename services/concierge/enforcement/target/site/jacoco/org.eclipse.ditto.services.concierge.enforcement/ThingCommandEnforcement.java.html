<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ThingCommandEnforcement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Eclipse Ditto :: Services :: Concierge :: Enforcement</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.ditto.services.concierge.enforcement</a> &gt; <span class="el_source">ThingCommandEnforcement.java</span></div><h1>ThingCommandEnforcement.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Bosch Software Innovations GmbH.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/index.php
 *
 * Contributors:
 *    Bosch Software Innovations GmbH - initial contribution
 */
package org.eclipse.ditto.services.concierge.enforcement;

import static java.util.Objects.requireNonNull;
import static org.eclipse.ditto.model.things.Permission.ADMINISTRATE;
import static org.eclipse.ditto.services.models.policies.Permission.MIN_REQUIRED_POLICY_PERMISSIONS;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletionStage;
import java.util.function.BiFunction;

import org.eclipse.ditto.json.JsonFactory;
import org.eclipse.ditto.json.JsonFieldSelector;
import org.eclipse.ditto.json.JsonFieldSelectorBuilder;
import org.eclipse.ditto.json.JsonObject;
import org.eclipse.ditto.json.JsonObjectBuilder;
import org.eclipse.ditto.json.JsonValue;
import org.eclipse.ditto.model.base.auth.AuthorizationContext;
import org.eclipse.ditto.model.base.auth.AuthorizationSubject;
import org.eclipse.ditto.model.base.exceptions.DittoRuntimeException;
import org.eclipse.ditto.model.base.headers.DittoHeaders;
import org.eclipse.ditto.model.base.headers.WithDittoHeaders;
import org.eclipse.ditto.model.base.json.FieldType;
import org.eclipse.ditto.model.base.json.JsonSchemaVersion;
import org.eclipse.ditto.model.enforcers.AclEnforcer;
import org.eclipse.ditto.model.enforcers.Enforcer;
import org.eclipse.ditto.model.enforcers.PolicyEnforcers;
import org.eclipse.ditto.model.policies.Permissions;
import org.eclipse.ditto.model.policies.PoliciesModelFactory;
import org.eclipse.ditto.model.policies.PoliciesResourceType;
import org.eclipse.ditto.model.policies.Policy;
import org.eclipse.ditto.model.policies.ResourceKey;
import org.eclipse.ditto.model.policies.Subject;
import org.eclipse.ditto.model.policies.SubjectId;
import org.eclipse.ditto.model.policies.SubjectIssuer;
import org.eclipse.ditto.model.things.AccessControlList;
import org.eclipse.ditto.model.things.AclInvalidException;
import org.eclipse.ditto.model.things.AclNotAllowedException;
import org.eclipse.ditto.model.things.AclValidator;
import org.eclipse.ditto.model.things.Thing;
import org.eclipse.ditto.services.concierge.cache.IdentityCache;
import org.eclipse.ditto.services.models.concierge.EntityId;
import org.eclipse.ditto.services.models.concierge.cache.Entry;
import org.eclipse.ditto.services.models.policies.Permission;
import org.eclipse.ditto.services.models.policies.PoliciesAclMigrations;
import org.eclipse.ditto.services.models.policies.PoliciesValidator;
import org.eclipse.ditto.services.utils.cache.Cache;
import org.eclipse.ditto.signals.commands.base.CommandToExceptionRegistry;
import org.eclipse.ditto.signals.commands.policies.PolicyCommand;
import org.eclipse.ditto.signals.commands.policies.exceptions.PolicyConflictException;
import org.eclipse.ditto.signals.commands.policies.exceptions.PolicyNotAccessibleException;
import org.eclipse.ditto.signals.commands.policies.exceptions.PolicyUnavailableException;
import org.eclipse.ditto.signals.commands.policies.modify.CreatePolicy;
import org.eclipse.ditto.signals.commands.policies.modify.CreatePolicyResponse;
import org.eclipse.ditto.signals.commands.policies.query.RetrievePolicy;
import org.eclipse.ditto.signals.commands.policies.query.RetrievePolicyResponse;
import org.eclipse.ditto.signals.commands.things.ThingCommand;
import org.eclipse.ditto.signals.commands.things.ThingCommandResponse;
import org.eclipse.ditto.signals.commands.things.ThingErrorResponse;
import org.eclipse.ditto.signals.commands.things.exceptions.PolicyIdNotAllowedException;
import org.eclipse.ditto.signals.commands.things.exceptions.PolicyInvalidException;
import org.eclipse.ditto.signals.commands.things.exceptions.ThingCommandToAccessExceptionRegistry;
import org.eclipse.ditto.signals.commands.things.exceptions.ThingCommandToModifyExceptionRegistry;
import org.eclipse.ditto.signals.commands.things.exceptions.ThingNotAccessibleException;
import org.eclipse.ditto.signals.commands.things.exceptions.ThingNotCreatableException;
import org.eclipse.ditto.signals.commands.things.exceptions.ThingNotModifiableException;
import org.eclipse.ditto.signals.commands.things.exceptions.ThingUnavailableException;
import org.eclipse.ditto.signals.commands.things.modify.CreateThing;
import org.eclipse.ditto.signals.commands.things.modify.ModifyThing;
import org.eclipse.ditto.signals.commands.things.modify.ThingModifyCommand;
import org.eclipse.ditto.signals.commands.things.query.RetrieveThing;
import org.eclipse.ditto.signals.commands.things.query.RetrieveThingResponse;
import org.eclipse.ditto.signals.commands.things.query.ThingQueryCommand;
import org.eclipse.ditto.signals.commands.things.query.ThingQueryCommandResponse;

import akka.actor.ActorRef;
import akka.event.DiagnosticLoggingAdapter;
import akka.pattern.AskTimeoutException;
import akka.pattern.PatternsCS;

/**
 * Authorize {@code ThingCommand}.
 */
public final class ThingCommandEnforcement extends AbstractEnforcement&lt;ThingCommand&gt; {

    /**
     * Label of default policy entry in default policy.
     */
    private static final String DEFAULT_POLICY_ENTRY_LABEL = &quot;DEFAULT&quot;;

    /**
     * Json fields that are always shown regardless of authorization.
     */
<span class="fc" id="L108">    private static final JsonFieldSelector THING_QUERY_COMMAND_RESPONSE_WHITELIST =</span>
<span class="fc" id="L109">            JsonFactory.newFieldSelector(Thing.JsonFields.ID);</span>

    private final List&lt;SubjectIssuer&gt; subjectIssuersForPolicyMigration;
    private final ActorRef thingsShardRegion;
    private final ActorRef policiesShardRegion;
    private final EnforcerRetriever thingEnforcerRetriever;
    private final EnforcerRetriever policyEnforcerRetriever;
    private final Cache&lt;EntityId, Entry&lt;EntityId&gt;&gt; thingIdCache;
    private final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; policyEnforcerCache;
    private final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; aclEnforcerCache;

    private ThingCommandEnforcement(final Context data, final ActorRef thingsShardRegion,
            final ActorRef policiesShardRegion, final Cache&lt;EntityId, Entry&lt;EntityId&gt;&gt; thingIdCache,
            final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; policyEnforcerCache,
            final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; aclEnforcerCache,
            final List&lt;SubjectIssuer&gt; subjectIssuersForPolicyMigration) {

<span class="fc" id="L126">        super(data);</span>
<span class="fc" id="L127">        this.thingsShardRegion = requireNonNull(thingsShardRegion);</span>
<span class="fc" id="L128">        this.policiesShardRegion = requireNonNull(policiesShardRegion);</span>
<span class="fc" id="L129">        this.subjectIssuersForPolicyMigration = requireNonNull(subjectIssuersForPolicyMigration);</span>

<span class="fc" id="L131">        this.thingIdCache = requireNonNull(thingIdCache);</span>
<span class="fc" id="L132">        this.policyEnforcerCache = requireNonNull(policyEnforcerCache);</span>
<span class="fc" id="L133">        this.aclEnforcerCache = requireNonNull(aclEnforcerCache);</span>
<span class="fc" id="L134">        thingEnforcerRetriever =</span>
<span class="fc" id="L135">                PolicyOrAclEnforcerRetrieverFactory.create(thingIdCache, policyEnforcerCache, aclEnforcerCache);</span>
<span class="fc" id="L136">        policyEnforcerRetriever = new EnforcerRetriever(IdentityCache.INSTANCE, policyEnforcerCache);</span>
<span class="fc" id="L137">    }</span>

    /**
     * Authorize a thing command. Either the command is forwarded to things-shard-region for execution or
     * the sender is told of an error.
     *
     * @param signal the command to authorize.
     * @param sender of the command.
     * @param log the logger to use for logging.
     */
    @Override
    public void enforce(final ThingCommand signal, final ActorRef sender, final DiagnosticLoggingAdapter log) {
<span class="fc" id="L149">        thingEnforcerRetriever.retrieve(entityId(), (enforcerKeyEntry, enforcerEntry) -&gt; {</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">            if (!enforcerEntry.exists()) {</span>
<span class="fc" id="L151">                enforceThingCommandByNonexistentEnforcer(enforcerKeyEntry, signal, sender);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">            } else if (isAclEnforcer(enforcerKeyEntry)) {</span>
<span class="fc" id="L153">                enforceThingCommandByAclEnforcer(signal, enforcerEntry.getValue(), sender);</span>
            } else {
<span class="fc" id="L155">                final String policyId = enforcerKeyEntry.getValue().getId();</span>
<span class="fc" id="L156">                enforceThingCommandByPolicyEnforcer(signal, policyId, enforcerEntry.getValue(), sender);</span>
            }
<span class="fc" id="L158">        });</span>
<span class="fc" id="L159">    }</span>

    /**
     * Provides {@link AbstractEnforcement} for commands of type {@link ThingCommand}.
     */
    public static final class Provider implements EnforcementProvider&lt;ThingCommand&gt; {

<span class="fc" id="L166">        private static final List&lt;SubjectIssuer&gt; DEFAULT_SUBJECT_ISSUERS_FOR_POLICY_MIGRATION =</span>
<span class="fc" id="L167">                Collections.singletonList(SubjectIssuer.GOOGLE);</span>
        private final ActorRef thingsShardRegion;
        private final ActorRef policiesShardRegion;
        private final Cache&lt;EntityId, Entry&lt;EntityId&gt;&gt; thingIdCache;
        private final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; policyEnforcerCache;
        private final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; aclEnforcerCache;
        private final List&lt;SubjectIssuer&gt; subjectIssuersForPolicyMigration;

        /**
         * Constructor.
         *
         * @param thingsShardRegion the ActorRef to the Things shard region.
         * @param policiesShardRegion the ActorRef to the Policies shard region.
         * @param thingIdCache the thing-id-cache.
         * @param policyEnforcerCache the policy-enforcer cache.
         * @param aclEnforcerCache the acl-enforcer cache.
         */
        public Provider(final ActorRef thingsShardRegion,
                final ActorRef policiesShardRegion, final Cache&lt;EntityId, Entry&lt;EntityId&gt;&gt; thingIdCache,
                final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; policyEnforcerCache,
                final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; aclEnforcerCache) {
<span class="fc" id="L188">            this(thingsShardRegion, policiesShardRegion, thingIdCache, policyEnforcerCache, aclEnforcerCache,</span>
                    DEFAULT_SUBJECT_ISSUERS_FOR_POLICY_MIGRATION);
<span class="fc" id="L190">        }</span>

        /**
         * Constructor.
         *
         * @param thingsShardRegion the ActorRef to the Things shard region.
         * @param policiesShardRegion the ActorRef to the Policies shard region.
         * @param thingIdCache the thing-id-cache.
         * @param policyEnforcerCache the policy-enforcer cache.
         * @param aclEnforcerCache the acl-enforcer cache.
         * @param subjectIssuersForPolicyMigration a list of {@link SubjectIssuer}s for which a {@link Subject} will
         * be created per ACL SID. E.g. when {@link SubjectIssuer#GOOGLE} is specified, for the ACL SID &quot;123&quot;, a
         * {@link Subject} &quot;google:123&quot; will be created.
         */
        public Provider(final ActorRef thingsShardRegion,
                final ActorRef policiesShardRegion, final Cache&lt;EntityId, Entry&lt;EntityId&gt;&gt; thingIdCache,
                final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; policyEnforcerCache,
                final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; aclEnforcerCache,
<span class="fc" id="L208">                final List&lt;SubjectIssuer&gt; subjectIssuersForPolicyMigration) {</span>
<span class="fc" id="L209">            this.thingsShardRegion = requireNonNull(thingsShardRegion);</span>
<span class="fc" id="L210">            this.policiesShardRegion = requireNonNull(policiesShardRegion);</span>
<span class="fc" id="L211">            this.thingIdCache = requireNonNull(thingIdCache);</span>
<span class="fc" id="L212">            this.policyEnforcerCache = requireNonNull(policyEnforcerCache);</span>
<span class="fc" id="L213">            this.aclEnforcerCache = requireNonNull(aclEnforcerCache);</span>
<span class="fc" id="L214">            this.subjectIssuersForPolicyMigration = requireNonNull(subjectIssuersForPolicyMigration);</span>
<span class="fc" id="L215">        }</span>

        @Override
        public Class&lt;ThingCommand&gt; getCommandClass() {
<span class="fc" id="L219">            return ThingCommand.class;</span>
        }

        @Override
        public boolean isApplicable(final ThingCommand command) {
            // live commands are not applicable for thing command enforcement
            // because they should never be forwarded to things shard region
<span class="fc bfc" id="L226" title="All 2 branches covered.">            return !LiveSignalEnforcement.isLiveSignal(command);</span>
        }

        @Override
        public AbstractEnforcement&lt;ThingCommand&gt; createEnforcement(final AbstractEnforcement.Context context) {
<span class="fc" id="L231">            return new ThingCommandEnforcement(context, thingsShardRegion, policiesShardRegion, thingIdCache,</span>
                    policyEnforcerCache, aclEnforcerCache, subjectIssuersForPolicyMigration
            );
        }
    }

    /**
     * Authorize a thing command in the absence of an enforcer. This happens when the thing did
     * not exist or when the policy of the thing does not exist.
     *
     * @param enforcerKeyEntry cache entry in the entity ID cache for the enforcer cache key.
     * @param thingCommand the command to authorize.
     * @param sender sender of the command.
     */
    private void enforceThingCommandByNonexistentEnforcer(final Entry&lt;EntityId&gt; enforcerKeyEntry,
            final ThingCommand thingCommand, final ActorRef sender) {
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (enforcerKeyEntry.exists()) {</span>
            // Thing exists but its policy is deleted.
<span class="fc" id="L249">            final String thingId = thingCommand.getThingId();</span>
<span class="fc" id="L250">            final String policyId = enforcerKeyEntry.getValue().getId();</span>
<span class="fc" id="L251">            final DittoRuntimeException error = errorForExistingThingWithDeletedPolicy(thingCommand, thingId, policyId);</span>
<span class="fc" id="L252">            log(thingCommand).info(&quot;Enforcer was not existing for Thing &lt;{}&gt;, responding with: {}&quot;, thingId, error);</span>
<span class="fc" id="L253">            replyToSender(error, sender);</span>
<span class="fc" id="L254">        } else {</span>
            // Without prior enforcer in cache, enforce CreateThing by self.
<span class="fc" id="L256">            enforceCreateThingBySelf(thingCommand, sender).ifPresent(pair -&gt;</span>
<span class="fc" id="L257">                    handleInitialCreateThing(pair.createThing, pair.enforcer, sender));</span>
        }
<span class="fc" id="L259">    }</span>

    /**
     * Authorize a thing command by ACL enforcer with special handling for the field &quot;/acl&quot;.
     *
     * @param thingCommand the thing command.
     * @param enforcer the ACL enforcer.
     * @param sender sender of the command.
     */
    private void enforceThingCommandByAclEnforcer(final ThingCommand&lt;?&gt; thingCommand, final Enforcer enforcer,
            final ActorRef sender) {
<span class="fc" id="L270">        final Optional&lt;? extends ThingCommand&gt; authorizedCommand = authorizeByAcl(enforcer, thingCommand);</span>

<span class="fc bfc" id="L272" title="All 2 branches covered.">        if (authorizedCommand.isPresent()) {</span>
<span class="fc" id="L273">            final ThingCommand commandWithReadSubjects = authorizedCommand.get();</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">            if (commandWithReadSubjects instanceof RetrieveThing &amp;&amp;</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">                    shouldRetrievePolicyWithThing(commandWithReadSubjects)) {</span>
<span class="nc" id="L276">                final RetrieveThing retrieveThing = (RetrieveThing) commandWithReadSubjects;</span>
<span class="nc" id="L277">                retrieveThingAclAndMigrateToPolicy(retrieveThing, enforcer, sender);</span>
<span class="nc" id="L278">            } else {</span>
<span class="fc" id="L279">                forwardToThingsShardRegion(commandWithReadSubjects, sender);</span>
            }
<span class="fc" id="L281">        } else {</span>
<span class="fc" id="L282">            respondWithError(thingCommand, sender, self());</span>
        }
<span class="fc" id="L284">    }</span>

    private void retrieveThingAclAndMigrateToPolicy(final RetrieveThing retrieveThing,
            final Enforcer enforcer,
            final ActorRef sender) {
        final JsonFieldSelectorBuilder jsonFieldSelectorBuilder =
<span class="nc" id="L290">                JsonFactory.newFieldSelectorBuilder().addFieldDefinition(Thing.JsonFields.ACL);</span>
<span class="nc" id="L291">        retrieveThing.getSelectedFields().ifPresent(jsonFieldSelectorBuilder::addPointers);</span>
<span class="nc" id="L292">        final DittoHeaders dittoHeaders = retrieveThing</span>
<span class="nc" id="L293">                .getDittoHeaders()</span>
<span class="nc" id="L294">                .toBuilder()</span>
<span class="nc" id="L295">                .schemaVersion(JsonSchemaVersion.V_1)</span>
<span class="nc" id="L296">                .build();</span>
<span class="nc" id="L297">        final RetrieveThing retrieveThingV1 = RetrieveThing.getBuilder(retrieveThing.getThingId(), dittoHeaders)</span>
<span class="nc" id="L298">                .withSelectedFields(jsonFieldSelectorBuilder.build())</span>
<span class="nc" id="L299">                .build();</span>
<span class="nc" id="L300">        PatternsCS.ask(thingsShardRegion, retrieveThingV1, getAskTimeout().toMillis())</span>
<span class="nc" id="L301">                .handleAsync((response, error) -&gt; {</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">                    if (response instanceof RetrieveThingResponse) {</span>
<span class="nc" id="L303">                        final RetrieveThingResponse retrieveThingResponse = (RetrieveThingResponse) response;</span>
<span class="nc" id="L304">                        final Optional&lt;AccessControlList&gt; aclOptional =</span>
<span class="nc" id="L305">                                retrieveThingResponse.getThing().getAccessControlList();</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                        if (aclOptional.isPresent()) {</span>
<span class="nc" id="L307">                            final Policy policy =</span>
<span class="nc" id="L308">                                    PoliciesAclMigrations.accessControlListToPolicyEntries(aclOptional.get(),</span>
<span class="nc" id="L309">                                            retrieveThing.getThingId(), subjectIssuersForPolicyMigration);</span>
<span class="nc" id="L310">                            reportAggregatedThingAndPolicy(retrieveThing,</span>
<span class="nc" id="L311">                                    retrieveThingResponse.setDittoHeaders(retrieveThing.getDittoHeaders()),</span>
                                    policy, enforcer, sender);
<span class="nc" id="L313">                        } else {</span>
<span class="nc" id="L314">                            replyToSender(retrieveThingResponse.setDittoHeaders(retrieveThing.getDittoHeaders()),</span>
                                    sender);
                        }
<span class="nc bnc" id="L317" title="All 2 branches missed.">                    } else if (response instanceof WithDittoHeaders) {</span>
<span class="nc" id="L318">                        final WithDittoHeaders withDittoHeaders = (WithDittoHeaders) response;</span>
<span class="nc" id="L319">                        replyToSender(withDittoHeaders.setDittoHeaders(retrieveThing.getDittoHeaders()), sender);</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">                    } else if (isAskTimeoutException(response, error)) {</span>
<span class="nc" id="L321">                        reportThingUnavailable(retrieveThing.getThingId(), retrieveThing.getDittoHeaders(), sender);</span>
                    } else {
<span class="nc" id="L323">                        reportUnexpectedErrorOrResponse(&quot;retrieving thing for ACL migration&quot;,</span>
<span class="nc" id="L324">                                sender, response, error, retrieveThing.getDittoHeaders());</span>
                    }
<span class="nc" id="L326">                    return null;</span>
                });
<span class="nc" id="L328">    }</span>

    /**
     * Authorize a thing command by policy enforcer with view restriction for query commands.
     *
     * @param thingCommand the thing command.
     * @param policyId Id of the thing's policy.
     * @param enforcer the policy enforcer.
     * @param sender sender of the command.
     */
    private void enforceThingCommandByPolicyEnforcer(final ThingCommand&lt;?&gt; thingCommand,
            final String policyId,
            final Enforcer enforcer,
            final ActorRef sender) {
<span class="fc" id="L342">        final boolean authorized = authorizeByPolicy(enforcer, thingCommand)</span>
<span class="fc" id="L343">                .map(commandWithReadSubjects -&gt; {</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">                    if (commandWithReadSubjects instanceof ThingQueryCommand) {</span>
<span class="fc" id="L345">                        final ThingQueryCommand thingQueryCommand = (ThingQueryCommand) commandWithReadSubjects;</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">                        if (thingQueryCommand instanceof RetrieveThing &amp;&amp;</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">                                shouldRetrievePolicyWithThing(thingQueryCommand)) {</span>

<span class="fc" id="L349">                            final RetrieveThing retrieveThing = (RetrieveThing) thingQueryCommand;</span>
<span class="fc" id="L350">                            return retrieveThingAndPolicy(retrieveThing, policyId, enforcer, sender);</span>
                        } else {
<span class="fc" id="L352">                            return askThingsShardRegionAndBuildJsonView(thingQueryCommand, enforcer, sender);</span>
                        }
                    } else {
<span class="fc" id="L355">                        return forwardToThingsShardRegion(commandWithReadSubjects, sender);</span>
                    }
                })
<span class="fc" id="L358">                .isPresent();</span>

<span class="fc bfc" id="L360" title="All 2 branches covered.">        if (!authorized) {</span>
<span class="fc" id="L361">            respondWithError(thingCommand, sender, self());</span>
        }
<span class="fc" id="L363">    }</span>

    /**
     * Responds to the passed {@code sender} with an error based on the type of the passed in {@code thingCommand}.
     *
     * @param thingCommand the ThingCommand to use for determining which error to send back
     * @param sender the sender to send back the error to
     * @param self the self reference
     */
    static void respondWithError(final ThingCommand thingCommand, final ActorRef sender, final ActorRef self) {
<span class="fc" id="L373">        sender.tell(errorForThingCommand(thingCommand), self);</span>
<span class="fc" id="L374">    }</span>

    /**
     * Retrieve for response of a query command and limit the response
     * according to a policy
     * enforcer.
     *
     * @param commandWithReadSubjects the command to ask.
     * @param enforcer enforcer to build JsonView with.
     * @param sender sender of the command.
     * @return always {@code true}.
     */
    private boolean askThingsShardRegionAndBuildJsonView(
            final ThingQueryCommand commandWithReadSubjects,
            final Enforcer enforcer,
            final ActorRef sender) {

<span class="fc" id="L391">        PatternsCS.ask(thingsShardRegion, commandWithReadSubjects, getAskTimeout().toMillis())</span>
<span class="fc" id="L392">                .handleAsync((response, error) -&gt; {</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">                    if (response instanceof ThingQueryCommandResponse) {</span>
<span class="fc" id="L394">                        reportJsonViewForThingQuery(sender, (ThingQueryCommandResponse) response, enforcer);</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">                    } else if (response instanceof DittoRuntimeException) {</span>
<span class="fc" id="L396">                        replyToSender(response, sender);</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">                    } else if (isAskTimeoutException(response, error)) {</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">                        final AskTimeoutException askTimeoutException = error instanceof AskTimeoutException</span>
                                ? (AskTimeoutException) error
                                : (AskTimeoutException) response;
<span class="nc" id="L401">                        reportTimeoutForThingQuery(commandWithReadSubjects, sender, askTimeoutException);</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">                    } else if (error != null) {</span>
<span class="nc" id="L403">                        reportUnexpectedError(&quot;before building JsonView&quot;, sender, error,</span>
<span class="nc" id="L404">                                commandWithReadSubjects.getDittoHeaders());</span>
                    } else {
<span class="nc" id="L406">                        reportUnknownResponse(&quot;before building JsonView&quot;, sender, response,</span>
<span class="nc" id="L407">                                commandWithReadSubjects.getDittoHeaders());</span>
                    }
<span class="fc" id="L409">                    return null;</span>
                });
<span class="fc" id="L411">        return true;</span>
    }

    /**
     * Retrieve a thing and its policy and combine them into a response.
     *
     * @param retrieveThing the retrieve-thing command.
     * @param policyId ID of the thing's policy.
     * @param enforcer the enforcer for the command.
     * @param sender sender of the command.
     * @return always {@code true}.
     */
    private boolean retrieveThingAndPolicy(
            final RetrieveThing retrieveThing,
            final String policyId,
            final Enforcer enforcer,
            final ActorRef sender) {

<span class="fc" id="L429">        final Optional&lt;RetrievePolicy&gt; retrievePolicyOptional = PolicyCommandEnforcement.authorizePolicyCommand(</span>
<span class="fc" id="L430">                RetrievePolicy.of(policyId, retrieveThing.getDittoHeaders()), enforcer);</span>

<span class="fc bfc" id="L432" title="All 2 branches covered.">        if (retrievePolicyOptional.isPresent()) {</span>
<span class="fc" id="L433">            retrieveThingBeforePolicy(retrieveThing, sender).thenAccept(thingResponse -&gt;</span>
<span class="fc" id="L434">                    thingResponse.ifPresent(retrieveThingResponse -&gt; {</span>
<span class="fc" id="L435">                        final RetrievePolicy retrievePolicy = retrievePolicyOptional.get();</span>
<span class="fc" id="L436">                        retrieveInlinedPolicyForThing(retrieveThing, retrievePolicy).thenAccept(policyResponse -&gt; {</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">                            if (policyResponse.isPresent()) {</span>
<span class="fc" id="L438">                                final RetrievePolicyResponse filteredPolicyResponse =</span>
<span class="fc" id="L439">                                        PolicyCommandEnforcement.buildJsonViewForPolicyQueryCommandResponse(</span>
<span class="fc" id="L440">                                                policyResponse.get(), enforcer);</span>
<span class="fc" id="L441">                                reportAggregatedThingAndPolicyResponse(retrieveThing, retrieveThingResponse,</span>
                                        filteredPolicyResponse, enforcer, sender);
<span class="fc" id="L443">                            } else {</span>
<span class="fc" id="L444">                                replyToSender(retrieveThingResponse, sender);</span>
                            }
<span class="fc" id="L446">                        });</span>
<span class="fc" id="L447">                    }));</span>
<span class="fc" id="L448">            return true;</span>
        } else {
            // sender is not authorized to view the policy, ignore the request to embed policy.
<span class="fc" id="L451">            return askThingsShardRegionAndBuildJsonView(retrieveThing, enforcer, sender);</span>
        }
    }

    /**
     * Retrieve a thing before retrieving its inlined policy. Report errors to sender.
     *
     * @param retrieveThing the command.
     * @param sender whom to report errors to.
     * @return future response from things-shard-region.
     */
    private CompletionStage&lt;Optional&lt;RetrieveThingResponse&gt;&gt; retrieveThingBeforePolicy(
            final RetrieveThing retrieveThing,
            final ActorRef sender) {

<span class="fc" id="L466">        return PatternsCS.ask(thingsShardRegion, retrieveThing, getAskTimeout().toMillis())</span>
<span class="fc" id="L467">                .handleAsync((response, error) -&gt; {</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">                    if (response instanceof RetrieveThingResponse) {</span>
<span class="fc" id="L469">                        return Optional.of((RetrieveThingResponse) response);</span>
<span class="pc bpc" id="L470" title="2 of 4 branches missed.">                    } else if (response instanceof ThingErrorResponse || response instanceof DittoRuntimeException) {</span>
<span class="nc" id="L471">                        replyToSender(response, sender);</span>
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">                    } else if (isAskTimeoutException(response, error)) {</span>
<span class="fc" id="L473">                        reportThingUnavailable(retrieveThing.getThingId(), retrieveThing.getDittoHeaders(), sender);</span>
                    } else {
<span class="nc" id="L475">                        reportUnexpectedErrorOrResponse(&quot;retrieving thing before inlined policy&quot;,</span>
<span class="nc" id="L476">                                sender, response, error, retrieveThing.getDittoHeaders());</span>
                    }
<span class="fc" id="L478">                    return Optional.empty();</span>
                });
    }

    private void reportThingUnavailable(final String thingId, final DittoHeaders dittoHeaders, final ActorRef sender) {
<span class="fc" id="L483">        final ThingUnavailableException thingUnavailableException =</span>
<span class="fc" id="L484">                ThingUnavailableException.newBuilder(thingId).dittoHeaders(dittoHeaders).build();</span>
<span class="fc" id="L485">        replyToSender(thingUnavailableException, sender);</span>
<span class="fc" id="L486">    }</span>

    /**
     * Retrieve inlined policy after retrieving a thing. Do not report errors.
     *
     * @param retrieveThing the original command.
     * @param retrievePolicy the command to retrieve the thing's policy.
     * @return future response from policies-shard-region.
     */
    private CompletionStage&lt;Optional&lt;RetrievePolicyResponse&gt;&gt; retrieveInlinedPolicyForThing(
            final RetrieveThing retrieveThing,
            final RetrievePolicy retrievePolicy) {

<span class="fc" id="L499">        return PatternsCS.ask(policiesShardRegion, retrievePolicy, getAskTimeout().toMillis())</span>
<span class="fc" id="L500">                .handleAsync((response, error) -&gt; {</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">                    if (response instanceof RetrievePolicyResponse) {</span>
<span class="fc" id="L502">                        return Optional.of((RetrievePolicyResponse) response);</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">                    } else if (error != null) {</span>
<span class="nc" id="L504">                        log(error).error(error, &quot;retrieving inlined policy after RetrieveThing&quot;);</span>
                    } else {
<span class="fc" id="L506">                        log(response).info(</span>
                                &quot;No authorized response when retrieving inlined policy &lt;{}&gt; for thing &lt;{}&gt;: {}&quot;,
<span class="fc" id="L508">                                retrievePolicy.getId(), retrieveThing.getThingId(), response);</span>
                    }
<span class="fc" id="L510">                    return Optional.empty();</span>
                });
    }

    /**
     * Put thing and policy together as response to the sender.
     *
     * @param retrieveThing the original command.
     * @param retrieveThingResponse response from things-shard-region.
     * @param retrievePolicyResponse response from policies-shard-region.
     * @param enforcer enforcer to bulid the Json view.
     * @param sender sender of the original command.
     */
    private void reportAggregatedThingAndPolicyResponse(
            final RetrieveThing retrieveThing,
            final RetrieveThingResponse retrieveThingResponse,
            final RetrievePolicyResponse retrievePolicyResponse,
            final Enforcer enforcer,
            final ActorRef sender) {

<span class="fc" id="L530">        reportAggregatedThingAndPolicy(retrieveThing, retrieveThingResponse, retrievePolicyResponse.getPolicy(),</span>
                enforcer, sender);
<span class="fc" id="L532">    }</span>

    private void reportAggregatedThingAndPolicy(
            final RetrieveThing retrieveThing,
            final RetrieveThingResponse retrieveThingResponse,
            final Policy policy,
            final Enforcer enforcer,
            final ActorRef sender) {

<span class="fc" id="L541">        final RetrieveThingResponse limitedView =</span>
<span class="fc" id="L542">                buildJsonViewForThingQueryCommandResponse(retrieveThingResponse, enforcer);</span>

<span class="fc" id="L544">        final JsonObject inlinedPolicy =</span>
<span class="fc" id="L545">                policy.toInlinedJson(retrieveThing.getImplementedSchemaVersion(), FieldType.notHidden());</span>

<span class="fc" id="L547">        final JsonObject thingWithInlinedPolicy = limitedView.getEntity().asObject().toBuilder()</span>
<span class="fc" id="L548">                .setAll(inlinedPolicy)</span>
<span class="fc" id="L549">                .build();</span>

<span class="fc" id="L551">        replyToSender(limitedView.setEntity(thingWithInlinedPolicy), sender);</span>
<span class="fc" id="L552">    }</span>

    /**
     * Report timeout of {@code ThingQueryComand}.
     *
     * @param command the original command.
     * @param sender sender of the command.
     * @param askTimeoutException the timeout exception.
     */
    private void reportTimeoutForThingQuery(
            final ThingQueryCommand command,
            final ActorRef sender,
            final AskTimeoutException askTimeoutException) {
<span class="nc" id="L565">        log(command).error(askTimeoutException, &quot;Timeout before building JsonView&quot;);</span>
<span class="nc" id="L566">        replyToSender(ThingUnavailableException.newBuilder(command.getThingId())</span>
<span class="nc" id="L567">                .dittoHeaders(command.getDittoHeaders())</span>
<span class="nc" id="L568">                .build(), sender);</span>
<span class="nc" id="L569">    }</span>

    /**
     * Mixin-private: report thing query response with view on entity restricted by enforcer.
     *
     * @param sender sender of the command.
     * @param thingQueryCommandResponse response of query.
     * @param enforcer the enforcer.
     */
    private void reportJsonViewForThingQuery(final ActorRef sender,
            final ThingQueryCommandResponse&lt;?&gt; thingQueryCommandResponse,
            final Enforcer enforcer) {

        try {
<span class="fc" id="L583">            final ThingQueryCommandResponse responseWithLimitedJsonView =</span>
<span class="fc" id="L584">                    buildJsonViewForThingQueryCommandResponse(thingQueryCommandResponse, enforcer);</span>
<span class="fc" id="L585">            replyToSender(responseWithLimitedJsonView, sender);</span>
<span class="nc" id="L586">        } catch (final RuntimeException e) {</span>
<span class="nc" id="L587">            reportError(&quot;Error after building JsonView&quot;, sender, e, thingQueryCommandResponse.getDittoHeaders());</span>
<span class="fc" id="L588">        }</span>
<span class="fc" id="L589">    }</span>

    /**
     * Query caches again to authorize a {@code CreateThing} command with explicit policy ID and no inline policy.
     *
     * @param createThing the command.
     * @param policyId the policy ID.
     * @param sender sender of the command.
     */
    private void enforceCreateThingForNonexistentThingWithPolicyId(final CreateThing createThing,
            final String policyId,
            final ActorRef sender) {
<span class="fc" id="L601">        final EntityId policyEntityId = EntityId.of(PolicyCommand.RESOURCE_TYPE, policyId);</span>
<span class="fc" id="L602">        policyEnforcerRetriever.retrieve(policyEntityId, (policyIdEntry, policyEnforcerEntry) -&gt; {</span>
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">            if (policyEnforcerEntry.exists()) {</span>
<span class="fc" id="L604">                enforceThingCommandByPolicyEnforcer(createThing, policyId, policyEnforcerEntry.getValue(), sender);</span>
            } else {
<span class="nc" id="L606">                final DittoRuntimeException error =</span>
<span class="nc" id="L607">                        errorForExistingThingWithDeletedPolicy(createThing, createThing.getThingId(), policyId);</span>
<span class="nc" id="L608">                replyToSender(error, sender);</span>
            }
<span class="fc" id="L610">        });</span>
<span class="fc" id="L611">    }</span>

    /**
     * Limit view on entity of {@code ThingQueryCommandResponse} by enforcer.
     *
     * @param response the response.
     * @param enforcer the enforcer.
     * @return response with view on entity restricted by enforcer..
     */
    private static &lt;T extends ThingQueryCommandResponse&gt; T buildJsonViewForThingQueryCommandResponse(
            final ThingQueryCommandResponse&lt;T&gt; response,
            final Enforcer enforcer) {

<span class="fc" id="L624">        final JsonValue entity = response.getEntity();</span>
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">        if (entity.isObject()) {</span>
<span class="fc" id="L626">            final JsonObject filteredView =</span>
<span class="fc" id="L627">                    getJsonViewForThingQueryCommandResponse(entity.asObject(), response, enforcer);</span>
<span class="fc" id="L628">            return response.setEntity(filteredView);</span>
        } else {
<span class="nc" id="L630">            return response.setEntity(entity);</span>
        }
    }

    /**
     * Forward a command to things-shard-region.
     * Do not call {@code Actor.forward(Object, ActorContext)} because it is not thread-safe.
     *
     * @param command command to forward.
     * @param sender sender of the command.
     * @return true.
     */
    private boolean forwardToThingsShardRegion(final ThingCommand command, final ActorRef sender) {
<span class="fc" id="L643">        thingsShardRegion.tell(command, sender);</span>
<span class="fc bfc" id="L644" title="All 4 branches covered.">        if (command instanceof ThingModifyCommand &amp;&amp; ((ThingModifyCommand) command).changesAuthorization()) {</span>
<span class="fc" id="L645">            invalidateThingCaches(command.getThingId());</span>
        }
<span class="fc" id="L647">        return true;</span>
    }

    /**
     * Whenever a Command changed the authorization, the caches must be invalidated - otherwise a directly following
     * Command targeted for the same entity will probably fail as the enforcer was not yet updated.
     *
     * @param thingId the ID of the Thing to invalidate caches for.
     */
    private void invalidateThingCaches(final String thingId) {
<span class="fc" id="L657">        final EntityId entityId = EntityId.of(ThingCommand.RESOURCE_TYPE, thingId);</span>
<span class="fc" id="L658">        thingIdCache.invalidate(entityId);</span>
<span class="fc" id="L659">        aclEnforcerCache.invalidate(entityId);</span>
<span class="fc" id="L660">    }</span>

    private void invalidatePolicyCache(final String policyId) {
<span class="fc" id="L663">        final EntityId entityId = EntityId.of(PolicyCommand.RESOURCE_TYPE, policyId);</span>
<span class="fc" id="L664">        policyEnforcerCache.invalidate(entityId);</span>
<span class="fc" id="L665">    }</span>

    /**
     * Restrict view on a JSON object by enforcer.
     *
     * @param responseEntity the JSON object to restrict view on.
     * @param response the response containing the object.
     * @param enforcer the enforcer.
     * @return JSON object with view restricted by enforcer.
     */
    private static JsonObject getJsonViewForThingQueryCommandResponse(final JsonObject responseEntity,
            final ThingQueryCommandResponse response,
            final Enforcer enforcer) {


<span class="fc" id="L680">        final ResourceKey resourceKey = ResourceKey.newInstance(ThingCommand.RESOURCE_TYPE, response.getResourcePath());</span>
<span class="fc" id="L681">        final AuthorizationContext authorizationContext = response.getDittoHeaders().getAuthorizationContext();</span>

<span class="fc" id="L683">        return enforcer.buildJsonView(resourceKey, responseEntity, authorizationContext,</span>
<span class="fc" id="L684">                THING_QUERY_COMMAND_RESPONSE_WHITELIST, Permissions.newInstance(Permission.READ));</span>
    }


    /**
     * Create error for commands to an existing thing whose policy is deleted.
     *
     * @param thingCommand the triggering command.
     * @param thingId ID of the thing.
     * @param policyId ID of the deleted policy.
     * @return an appropriate error.
     */
    private static DittoRuntimeException errorForExistingThingWithDeletedPolicy(
            final ThingCommand thingCommand,
            final String thingId,
            final String policyId) {

<span class="fc" id="L701">        final String message = String.format(</span>
                &quot;The Thing with ID ''%s'' could not be accessed as its Policy with ID ''%s'' is not or no longer existing.&quot;,
                thingId, policyId);
<span class="fc" id="L704">        final String description = String.format(</span>
                &quot;Recreate/create the Policy with ID ''%s'' in order to get access to the Thing again.&quot;,
                policyId);

<span class="fc bfc" id="L708" title="All 2 branches covered.">        if (thingCommand instanceof ThingModifyCommand) {</span>
<span class="fc" id="L709">            return ThingNotModifiableException.newBuilder(thingId)</span>
<span class="fc" id="L710">                    .message(message)</span>
<span class="fc" id="L711">                    .description(description)</span>
<span class="fc" id="L712">                    .dittoHeaders(thingCommand.getDittoHeaders())</span>
<span class="fc" id="L713">                    .build();</span>
        } else {
<span class="fc" id="L715">            return ThingNotAccessibleException.newBuilder(thingId)</span>
<span class="fc" id="L716">                    .message(message)</span>
<span class="fc" id="L717">                    .description(description)</span>
<span class="fc" id="L718">                    .dittoHeaders(thingCommand.getDittoHeaders())</span>
<span class="fc" id="L719">                    .build();</span>
        }
    }

    /**
     * Create error due to failing to execute a thing-command in the expected way.
     *
     * @param thingCommand the command.
     * @return the error.
     */
    private static DittoRuntimeException errorForThingCommand(final ThingCommand thingCommand) {
<span class="fc bfc" id="L730" title="All 2 branches covered.">        final CommandToExceptionRegistry&lt;ThingCommand, DittoRuntimeException&gt; registry =</span>
                thingCommand instanceof ThingModifyCommand
<span class="fc" id="L732">                        ? ThingCommandToModifyExceptionRegistry.getInstance()</span>
<span class="fc" id="L733">                        : ThingCommandToAccessExceptionRegistry.getInstance();</span>
<span class="fc" id="L734">        return registry.exceptionFrom(thingCommand);</span>
    }

    /**
     * Check if an enforcer key points to an access-control-list enforcer.
     *
     * @param enforcerKeyEntry cache key entry of an enforcer.
     * @return whether it is based on an access control list and requires special handling.
     */
    private static boolean isAclEnforcer(final Entry&lt;EntityId&gt; enforcerKeyEntry) {
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">        return enforcerKeyEntry.exists() &amp;&amp;</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">                Objects.equals(ThingCommand.RESOURCE_TYPE, enforcerKeyEntry.getValue().getResourceType());</span>
    }

    /**
     * Authorize a thing-command by authorization information contained in itself. Only {@code
     * CreateThing} commands are authorized in this manner in the absence of an existing enforcer. {@code
     * ModifyThing} commands are transformed to {@code CreateThing} commands before being processed.
     *
     * @param receivedThingCommand the command to authorize.
     * @return optionally the authorized command extended by  read subjects.
     */
    private Optional&lt;CreateThingWithEnforcer&gt; enforceCreateThingBySelf(
            final ThingCommand receivedThingCommand, final ActorRef sender) {

<span class="fc" id="L759">        final ThingCommand thingCommand = transformModifyThingToCreateThing(receivedThingCommand);</span>
        final Optional&lt;CreateThingWithEnforcer&gt; result;
<span class="fc bfc" id="L761" title="All 2 branches covered.">        if (thingCommand instanceof CreateThing) {</span>
<span class="fc" id="L762">            final CreateThing createThing = (CreateThing) thingCommand;</span>
<span class="fc" id="L763">            final Optional&lt;JsonObject&gt; initialPolicyOptional = createThing.getInitialPolicy();</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">            if (initialPolicyOptional.isPresent()) {</span>
<span class="fc" id="L765">                result = enforceCreateThingByOwnInlinedPolicy(createThing, initialPolicyOptional.get(), sender);</span>
            } else {
<span class="fc" id="L767">                final Optional&lt;AccessControlList&gt; aclOptional =</span>
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">                        createThing.getThing().getAccessControlList().filter(acl -&gt; !acl.isEmpty());</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">                if (aclOptional.isPresent()) {</span>
<span class="fc" id="L770">                    result = enforceCreateThingByOwnAcl(createThing, aclOptional.get(), sender);</span>
                } else {
<span class="fc" id="L772">                    result = enforceCreateThingByAuthorizationContext(createThing);</span>
                }
            }
<span class="fc" id="L775">        } else {</span>
            // Other commands cannot be authorized by ACL or policy contained in self.
<span class="fc" id="L777">            final DittoRuntimeException error =</span>
<span class="fc" id="L778">                    ThingNotAccessibleException.newBuilder(thingCommand.getThingId())</span>
<span class="fc" id="L779">                            .dittoHeaders(thingCommand.getDittoHeaders())</span>
<span class="fc" id="L780">                            .build();</span>
<span class="fc" id="L781">            log(thingCommand).info(&quot;Enforcer was not existing for Thing &lt;{}&gt; and no auth info was inlined, &quot; +</span>
<span class="fc" id="L782">                    &quot;responding with: {}&quot;, thingCommand.getThingId(), error);</span>
<span class="fc" id="L783">            replyToSender(error, sender);</span>
<span class="fc" id="L784">            result = Optional.empty();</span>
        }
<span class="fc" id="L786">        return result;</span>
    }

    private Optional&lt;CreateThingWithEnforcer&gt; enforceCreateThingByAuthorizationContext(final CreateThing createThing) {
        // Command without authorization information is authorized by default.
<span class="fc" id="L791">        final Set&lt;String&gt; authorizedSubjects = createThing.getDittoHeaders()</span>
<span class="fc" id="L792">                .getAuthorizationContext()</span>
<span class="fc" id="L793">                .getFirstAuthorizationSubject()</span>
<span class="fc" id="L794">                .map(subject -&gt; Collections.singleton(subject.getId()))</span>
<span class="fc" id="L795">                .orElse(Collections.emptySet());</span>
<span class="fc" id="L796">        final CreateThing command =</span>
<span class="fc" id="L797">                AbstractEnforcement.addReadSubjectsToSignal(createThing, authorizedSubjects);</span>
<span class="fc" id="L798">        final Enforcer enforcer = new AuthorizedSubjectsEnforcer(authorizedSubjects);</span>
<span class="fc" id="L799">        return Optional.of(new CreateThingWithEnforcer(command, enforcer));</span>
    }

    private Optional&lt;CreateThingWithEnforcer&gt; enforceCreateThingByOwnInlinedPolicy(final CreateThing createThing,
            final JsonObject inlinedPolicy, final ActorRef sender) {
<span class="fc" id="L804">        final Policy initialPolicy = PoliciesModelFactory.newPolicy(inlinedPolicy);</span>
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">        if (PoliciesValidator.newInstance(initialPolicy).isValid()) {</span>
<span class="fc" id="L806">            final Enforcer initialEnforcer = PolicyEnforcers.defaultEvaluator(initialPolicy);</span>
<span class="fc" id="L807">            return attachEnforcerOrReplyWithError(createThing, initialEnforcer,</span>
                    ThingCommandEnforcement::authorizeByPolicy, sender);
        } else {
<span class="nc" id="L810">            final DittoRuntimeException error =</span>
<span class="nc" id="L811">                    PolicyInvalidException.newBuilder(MIN_REQUIRED_POLICY_PERMISSIONS, createThing.getThingId())</span>
<span class="nc" id="L812">                            .dittoHeaders(createThing.getDittoHeaders())</span>
<span class="nc" id="L813">                            .build();</span>
<span class="nc" id="L814">            replyToSender(error, sender);</span>
<span class="nc" id="L815">            return Optional.empty();</span>
        }
    }

    private Optional&lt;CreateThingWithEnforcer&gt; enforceCreateThingByOwnAcl(final CreateThing createThing,
            final AccessControlList acl, final ActorRef sender) {
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">        if (AclValidator.newInstance(acl, Thing.MIN_REQUIRED_PERMISSIONS).isValid()) {</span>
<span class="fc" id="L822">            final Enforcer initialEnforcer = AclEnforcer.of(acl);</span>
<span class="fc" id="L823">            return attachEnforcerOrReplyWithError(createThing, initialEnforcer,</span>
                    ThingCommandEnforcement::authorizeByAcl, sender);
        } else {
<span class="nc" id="L826">            final DittoRuntimeException error = AclInvalidException.newBuilder(createThing.getThingId())</span>
<span class="nc" id="L827">                    .dittoHeaders(createThing.getDittoHeaders())</span>
<span class="nc" id="L828">                    .build();</span>
<span class="nc" id="L829">            replyToSender(error, sender);</span>
<span class="nc" id="L830">            return Optional.empty();</span>
        }

    }

    private Optional&lt;CreateThingWithEnforcer&gt; attachEnforcerOrReplyWithError(final CreateThing command,
            final Enforcer enforcer,
            final BiFunction&lt;Enforcer, ThingCommand&lt;CreateThing&gt;, Optional&lt;CreateThing&gt;&gt; authorization,
            final ActorRef sender) {

<span class="fc" id="L840">        final Optional&lt;CreateThing&gt; authorizedCommand = authorization.apply(enforcer, command);</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">        if (authorizedCommand.isPresent()) {</span>
<span class="fc" id="L842">            return authorizedCommand.map(cmd -&gt; new CreateThingWithEnforcer(cmd, enforcer));</span>
        } else {
<span class="fc" id="L844">            respondWithError(command, sender, self());</span>
<span class="fc" id="L845">            return Optional.empty();</span>
        }
    }

    /**
     * Transform a {@code ModifyThing} command sent to nonexistent thing to {@code CreateThing}
     * command if it is sent to a nonexistent thing.
     *
     * @param receivedCommand the command to transform.
     * @return {@code CreateThing} command containing the same information if the argument is a {@code ModifyThing}
     * command. Otherwise return the command itself.
     */
    private static ThingCommand transformModifyThingToCreateThing(final ThingCommand receivedCommand) {
<span class="fc bfc" id="L858" title="All 2 branches covered.">        if (receivedCommand instanceof ModifyThing) {</span>
<span class="fc" id="L859">            final ModifyThing modifyThing = (ModifyThing) receivedCommand;</span>
<span class="fc" id="L860">            final JsonObject initialPolicy = modifyThing.getInitialPolicy().orElse(null);</span>
<span class="fc" id="L861">            return CreateThing.of(modifyThing.getThing(), initialPolicy, modifyThing.getDittoHeaders());</span>
        } else {
<span class="fc" id="L863">            return receivedCommand;</span>
        }
    }

    /**
     * Authorize a thing-command by a policy enforcer.
     *
     * @param &lt;T&gt; type of the thing-command.
     * @param policyEnforcer the policy enforcer.
     * @param command the command to authorize.
     * @return optionally the authorized command extended by read subjects.
     */
    static &lt;T extends ThingCommand&gt; Optional&lt;T&gt; authorizeByPolicy(final Enforcer policyEnforcer,
            final ThingCommand&lt;T&gt; command) {

<span class="fc" id="L878">        final ResourceKey thingResourceKey = PoliciesResourceType.thingResource(command.getResourcePath());</span>
<span class="fc" id="L879">        final AuthorizationContext authorizationContext = command.getDittoHeaders().getAuthorizationContext();</span>
        final boolean authorized;
<span class="fc bfc" id="L881" title="All 2 branches covered.">        if (command instanceof ThingModifyCommand) {</span>
<span class="fc" id="L882">            final String permission = Permission.WRITE;</span>
<span class="fc" id="L883">            authorized = policyEnforcer.hasUnrestrictedPermissions(thingResourceKey, authorizationContext, permission);</span>
<span class="fc" id="L884">        } else {</span>
<span class="fc" id="L885">            final String permission = Permission.READ;</span>
<span class="fc" id="L886">            authorized = policyEnforcer.hasPartialPermissions(thingResourceKey, authorizationContext, permission);</span>
        }
<span class="fc bfc" id="L888" title="All 2 branches covered.">        return authorized</span>
<span class="fc" id="L889">                ? Optional.of(AbstractEnforcement.addReadSubjectsToThingSignal(command, policyEnforcer))</span>
<span class="fc" id="L890">                : Optional.empty();</span>
    }

    /**
     * Authorize a thing-command by an ACL enforcer.
     *
     * @param &lt;T&gt; type of the thing-command.
     * @param aclEnforcer the ACL enforcer.
     * @param command the command to authorize.
     * @return optionally the authorized command extended by read subjects.
     */
    static &lt;T extends ThingCommand&gt; Optional&lt;T&gt; authorizeByAcl(final Enforcer aclEnforcer,
            final ThingCommand&lt;T&gt; command) {
<span class="fc" id="L903">        final ResourceKey thingResourceKey = PoliciesResourceType.thingResource(command.getResourcePath());</span>
<span class="fc" id="L904">        final AuthorizationContext authorizationContext = command.getDittoHeaders().getAuthorizationContext();</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">        final Permissions permissions = command instanceof ThingModifyCommand</span>
<span class="fc" id="L906">                ? computeAclPermissions((ThingModifyCommand) command)</span>
<span class="fc" id="L907">                : Permissions.newInstance(Permission.READ);</span>
<span class="fc bfc" id="L908" title="All 2 branches covered.">        return aclEnforcer.hasUnrestrictedPermissions(thingResourceKey, authorizationContext, permissions)</span>
<span class="fc" id="L909">                ? Optional.of(AbstractEnforcement.addReadSubjectsToThingSignal(command, aclEnforcer))</span>
<span class="fc" id="L910">                : Optional.empty();</span>
    }

    /**
     * Compute ACL permissions relevant for a {@code ThingModifyCommand}. The field &quot;/acl&quot; is handled
     * specially with the &quot;ADMINISTRATE&quot; permission.
     *
     * @param command the command.
     * @return permissions needed to execute the command.
     */
    private static Permissions computeAclPermissions(final ThingModifyCommand command) {
<span class="fc bfc" id="L921" title="All 2 branches covered.">        return command.changesAuthorization()</span>
<span class="fc" id="L922">                ? Permissions.newInstance(Permission.WRITE, ADMINISTRATE.name())</span>
<span class="fc" id="L923">                : Permissions.newInstance(Permission.WRITE);</span>
    }

    /**
     * Check if inlined policy should be retrieved together with the thing.
     *
     * @param command the thing query command.
     * @return whether it is necessary to retrieve the thing's policy.
     */
    private static boolean shouldRetrievePolicyWithThing(final ThingCommand command) {
<span class="fc" id="L933">        final RetrieveThing retrieveThing = (RetrieveThing) command;</span>
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">        final boolean isNotV1 = JsonSchemaVersion.V_1 != command.getImplementedSchemaVersion();</span>
<span class="pc bpc" id="L935" title="1 of 2 branches missed.">        return isNotV1 &amp;&amp; retrieveThing.getSelectedFields().filter(selector -&gt;</span>
<span class="fc" id="L936">                selector.getPointers().stream().anyMatch(jsonPointer -&gt;</span>
<span class="fc" id="L937">                        jsonPointer.getRoot()</span>
<span class="fc" id="L938">                                .filter(jsonKey -&gt; Policy.INLINED_FIELD_NAME.equals(jsonKey.toString()))</span>
<span class="fc" id="L939">                                .isPresent()))</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">                .isPresent();</span>
    }

    /**
     * A pair of {@code CreateThing} command with {@code Enforcer}.
     */
    private static final class CreateThingWithEnforcer {

        private final CreateThing createThing;
        private final Enforcer enforcer;

        private CreateThingWithEnforcer(final CreateThing createThing,
<span class="fc" id="L952">                final Enforcer enforcer) {</span>
<span class="fc" id="L953">            this.createThing = createThing;</span>
<span class="fc" id="L954">            this.enforcer = enforcer;</span>
<span class="fc" id="L955">        }</span>
    }

    private void handleInitialCreateThing(final CreateThing createThing, final Enforcer enforcer,
            final ActorRef sender) {
<span class="fc bfc" id="L960" title="All 2 branches covered.">        if (shouldCreatePolicyForCreateThing(createThing)) {</span>
<span class="fc" id="L961">            final Optional&lt;DittoRuntimeException&gt; errorOpt = checkForErrorsInCreateThingWithPolicy(createThing);</span>
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">            if (errorOpt.isPresent()) {</span>
<span class="nc" id="L963">                replyToSender(errorOpt.get(), sender);</span>
            } else {
<span class="fc" id="L965">                createThingWithInitialPolicy(createThing, enforcer, sender);</span>
            }
<span class="fc bfc" id="L967" title="All 2 branches covered.">        } else if (createThing.getThing().getPolicyId().isPresent()) {</span>
<span class="fc" id="L968">            final String policyId = createThing.getThing().getPolicyId().orElseThrow(IllegalStateException::new);</span>
<span class="fc" id="L969">            final Optional&lt;DittoRuntimeException&gt; errorOpt = checkForErrorsInCreateThingWithPolicy(createThing);</span>
<span class="pc bpc" id="L970" title="1 of 2 branches missed.">            if (errorOpt.isPresent()) {</span>
<span class="nc" id="L971">                replyToSender(errorOpt.get(), sender);</span>
            } else {
<span class="fc" id="L973">                enforceCreateThingForNonexistentThingWithPolicyId(createThing, policyId, sender);</span>
            }
<span class="fc" id="L975">        } else {</span>
            // nothing to do with policy, simply forward the command
<span class="fc" id="L977">            forwardToThingsShardRegion(createThing, sender);</span>
        }
<span class="fc" id="L979">    }</span>

    private void createThingWithInitialPolicy(final CreateThing createThing,
            final Enforcer enforcer,
            final ActorRef sender) {

        try {
<span class="fc" id="L986">            final Optional&lt;Policy&gt; policy =</span>
<span class="fc" id="L987">                    getInlinedOrDefaultPolicyForCreateThing(createThing);</span>

<span class="pc bpc" id="L989" title="1 of 2 branches missed.">            if (policy.isPresent()) {</span>

<span class="fc" id="L991">                final CreatePolicy createPolicy = CreatePolicy.of(policy.get(), createThing.getDittoHeaders());</span>
<span class="fc" id="L992">                final Optional&lt;CreatePolicy&gt; authorizedCreatePolicy =</span>
<span class="fc" id="L993">                        PolicyCommandEnforcement.authorizePolicyCommand(createPolicy, enforcer);</span>

                // CreatePolicy is rejected; abort CreateThing.
<span class="fc" id="L996">                final boolean created = authorizedCreatePolicy</span>
<span class="fc" id="L997">                        .filter(cmd -&gt; createPolicyAndThing(cmd, createThing, sender))</span>
<span class="fc" id="L998">                        .isPresent();</span>

<span class="fc bfc" id="L1000" title="All 2 branches covered.">                if (!created) {</span>
<span class="fc" id="L1001">                    final DittoRuntimeException error = errorForThingCommand(createThing);</span>
<span class="fc" id="L1002">                    replyToSender(error, sender);</span>
                }
<span class="fc" id="L1004">            } else {</span>
                // cannot create policy.
<span class="nc" id="L1006">                final String thingId = createThing.getThingId();</span>
<span class="nc" id="L1007">                final String message = String.format(&quot;The Thing with ID ''%s'' could not be created with implicit &quot; +</span>
                        &quot;Policy because no authorization subject is present.&quot;, thingId);
<span class="nc" id="L1009">                final ThingNotCreatableException error =</span>
<span class="nc" id="L1010">                        ThingNotCreatableException.newBuilderForPolicyMissing(thingId, thingId)</span>
<span class="nc" id="L1011">                                .message(message)</span>
<span class="nc" id="L1012">                                .description(() -&gt; null)</span>
<span class="nc" id="L1013">                                .dittoHeaders(createThing.getDittoHeaders())</span>
<span class="nc" id="L1014">                                .build();</span>
<span class="nc" id="L1015">                replyToSender(error, sender);</span>
            }
<span class="nc" id="L1017">        } catch (final RuntimeException error) {</span>
<span class="nc" id="L1018">            reportError(&quot;error before creating thing with initial policy&quot;, sender, error,</span>
<span class="nc" id="L1019">                    createThing.getDittoHeaders());</span>
<span class="fc" id="L1020">        }</span>
<span class="fc" id="L1021">    }</span>

    private static Optional&lt;Policy&gt; getInlinedOrDefaultPolicyForCreateThing(final CreateThing createThing) {
<span class="fc" id="L1024">        final Optional&lt;JsonObject&gt; initialPolicy = createThing.getInitialPolicy();</span>
<span class="fc bfc" id="L1025" title="All 2 branches covered.">        if (initialPolicy.isPresent()) {</span>
<span class="fc" id="L1026">            final JsonObject policyJson = initialPolicy.get();</span>
<span class="fc" id="L1027">            final JsonObjectBuilder policyJsonBuilder = policyJson.toBuilder();</span>
<span class="fc" id="L1028">            final Thing thing = createThing.getThing();</span>
<span class="pc bpc" id="L1029" title="1 of 4 branches missed.">            if (thing.getPolicyId().isPresent() || !policyJson.contains(Policy.JsonFields.ID.getPointer())) {</span>
<span class="fc" id="L1030">                final String policyId = thing.getPolicyId().orElse(createThing.getThingId());</span>
<span class="fc" id="L1031">                policyJsonBuilder.set(Policy.JsonFields.ID, policyId);</span>
            }
<span class="fc" id="L1033">            return Optional.of(PoliciesModelFactory.newPolicy(policyJsonBuilder.build()));</span>
        } else {
<span class="fc" id="L1035">            return getDefaultPolicy(createThing.getDittoHeaders().getAuthorizationContext(), createThing.getThingId());</span>
        }
    }

    private static Optional&lt;DittoRuntimeException&gt; checkForErrorsInCreateThingWithPolicy(
            final CreateThing createThing) {
<span class="fc" id="L1041">        return checkAclAbsenceInCreateThing(createThing)</span>
<span class="fc" id="L1042">                .map(Optional::of)</span>
<span class="fc" id="L1043">                .orElseGet(() -&gt; checkPolicyIdValidityForCreateThing(createThing));</span>
    }

    private static Optional&lt;DittoRuntimeException&gt; checkAclAbsenceInCreateThing(final CreateThing createThing) {
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">        if (createThing.getThing().getAccessControlList().isPresent()) {</span>
<span class="nc" id="L1048">            final DittoRuntimeException error = AclNotAllowedException.newBuilder(createThing.getThingId())</span>
<span class="nc" id="L1049">                    .dittoHeaders(createThing.getDittoHeaders())</span>
<span class="nc" id="L1050">                    .build();</span>
<span class="nc" id="L1051">            return Optional.of(error);</span>
        } else {
<span class="fc" id="L1053">            return Optional.empty();</span>
        }
    }

    private static Optional&lt;DittoRuntimeException&gt; checkPolicyIdValidityForCreateThing(final CreateThing createThing) {
<span class="fc" id="L1058">        final Thing thing = createThing.getThing();</span>
<span class="fc" id="L1059">        final Optional&lt;String&gt; thingIdOpt = thing.getId();</span>
<span class="fc" id="L1060">        final Optional&lt;String&gt; policyIdOpt = thing.getPolicyId();</span>
<span class="fc" id="L1061">        final Optional&lt;String&gt; policyIdInPolicyOpt = createThing.getInitialPolicy()</span>
<span class="fc" id="L1062">                .flatMap(jsonObject -&gt; jsonObject.getValue(Thing.JsonFields.POLICY_ID));</span>

        final boolean isValid;
<span class="fc bfc" id="L1065" title="All 2 branches covered.">        if (policyIdOpt.isPresent()) {</span>
<span class="pc bpc" id="L1066" title="1 of 4 branches missed.">            isValid = !policyIdInPolicyOpt.isPresent() || policyIdInPolicyOpt.equals(policyIdOpt);</span>
        } else {
<span class="pc bpc" id="L1068" title="1 of 4 branches missed.">            isValid = !policyIdInPolicyOpt.isPresent() || policyIdInPolicyOpt.equals(thingIdOpt);</span>
        }

<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">        if (!isValid) {</span>
<span class="nc" id="L1072">            final DittoRuntimeException error = PolicyIdNotAllowedException.newBuilder(createThing.getThingId())</span>
<span class="nc" id="L1073">                    .dittoHeaders(createThing.getDittoHeaders())</span>
<span class="nc" id="L1074">                    .build();</span>
<span class="nc" id="L1075">            return Optional.of(error);</span>
        } else {
<span class="fc" id="L1077">            return Optional.empty();</span>
        }
    }

    private static boolean shouldCreatePolicyForCreateThing(final CreateThing createThing) {
<span class="fc" id="L1082">        final JsonSchemaVersion commandVersion =</span>
<span class="fc" id="L1083">                createThing.getDittoHeaders().getSchemaVersion().orElse(JsonSchemaVersion.LATEST);</span>
<span class="fc bfc" id="L1084" title="All 4 branches covered.">        return createThing.getInitialPolicy().isPresent() ||</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">                (JsonSchemaVersion.V_1 != commandVersion &amp;&amp; !createThing.getThing().getPolicyId().isPresent());</span>
    }

    private boolean createPolicyAndThing(final CreatePolicy createPolicy,
            final CreateThing createThingWithoutPolicyId,
            final ActorRef sender) {

<span class="fc" id="L1092">        final long timeout = getAskTimeout().toMillis();</span>

<span class="fc" id="L1094">        final CreateThing createThing = CreateThing.of(</span>
<span class="fc" id="L1095">                createThingWithoutPolicyId.getThing().setPolicyId(createPolicy.getId()),</span>
                null,
<span class="fc" id="L1097">                createThingWithoutPolicyId.getDittoHeaders());</span>

<span class="fc" id="L1099">        invalidatePolicyCache(createPolicy.getId());</span>
<span class="fc" id="L1100">        PatternsCS.ask(policiesShardRegion, createPolicy, timeout).handleAsync((policyResponse, policyError) -&gt; {</span>
<span class="fc" id="L1101">            final Optional&lt;CreateThing&gt; nextStep =</span>
<span class="fc" id="L1102">                    handlePolicyResponseForCreateThing(createPolicy, createThing, policyResponse, policyError, sender);</span>

<span class="fc" id="L1104">            nextStep.ifPresent(cmd -&gt; {</span>
<span class="fc" id="L1105">                invalidateThingCaches(cmd.getThingId());</span>
<span class="fc" id="L1106">                PatternsCS.ask(thingsShardRegion, cmd, timeout)</span>
<span class="fc" id="L1107">                        .handleAsync((thingResponse, thingError) -&gt;</span>
<span class="fc" id="L1108">                                handleThingResponseForCreateThing(createThing, thingResponse, thingError, sender));</span>
<span class="fc" id="L1109">            });</span>

<span class="fc" id="L1111">            return null;</span>
        });

<span class="fc" id="L1114">        return true;</span>
    }

    private Optional&lt;CreateThing&gt; handlePolicyResponseForCreateThing(
            final CreatePolicy createPolicy,
            final CreateThing createThing,
            final Object policyResponse,
            final Throwable policyError,
            final ActorRef sender) {

<span class="fc bfc" id="L1124" title="All 2 branches covered.">        if (policyResponse instanceof CreatePolicyResponse) {</span>

<span class="fc" id="L1126">            return Optional.of(createThing);</span>

<span class="pc bpc" id="L1128" title="3 of 4 branches missed.">        } else if (policyResponse instanceof PolicyConflictException ||</span>
                policyResponse instanceof PolicyNotAccessibleException) {

<span class="fc" id="L1131">            reportInitialPolicyCreationFailure(createPolicy.getId(), createThing, sender);</span>

<span class="nc bnc" id="L1133" title="All 2 branches missed.">        } else if (isAskTimeoutException(policyResponse, policyError)) {</span>

<span class="nc" id="L1135">            replyToSender(PolicyUnavailableException.newBuilder(createThing.getThingId())</span>
<span class="nc" id="L1136">                    .dittoHeaders(createThing.getDittoHeaders())</span>
<span class="nc" id="L1137">                    .build(), sender);</span>

        } else {

<span class="nc" id="L1141">            final String hint =</span>
<span class="nc" id="L1142">                    String.format(&quot;creating initial policy during creation of Thing &lt;%s&gt;&quot;,</span>
<span class="nc" id="L1143">                            createThing.getThingId());</span>
<span class="nc" id="L1144">            reportUnexpectedErrorOrResponse(hint, sender, policyResponse, policyError, createThing.getDittoHeaders());</span>
        }

<span class="fc" id="L1147">        return Optional.empty();</span>
    }

    private Void handleThingResponseForCreateThing(
            final CreateThing createThing,
            final Object thingResponse,
            final Throwable thingError,
            final ActorRef sender) {

<span class="pc bpc" id="L1156" title="3 of 4 branches missed.">        if (thingResponse instanceof ThingCommandResponse || thingResponse instanceof DittoRuntimeException) {</span>

<span class="fc" id="L1158">            replyToSender(thingResponse, sender);</span>

<span class="nc bnc" id="L1160" title="All 2 branches missed.">        } else if (isAskTimeoutException(thingResponse, thingError)) {</span>

<span class="nc" id="L1162">            replyToSender(ThingUnavailableException.newBuilder(createThing.getThingId())</span>
<span class="nc" id="L1163">                    .dittoHeaders(createThing.getDittoHeaders())</span>
<span class="nc" id="L1164">                    .build(), sender);</span>

        } else {

<span class="nc" id="L1168">            final String hint =</span>
<span class="nc" id="L1169">                    String.format(&quot;after creating initial policy during creation of Thing &lt;%s&gt;&quot;,</span>
<span class="nc" id="L1170">                            createThing.getThingId());</span>
<span class="nc" id="L1171">            reportUnexpectedErrorOrResponse(hint, sender, thingResponse, thingError, createThing.getDittoHeaders());</span>
        }

<span class="fc" id="L1174">        return null;</span>
    }

    private void reportInitialPolicyCreationFailure(final String policyId,
            final CreateThing command,
            final ActorRef sender) {

<span class="fc" id="L1181">        log(command).info(&quot;The Policy with ID '{}' is already existing, the CreateThing &quot; +</span>
                &quot;command which would have created an implicit Policy for the Thing with ID '{}' &quot; +
<span class="fc" id="L1183">                &quot;is therefore not handled&quot;, policyId, command.getThingId());</span>
<span class="fc" id="L1184">        final ThingNotCreatableException error =</span>
<span class="fc" id="L1185">                ThingNotCreatableException.newBuilderForPolicyExisting(command.getThingId(), policyId)</span>
<span class="fc" id="L1186">                        .dittoHeaders(command.getDittoHeaders())</span>
<span class="fc" id="L1187">                        .build();</span>
<span class="fc" id="L1188">        replyToSender(error, sender);</span>
<span class="fc" id="L1189">    }</span>

    private static Optional&lt;Policy&gt; getDefaultPolicy(final AuthorizationContext authorizationContext,
            final CharSequence thingId) {

<span class="fc" id="L1194">        final Optional&lt;Subject&gt; subjectOptional = authorizationContext.getFirstAuthorizationSubject()</span>
<span class="fc" id="L1195">                .map(AuthorizationSubject::getId)</span>
<span class="fc" id="L1196">                .map(SubjectId::newInstance)</span>
<span class="fc" id="L1197">                .map(Subject::newInstance);</span>

<span class="fc" id="L1199">        return subjectOptional.map(subject -&gt;</span>
<span class="fc" id="L1200">                Policy.newBuilder(thingId)</span>
<span class="fc" id="L1201">                        .forLabel(DEFAULT_POLICY_ENTRY_LABEL)</span>
<span class="fc" id="L1202">                        .setSubject(subject)</span>
<span class="fc" id="L1203">                        .setGrantedPermissions(PoliciesResourceType.thingResource(&quot;/&quot;),</span>
                                org.eclipse.ditto.services.models.things.Permission.DEFAULT_THING_PERMISSIONS)
<span class="fc" id="L1205">                        .setGrantedPermissions(PoliciesResourceType.policyResource(&quot;/&quot;),</span>
                                org.eclipse.ditto.services.models.policies.Permission.DEFAULT_POLICY_PERMISSIONS)
<span class="fc" id="L1207">                        .setGrantedPermissions(PoliciesResourceType.messageResource(&quot;/&quot;),</span>
                                org.eclipse.ditto.services.models.policies.Permission.DEFAULT_POLICY_PERMISSIONS)
<span class="fc" id="L1209">                        .build());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>