<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DittoService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Eclipse Ditto :: Services :: Base</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.ditto.services.base</a> &gt; <span class="el_source">DittoService.java</span></div><h1>DittoService.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Bosch Software Innovations GmbH.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/index.php
 *
 * Contributors:
 *    Bosch Software Innovations GmbH - initial contribution
 */
package org.eclipse.ditto.services.base;

import static org.eclipse.ditto.model.base.common.ConditionChecker.argumentNotEmpty;
import static org.eclipse.ditto.model.base.common.ConditionChecker.checkNotNull;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;
import java.time.Duration;
import java.util.Collection;
import java.util.Collections;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;

import javax.annotation.concurrent.Immutable;
import javax.annotation.concurrent.NotThreadSafe;

import org.eclipse.ditto.services.base.config.ServiceConfigReader;
import org.eclipse.ditto.services.utils.cluster.ClusterMemberAwareActor;
import org.eclipse.ditto.services.utils.config.ConfigUtil;
import org.eclipse.ditto.services.utils.devops.DevOpsCommandsActor;
import org.eclipse.ditto.services.utils.devops.LogbackLoggingFacade;
import org.eclipse.ditto.services.utils.health.status.StatusSupplierActor;
import org.slf4j.Logger;

import com.typesafe.config.Config;
import com.typesafe.config.ConfigFactory;

import akka.Done;
import akka.actor.ActorRef;
import akka.actor.ActorRefFactory;
import akka.actor.ActorSystem;
import akka.actor.CoordinatedShutdown;
import akka.actor.Props;
import akka.cluster.Cluster;
import akka.cluster.pubsub.DistributedPubSub;
import akka.management.AkkaManagement;
import akka.management.cluster.bootstrap.ClusterBootstrap;
import akka.stream.ActorMaterializer;
import kamon.Kamon;

/**
 * Abstract base implementation of a Ditto service which takes care of the complete startup procedure.
 * &lt;p&gt;
 * This class provides the template method {@link #startActorSystem()} which by default starts the Akka actor system as
 * well as all Akka actors of this service which are required for startup.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Each hook method may be overridden to change this particular part of the startup procedure. Please have a look at
 * the Javadoc comment before overriding a hook method. The hook methods are automatically called in the following
 * order:
 * &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;{@link #determineConfig()},&lt;/li&gt;
 * &lt;li&gt;{@link #createActorSystem(Config)},&lt;/li&gt;
 * &lt;li&gt;{@link #startStatusSupplierActor(ActorSystem, Config)},&lt;/li&gt;
 * &lt;li&gt;{@link #startClusterMemberAwareActor(ActorSystem, ServiceConfigReader)} and&lt;/li&gt;
 * &lt;li&gt;{@link #startServiceRootActors(ActorSystem, ServiceConfigReader)}.
 * &lt;ol&gt;
 * &lt;li&gt;{@link #startStatsdMetricsReporter(ActorSystem, ServiceConfigReader)},&lt;/li&gt;
 * &lt;li&gt;{@link #getMainRootActorProps(ServiceConfigReader, ActorRef, ActorMaterializer)},&lt;/li&gt;
 * &lt;li&gt;{@link #startMainRootActor(ActorSystem, Props)},&lt;/li&gt;
 * &lt;li&gt;{@link #getAdditionalRootActorsInformation(ServiceConfigReader, ActorRef, ActorMaterializer)} and&lt;/li&gt;
 * &lt;li&gt;{@link #startAdditionalRootActors(ActorSystem, Iterable)}.&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;/li&gt;
 * &lt;/ol&gt;
 *
 * @param &lt;C&gt; type of configuration reader for the service.
 */
@NotThreadSafe
public abstract class DittoService&lt;C extends ServiceConfigReader&gt; {

    /**
     * Name of the cluster of this service.
     */
    public static final String CLUSTER_NAME = &quot;ditto-cluster&quot;;

    private final Logger logger;
    private final String serviceName;
    private final String rootActorName;
    private final C configReader;

    /**
     * Constructs a new {@code DittoService} object.
     *
     * @param logger the Logger to be used for logging.
     * @param serviceName the name of this service.
     * @param rootActorName the name of this service's root actor.
     * @param configReaderCreator creator of a service config reader.
     * @throws NullPointerException if any argument is {@code null}.
     * @throws java.lang.IllegalArgumentException if {@code serviceName} or {@code rootActorName} is empty.
     */
    protected DittoService(final Logger logger,
            final String serviceName,
            final String rootActorName,
<span class="nc" id="L107">            final Function&lt;Config, C&gt; configReaderCreator) {</span>

<span class="nc" id="L109">        this.logger = checkNotNull(logger, &quot;logger&quot;);</span>
<span class="nc" id="L110">        this.serviceName = argumentNotEmpty(serviceName, &quot;service name&quot;);</span>
<span class="nc" id="L111">        this.rootActorName = argumentNotEmpty(rootActorName, &quot;root actor name&quot;);</span>
<span class="nc" id="L112">        final Config config = determineConfig();</span>
<span class="nc" id="L113">        this.configReader = checkNotNull(configReaderCreator, &quot;config reader creator&quot;).apply(config);</span>
<span class="nc" id="L114">    }</span>

    /**
     * Starts this service. Any thrown {@code Throwable}s will be logged and re-thrown.
     */
    public void start() {
<span class="nc" id="L120">        MainMethodExceptionHandler.getInstance(logger).run(this::doStart);</span>
<span class="nc" id="L121">    }</span>

    /**
     * Starts this service.
     * &lt;p&gt;
     * May be overridden to &lt;em&gt;completely&lt;/em&gt; change the way how this service is started.
     * &lt;em&gt;Note: If this method is overridden, no other method of this class will be called automatically.&lt;/em&gt;
     * &lt;/p&gt;
     */
    protected void doStart() {
<span class="nc" id="L131">        logRuntimeParameters();</span>
<span class="nc" id="L132">        startKamon();</span>
<span class="nc" id="L133">        startActorSystem();</span>
<span class="nc" id="L134">    }</span>

    private void logRuntimeParameters() {
<span class="nc" id="L137">        final RuntimeMXBean bean = ManagementFactory.getRuntimeMXBean();</span>
<span class="nc" id="L138">        logger.info(&quot;Running with following runtime parameters: {}&quot;, bean.getInputArguments());</span>
<span class="nc" id="L139">        logger.info(&quot;Available processors: {}&quot;, Runtime.getRuntime().availableProcessors());</span>
<span class="nc" id="L140">    }</span>

    private static void startKamon() {
<span class="nc" id="L143">        Kamon.start(ConfigFactory.load(&quot;kamon&quot;));</span>
<span class="nc" id="L144">    }</span>

    /**
     * Starts the Akka actor system as well as all required actors.
     * &lt;p&gt;
     * May be overridden to change the way how the Akka actor system and actors are started. &lt;em&gt;Note: If this
     * method is overridden, none of the following mentioned methods and their descendant methods will be called
     * automatically:&lt;/em&gt;
     * &lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link #determineConfig()},&lt;/li&gt;
     * &lt;li&gt;{@link #createActorSystem(Config)},&lt;/li&gt;
     * &lt;li&gt;{@link #startStatusSupplierActor(ActorSystem, Config)},&lt;/li&gt;
     * &lt;li&gt;{@link #startClusterMemberAwareActor(ActorSystem, ServiceConfigReader)} and&lt;/li&gt;
     * &lt;li&gt;{@link #startServiceRootActors(ActorSystem, ServiceConfigReader)}.&lt;/li&gt;
     * &lt;/ul&gt;
     */
    protected void startActorSystem() {
<span class="nc" id="L162">        final Config config = configReader.getRawConfig();</span>
<span class="nc" id="L163">        final double parallelismMax =</span>
<span class="nc" id="L164">                config.getDouble(&quot;akka.actor.default-dispatcher.fork-join-executor.parallelism-max&quot;);</span>
<span class="nc" id="L165">        logger.info(&quot;Running 'default-dispatcher' with 'parallelism-max': &lt;{}&gt;&quot;, parallelismMax);</span>
<span class="nc" id="L166">        final ActorSystem actorSystem = createActorSystem(config);</span>

<span class="nc" id="L168">        AkkaManagement.get(actorSystem).start();</span>
<span class="nc" id="L169">        ClusterBootstrap.get(actorSystem).start();</span>

<span class="nc" id="L171">        startStatusSupplierActor(actorSystem, config);</span>
<span class="nc" id="L172">        startDevOpsCommandsActor(actorSystem, config);</span>
<span class="nc" id="L173">        startClusterMemberAwareActor(actorSystem, configReader);</span>
<span class="nc" id="L174">        startServiceRootActors(actorSystem, configReader);</span>

<span class="nc" id="L176">        CoordinatedShutdown.get(actorSystem).addTask(</span>
<span class="nc" id="L177">                CoordinatedShutdown.PhaseBeforeServiceUnbind(), &quot;Log shutdown initiation&quot;,</span>
                () -&gt; {
<span class="nc" id="L179">                    logger.info(&quot;Shutdown issued from outside (e.g. SIGTERM) - gracefully shutting down..&quot;);</span>
<span class="nc" id="L180">                    return CompletableFuture.completedFuture(Done.getInstance());</span>
                });

<span class="nc" id="L183">        CoordinatedShutdown.get(actorSystem).addTask(</span>
<span class="nc" id="L184">                CoordinatedShutdown.PhaseBeforeActorSystemTerminate(), &quot;Log successful graceful shutdown&quot;,</span>
                () -&gt; {
<span class="nc" id="L186">                    logger.info(&quot;Graceful shutdown completed.&quot;);</span>
<span class="nc" id="L187">                    return CompletableFuture.completedFuture(Done.getInstance());</span>
                });
<span class="nc" id="L189">    }</span>

    /**
     * Determines the {@link Config} of this service. May be overridden to change the way how the config is determined.
     *
     * @return the config of this service.
     */
    protected Config determineConfig() {
<span class="nc" id="L197">        return ConfigUtil.determineConfig(serviceName);</span>
    }

    /**
     * Creates the Akka actor system. May be overridden to change the way how the actor system is created.
     *
     * @param config the configuration settings of this service.
     * @return the actor system.
     */
    protected ActorSystem createActorSystem(final Config config) {
<span class="nc" id="L207">        return ActorSystem.create(CLUSTER_NAME, config);</span>
    }

    /**
     * Starts the {@link StatusSupplierActor}. May be overridden to change the way how the actor is started.
     *
     * @param actorSystem Akka actor system for starting actors.
     * @param config the configuration settings of this service.
     */
    protected void startStatusSupplierActor(final ActorSystem actorSystem, final Config config) {
<span class="nc" id="L217">        startActor(actorSystem, StatusSupplierActor.props(rootActorName), StatusSupplierActor.ACTOR_NAME);</span>
<span class="nc" id="L218">    }</span>

    private void startActor(final ActorSystem actorSystem, final Props actorProps, final String actorName) {
<span class="nc" id="L221">        logStartingActor(actorName);</span>
<span class="nc" id="L222">        actorSystem.actorOf(actorProps, actorName);</span>
<span class="nc" id="L223">    }</span>

    private void logStartingActor(final String actorName) {
<span class="nc" id="L226">        logger.info(&quot;Starting actor &lt;{}&gt;.&quot;, actorName);</span>
<span class="nc" id="L227">    }</span>

    /**
     * Starts the {@link DevOpsCommandsActor}. May be overridden to change the way how the actor is started.
     *
     * @param actorSystem Akka actor system for starting actors.
     * @param config the configuration settings of this service.
     */
    protected void startDevOpsCommandsActor(final ActorSystem actorSystem, final Config config) {
<span class="nc" id="L236">        startActor(actorSystem, DevOpsCommandsActor.props(LogbackLoggingFacade.newInstance(), serviceName,</span>
<span class="nc" id="L237">                ConfigUtil.instanceIndex()), DevOpsCommandsActor.ACTOR_NAME);</span>
<span class="nc" id="L238">    }</span>

    /**
     * Starts the {@link ClusterMemberAwareActor}. May be overridden to change the way how the actor is started.
     *
     * @param actorSystem Akka actor system for starting actors.
     * @param configReader the config reader of this service.
     */
    protected void startClusterMemberAwareActor(final ActorSystem actorSystem, final C configReader) {
<span class="nc" id="L247">        startActor(actorSystem, ClusterMemberAwareActor.props(serviceName, isMajorityCheckEnabled(configReader),</span>
<span class="nc" id="L248">                getMajorityCheckDelay(configReader)), ClusterMemberAwareActor.ACTOR_NAME);</span>
<span class="nc" id="L249">    }</span>

    private boolean isMajorityCheckEnabled(final ServiceConfigReader configReader) {
<span class="nc" id="L252">        return configReader.cluster().majorityCheckEnabled();</span>

    }

    private Duration getMajorityCheckDelay(final ServiceConfigReader configReader) {
<span class="nc" id="L257">        return configReader.cluster().majorityCheckDelay();</span>
    }

    /**
     * Starts the root actor(s) of this service.
     * &lt;p&gt;
     * May be overridden to change the way how the root actor(s) of this service are started. &lt;em&gt;Note: If this
     * method is overridden, the following methods will not be called automatically:&lt;/em&gt;
     * &lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link #startStatsdMetricsReporter(ActorSystem, ServiceConfigReader)},&lt;/li&gt;
     * &lt;li&gt;{@link #getMainRootActorProps(ServiceConfigReader, ActorRef, ActorMaterializer)},&lt;/li&gt;
     * &lt;li&gt;{@link #startMainRootActor(ActorSystem, Props)},&lt;/li&gt;
     * &lt;li&gt;{@link #getAdditionalRootActorsInformation(ServiceConfigReader, ActorRef, ActorMaterializer)} and&lt;/li&gt;
     * &lt;li&gt;{@link #startAdditionalRootActors(ActorSystem, Iterable)}.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param actorSystem Akka actor system for starting actors.
     * @param configReader the configuration settings of this service.
     */
    protected void startServiceRootActors(final ActorSystem actorSystem, final C configReader) {

<span class="nc" id="L279">        logger.info(&quot;Waiting for member to be up before proceeding with further initialisation.&quot;);</span>
<span class="nc" id="L280">        Cluster.get(actorSystem).registerOnMemberUp(() -&gt; {</span>
<span class="nc" id="L281">            logger.info(&quot;Member successfully joined the cluster, instantiating remaining actors.&quot;);</span>

<span class="nc" id="L283">            startStatsdMetricsReporter(actorSystem, configReader);</span>

<span class="nc" id="L285">            final ActorRef pubSubMediator = getDistributedPubSubMediatorActor(actorSystem);</span>
<span class="nc" id="L286">            final ActorMaterializer materializer = createActorMaterializer(actorSystem);</span>

<span class="nc" id="L288">            startMainRootActor(actorSystem, getMainRootActorProps(configReader, pubSubMediator, materializer));</span>
<span class="nc" id="L289">            startAdditionalRootActors(actorSystem, getAdditionalRootActorsInformation(configReader, pubSubMediator,</span>
                    materializer));
<span class="nc" id="L291">        });</span>
<span class="nc" id="L292">    }</span>

    /**
     * May be overridden to start a StatsD metrics reporter. &lt;em&gt;The base implementation does nothing.&lt;/em&gt;
     *
     * @param actorSystem Akka actor system for starting actors.
     * @param configReader the configuration reader of this service.
     */
    protected void startStatsdMetricsReporter(final ActorSystem actorSystem, final C configReader) {
        // Does nothing by default.
<span class="nc" id="L302">    }</span>

    private static ActorRef getDistributedPubSubMediatorActor(final ActorSystem actorSystem) {
<span class="nc" id="L305">        return DistributedPubSub.get(actorSystem).mediator();</span>
    }

    private static ActorMaterializer createActorMaterializer(final ActorRefFactory actorSystem) {
<span class="nc" id="L309">        return ActorMaterializer.create(actorSystem);</span>
    }

    /**
     * Returns the Props of this service's main root actor.
     *
     * @param configReader the configuration reader of this service.
     * @param pubSubMediator ActorRef of the distributed pub-sub-mediator.
     * @param materializer the materializer for the Akka actor system.
     * @return the Props.
     */
    protected abstract Props getMainRootActorProps(C configReader, ActorRef pubSubMediator,
            ActorMaterializer materializer);

    /**
     * Starts the main root actor of this service. May be overridden to change the way of starting this service's root
     * actor.
     *
     * @param actorSystem Akka actor system for starting actors.
     * @param mainRootActorProps the Props of the main root actor.
     */
    protected void startMainRootActor(final ActorSystem actorSystem, final Props mainRootActorProps) {
<span class="nc" id="L331">        startActor(actorSystem, mainRootActorProps, rootActorName);</span>
<span class="nc" id="L332">    }</span>

    /**
     * May be overridden to return information of additional root actors of this service. &lt;em&gt;The base implementation
     * returns an empty collection.&lt;/em&gt;
     *
     * @param configReader the configuration reader of this service.
     * @param pubSubMediator ActorRef of the distributed pub-sub-mediator.
     * @param materializer the materializer for the Akka actor system.
     * @return the additional root actors information.
     */
    protected Collection&lt;RootActorInformation&gt; getAdditionalRootActorsInformation(final C configReader,
            final ActorRef pubSubMediator, final ActorMaterializer materializer) {

<span class="nc" id="L346">        return Collections.emptyList();</span>
    }

    /**
     * Starts additional root actors of this service. May be overridden to change the way how additional root actors
     * will be started.
     *
     * @param actorSystem Akka actor system for starting actors.
     * @param additionalRootActorsInformation information of additional root actors to be started.
     */
    protected void startAdditionalRootActors(final ActorSystem actorSystem,
            final Iterable&lt;RootActorInformation&gt; additionalRootActorsInformation) {

<span class="nc bnc" id="L359" title="All 2 branches missed.">        for (final RootActorInformation rootActorInformation : additionalRootActorsInformation) {</span>
<span class="nc" id="L360">            startActor(actorSystem, rootActorInformation.props, rootActorInformation.name);</span>
<span class="nc" id="L361">        }</span>
<span class="nc" id="L362">    }</span>

    /**
     * This class bundles meta information of this service's root actor.
     */
    @Immutable
    public static final class RootActorInformation {

        private final Props props;
        private final String name;

<span class="nc" id="L373">        private RootActorInformation(final Props theProps, final String theName) {</span>
<span class="nc" id="L374">            props = theProps;</span>
<span class="nc" id="L375">            name = theName;</span>
<span class="nc" id="L376">        }</span>

        /**
         * Returns an instance of {@code RootActorInformation}.
         *
         * @param props the Props of the root actor.
         * @param name the name of the root actor.
         * @return the instance.
         * @throws NullPointerException if any argument is {@code null}.
         * @throws IllegalArgumentException if {@code name} is empty.
         */
        public static RootActorInformation getInstance(final Props props, final String name) {
<span class="nc" id="L388">            checkNotNull(props, &quot;root actor props&quot;);</span>
<span class="nc" id="L389">            argumentNotEmpty(name, &quot;root actor name&quot;);</span>

<span class="nc" id="L391">            return new RootActorInformation(props, name);</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>