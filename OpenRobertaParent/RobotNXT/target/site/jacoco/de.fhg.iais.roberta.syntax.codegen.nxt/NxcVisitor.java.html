<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NxcVisitor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RobotNXT</a> &gt; <a href="index.source.html" class="el_package">de.fhg.iais.roberta.syntax.codegen.nxt</a> &gt; <span class="el_source">NxcVisitor.java</span></div><h1>NxcVisitor.java</h1><pre class="source lang-java linenums">package de.fhg.iais.roberta.syntax.codegen.nxt;

import java.util.ArrayList;
import java.util.Map.Entry;
import java.util.Set;

import de.fhg.iais.roberta.components.Sensor;
import de.fhg.iais.roberta.components.UsedActor;
import de.fhg.iais.roberta.components.nxt.NxtConfiguration;
import de.fhg.iais.roberta.inter.mode.action.IActorPort;
import de.fhg.iais.roberta.inter.mode.sensor.ISensorPort;
import de.fhg.iais.roberta.mode.action.ActorPort;
import de.fhg.iais.roberta.mode.action.DriveDirection;
import de.fhg.iais.roberta.mode.action.MotorMoveMode;
import de.fhg.iais.roberta.mode.action.MotorStopMode;
import de.fhg.iais.roberta.mode.action.TurnDirection;
import de.fhg.iais.roberta.mode.general.IndexLocation;
import de.fhg.iais.roberta.mode.general.nxt.PickColor;
import de.fhg.iais.roberta.mode.sensor.ColorSensorMode;
import de.fhg.iais.roberta.mode.sensor.MotorTachoMode;
import de.fhg.iais.roberta.mode.sensor.TimerSensorMode;
import de.fhg.iais.roberta.syntax.Phrase;
import de.fhg.iais.roberta.syntax.action.communication.BluetoothCheckConnectAction;
import de.fhg.iais.roberta.syntax.action.communication.BluetoothConnectAction;
import de.fhg.iais.roberta.syntax.action.communication.BluetoothReceiveAction;
import de.fhg.iais.roberta.syntax.action.communication.BluetoothSendAction;
import de.fhg.iais.roberta.syntax.action.communication.BluetoothWaitForConnectionAction;
import de.fhg.iais.roberta.syntax.action.display.ClearDisplayAction;
import de.fhg.iais.roberta.syntax.action.display.ShowPictureAction;
import de.fhg.iais.roberta.syntax.action.display.ShowTextAction;
import de.fhg.iais.roberta.syntax.action.light.LightAction;
import de.fhg.iais.roberta.syntax.action.light.LightStatusAction;
import de.fhg.iais.roberta.syntax.action.motor.CurveAction;
import de.fhg.iais.roberta.syntax.action.motor.DriveAction;
import de.fhg.iais.roberta.syntax.action.motor.MotorDriveStopAction;
import de.fhg.iais.roberta.syntax.action.motor.MotorGetPowerAction;
import de.fhg.iais.roberta.syntax.action.motor.MotorOnAction;
import de.fhg.iais.roberta.syntax.action.motor.MotorSetPowerAction;
import de.fhg.iais.roberta.syntax.action.motor.MotorStopAction;
import de.fhg.iais.roberta.syntax.action.motor.TurnAction;
import de.fhg.iais.roberta.syntax.action.sound.PlayFileAction;
import de.fhg.iais.roberta.syntax.action.sound.PlayNoteAction;
import de.fhg.iais.roberta.syntax.action.sound.SayTextAction;
import de.fhg.iais.roberta.syntax.action.sound.SetLanguageAction;
import de.fhg.iais.roberta.syntax.action.sound.ToneAction;
import de.fhg.iais.roberta.syntax.action.sound.VolumeAction;
import de.fhg.iais.roberta.syntax.check.hardware.nxt.UsedHardwareCollectorVisitor;
import de.fhg.iais.roberta.syntax.codegen.RobotCppVisitor;
import de.fhg.iais.roberta.syntax.lang.blocksequence.MainTask;
import de.fhg.iais.roberta.syntax.lang.expr.Binary;
import de.fhg.iais.roberta.syntax.lang.expr.Binary.Op;
import de.fhg.iais.roberta.syntax.lang.expr.ColorConst;
import de.fhg.iais.roberta.syntax.lang.expr.ListCreate;
import de.fhg.iais.roberta.syntax.lang.expr.MathConst;
import de.fhg.iais.roberta.syntax.lang.expr.VarDeclaration;
import de.fhg.iais.roberta.syntax.lang.functions.FunctionNames;
import de.fhg.iais.roberta.syntax.lang.functions.GetSubFunct;
import de.fhg.iais.roberta.syntax.lang.functions.IndexOfFunct;
import de.fhg.iais.roberta.syntax.lang.functions.LengthOfIsEmptyFunct;
import de.fhg.iais.roberta.syntax.lang.functions.ListGetIndex;
import de.fhg.iais.roberta.syntax.lang.functions.ListSetIndex;
import de.fhg.iais.roberta.syntax.lang.functions.MathConstrainFunct;
import de.fhg.iais.roberta.syntax.lang.functions.MathNumPropFunct;
import de.fhg.iais.roberta.syntax.lang.functions.MathOnListFunct;
import de.fhg.iais.roberta.syntax.lang.functions.MathPowerFunct;
import de.fhg.iais.roberta.syntax.lang.functions.MathRandomFloatFunct;
import de.fhg.iais.roberta.syntax.lang.functions.MathRandomIntFunct;
import de.fhg.iais.roberta.syntax.lang.functions.MathSingleFunct;
import de.fhg.iais.roberta.syntax.lang.functions.TextJoinFunct;
import de.fhg.iais.roberta.syntax.lang.stmt.RepeatStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.WaitStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.WaitTimeStmt;
import de.fhg.iais.roberta.syntax.sensor.generic.BrickSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.ColorSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.CompassSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.EncoderSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.GyroSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.InfraredSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.LightSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.SoundSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.TemperatureSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.TimerSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.TouchSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.UltrasonicSensor;
import de.fhg.iais.roberta.typecheck.BlocklyType;
import de.fhg.iais.roberta.util.dbc.Assert;
import de.fhg.iais.roberta.util.dbc.DbcException;
import de.fhg.iais.roberta.visitor.AstVisitor;
import de.fhg.iais.roberta.visitor.actor.AstActorCommunicationVisitor;
import de.fhg.iais.roberta.visitor.actor.AstActorDisplayVisitor;
import de.fhg.iais.roberta.visitor.actor.AstActorLightVisitor;
import de.fhg.iais.roberta.visitor.actor.AstActorMotorVisitor;
import de.fhg.iais.roberta.visitor.actor.AstActorSoundVisitor;
import de.fhg.iais.roberta.visitor.sensor.AstSensorsVisitor;

/**
 * This class is implementing {@link AstVisitor}. All methods are implemented and they append a human-readable NXC code representation of a phrase to a
 * StringBuilder. &lt;b&gt;This representation is correct NXC code for NXT.&lt;/b&gt; &lt;br&gt;
 *
 * @param &lt;V&gt;
 */
public class NxcVisitor extends RobotCppVisitor implements AstSensorsVisitor&lt;Void&gt;, AstActorCommunicationVisitor&lt;Void&gt;, AstActorDisplayVisitor&lt;Void&gt;,
    AstActorMotorVisitor&lt;Void&gt;, AstActorLightVisitor&lt;Void&gt;, AstActorSoundVisitor&lt;Void&gt; {
    private final NxtConfiguration brickConfiguration;

    private final boolean timeSensorUsed;
    private final boolean isVolumeVariableNeeded;

    protected final Set&lt;UsedActor&gt; usedActors;
    //private final String tmpArr;
    //private int tmpArrCount = 0;
    ArrayList&lt;VarDeclaration&lt;Void&gt;&gt; usedVars;

    /**
     * initialize the Nxc code generator visitor.
     *
     * @param brickConfiguration hardware configuration of the brick
     * @param programPhrases to generate the code from
     * @param indentation to start with. Will be incr/decr depending on block structure
     */
    private NxcVisitor(NxtConfiguration brickConfiguration, ArrayList&lt;ArrayList&lt;Phrase&lt;Void&gt;&gt;&gt; programPhrases, int indentation) {
<span class="fc" id="L122">        super(programPhrases, indentation);</span>
<span class="fc" id="L123">        this.brickConfiguration = brickConfiguration;</span>
<span class="fc" id="L124">        UsedHardwareCollectorVisitor codePreprocessVisitor = new UsedHardwareCollectorVisitor(programPhrases, brickConfiguration);</span>
<span class="fc" id="L125">        this.usedVars = codePreprocessVisitor.getVisitedVars();</span>
<span class="fc" id="L126">        this.usedActors = codePreprocessVisitor.getUsedActors();</span>
<span class="fc" id="L127">        this.timeSensorUsed = codePreprocessVisitor.isTimerSensorUsed();</span>
<span class="fc" id="L128">        this.isVolumeVariableNeeded = codePreprocessVisitor.isVolumeVariableNeeded();</span>
<span class="fc" id="L129">        this.loopsLabels = codePreprocessVisitor.getloopsLabelContainer();</span>
<span class="fc" id="L130">        this.userDefinedMethods = codePreprocessVisitor.getUserDefinedMethods();</span>
        //this.tmpArr = codePreprocessVisitor.getTmpArrVar();
<span class="fc" id="L132">    }</span>

    /**
     * factory method to generate NXC code from an AST.&lt;br&gt;
     *
     * @param brickConfiguration hardware configuration of the brick
     * @param programPhrases to generate the code from
     * @param withWrapping if false the generated code will be without the surrounding configuration code
     */
    public static String generate(NxtConfiguration brickConfiguration, ArrayList&lt;ArrayList&lt;Phrase&lt;Void&gt;&gt;&gt; programPhrases, boolean withWrapping) //
    {
<span class="fc" id="L143">        Assert.notNull(brickConfiguration);</span>

<span class="fc bfc" id="L145" title="All 2 branches covered.">        NxcVisitor astVisitor = new NxcVisitor(brickConfiguration, programPhrases, withWrapping ? 1 : 0);</span>
<span class="fc" id="L146">        astVisitor.generateCode(withWrapping);</span>
<span class="fc" id="L147">        return astVisitor.sb.toString();</span>
    }

    @Override
    public Void visitColorConst(ColorConst&lt;Void&gt; colorConst) {
        String value;
<span class="pc bpc" id="L153" title="11 of 13 branches missed.">        switch ( (PickColor) colorConst.getValue() ) {</span>
            case BLACK:
<span class="nc" id="L155">                value = &quot;INPUT_BLACKCOLOR&quot;;</span>
<span class="nc" id="L156">                break;</span>
            case BLUE:
<span class="nc" id="L158">                value = &quot;INPUT_BLUECOLOR&quot;;</span>
<span class="nc" id="L159">                break;</span>
            case GREEN:
<span class="nc" id="L161">                value = &quot;INPUT_GREENCOLOR&quot;;</span>
<span class="nc" id="L162">                break;</span>
            case YELLOW:
<span class="nc" id="L164">                value = &quot;INPUT_YELLOWCOLOR&quot;;</span>
<span class="nc" id="L165">                break;</span>
            case RED:
<span class="fc" id="L167">                value = &quot;INPUT_REDCOLOR&quot;;</span>
<span class="fc" id="L168">                break;</span>
            case WHITE:
<span class="nc" id="L170">                value = &quot;INPUT_WHITECOLOR&quot;;</span>
<span class="nc" id="L171">                break;</span>
            case MAGENTA:
<span class="nc" id="L173">                value = &quot;INPUT_MAGENTACOLOR&quot;;</span>
<span class="nc" id="L174">                break;</span>
            case ORANGE:
<span class="nc" id="L176">                value = &quot;INPUT_ORANGECOLOR&quot;;</span>
<span class="nc" id="L177">                break;</span>
            case LIME:
<span class="nc" id="L179">                value = &quot;INPUT_LIMECOLOR&quot;;</span>
<span class="nc" id="L180">                break;</span>
            case VIOLET:
<span class="nc" id="L182">                value = &quot;INPUT_VIOLETCOLOR&quot;;</span>
<span class="nc" id="L183">                break;</span>
            case CRIMSON:
<span class="nc" id="L185">                value = &quot;INPUT_CRIMSONCOLOR&quot;;</span>
<span class="nc" id="L186">                break;</span>
            case PURPLE:
<span class="nc" id="L188">                value = &quot;INPUT_PURPLECOLOR&quot;;</span>
<span class="nc" id="L189">                break;</span>
            default:
<span class="fc" id="L191">                value = &quot;NULL&quot;;</span>
        }
<span class="fc" id="L193">        this.sb.append(value);</span>
<span class="fc" id="L194">        return null;</span>
    }

    @Override
    public Void visitMathConst(MathConst&lt;Void&gt; mathConst) {
<span class="pc bpc" id="L199" title="1 of 7 branches missed.">        switch ( mathConst.getMathConst() ) {</span>
            case PI:
<span class="fc" id="L201">                this.sb.append(&quot;PI&quot;);</span>
<span class="fc" id="L202">                break;</span>
            case E:
<span class="fc" id="L204">                this.sb.append(&quot;E&quot;);</span>
<span class="fc" id="L205">                break;</span>
            case GOLDEN_RATIO:
<span class="fc" id="L207">                this.sb.append(&quot;GOLDEN_RATIO&quot;);</span>
<span class="fc" id="L208">                break;</span>
            case SQRT2:
<span class="fc" id="L210">                this.sb.append(&quot;SQRT2&quot;);</span>
<span class="fc" id="L211">                break;</span>
            case SQRT1_2:
<span class="fc" id="L213">                this.sb.append(&quot;SQRT1_2&quot;);</span>
<span class="fc" id="L214">                break;</span>
            // IEEE 754 floating point representation
            case INFINITY:
<span class="fc" id="L217">                this.sb.append(&quot;INFINITY&quot;);</span>
<span class="fc" id="L218">                break;</span>
            default:
                break;
        }
<span class="fc" id="L222">        return null;</span>
    }

    protected Void generateUsedVars() {
<span class="fc bfc" id="L226" title="All 2 branches covered.">        for ( VarDeclaration&lt;Void&gt; var : this.usedVars ) {</span>
<span class="fc" id="L227">            nlIndent();</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if ( !var.getValue().getKind().hasName(&quot;EMPTY_EXPR&quot;) ) {</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">                if ( var.getTypeVar().isArray() ) {</span>
<span class="fc" id="L230">                    this.sb.append(getLanguageVarTypeFromBlocklyType(var.getTypeVar())).append(&quot; &quot;);</span>
<span class="fc" id="L231">                    this.sb.append(&quot;__&quot;);</span>
                }
<span class="fc" id="L233">                this.sb.append(var.getName());</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">                this.sb.append(var.getTypeVar().isArray() ? &quot;[]&quot; : &quot;&quot;);</span>
<span class="fc" id="L235">                this.sb.append(&quot; = &quot;);</span>
<span class="fc" id="L236">                var.getValue().visit(this);</span>
<span class="fc" id="L237">                this.sb.append(&quot;;&quot;);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">                if ( var.getTypeVar().isArray() ) {</span>
<span class="fc" id="L239">                    nlIndent();</span>
                    //this.sb.append(&quot;for(int i = 0; i &lt; ArrayLen(&quot; + var.getName() + &quot;); i++) {&quot;);
                    //incrIndentation();
                    //nlIndent();
<span class="fc" id="L243">                    this.sb.append(var.getName()).append(&quot; = __&quot; + var.getName() + &quot;;&quot;);</span>
                    //decrIndentation();
                    //nlIndent();
                    //this.sb.append(&quot;}&quot;);
                }
            }
<span class="fc" id="L249">        }</span>
<span class="fc" id="L250">        return null;</span>
    }

    @Override
    public Void visitVarDeclaration(VarDeclaration&lt;Void&gt; var) {
<span class="fc" id="L255">        this.sb.append(getLanguageVarTypeFromBlocklyType(var.getTypeVar())).append(&quot; &quot;);</span>
<span class="fc" id="L256">        this.sb.append(var.getName());</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if ( var.getTypeVar().isArray() ) {</span>
<span class="fc" id="L258">            this.sb.append(&quot;[&quot;);</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">            if ( var.getValue().getKind().hasName(&quot;EMPTY_EXPR&quot;) ) {</span>
                // nothing to do
            } else {
<span class="fc" id="L262">                ListCreate&lt;Void&gt; list = (ListCreate&lt;Void&gt;) var.getValue();</span>
<span class="fc" id="L263">                this.sb.append(list.getValue().get().size());</span>
            }
<span class="fc" id="L265">            this.sb.append(&quot;]&quot;);</span>
        }
<span class="fc" id="L267">        return null;</span>
    }

    //TODO: fix the string concatenation
    @Override
    public Void visitBinary(Binary&lt;Void&gt; binary) {
<span class="fc" id="L273">        generateSubExpr(this.sb, false, binary.getLeft(), binary);</span>
<span class="fc" id="L274">        Op op = binary.getOp();</span>
<span class="fc" id="L275">        String sym = getBinaryOperatorSymbol(op);</span>
<span class="fc" id="L276">        this.sb.append(whitespace() + sym + whitespace());</span>
<span class="pc bfc" id="L277" title="All 3 branches covered.">        switch ( op ) {</span>
            case TEXT_APPEND:
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">                if ( binary.getRight().getVarType().toString().contains(&quot;NUMBER&quot;) ) {</span>
<span class="nc" id="L280">                    this.sb.append(&quot;NumToStr(&quot;);</span>
<span class="nc" id="L281">                    generateSubExpr(this.sb, false, binary.getRight(), binary);</span>
<span class="nc" id="L282">                    this.sb.append(&quot;)&quot;);</span>
                } else {
<span class="fc" id="L284">                    generateSubExpr(this.sb, false, binary.getRight(), binary);</span>
                }
<span class="fc" id="L286">                break;</span>
            case DIVIDE:
<span class="fc" id="L288">                this.sb.append(&quot;((&quot;);</span>
<span class="fc" id="L289">                generateSubExpr(this.sb, parenthesesCheck(binary), binary.getRight(), binary);</span>
<span class="fc" id="L290">                this.sb.append(&quot;)*1.0)&quot;);</span>
<span class="fc" id="L291">                break;</span>

            default:
<span class="fc" id="L294">                generateSubExpr(this.sb, parenthesesCheck(binary), binary.getRight(), binary);</span>
        }

<span class="fc" id="L297">        return null;</span>
    }

    @Override
    public Void visitRepeatStmt(RepeatStmt&lt;Void&gt; repeatStmt) {
<span class="fc bfc" id="L302" title="All 2 branches covered.">        boolean isWaitStmt = repeatStmt.getMode() == RepeatStmt.Mode.WAIT;</span>
<span class="pc bpc" id="L303" title="1 of 5 branches missed.">        switch ( repeatStmt.getMode() ) {</span>
            case UNTIL:
            case WHILE:
            case FOREVER:
<span class="fc" id="L307">                increaseLoopCounter();</span>
<span class="fc" id="L308">                generateCodeFromStmtCondition(&quot;while&quot;, repeatStmt.getExpr());</span>
<span class="fc" id="L309">                break;</span>
            case TIMES:
            case FOR:
<span class="fc" id="L312">                increaseLoopCounter();</span>
<span class="fc" id="L313">                generateCodeFromStmtConditionFor(&quot;for&quot;, repeatStmt.getExpr());</span>
<span class="fc" id="L314">                break;</span>
            case WAIT:
<span class="fc" id="L316">                generateCodeFromStmtCondition(&quot;if&quot;, repeatStmt.getExpr());</span>
<span class="fc" id="L317">                break;</span>
            case FOR_EACH:
<span class="fc" id="L319">                increaseLoopCounter();</span>
                String varType;
<span class="fc" id="L321">                String expression = repeatStmt.getExpr().toString();</span>
<span class="fc" id="L322">                String segments[] = expression.split(&quot;,&quot;);</span>
<span class="fc" id="L323">                String element = segments[2];</span>
<span class="fc" id="L324">                String arr = null;</span>
<span class="pc bpc" id="L325" title="3 of 4 branches missed.">                if ( expression.contains(&quot;NUMBER&quot;) || expression.contains(&quot;CONNECTION&quot;) ) {</span>
<span class="fc" id="L326">                    varType = &quot;float&quot;;</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">                } else if ( expression.contains(&quot;BOOLEAN&quot;) ) {</span>
<span class="nc" id="L328">                    varType = &quot;bool&quot;;</span>
                } else {
<span class="nc" id="L330">                    varType = &quot;String&quot;;</span>
                }
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">                if ( !segments[6].contains(&quot;java.util&quot;) ) {</span>
<span class="fc" id="L333">                    arr = segments[6].substring(segments[6].indexOf(&quot;[&quot;) + 1, segments[6].indexOf(&quot;]&quot;));</span>
<span class="fc" id="L334">                    this.sb.append(</span>
                        &quot;for(&quot;
                            + varType
<span class="fc" id="L337">                            + whitespace()</span>
                            + element
                            + &quot; = 0;&quot;
                            + element
                            + &quot; &lt; sizeof(&quot;
                            + arr
                            + &quot;) / sizeof(&quot;
                            + arr
                            + &quot;[0]); &quot;
                            + element
                            + &quot;++) {&quot;);
                } else {
<span class="nc" id="L349">                    this.sb.append(&quot;while(false){&quot;);</span>
                }
<span class="nc" id="L351">                break;</span>
            default:
                break;
        }
<span class="fc" id="L355">        incrIndentation();</span>
<span class="fc" id="L356">        repeatStmt.getList().visit(this);</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if ( !isWaitStmt ) {</span>
<span class="fc" id="L358">            addContinueLabelToLoop();</span>
        } else {
<span class="fc" id="L360">            appendBreakStmt();</span>
        }
<span class="fc" id="L362">        decrIndentation();</span>
<span class="fc" id="L363">        nlIndent();</span>
<span class="fc" id="L364">        this.sb.append(&quot;}&quot;);</span>
<span class="fc" id="L365">        addBreakLabelToLoop(isWaitStmt);</span>

<span class="fc" id="L367">        return null;</span>
    }

    @Override
    public Void visitWaitStmt(WaitStmt&lt;Void&gt; waitStmt) {
<span class="fc" id="L372">        this.sb.append(&quot;while (true) {&quot;);</span>
<span class="fc" id="L373">        incrIndentation();</span>
<span class="fc" id="L374">        visitStmtList(waitStmt.getStatements());</span>
<span class="fc" id="L375">        nlIndent();</span>
<span class="fc" id="L376">        this.sb.append(&quot;Wait(15);&quot;);</span>
<span class="fc" id="L377">        decrIndentation();</span>
<span class="fc" id="L378">        nlIndent();</span>
<span class="fc" id="L379">        this.sb.append(&quot;}&quot;);</span>
<span class="fc" id="L380">        return null;</span>
    }

    @Override
    public Void visitWaitTimeStmt(WaitTimeStmt&lt;Void&gt; waitTimeStmt) {
<span class="nc" id="L385">        this.sb.append(&quot;Wait(&quot;);</span>
<span class="nc" id="L386">        waitTimeStmt.getTime().visit(this);</span>
<span class="nc" id="L387">        this.sb.append(&quot;);&quot;);</span>
<span class="nc" id="L388">        return null;</span>
    }

    // TODO add uploading pictures to NXT before implementing this.
    @Override
    public Void visitShowPictureAction(ShowPictureAction&lt;Void&gt; showPictureAction) {
<span class="nc" id="L394">        return null;</span>
    }

    @Override
    public Void visitShowTextAction(ShowTextAction&lt;Void&gt; showTextAction) {
        String methodName;
<span class="pc bpc" id="L400" title="5 of 6 branches missed.">        switch ( showTextAction.getMsg().getVarType() ) {</span>
            case ARRAY_STRING:
            case STRING:
<span class="fc" id="L403">                methodName = &quot;TextOut&quot;;</span>
<span class="fc" id="L404">                break;</span>
            case ARRAY_BOOLEAN:
            case BOOLEAN:
<span class="nc" id="L407">                methodName = &quot;BoolOut&quot;;</span>
<span class="nc" id="L408">                break;</span>
            case COLOR:
<span class="nc" id="L410">                methodName = &quot;ColorOut&quot;;</span>
<span class="nc" id="L411">                break;</span>
            case NOTHING:
<span class="nc bnc" id="L413" title="All 2 branches missed.">                if ( showTextAction.getMsg().getProperty().getBlockType().toString().contains(&quot;isPressed&quot;)</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">                    || showTextAction.getMsg().getProperty().getBlockType().toString().contains(&quot;logic_ternary&quot;) ) {</span>
<span class="nc" id="L415">                    methodName = &quot;BoolOut&quot;;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                } else if ( showTextAction.getMsg().getProperty().getBlockType().toString().contains(&quot;colour&quot;) ) {</span>
<span class="nc" id="L417">                    methodName = &quot;ColorOut&quot;;</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">                } else if ( showTextAction.getMsg().getProperty().getBlockType().toString().contains(&quot;robSensors&quot;)</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">                    || showTextAction.getMsg().getProperty().getBlockType().toString().contains(&quot;robActions&quot;)</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;POWER&quot;) ) {</span>
<span class="nc" id="L421">                    methodName = &quot;NumOut&quot;;</span>
                } else {
<span class="nc" id="L423">                    methodName = &quot;TextOut&quot;;</span>
                }
<span class="nc" id="L425">                break;</span>
            case CAPTURED_TYPE:
<span class="nc bnc" id="L427" title="All 2 branches missed.">                if ( showTextAction.getMsg().toString().contains(&quot;Number&quot;)</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;ADD&quot;)</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;MINUS&quot;)</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;MULTIPLY&quot;)</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;DIVIDE&quot;)</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;MOD&quot;)</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;NEG&quot;)</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;LISTS_LENGTH&quot;)</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;IndexOfFunct&quot;)</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;[ListGetIndex [GET, FROM_START, [ListCreate [NUMBER&quot;)</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;[ListGetIndex [GET, FROM_START, [ListCreate [CONNECTION&quot;)</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;MotorGetPower&quot;)</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;VolumeAction&quot;) ) {</span>
<span class="nc" id="L440">                    methodName = &quot;NumOut&quot;;</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">                } else if ( showTextAction.getMsg().toString().contains(&quot;EQ&quot;)</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;NEQ&quot;)</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;LT&quot;)</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;LTE&quot;)</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;GT&quot;)</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;GTE&quot;)</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;LIST_IS_EMPTY&quot;)</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;AND&quot;)</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;OR&quot;)</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;NOT&quot;)</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;[ListGetIndex [GET, FROM_START, [ListCreate [BOOLEAN&quot;)</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">                    || showTextAction.getMsg().toString().contains(&quot;BluetoothConnectAction&quot;) ) {</span>
<span class="nc" id="L453">                    methodName = &quot;BoolOut&quot;;</span>
                } else {
<span class="nc" id="L455">                    methodName = &quot;TextOut&quot;;</span>
                }
<span class="nc" id="L457">                break;</span>
            default:
<span class="nc" id="L459">                methodName = &quot;NumOut&quot;;</span>
                break;
        }
<span class="fc" id="L462">        this.sb.append(methodName + &quot;(&quot;);</span>
<span class="fc" id="L463">        showTextAction.getX().visit(this);</span>
<span class="fc" id="L464">        this.sb.append(&quot;, (MAXLINES - &quot;);</span>
<span class="fc" id="L465">        showTextAction.getY().visit(this);</span>

<span class="fc" id="L467">        this.sb.append(&quot;) * MAXLINES, &quot;);</span>
<span class="fc" id="L468">        showTextAction.getMsg().visit(this);</span>
<span class="fc" id="L469">        this.sb.append(&quot;);&quot;);</span>
<span class="fc" id="L470">        return null;</span>
    }

    @Override
    public Void visitClearDisplayAction(ClearDisplayAction&lt;Void&gt; clearDisplayAction) {
<span class="nc" id="L475">        this.sb.append(&quot;ClearScreen();&quot;);</span>
<span class="nc" id="L476">        return null;</span>
    }

    @Override
    public Void visitVolumeAction(VolumeAction&lt;Void&gt; volumeAction) {
<span class="pc bpc" id="L481" title="1 of 3 branches missed.">        switch ( volumeAction.getMode() ) {</span>
            case SET:
<span class="fc" id="L483">                this.sb.append(&quot;volume = (&quot;);</span>
<span class="fc" id="L484">                volumeAction.getVolume().visit(this);</span>
<span class="fc" id="L485">                this.sb.append(&quot;) * 4 / 100.0;&quot;);</span>
<span class="fc" id="L486">                break;</span>
            case GET:
<span class="fc" id="L488">                this.sb.append(&quot;volume * 100 / 4&quot;);</span>
<span class="fc" id="L489">                break;</span>
            default:
<span class="nc" id="L491">                throw new DbcException(&quot;Invalid volume action mode!&quot;);</span>
        }
<span class="fc" id="L493">        return null;</span>
    }

    @Override
    public Void visitSetLanguageAction(SetLanguageAction&lt;Void&gt; setLanguageAction) {
<span class="nc" id="L498">        return null;</span>
    }

    @Override
    public Void visitSayTextAction(SayTextAction&lt;Void&gt; sayTextAction) {
<span class="nc" id="L503">        return null;</span>
    }

    @Override
    public Void visitLightStatusAction(LightStatusAction&lt;Void&gt; lightStatusAction) {
<span class="nc" id="L508">        return null;</span>
    }

    @Override
    public Void visitPlayFileAction(PlayFileAction&lt;Void&gt; playFileAction) {
<span class="fc" id="L513">        this.sb.append(&quot;PlayFile(&quot; + playFileAction.getFileName() + &quot;);&quot;);</span>
<span class="fc" id="L514">        return null;</span>
    }

    @Override
    public Void visitToneAction(ToneAction&lt;Void&gt; toneAction) {
<span class="fc" id="L519">        this.sb.append(&quot;PlayToneEx(&quot;);</span>
<span class="fc" id="L520">        toneAction.getFrequency().visit(this);</span>
<span class="fc" id="L521">        this.sb.append(&quot;, &quot;);</span>
<span class="fc" id="L522">        toneAction.getDuration().visit(this);</span>
<span class="fc" id="L523">        this.sb.append(&quot;, volume, false);&quot;);</span>
<span class="fc" id="L524">        nlIndent();</span>
<span class="fc" id="L525">        this.sb.append(&quot;Wait(&quot;);</span>
<span class="fc" id="L526">        toneAction.getDuration().visit(this);</span>
<span class="fc" id="L527">        this.sb.append(&quot;);&quot;);</span>
<span class="fc" id="L528">        return null;</span>
    }

    @Override
    public Void visitPlayNoteAction(PlayNoteAction&lt;Void&gt; playNoteAction) {
<span class="fc" id="L533">        this.sb.append(&quot;PlayToneEx(&quot;);</span>
<span class="fc" id="L534">        this.sb.append(playNoteAction.getFrequency());</span>
<span class="fc" id="L535">        this.sb.append(&quot;, &quot;);</span>
<span class="fc" id="L536">        this.sb.append(playNoteAction.getDuration());</span>
<span class="fc" id="L537">        this.sb.append(&quot;, volume, false);&quot;);</span>
<span class="fc" id="L538">        nlIndent();</span>
<span class="fc" id="L539">        this.sb.append(&quot;Wait(&quot;);</span>
<span class="fc" id="L540">        this.sb.append(playNoteAction.getDuration());</span>
<span class="fc" id="L541">        this.sb.append(&quot;);&quot;);</span>
<span class="fc" id="L542">        return null;</span>
    }

    private boolean isActorOnPort(IActorPort port) {
<span class="fc" id="L546">        boolean isActorOnPort = false;</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        if ( port != null ) {</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">            for ( UsedActor actor : this.usedActors ) {</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">                isActorOnPort = isActorOnPort ? isActorOnPort : actor.getPort().equals(port);</span>
<span class="fc" id="L550">            }</span>
        }
<span class="fc" id="L552">        return isActorOnPort;</span>
    }

    @Override
    public Void visitMotorOnAction(MotorOnAction&lt;Void&gt; motorOnAction) {
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">        if ( isActorOnPort(motorOnAction.getPort()) ) {</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">            final boolean reverse = this.brickConfiguration.getActorOnPort(motorOnAction.getPort()).getRotationDirection() == DriveDirection.BACKWARD;</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">            final boolean isDuration = motorOnAction.getParam().getDuration() != null;</span>
<span class="fc" id="L560">            final boolean isRegulatedDrive = this.brickConfiguration.isMotorRegulated(motorOnAction.getPort());</span>
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">            String sign = reverse ? &quot;-&quot; : &quot;&quot;;</span>
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">            String methodNamePart = reverse ? &quot;OnRev&quot; : &quot;OnFwd&quot;;</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">            if ( isDuration ) {</span>
<span class="fc" id="L564">                this.sb.append(&quot;RotateMotor(OUT_&quot; + motorOnAction.getPort() + &quot;, &quot; + sign + &quot;SpeedTest(&quot;);</span>
<span class="fc" id="L565">                motorOnAction.getParam().getSpeed().visit(this);</span>
<span class="fc" id="L566">                this.sb.append(&quot;)&quot;);</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">                if ( motorOnAction.getDurationMode() == MotorMoveMode.ROTATIONS ) {</span>
<span class="fc" id="L568">                    this.sb.append(&quot;, 360 * &quot;);</span>
                } else {
<span class="nc" id="L570">                    this.sb.append(&quot;, &quot;);</span>
                }
<span class="fc" id="L572">                motorOnAction.getParam().getDuration().getValue().visit(this);</span>
            } else {
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">                if ( isRegulatedDrive ) {</span>
<span class="fc" id="L575">                    this.sb.append(methodNamePart + &quot;Reg(OUT_&quot; + motorOnAction.getPort() + &quot;, SpeedTest(&quot;);</span>
<span class="fc" id="L576">                    motorOnAction.getParam().getSpeed().visit(this);</span>
<span class="fc" id="L577">                    this.sb.append(&quot;), OUT_REGMODE_SPEED&quot;);</span>
                } else {
<span class="nc" id="L579">                    this.sb.append(methodNamePart + &quot;(OUT_&quot; + motorOnAction.getPort() + &quot;, SpeedTest(&quot;);</span>
<span class="nc" id="L580">                    motorOnAction.getParam().getSpeed().visit(this);</span>
<span class="nc" id="L581">                    this.sb.append(&quot;)&quot;);</span>
                }
            }
<span class="fc" id="L584">            this.sb.append(&quot;);&quot;);</span>
        }
<span class="fc" id="L586">        return null;</span>
    }

    @Override
    public Void visitMotorSetPowerAction(MotorSetPowerAction&lt;Void&gt; motorSetPowerAction) {
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">        if ( isActorOnPort(motorSetPowerAction.getPort()) ) {</span>
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">            final boolean reverse = this.brickConfiguration.getActorOnPort(motorSetPowerAction.getPort()).getRotationDirection() == DriveDirection.BACKWARD;</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">            String sign = reverse ? &quot;-&quot; : &quot;&quot;;</span>
<span class="fc" id="L594">            final String methodName = &quot;OnFwdReg&quot;;</span>
            //final boolean isRegulated = brickConfiguration.isMotorRegulated(motorSetPowerAction.getPort());
<span class="fc" id="L596">            this.sb.append(methodName + &quot;(OUT_&quot; + motorSetPowerAction.getPort() + &quot;, &quot; + sign + &quot;SpeedTest(&quot;);</span>
<span class="fc" id="L597">            motorSetPowerAction.getPower().visit(this);</span>
<span class="fc" id="L598">            this.sb.append(&quot;), OUT_REGMODE_SPEED&quot;);</span>
<span class="fc" id="L599">            this.sb.append(&quot;);&quot;);</span>
        }
<span class="fc" id="L601">        return null;</span>
    }

    @Override
    public Void visitMotorGetPowerAction(MotorGetPowerAction&lt;Void&gt; motorGetPowerAction) {
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">        if ( isActorOnPort(motorGetPowerAction.getPort()) ) {</span>
<span class="fc" id="L607">            final String methodName = &quot;MotorPower&quot;;</span>
<span class="fc" id="L608">            this.sb.append(methodName + &quot;(OUT_&quot; + motorGetPowerAction.getPort());</span>
<span class="fc" id="L609">            this.sb.append(&quot;)&quot;);</span>
        }
<span class="fc" id="L611">        return null;</span>
    }

    @Override
    public Void visitMotorStopAction(MotorStopAction&lt;Void&gt; motorStopAction) {
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">        if ( motorStopAction.getMode() == MotorStopMode.FLOAT ) {</span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">            if ( isActorOnPort(motorStopAction.getPort()) ) {</span>
<span class="fc" id="L618">                this.sb.append(&quot;Float(OUT_&quot; + motorStopAction.getPort());</span>
<span class="fc" id="L619">                this.sb.append(&quot;);&quot;);</span>
            }
        } else {
<span class="nc bnc" id="L622" title="All 2 branches missed.">            if ( isActorOnPort(motorStopAction.getPort()) ) {</span>
<span class="nc" id="L623">                this.sb.append(&quot;Off(OUT_&quot; + motorStopAction.getPort());</span>
<span class="nc" id="L624">                this.sb.append(&quot;);&quot;);</span>
            }
        }
<span class="fc" id="L627">        return null;</span>
    }

    @Override
    public Void visitDriveAction(DriveAction&lt;Void&gt; driveAction) {
<span class="pc bpc" id="L632" title="2 of 4 branches missed.">        if ( isActorOnPort(this.brickConfiguration.getLeftMotorPort()) &amp;&amp; isActorOnPort(this.brickConfiguration.getRightMotorPort()) ) {</span>
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">            final boolean isDuration = driveAction.getParam().getDuration() != null;</span>
<span class="fc" id="L634">            final boolean reverse =</span>
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">                (this.brickConfiguration.getActorOnPort(this.brickConfiguration.getLeftMotorPort()).getRotationDirection() == DriveDirection.BACKWARD)</span>
<span class="pc bpc" id="L636" title="1 of 2 branches missed.">                    || (this.brickConfiguration.getActorOnPort(this.brickConfiguration.getRightMotorPort()).getRotationDirection() == DriveDirection.BACKWARD);</span>
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">            final boolean localReverse = driveAction.getDirection() == DriveDirection.BACKWARD;</span>
<span class="fc" id="L638">            String methodName = &quot;&quot;;</span>
<span class="pc bpc" id="L639" title="1 of 2 branches missed.">            if ( isDuration ) {</span>
<span class="nc" id="L640">                methodName = &quot;RotateMotorEx&quot;;</span>
            } else {
<span class="fc" id="L642">                methodName = &quot;OnFwdReg&quot;;</span>
            }
<span class="fc" id="L644">            this.sb.append(methodName + &quot;(OUT_&quot;);</span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">            if ( this.brickConfiguration.getLeftMotorPort().toString().charAt(0) &lt; this.brickConfiguration.getRightMotorPort().toString().charAt(0) ) {</span>
<span class="fc" id="L646">                this.sb.append(this.brickConfiguration.getLeftMotorPort());</span>
<span class="fc" id="L647">                this.sb.append(this.brickConfiguration.getRightMotorPort());</span>
            } else {
<span class="nc" id="L649">                this.sb.append(this.brickConfiguration.getRightMotorPort());</span>
<span class="nc" id="L650">                this.sb.append(this.brickConfiguration.getLeftMotorPort());</span>
            }
<span class="pc bpc" id="L652" title="4 of 8 branches missed.">            if ( (!reverse &amp;&amp; localReverse) || (!localReverse &amp;&amp; reverse) ) {</span>
<span class="nc" id="L653">                this.sb.append(&quot;, -1 * &quot;);</span>
            } else {
<span class="fc" id="L655">                this.sb.append(&quot;, &quot;);</span>
            }
<span class="fc" id="L657">            this.sb.append(&quot;SpeedTest(&quot;);</span>
<span class="fc" id="L658">            driveAction.getParam().getSpeed().visit(this);</span>
<span class="fc" id="L659">            this.sb.append(&quot;)&quot;).append(&quot;, &quot;);</span>
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">            if ( isDuration ) {</span>
<span class="nc" id="L661">                this.sb.append(&quot;(&quot;);</span>
<span class="nc" id="L662">                driveAction.getParam().getDuration().getValue().visit(this);</span>
<span class="nc" id="L663">                this.sb.append(&quot; * 360 / (PI * WHEELDIAMETER)), 0, true, true);&quot;);</span>
<span class="nc" id="L664">                this.nlIndent();</span>
<span class="nc" id="L665">                this.sb.append(&quot;Wait(1&quot;);</span>
            } else {
<span class="fc" id="L667">                this.sb.append(&quot;OUT_REGMODE_SYNC&quot;);</span>
            }
<span class="fc" id="L669">            this.sb.append(&quot;);&quot;);</span>
        }
<span class="fc" id="L671">        return null;</span>
    }

    @Override
    public Void visitTurnAction(TurnAction&lt;Void&gt; turnAction) {
<span class="pc bpc" id="L676" title="2 of 4 branches missed.">        if ( isActorOnPort(this.brickConfiguration.getLeftMotorPort()) &amp;&amp; isActorOnPort(this.brickConfiguration.getRightMotorPort()) ) {</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">            final boolean isDuration = turnAction.getParam().getDuration() != null;</span>
<span class="fc" id="L678">            final boolean reverse =</span>
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">                (this.brickConfiguration.getActorOnPort(this.brickConfiguration.getLeftMotorPort()).getRotationDirection() == DriveDirection.BACKWARD)</span>
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">                    || (this.brickConfiguration.getActorOnPort(this.brickConfiguration.getRightMotorPort()).getRotationDirection() == DriveDirection.BACKWARD);</span>

<span class="fc" id="L682">            String methodName = &quot;&quot;;</span>
<span class="fc" id="L683">            int turnpct = 100;</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">            if ( isDuration ) {</span>
<span class="fc" id="L685">                methodName = &quot;RotateMotorEx&quot;;</span>
            } else {
<span class="fc" id="L687">                methodName = &quot;OnFwdSync&quot;;</span>
            }
<span class="fc" id="L689">            this.sb.append(methodName + &quot;(OUT_&quot;);</span>
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">            if ( this.brickConfiguration.getLeftMotorPort().toString().charAt(0) &lt; this.brickConfiguration.getRightMotorPort().toString().charAt(0) ) {</span>
<span class="fc" id="L691">                turnpct *= -1;</span>
<span class="fc" id="L692">                this.sb.append(this.brickConfiguration.getLeftMotorPort());</span>
<span class="fc" id="L693">                this.sb.append(this.brickConfiguration.getRightMotorPort());</span>
            } else {
<span class="nc" id="L695">                this.sb.append(this.brickConfiguration.getRightMotorPort());</span>
<span class="nc" id="L696">                this.sb.append(this.brickConfiguration.getLeftMotorPort());</span>
            }
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">            if ( reverse ) {</span>
<span class="nc" id="L699">                turnpct *= -1;</span>
            }
<span class="fc" id="L701">            this.sb.append(&quot;, SpeedTest(&quot;);</span>
<span class="fc" id="L702">            turnAction.getParam().getSpeed().visit(this);</span>
<span class="fc" id="L703">            this.sb.append(&quot;)&quot;);</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">            if ( turnAction.getDirection() == TurnDirection.LEFT ) {</span>
<span class="nc" id="L705">                turnpct *= -1;</span>
            }
<span class="fc" id="L707">            this.sb.append(&quot;, &quot;);</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">            if ( isDuration ) {</span>
<span class="fc" id="L709">                this.sb.append(&quot;(&quot;);</span>
<span class="fc" id="L710">                turnAction.getParam().getDuration().getValue().visit(this);</span>
<span class="fc" id="L711">                this.sb.append(&quot; * TRACKWIDTH / WHEELDIAMETER), &quot; + turnpct + &quot;, true, true);&quot;);</span>
<span class="fc" id="L712">                this.nlIndent();</span>
<span class="fc" id="L713">                this.sb.append(&quot;Wait(1&quot;);</span>
            } else {
<span class="fc" id="L715">                this.sb.append(turnpct);</span>
            }
<span class="fc" id="L717">            this.sb.append(&quot;);&quot;);</span>
        }
<span class="fc" id="L719">        return null;</span>
    }

    @Override
    public Void visitCurveAction(CurveAction&lt;Void&gt; curveAction) {
<span class="pc bpc" id="L724" title="2 of 4 branches missed.">        if ( isActorOnPort(this.brickConfiguration.getLeftMotorPort()) &amp;&amp; isActorOnPort(this.brickConfiguration.getRightMotorPort()) ) {</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">            final boolean isDuration = curveAction.getParamLeft().getDuration() != null;</span>
<span class="fc" id="L726">            final boolean confForward =</span>
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">                this.brickConfiguration.getActorOnPort(this.brickConfiguration.getLeftMotorPort()).getRotationDirection() == DriveDirection.FOREWARD;</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">            final boolean blockForward = curveAction.getDirection() == DriveDirection.FOREWARD;</span>
<span class="fc" id="L729">            String methodName = &quot;&quot;;</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">            if ( isDuration ) {</span>
<span class="fc" id="L731">                methodName = &quot;SteerDriveEx&quot;;</span>
            } else {
<span class="fc" id="L733">                methodName = &quot;SteerDrive&quot;;</span>
            }
<span class="fc" id="L735">            this.sb.append(methodName);</span>
<span class="fc" id="L736">            this.sb.append(&quot;(OUT_&quot; + this.brickConfiguration.getLeftMotorPort());</span>
<span class="fc" id="L737">            this.sb.append(&quot;, OUT_&quot; + this.brickConfiguration.getRightMotorPort());</span>
<span class="fc" id="L738">            this.sb.append(&quot;, SpeedTest(&quot;);</span>
<span class="fc" id="L739">            curveAction.getParamLeft().getSpeed().visit(this);</span>
<span class="fc" id="L740">            this.sb.append(&quot;), SpeedTest(&quot;);</span>
<span class="fc" id="L741">            curveAction.getParamRight().getSpeed().visit(this);</span>
<span class="fc" id="L742">            this.sb.append(&quot;), &quot;);</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">            this.sb.append(confForward == blockForward);</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">            if ( isDuration ) {</span>
<span class="fc" id="L745">                this.sb.append(&quot;, &quot;);</span>
<span class="fc" id="L746">                curveAction.getParamLeft().getDuration().getValue().visit(this);</span>
            }
<span class="fc" id="L748">            this.sb.append(&quot;);&quot;);</span>
        }
<span class="fc" id="L750">        return null;</span>
    }

    @Override
    public Void visitMotorDriveStopAction(MotorDriveStopAction&lt;Void&gt; stopAction) {
<span class="pc bpc" id="L755" title="2 of 4 branches missed.">        if ( isActorOnPort(this.brickConfiguration.getLeftMotorPort()) &amp;&amp; isActorOnPort(this.brickConfiguration.getRightMotorPort()) ) {</span>
<span class="fc" id="L756">            this.sb.append(&quot;Off(OUT_&quot;);</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">            if ( this.brickConfiguration.getLeftMotorPort().toString().charAt(0) &lt; this.brickConfiguration.getRightMotorPort().toString().charAt(0) ) {</span>
<span class="fc" id="L758">                this.sb.append(this.brickConfiguration.getLeftMotorPort());</span>
<span class="fc" id="L759">                this.sb.append(this.brickConfiguration.getRightMotorPort());</span>
            } else {
<span class="nc" id="L761">                this.sb.append(this.brickConfiguration.getRightMotorPort());</span>
<span class="nc" id="L762">                this.sb.append(this.brickConfiguration.getLeftMotorPort());</span>
            }
<span class="fc" id="L764">            this.sb.append(&quot;);&quot;);</span>
        }
<span class="fc" id="L766">        return null;</span>
    }

    @Override
    public Void visitLightAction(LightAction&lt;Void&gt; lightAction) {
<span class="fc bfc" id="L771" title="All 2 branches covered.">        if ( lightAction.getMode().toString().equals(&quot;ON&quot;) ) {</span>
<span class="fc" id="L772">            this.sb.append(&quot;SetSensorColor&quot; + lightAction.getColor().getValues()[0] + &quot;(&quot;);</span>
        } else {
<span class="fc" id="L774">            this.sb.append(&quot;SetSensorColorNone(&quot;);</span>
        }
<span class="fc" id="L776">        this.sb.append(lightAction.getPort());</span>
<span class="fc" id="L777">        this.sb.append(&quot;);&quot;);</span>
<span class="fc" id="L778">        return null;</span>
    }

    @Override
    public Void visitLightSensor(LightSensor&lt;Void&gt; lightSensor) {
<span class="fc" id="L783">        this.sb.append(&quot;SensorLight(&quot;);</span>
<span class="fc" id="L784">        this.sb.append(lightSensor.getPort().getCodeName());</span>
<span class="fc" id="L785">        this.sb.append(&quot;, &quot;);</span>
<span class="fc" id="L786">        this.sb.append(&quot;\&quot;&quot; + lightSensor.getMode() + &quot;\&quot;&quot;);</span>
<span class="fc" id="L787">        this.sb.append(&quot;)&quot;);</span>
<span class="fc" id="L788">        return null;</span>
    }

    @Override
    public Void visitBrickSensor(BrickSensor&lt;Void&gt; brickSensor) {
<span class="fc" id="L793">        this.sb.append(&quot;ButtonPressed(&quot; + brickSensor.getPort().getCodeName() + &quot;, false)&quot;);</span>
<span class="fc" id="L794">        return null;</span>
    }

    @Override
    public Void visitColorSensor(ColorSensor&lt;Void&gt; colorSensor) {
<span class="nc bnc" id="L799" title="All 2 branches missed.">        if ( this.brickConfiguration.getSensorOnPort((ISensorPort) colorSensor.getPort()).getType().toString().contains(&quot;HT_COLOR&quot;) ) {</span>
<span class="nc" id="L800">            this.sb.append(&quot;SensorHtColor(&quot;);</span>
        } else {
<span class="nc" id="L802">            this.sb.append(&quot;SensorColor(&quot;);</span>
        }
<span class="nc" id="L804">        this.sb.append(colorSensor.getPort().getCodeName());</span>
<span class="nc" id="L805">        this.sb.append(&quot;, &quot;);</span>
<span class="nc" id="L806">        ColorSensorMode sensorMode = (ColorSensorMode) colorSensor.getMode();</span>
<span class="pc bnc" id="L807" title="All 4 branches missed.">        switch ( sensorMode ) {</span>
            case COLOUR:
<span class="nc" id="L809">                this.sb.append(&quot;\&quot;COLOR\&quot;&quot;);</span>
<span class="nc" id="L810">                break;</span>
            case AMBIENTLIGHT:
<span class="nc" id="L812">                this.sb.append(&quot;\&quot;AMBIENTLIGHT\&quot;&quot;);</span>
<span class="nc" id="L813">                break;</span>
            case LIGHT:
<span class="nc" id="L815">                this.sb.append(&quot;\&quot;LIGHT\&quot;&quot;);</span>
<span class="nc" id="L816">                break;</span>
            default:
<span class="nc" id="L818">                throw new DbcException(&quot;Invalide Color Sensor Mode: &quot; + sensorMode + &quot; !&quot;);</span>
        }
<span class="nc" id="L820">        this.sb.append(&quot;)&quot;);</span>
<span class="nc" id="L821">        return null;</span>
    }

    @Override
    public Void visitSoundSensor(SoundSensor&lt;Void&gt; soundSensor) {
<span class="nc" id="L826">        this.sb.append(&quot;Sensor(&quot;);</span>
<span class="nc" id="L827">        this.sb.append(soundSensor.getPort().getCodeName());</span>
<span class="nc" id="L828">        this.sb.append(&quot;)&quot;);</span>
<span class="nc" id="L829">        return null;</span>
    }

    @Override
    public Void visitEncoderSensor(EncoderSensor&lt;Void&gt; encoderSensor) {
<span class="fc" id="L834">        ActorPort encoderMotorPort = (ActorPort) encoderSensor.getPort();</span>
<span class="fc" id="L835">        MotorTachoMode mode = (MotorTachoMode) encoderSensor.getMode();</span>
<span class="pc bpc" id="L836" title="2 of 5 branches missed.">        switch ( mode ) {</span>
            case RESET:
<span class="fc" id="L838">                this.sb.append(&quot;ResetTachoCount(OUT_&quot; + encoderMotorPort + &quot;);&quot;);</span>
<span class="fc" id="L839">                break;</span>
            case ROTATION:
<span class="fc" id="L841">                this.sb.append(&quot;MotorTachoCount(OUT_&quot; + encoderMotorPort + &quot;) / 360.0&quot;);</span>
<span class="fc" id="L842">                break;</span>
            case DEGREE:
<span class="fc" id="L844">                this.sb.append(&quot;MotorTachoCount(OUT_&quot; + encoderMotorPort + &quot;)&quot;);</span>
<span class="fc" id="L845">                break;</span>
            case DISTANCE:
<span class="nc" id="L847">                this.sb.append(&quot;MotorTachoCount(OUT_&quot; + encoderMotorPort + &quot;) * PI / 360.0 * WHEELDIAMETER&quot;);</span>
<span class="nc" id="L848">                break;</span>
            default:
<span class="nc" id="L850">                throw new DbcException(&quot;Invalide encoder sensor mode:&quot; + mode + &quot;!&quot;);</span>

        }
<span class="fc" id="L853">        return null;</span>
    }

    @Override
    public Void visitGyroSensor(GyroSensor&lt;Void&gt; gyroSensor) {
<span class="nc" id="L858">        return null;</span>
    }

    @Override
    public Void visitInfraredSensor(InfraredSensor&lt;Void&gt; infraredSensor) {
<span class="nc" id="L863">        return null;</span>
    }

    @Override
    public Void visitTimerSensor(TimerSensor&lt;Void&gt; timerSensor) {
<span class="fc" id="L868">        String timerNumber = timerSensor.getPort().getOraName();</span>
<span class="pc bpc" id="L869" title="1 of 3 branches missed.">        switch ( (TimerSensorMode) timerSensor.getMode() ) {</span>
            case DEFAULT:
            case VALUE:
<span class="fc" id="L872">                this.sb.append(&quot;GetTimerValue(timer&quot; + timerNumber + &quot;)&quot;);</span>
<span class="fc" id="L873">                break;</span>
            case RESET:
<span class="fc" id="L875">                this.sb.append(&quot;ResetTimerValue(timer&quot; + timerNumber + &quot;);&quot;);</span>
<span class="fc" id="L876">                break;</span>
            default:
<span class="nc" id="L878">                throw new DbcException(&quot;Invalid Time Mode!&quot;);</span>
        }
<span class="fc" id="L880">        return null;</span>
    }

    @Override
    public Void visitTouchSensor(TouchSensor&lt;Void&gt; touchSensor) {
<span class="fc" id="L885">        this.sb.append(&quot;Sensor(&quot; + touchSensor.getPort().getCodeName());</span>
<span class="fc" id="L886">        this.sb.append(&quot;)&quot;);</span>
<span class="fc" id="L887">        return null;</span>
    }

    @Override
    public Void visitUltrasonicSensor(UltrasonicSensor&lt;Void&gt; ultrasonicSensor) {
<span class="fc" id="L892">        this.sb.append(&quot;SensorUS(&quot; + ultrasonicSensor.getPort().getCodeName() + &quot;)&quot;);</span>
<span class="fc" id="L893">        return null;</span>
    }

    @Override
    public Void visitCompassSensor(CompassSensor&lt;Void&gt; compassSensor) {

<span class="nc" id="L899">        return null;</span>
    }

    @Override
    public Void visitMainTask(MainTask&lt;Void&gt; mainTask) {
<span class="fc bfc" id="L904" title="All 2 branches covered.">        if ( this.isVolumeVariableNeeded ) {</span>
<span class="fc" id="L905">            this.sb.append(&quot;byte volume = 0x02;&quot;);</span>
        }
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">        if ( this.timeSensorUsed ) {</span>
<span class="nc" id="L908">            nlIndent();</span>
<span class="nc" id="L909">            this.sb.append(&quot;long timer1;&quot;);</span>
        }
        //this.sb.append(this.tmpArr);
<span class="fc" id="L912">        mainTask.getVariables().visit(this);</span>
<span class="fc" id="L913">        incrIndentation();</span>
<span class="fc" id="L914">        this.sb.append(&quot;\n&quot;).append(&quot;task main() {&quot;);</span>
<span class="fc" id="L915">        this.generateUsedVars();</span>
<span class="fc" id="L916">        this.generateSensors();</span>
<span class="fc" id="L917">        return null;</span>
    }

    @Override
    public Void visitGetSubFunct(GetSubFunct&lt;Void&gt; getSubFunct) {
<span class="nc" id="L922">        return null;</span>

    }

    @Override
    public Void visitIndexOfFunct(IndexOfFunct&lt;Void&gt; indexOfFunct) {
<span class="nc" id="L928">        BlocklyType arrayType = indexOfFunct.getParam().get(0).getVarType();</span>
<span class="nc" id="L929">        String methodName = &quot;ArrFindFirst&quot;;</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">        if ( indexOfFunct.getLocation() == IndexLocation.LAST ) {</span>
<span class="nc" id="L931">            methodName = &quot;ArrFindLast&quot;;</span>
        }
<span class="nc bnc" id="L933" title="All 5 branches missed.">        switch ( arrayType ) {</span>
            case NUMBER:
            case ARRAY_CONNECTION:
            case ARRAY_NUMBER:
<span class="nc" id="L937">                methodName += &quot;Num(&quot;;</span>
<span class="nc" id="L938">                break;</span>
            case STRING:
            case ARRAY_STRING:
<span class="nc" id="L941">                methodName += &quot;Str(&quot;;</span>
<span class="nc" id="L942">                break;</span>
            case BOOLEAN:
            case ARRAY_BOOLEAN:
<span class="nc" id="L945">                methodName += &quot;Bool(&quot;;</span>
<span class="nc" id="L946">                break;</span>
            case NOTHING:
<span class="nc" id="L948">                methodName += &quot;Num(&quot;;</span>
            default:
<span class="nc" id="L950">                throw new DbcException(&quot;Invalid array type: &quot; + arrayType);</span>
        }

<span class="nc" id="L953">        this.sb.append(methodName);</span>
        /*if ( !indexOfFunct.getParam().get(0).getVarType().toString().contains(&quot;ARRAY&quot;) ) {
            this.tmpArrCount += 1;
            this.sb.append(&quot;__tmpArr&quot; + this.tmpArrCount);
        } else {*/
<span class="nc" id="L958">        indexOfFunct.getParam().get(0).visit(this);</span>
        //}
<span class="nc" id="L960">        this.sb.append(&quot;, &quot;);</span>
<span class="nc" id="L961">        indexOfFunct.getParam().get(1).visit(this);</span>
<span class="nc" id="L962">        this.sb.append(&quot;)&quot;);</span>
<span class="nc" id="L963">        return null;</span>
    }

    @Override
    public Void visitLengthOfIsEmptyFunct(LengthOfIsEmptyFunct&lt;Void&gt; lengthOfIsEmptyFunct) {
<span class="fc" id="L968">        String methodName = &quot;ArrayLen(&quot;;</span>
<span class="fc bfc" id="L969" title="All 2 branches covered.">        if ( lengthOfIsEmptyFunct.getFunctName() == FunctionNames.LIST_IS_EMPTY ) {</span>
<span class="fc" id="L970">            methodName = &quot;ArrIsEmpty(&quot;;</span>
        }
<span class="fc" id="L972">        this.sb.append(methodName);</span>
        /*if ( !lengthOfIsEmptyFunct.getParam().get(0).getVarType().toString().contains(&quot;ARRAY&quot;) ) {
            this.tmpArrCount += 1;
            this.sb.append(&quot;__tmpArr&quot; + this.tmpArrCount);
        } else {*/
<span class="fc" id="L977">        lengthOfIsEmptyFunct.getParam().get(0).visit(this);</span>
        //}
<span class="fc" id="L979">        this.sb.append(&quot;)&quot;);</span>
<span class="fc" id="L980">        return null;</span>
    }

    @Override
    public Void visitListGetIndex(ListGetIndex&lt;Void&gt; listGetIndex) {
        /*if ( !listGetIndex.getParam().get(0).getVarType().toString().contains(&quot;ARRAY&quot;) ) {
        this.tmpArrCount += 1;
        this.sb.append(&quot;__tmpArr&quot; + this.tmpArrCount);
        } else {*/
<span class="nc" id="L989">        listGetIndex.getParam().get(0).visit(this);</span>
        //}
<span class="nc" id="L991">        this.sb.append(&quot;[&quot;);</span>
<span class="nc" id="L992">        listGetIndex.getParam().get(1).visit(this);</span>
<span class="nc" id="L993">        this.sb.append(&quot;]&quot;);</span>
<span class="nc" id="L994">        return null;</span>
    }

    @Override
    public Void visitListSetIndex(ListSetIndex&lt;Void&gt; listSetIndex) {
<span class="nc" id="L999">        listSetIndex.getParam().get(0).visit(this);</span>
<span class="nc" id="L1000">        this.sb.append(&quot;[&quot;);</span>
        /*if ( !listSetIndex.getParam().get(1).getVarType().toString().contains(&quot;ARRAY&quot;) ) {
            this.tmpArrCount += 1;
            this.sb.append(&quot;__tmpArr&quot; + this.tmpArrCount);
        } else {*/
<span class="nc" id="L1005">        listSetIndex.getParam().get(2).visit(this);</span>
        //}
<span class="nc" id="L1007">        this.sb.append(&quot;]&quot;);</span>
<span class="nc" id="L1008">        this.sb.append(&quot; = &quot;);</span>
<span class="nc" id="L1009">        listSetIndex.getParam().get(1).visit(this);</span>
<span class="nc" id="L1010">        this.sb.append(&quot;;&quot;);</span>
<span class="nc" id="L1011">        return null;</span>
    }

    @Override
    public Void visitMathConstrainFunct(MathConstrainFunct&lt;Void&gt; mathConstrainFunct) {
<span class="fc" id="L1016">        this.sb.append(&quot;Constrain(&quot;);</span>
<span class="fc" id="L1017">        mathConstrainFunct.getParam().get(0).visit(this);</span>
<span class="fc" id="L1018">        this.sb.append(&quot;, &quot;);</span>
<span class="fc" id="L1019">        mathConstrainFunct.getParam().get(1).visit(this);</span>
<span class="fc" id="L1020">        this.sb.append(&quot;, &quot;);</span>
<span class="fc" id="L1021">        mathConstrainFunct.getParam().get(2).visit(this);</span>
<span class="fc" id="L1022">        this.sb.append(&quot;)&quot;);</span>
<span class="fc" id="L1023">        return null;</span>
    }

    @Override
    public Void visitMathNumPropFunct(MathNumPropFunct&lt;Void&gt; mathNumPropFunct) {
<span class="pc bpc" id="L1028" title="1 of 8 branches missed.">        switch ( mathNumPropFunct.getFunctName() ) {</span>
            case EVEN:
<span class="fc" id="L1030">                this.sb.append(&quot;(&quot;);</span>
<span class="fc" id="L1031">                mathNumPropFunct.getParam().get(0).visit(this);</span>
<span class="fc" id="L1032">                this.sb.append(&quot; % 2 == 0)&quot;);</span>
<span class="fc" id="L1033">                break;</span>
            case ODD:
<span class="fc" id="L1035">                this.sb.append(&quot;(&quot;);</span>
<span class="fc" id="L1036">                mathNumPropFunct.getParam().get(0).visit(this);</span>
<span class="fc" id="L1037">                this.sb.append(&quot; % 2 != 0)&quot;);</span>
<span class="fc" id="L1038">                break;</span>
            case PRIME:
<span class="fc" id="L1040">                this.sb.append(&quot;MathPrime(&quot;);</span>
<span class="fc" id="L1041">                mathNumPropFunct.getParam().get(0).visit(this);</span>
<span class="fc" id="L1042">                this.sb.append(&quot;)&quot;);</span>
<span class="fc" id="L1043">                break;</span>
            // % in nxc doesn't leave a a fractional residual, e.g. 5.2%1 = 0, so it is not possible to cheack the wholeness by &quot;%1&quot;, that is why
            //an additional function is used
            case WHOLE:
<span class="fc" id="L1047">                this.sb.append(&quot;MathIsWhole(&quot;);</span>
<span class="fc" id="L1048">                mathNumPropFunct.getParam().get(0).visit(this);</span>
<span class="fc" id="L1049">                this.sb.append(&quot;)&quot;);</span>
<span class="fc" id="L1050">                break;</span>
            case POSITIVE:
<span class="fc" id="L1052">                this.sb.append(&quot;(&quot;);</span>
<span class="fc" id="L1053">                mathNumPropFunct.getParam().get(0).visit(this);</span>
<span class="fc" id="L1054">                this.sb.append(&quot; &gt; 0)&quot;);</span>
<span class="fc" id="L1055">                break;</span>
            case NEGATIVE:
<span class="fc" id="L1057">                this.sb.append(&quot;(&quot;);</span>
<span class="fc" id="L1058">                mathNumPropFunct.getParam().get(0).visit(this);</span>
<span class="fc" id="L1059">                this.sb.append(&quot; &lt; 0)&quot;);</span>
<span class="fc" id="L1060">                break;</span>
            //it would work only for whole numbers, however, I think that it makes sense to talk about being divisible only for the whole numbers
            case DIVISIBLE_BY:
<span class="fc" id="L1063">                this.sb.append(&quot;(&quot;);</span>
<span class="fc" id="L1064">                mathNumPropFunct.getParam().get(0).visit(this);</span>
<span class="fc" id="L1065">                this.sb.append(&quot; % &quot;);</span>
<span class="fc" id="L1066">                mathNumPropFunct.getParam().get(1).visit(this);</span>
<span class="fc" id="L1067">                this.sb.append(&quot; == 0)&quot;);</span>
<span class="fc" id="L1068">                break;</span>
            default:
                break;
        }
<span class="fc" id="L1072">        return null;</span>
    }

    @Override
    public Void visitMathOnListFunct(MathOnListFunct&lt;Void&gt; mathOnListFunct) {
<span class="pc bpc" id="L1077" title="1 of 9 branches missed.">        switch ( mathOnListFunct.getFunctName() ) {</span>
            case SUM:
<span class="fc" id="L1079">                this.sb.append(&quot;ArrSum(&quot;);</span>
<span class="fc" id="L1080">                break;</span>
            case MIN:
<span class="fc" id="L1082">                this.sb.append(&quot;ArrMin(&quot;);</span>
<span class="fc" id="L1083">                break;</span>
            case MAX:
<span class="fc" id="L1085">                this.sb.append(&quot;ArrMax(&quot;);</span>
<span class="fc" id="L1086">                break;</span>
            case AVERAGE:
<span class="fc" id="L1088">                this.sb.append(&quot;ArrMean(&quot;);</span>
<span class="fc" id="L1089">                break;</span>
            case MEDIAN:
<span class="fc" id="L1091">                this.sb.append(&quot;ArrMedian(&quot;);</span>
<span class="fc" id="L1092">                break;</span>
            case STD_DEV:
<span class="fc" id="L1094">                this.sb.append(&quot;ArrStandardDeviatioin(&quot;);</span>
<span class="fc" id="L1095">                break;</span>
            case RANDOM:
<span class="fc" id="L1097">                this.sb.append(&quot;ArrRand(&quot;);</span>
<span class="fc" id="L1098">                break;</span>
            case MODE:
<span class="fc" id="L1100">                this.sb.append(&quot;ArrMode(&quot;);</span>
<span class="fc" id="L1101">                break;</span>
            default:
                break;
        }
        /*if ( !mathOnListFunct.getParam().get(0).getVarType().toString().contains(&quot;ARRAY&quot;) ) {
            this.tmpArrCount += 1;
            this.sb.append(&quot;__tmpArr&quot; + this.tmpArrCount);
        } else {*/
<span class="fc" id="L1109">        mathOnListFunct.getParam().get(0).visit(this);</span>
        //}
<span class="fc" id="L1111">        this.sb.append(&quot;)&quot;);</span>
<span class="fc" id="L1112">        return null;</span>
    }

    @Override
    public Void visitMathRandomFloatFunct(MathRandomFloatFunct&lt;Void&gt; mathRandomFloatFunct) {
<span class="nc" id="L1117">        this.sb.append(&quot;RandomFloat()&quot;);</span>
<span class="nc" id="L1118">        return null;</span>
    }

    @Override
    public Void visitMathRandomIntFunct(MathRandomIntFunct&lt;Void&gt; mathRandomIntFunct) {
<span class="fc" id="L1123">        this.sb.append(&quot;RandomIntegerInRange(&quot;);</span>
<span class="fc" id="L1124">        mathRandomIntFunct.getParam().get(0).visit(this);</span>
<span class="fc" id="L1125">        this.sb.append(&quot;, &quot;);</span>
<span class="fc" id="L1126">        mathRandomIntFunct.getParam().get(1).visit(this);</span>
<span class="fc" id="L1127">        this.sb.append(&quot;)&quot;);</span>
<span class="fc" id="L1128">        return null;</span>
    }

    @Override
    public Void visitMathSingleFunct(MathSingleFunct&lt;Void&gt; mathSingleFunct) {
<span class="pc bpc" id="L1133" title="1 of 16 branches missed.">        switch ( mathSingleFunct.getFunctName() ) {</span>
            case ROOT:
<span class="fc" id="L1135">                this.sb.append(&quot;sqrt(&quot;);</span>
<span class="fc" id="L1136">                break;</span>
            case ABS:
<span class="fc" id="L1138">                this.sb.append(&quot;abs(&quot;);</span>
<span class="fc" id="L1139">                break;</span>
            //Taylor Series converge only when value is less than one. Larger values are calculated
            //using a table.
            case LN:
<span class="fc" id="L1143">                this.sb.append(&quot;MathLn(&quot;);</span>
<span class="fc" id="L1144">                break;</span>
            case LOG10:
<span class="fc" id="L1146">                this.sb.append(&quot;MathLog(&quot;);</span>
<span class="fc" id="L1147">                break;</span>
            case EXP:
<span class="fc" id="L1149">                this.sb.append(&quot;MathPow(E, &quot;);</span>
<span class="fc" id="L1150">                break;</span>
            case POW10:
<span class="fc" id="L1152">                this.sb.append(&quot;MathPow(10, &quot;);</span>
<span class="fc" id="L1153">                break;</span>
            //the 3 functions below accept degrees
            case SIN:
<span class="fc" id="L1156">                this.sb.append(&quot;MathSin(&quot;);</span>
<span class="fc" id="L1157">                break;</span>
            case COS:
<span class="fc" id="L1159">                this.sb.append(&quot;MathCos(&quot;);</span>
<span class="fc" id="L1160">                break;</span>
            case TAN:
<span class="fc" id="L1162">                this.sb.append(&quot;MathTan(&quot;);</span>
<span class="fc" id="L1163">                break;</span>
            case ASIN:
<span class="fc" id="L1165">                this.sb.append(&quot;MathAsin(&quot;);</span>
<span class="fc" id="L1166">                break;</span>
            //Taylor Series converge only when value is less than one. Larger values are calculated
            //using a table.
            case ATAN:
<span class="fc" id="L1170">                this.sb.append(&quot;MathAtan(&quot;);</span>
<span class="fc" id="L1171">                break;</span>
            case ACOS:
<span class="fc" id="L1173">                this.sb.append(&quot;MathAcos(&quot;);</span>
<span class="fc" id="L1174">                break;</span>
            case ROUND:
<span class="fc" id="L1176">                this.sb.append(&quot;MathRound(&quot;);</span>
<span class="fc" id="L1177">                break;</span>
            case ROUNDUP:
<span class="fc" id="L1179">                this.sb.append(&quot;MathRoundUp(&quot;);</span>
<span class="fc" id="L1180">                break;</span>
            //check why there are double brackets
            case ROUNDDOWN:
<span class="fc" id="L1183">                this.sb.append(&quot;MathFloor(&quot;);</span>
<span class="fc" id="L1184">                break;</span>
            default:
                break;
        }
<span class="fc" id="L1188">        mathSingleFunct.getParam().get(0).visit(this);</span>
<span class="fc" id="L1189">        this.sb.append(&quot;)&quot;);</span>

<span class="fc" id="L1191">        return null;</span>
    }

    @Override
    public Void visitMathPowerFunct(MathPowerFunct&lt;Void&gt; mathPowerFunct) {
<span class="nc" id="L1196">        this.sb.append(&quot;MathPow(&quot;);</span>
<span class="nc" id="L1197">        super.visitMathPowerFunct(mathPowerFunct);</span>
<span class="nc" id="L1198">        return null;</span>
    }

    @Override
    public Void visitTextJoinFunct(TextJoinFunct&lt;Void&gt; textJoinFunct) {
        // not supported by NXC
<span class="nc" id="L1204">        return null;</span>
    }

    @Override
    public Void visitBluetoothReceiveAction(BluetoothReceiveAction&lt;Void&gt; bluetoothReadAction) {
        String methodName;
<span class="nc bnc" id="L1210" title="All 10 branches missed.">        switch ( bluetoothReadAction.getDataType() ) {</span>
            case &quot;Boolean&quot;:
<span class="nc" id="L1212">                methodName = &quot;BluetoothGetBoolean(&quot;;</span>
<span class="nc" id="L1213">                break;</span>
            case &quot;String&quot;:
<span class="nc" id="L1215">                methodName = &quot;BluetoothGetString(&quot;;</span>
<span class="nc" id="L1216">                break;</span>
            default:
<span class="nc" id="L1218">                methodName = &quot;BluetoothGetNumber(&quot;;</span>
        }
<span class="nc" id="L1220">        this.sb.append(methodName);</span>
<span class="nc" id="L1221">        this.sb.append(bluetoothReadAction.getChannel());</span>
<span class="nc" id="L1222">        this.sb.append(&quot;)&quot;);</span>
<span class="nc" id="L1223">        return null;</span>
    }

    @Override
    public Void visitBluetoothCheckConnectAction(BluetoothCheckConnectAction&lt;Void&gt; bluetoothCheckConnectAction) {
<span class="nc" id="L1228">        this.sb.append(&quot;(BluetoothStatus(&quot;);</span>
<span class="nc" id="L1229">        bluetoothCheckConnectAction.getConnection().visit(this);</span>
<span class="nc" id="L1230">        this.sb.append(&quot;)==NO_ERR)&quot;);</span>
<span class="nc" id="L1231">        return null;</span>
    }

    @Override
    public Void visitBluetoothConnectAction(BluetoothConnectAction&lt;Void&gt; bluetoothConnectAction) {
<span class="nc" id="L1236">        return null;</span>
    }

    @Override
    public Void visitBluetoothSendAction(BluetoothSendAction&lt;Void&gt; bluetoothSendAction) {
        String methodName;

<span class="nc bnc" id="L1243" title="All 10 branches missed.">        switch ( bluetoothSendAction.getDataType() ) {</span>
            case &quot;Boolean&quot;:
<span class="nc" id="L1245">                methodName = &quot;SendRemoteBool(&quot;;</span>
<span class="nc" id="L1246">                break;</span>
            case &quot;String&quot;:
<span class="nc" id="L1248">                methodName = &quot;SendRemoteString(&quot;;</span>
<span class="nc" id="L1249">                break;</span>
            default:
<span class="nc" id="L1251">                methodName = &quot;SendRemoteNumber(&quot;;</span>
        }

<span class="nc" id="L1254">        this.sb.append(methodName);</span>
<span class="nc" id="L1255">        bluetoothSendAction.getConnection().visit(this);</span>
<span class="nc" id="L1256">        this.sb.append(&quot;, &quot;);</span>
<span class="nc" id="L1257">        this.sb.append(bluetoothSendAction.getChannel());</span>
<span class="nc" id="L1258">        this.sb.append(&quot;, &quot;);</span>
<span class="nc" id="L1259">        bluetoothSendAction.getMsg().visit(this);</span>
<span class="nc" id="L1260">        this.sb.append(&quot;);&quot;);</span>
<span class="nc" id="L1261">        return null;</span>
    }

    @Override
    public Void visitBluetoothWaitForConnectionAction(BluetoothWaitForConnectionAction&lt;Void&gt; bluetoothWaitForConnection) {
<span class="nc" id="L1266">        return null;</span>
    }

    @Override
    protected void generateProgramPrefix(boolean withWrapping) {
<span class="fc bfc" id="L1271" title="All 2 branches covered.">        if ( !withWrapping ) {</span>
<span class="fc" id="L1272">            return;</span>
        }
<span class="fc" id="L1274">        this.sb.append(&quot;#define WHEELDIAMETER &quot; + this.brickConfiguration.getWheelDiameterCM() + &quot;\n&quot;);</span>
<span class="fc" id="L1275">        this.sb.append(&quot;#define TRACKWIDTH &quot; + this.brickConfiguration.getTrackWidthCM() + &quot;\n&quot;);</span>
<span class="fc" id="L1276">        this.sb.append(&quot;#define MAXLINES 8 \n&quot;);</span>
<span class="fc" id="L1277">        this.sb.append(&quot;#include \&quot;NEPODefs.h\&quot; // contains NEPO declarations for the NXC NXT API resources \n \n&quot;);</span>
<span class="fc" id="L1278">        decrIndentation();</span>
<span class="fc" id="L1279">        this.generateSignaturesOfUserDefinedMethods();</span>
<span class="fc" id="L1280">    }</span>

    @Override
    protected void generateProgramSuffix(boolean withWrapping) {
<span class="fc bfc" id="L1284" title="All 2 branches covered.">        if ( withWrapping ) {</span>
<span class="fc" id="L1285">            this.sb.append(&quot;\n}\n&quot;);</span>
        }
<span class="fc" id="L1287">        generateUserDefinedMethods();</span>
<span class="fc" id="L1288">    }</span>

    @Override
    protected String getLanguageVarTypeFromBlocklyType(BlocklyType type) {
<span class="pc bpc" id="L1292" title="10 of 15 branches missed.">        switch ( type ) {</span>
            case ANY:
            case COMPARABLE:
            case ADDABLE:
            case NULL:
            case REF:
            case PRIM:
            case NOTHING:
            case CAPTURED_TYPE:
            case R:
            case S:
            case T:
<span class="nc" id="L1304">                return &quot;&quot;;</span>
            case ARRAY:
<span class="nc" id="L1306">                return &quot;int&quot;;</span>
            case ARRAY_NUMBER:
<span class="fc" id="L1308">                return &quot;float&quot;;</span>
            case ARRAY_STRING:
<span class="nc" id="L1310">                return &quot;string&quot;;</span>
            case ARRAY_BOOLEAN:
<span class="nc" id="L1312">                return &quot;bool&quot;;</span>
            case ARRAY_COLOUR:
<span class="nc" id="L1314">                return &quot;int&quot;;</span>
            case ARRAY_CONNECTION:
<span class="nc" id="L1316">                return &quot;int&quot;;</span>
            case BOOLEAN:
<span class="fc" id="L1318">                return &quot;bool&quot;;</span>
            case NUMBER:
<span class="fc" id="L1320">                return &quot;float&quot;;</span>
            case NUMBER_INT:
<span class="nc" id="L1322">                return &quot;int&quot;;</span>
            case STRING:
<span class="fc" id="L1324">                return &quot;string&quot;;</span>
            case VOID:
<span class="fc" id="L1326">                return &quot;void&quot;;</span>
            case COLOR:
<span class="nc" id="L1328">                return &quot;int&quot;;</span>
            case CONNECTION:
<span class="nc" id="L1330">                return &quot;int&quot;;</span>
            default:
<span class="nc" id="L1332">                throw new IllegalArgumentException(&quot;unhandled type&quot;);</span>
        }
    }

    private void generateSensors() {
<span class="fc bfc" id="L1337" title="All 2 branches covered.">        for ( final Entry&lt;ISensorPort, Sensor&gt; entry : this.brickConfiguration.getSensors().entrySet() ) {</span>
<span class="fc" id="L1338">            nlIndent();</span>
<span class="fc" id="L1339">            this.sb.append(&quot;SetSensor(&quot;);</span>
<span class="pc bpc" id="L1340" title="5 of 7 branches missed.">            switch ( entry.getValue().getType() ) {</span>
                case COLOR:
<span class="nc" id="L1342">                    this.sb.append(entry.getKey().getCodeName() + &quot;, SENSOR_COLORFULL);&quot;);</span>
<span class="nc" id="L1343">                    break;</span>
                case HT_COLOR:
<span class="nc" id="L1345">                    this.sb.append(entry.getKey().getCodeName() + &quot;, SENSOR_LOWSPEED);&quot;);</span>
<span class="nc" id="L1346">                    break;</span>
                case LIGHT:
<span class="nc" id="L1348">                    this.sb.append(entry.getKey().getCodeName() + &quot;, SENSOR_LIGHT);&quot;);</span>
<span class="nc" id="L1349">                    break;</span>
                case TOUCH:
<span class="fc" id="L1351">                    this.sb.append(entry.getKey().getCodeName() + &quot;, SENSOR_TOUCH);&quot;);</span>
<span class="fc" id="L1352">                    break;</span>
                case ULTRASONIC:
<span class="fc" id="L1354">                    this.sb.append(entry.getKey().getCodeName() + &quot;, SENSOR_LOWSPEED);&quot;);</span>
<span class="fc" id="L1355">                    break;</span>
                case SOUND:
<span class="nc" id="L1357">                    this.sb.append(entry.getKey().getCodeName() + &quot;, SENSOR_SOUND);&quot;);</span>
<span class="nc" id="L1358">                    break;</span>
                default:
                    break;
            }
<span class="fc" id="L1362">        }</span>
<span class="pc bpc" id="L1363" title="1 of 2 branches missed.">        if ( this.timeSensorUsed ) {</span>
<span class="nc" id="L1364">            nlIndent();</span>
<span class="nc" id="L1365">            this.sb.append(&quot;SetTimerValue(timer1);&quot;);</span>
        }
<span class="fc" id="L1367">    }</span>

    @Override
    public Void visitTemperatureSensor(TemperatureSensor&lt;Void&gt; temperatureSensor) {
<span class="nc" id="L1371">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>