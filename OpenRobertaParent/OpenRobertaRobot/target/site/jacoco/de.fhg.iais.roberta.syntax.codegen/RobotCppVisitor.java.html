<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RobotCppVisitor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenRobertaRobot</a> &gt; <a href="index.source.html" class="el_package">de.fhg.iais.roberta.syntax.codegen</a> &gt; <span class="el_source">RobotCppVisitor.java</span></div><h1>RobotCppVisitor.java</h1><pre class="source lang-java linenums">package de.fhg.iais.roberta.syntax.codegen;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import de.fhg.iais.roberta.syntax.Phrase;
import de.fhg.iais.roberta.syntax.lang.expr.Binary;
import de.fhg.iais.roberta.syntax.lang.expr.ColorConst;
import de.fhg.iais.roberta.syntax.lang.expr.ConnectConst;
import de.fhg.iais.roberta.syntax.lang.expr.EmptyExpr;
import de.fhg.iais.roberta.syntax.lang.expr.EmptyList;
import de.fhg.iais.roberta.syntax.lang.expr.Expr;
import de.fhg.iais.roberta.syntax.lang.expr.ExprList;
import de.fhg.iais.roberta.syntax.lang.expr.ListCreate;
import de.fhg.iais.roberta.syntax.lang.expr.NullConst;
import de.fhg.iais.roberta.syntax.lang.expr.Unary;
import de.fhg.iais.roberta.syntax.lang.functions.ListRepeat;
import de.fhg.iais.roberta.syntax.lang.functions.MathSingleFunct;
import de.fhg.iais.roberta.syntax.lang.functions.TextPrintFunct;
import de.fhg.iais.roberta.syntax.lang.methods.Method;
import de.fhg.iais.roberta.syntax.lang.methods.MethodCall;
import de.fhg.iais.roberta.syntax.lang.methods.MethodIfReturn;
import de.fhg.iais.roberta.syntax.lang.methods.MethodReturn;
import de.fhg.iais.roberta.syntax.lang.methods.MethodVoid;
import de.fhg.iais.roberta.syntax.lang.stmt.AssignStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.ExprStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.FunctionStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.IfStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.MethodStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.StmtFlowCon;
import de.fhg.iais.roberta.syntax.lang.stmt.StmtTextComment;
import de.fhg.iais.roberta.typecheck.BlocklyType;
import de.fhg.iais.roberta.visitor.AstVisitor;

/**
 * This class is implementing {@link AstVisitor}. All methods are implemented and they append a human-readable C++ code representation of a phrase to a
 * StringBuilder. &lt;b&gt;This representation is correct C++ code.&lt;/b&gt; &lt;br&gt;
 */
public abstract class RobotCppVisitor extends CommonLanguageVisitor {
<span class="nc" id="L43">    protected List&lt;Method&lt;Void&gt;&gt; userDefinedMethods = new ArrayList&lt;&gt;();</span>

    /**
     * initialize the cpp code generator visitor.
     *
     * @param indentation to start with. Will be ince/decr depending on block structure
     */
    protected RobotCppVisitor(ArrayList&lt;ArrayList&lt;Phrase&lt;Void&gt;&gt;&gt; programPhrases, int indentation) {
<span class="nc" id="L51">        super(programPhrases, indentation);</span>
<span class="nc" id="L52">    }</span>

    @Override
    public Void visitNullConst(NullConst&lt;Void&gt; nullConst) {
<span class="nc" id="L56">        this.sb.append(&quot;NULL&quot;);</span>
<span class="nc" id="L57">        return null;</span>
    }

    @Override
    public Void visitConnectConst(ConnectConst&lt;Void&gt; connectConst) {
<span class="nc" id="L62">        this.sb.append(connectConst.getValue());</span>
<span class="nc" id="L63">        return null;</span>
    }

    @Override
    public Void visitEmptyExpr(EmptyExpr&lt;Void&gt; emptyExpr) {
<span class="nc bnc" id="L68" title="All 6 branches missed.">        switch ( emptyExpr.getDefVal() ) {</span>
            case STRING:
<span class="nc" id="L70">                this.sb.append(&quot;\&quot;\&quot;&quot;);</span>
<span class="nc" id="L71">                break;</span>
            case BOOLEAN:
<span class="nc" id="L73">                this.sb.append(&quot;true&quot;);</span>
<span class="nc" id="L74">                break;</span>
            case NUMBER_INT:
<span class="nc" id="L76">                this.sb.append(&quot;0&quot;);</span>
<span class="nc" id="L77">                break;</span>
            case ARRAY:
<span class="nc" id="L79">                break;</span>
            case NULL:
<span class="nc" id="L81">                break;</span>
            default:
<span class="nc" id="L83">                this.sb.append(&quot;NULL&quot;);</span>
                break;
        }
<span class="nc" id="L86">        return null;</span>
    }

    @Override
    public Void visitAssignStmt(AssignStmt&lt;Void&gt; assignStmt) {
<span class="nc" id="L91">        super.visitAssignStmt(assignStmt);</span>
<span class="nc" id="L92">        this.sb.append(&quot;;&quot;);</span>
<span class="nc" id="L93">        return null;</span>
    }

    @Override
    public Void visitExprStmt(ExprStmt&lt;Void&gt; exprStmt) {
<span class="nc" id="L98">        super.visitExprStmt(exprStmt);</span>
<span class="nc" id="L99">        this.sb.append(&quot;;&quot;);</span>
<span class="nc" id="L100">        return null;</span>
    }

    @Override
    public Void visitFunctionStmt(FunctionStmt&lt;Void&gt; functionStmt) {
<span class="nc" id="L105">        super.visitFunctionStmt(functionStmt);</span>
<span class="nc" id="L106">        this.sb.append(&quot;;&quot;);</span>
<span class="nc" id="L107">        return null;</span>
    }

    @Override
    public Void visitStmtFlowCon(StmtFlowCon&lt;Void&gt; stmtFlowCon) {
<span class="nc bnc" id="L112" title="All 2 branches missed.">        if ( this.loopsLabels.get(this.currenLoop.getLast()) != null ) {</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">            if ( this.loopsLabels.get(this.currenLoop.getLast()) ) {</span>
<span class="nc" id="L114">                this.sb.append(&quot;goto &quot; + stmtFlowCon.getFlow().toString().toLowerCase() + &quot;_loop&quot; + this.currenLoop.getLast() + &quot;;&quot;);</span>
<span class="nc" id="L115">                return null;</span>
            }
        }
<span class="nc" id="L118">        this.sb.append(stmtFlowCon.getFlow().toString().toLowerCase() + &quot;;&quot;);</span>
<span class="nc" id="L119">        return null;</span>
    }

    @Override
    public Void visitEmptyList(EmptyList&lt;Void&gt; emptyList) {
<span class="nc" id="L124">        return null;</span>
    }

    @Override
    public Void visitListCreate(ListCreate&lt;Void&gt; listCreate) {
<span class="nc" id="L129">        this.sb.append(&quot;{&quot;);</span>
<span class="nc" id="L130">        listCreate.getValue().visit(this);</span>
<span class="nc" id="L131">        this.sb.append(&quot;}&quot;);</span>
<span class="nc" id="L132">        return null;</span>
    }

    @Override
    public Void visitListRepeat(ListRepeat&lt;Void&gt; listRepeat) {
<span class="nc" id="L137">        return null;</span>
    }

    @Override
    public Void visitMathSingleFunct(MathSingleFunct&lt;Void&gt; mathSingleFunct) {
<span class="nc" id="L142">        boolean extraPar = false;</span>
<span class="nc bnc" id="L143" title="All 16 branches missed.">        switch ( mathSingleFunct.getFunctName() ) {</span>
            case ROOT:
<span class="nc" id="L145">                this.sb.append(&quot;sqrt(&quot;);</span>
<span class="nc" id="L146">                break;</span>
            case ABS:
<span class="nc" id="L148">                this.sb.append(&quot;absD(&quot;);</span>
<span class="nc" id="L149">                break;</span>
            case LN:
<span class="nc" id="L151">                this.sb.append(&quot;log(&quot;);</span>
<span class="nc" id="L152">                break;</span>
            case LOG10:
<span class="nc" id="L154">                this.sb.append(&quot;log10(&quot;);</span>
<span class="nc" id="L155">                break;</span>
            case EXP:
<span class="nc" id="L157">                this.sb.append(&quot;exp(&quot;);</span>
<span class="nc" id="L158">                break;</span>
            case POW10:
<span class="nc" id="L160">                this.sb.append(&quot;pow(10.0, &quot;);</span>
<span class="nc" id="L161">                break;</span>
            case SIN:
<span class="nc" id="L163">                extraPar = true;</span>
<span class="nc" id="L164">                this.sb.append(&quot;sin(PI / 180.0 * (&quot;);</span>
<span class="nc" id="L165">                break;</span>
            case COS:
<span class="nc" id="L167">                extraPar = true;</span>
<span class="nc" id="L168">                this.sb.append(&quot;cos(PI / 180.0 * (&quot;);</span>
<span class="nc" id="L169">                break;</span>
            case TAN:
<span class="nc" id="L171">                extraPar = true;</span>
<span class="nc" id="L172">                this.sb.append(&quot;tan(PI / 180.0 * (&quot;);</span>
<span class="nc" id="L173">                break;</span>
            case ASIN:
<span class="nc" id="L175">                this.sb.append(&quot;180.0 / PI * asin(&quot;);</span>
<span class="nc" id="L176">                break;</span>
            case ATAN:
<span class="nc" id="L178">                this.sb.append(&quot;180.0 / PI * atan(&quot;);</span>
<span class="nc" id="L179">                break;</span>
            case ACOS:
<span class="nc" id="L181">                this.sb.append(&quot;180.0 / PI * acos(&quot;);</span>
<span class="nc" id="L182">                break;</span>
            case ROUND:
<span class="nc" id="L184">                this.sb.append(&quot;round(&quot;);</span>
<span class="nc" id="L185">                break;</span>
            case ROUNDUP:
<span class="nc" id="L187">                this.sb.append(&quot;ceil(&quot;);</span>
<span class="nc" id="L188">                break;</span>
            case ROUNDDOWN:
<span class="nc" id="L190">                this.sb.append(&quot;floor(&quot;);</span>
<span class="nc" id="L191">                break;</span>
            default:
                break;
        }
<span class="nc" id="L195">        mathSingleFunct.getParam().get(0).visit(this);</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">        if ( extraPar ) {</span>
<span class="nc" id="L197">            this.sb.append(&quot;)&quot;);</span>
        }
<span class="nc" id="L199">        this.sb.append(&quot;)&quot;);</span>

<span class="nc" id="L201">        return null;</span>
    }

    @Override
    public Void visitMethodVoid(MethodVoid&lt;Void&gt; methodVoid) {
<span class="nc" id="L206">        this.sb.append(&quot;\n&quot;).append(&quot;void &quot;);</span>
<span class="nc" id="L207">        this.sb.append(methodVoid.getMethodName() + &quot;(&quot;);</span>
<span class="nc" id="L208">        methodVoid.getParameters().visit(this);</span>
<span class="nc" id="L209">        this.sb.append(&quot;) {&quot;);</span>
<span class="nc" id="L210">        methodVoid.getBody().visit(this);</span>
<span class="nc" id="L211">        this.sb.append(&quot;\n&quot;).append(&quot;}&quot;);</span>
<span class="nc" id="L212">        return null;</span>
    }

    @Override
    public Void visitMethodReturn(MethodReturn&lt;Void&gt; methodReturn) {
<span class="nc" id="L217">        this.sb.append(&quot;\n&quot;).append(getLanguageVarTypeFromBlocklyType(methodReturn.getReturnType()));</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if ( methodReturn.getReturnType().toString().contains(&quot;ARRAY&quot;) ) {</span>
<span class="nc" id="L219">            this.sb.append(&quot;M&gt;&quot;);</span>
        }
<span class="nc" id="L221">        this.sb.append(&quot; &quot; + methodReturn.getMethodName() + &quot;(&quot;);</span>
<span class="nc" id="L222">        methodReturn.getParameters().visit(this);</span>
<span class="nc" id="L223">        this.sb.append(&quot;) {&quot;);</span>
<span class="nc" id="L224">        methodReturn.getBody().visit(this);</span>
<span class="nc" id="L225">        nlIndent();</span>
<span class="nc" id="L226">        this.sb.append(&quot;return &quot;);</span>
<span class="nc" id="L227">        methodReturn.getReturnValue().visit(this);</span>
<span class="nc" id="L228">        this.sb.append(&quot;;\n&quot;).append(&quot;}&quot;);</span>
<span class="nc" id="L229">        return null;</span>
    }

    @Override
    public Void visitMethodIfReturn(MethodIfReturn&lt;Void&gt; methodIfReturn) {
<span class="nc" id="L234">        this.sb.append(&quot;if (&quot;);</span>
<span class="nc" id="L235">        methodIfReturn.getCondition().visit(this);</span>
<span class="nc" id="L236">        this.sb.append(&quot;) &quot;);</span>
<span class="nc" id="L237">        this.sb.append(&quot;return &quot;);</span>
<span class="nc" id="L238">        methodIfReturn.getReturnValue().visit(this);</span>
<span class="nc" id="L239">        return null;</span>
    }

    @Override
    public Void visitMethodStmt(MethodStmt&lt;Void&gt; methodStmt) {
<span class="nc" id="L244">        super.visitMethodStmt(methodStmt);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        if ( methodStmt.getProperty().getBlockType().equals(&quot;robProcedures_ifreturn&quot;) ) {</span>
<span class="nc" id="L246">            this.sb.append(&quot;;&quot;);</span>
        }
<span class="nc" id="L248">        return null;</span>
    }

    @Override
    public Void visitMethodCall(MethodCall&lt;Void&gt; methodCall) {
<span class="nc" id="L253">        super.visitMethodCall(methodCall);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if ( methodCall.getReturnType() == BlocklyType.VOID ) {</span>
<span class="nc" id="L255">            this.sb.append(&quot;;&quot;);</span>
        }
<span class="nc" id="L257">        return null;</span>
    }

    @Override
    public Void visitTextPrintFunct(TextPrintFunct&lt;Void&gt; textPrintFunct) {
<span class="nc" id="L262">        return null;</span>
    }

    @Override
    public Void visitStmtTextComment(StmtTextComment&lt;Void&gt; stmtTextComment) {
<span class="nc" id="L267">        this.sb.append(&quot;// &quot; + stmtTextComment.getTextComment());</span>
<span class="nc" id="L268">        return null;</span>
    };

    @Override
    public Void visitColorConst(ColorConst&lt;Void&gt; colorConst) {
<span class="nc" id="L273">        this.sb.append(&quot;\&quot;&quot; + colorConst.getValue() + &quot;\&quot;&quot;);</span>
<span class="nc" id="L274">        return null;</span>
    }

    protected void addContinueLabelToLoop() {
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if ( this.loopsLabels.get(this.currenLoop.getLast()) ) {</span>
<span class="nc" id="L279">            nlIndent();</span>
<span class="nc" id="L280">            this.sb.append(&quot;continue_loop&quot; + this.currenLoop.getLast() + &quot;:&quot;);</span>
        }
<span class="nc" id="L282">    }</span>

    protected void addBreakLabelToLoop(boolean isWaitStmt) {
<span class="nc bnc" id="L285" title="All 2 branches missed.">        if ( !isWaitStmt ) {</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">            if ( this.loopsLabels.get(this.currenLoop.getLast()) ) {</span>
<span class="nc" id="L287">                nlIndent();</span>
<span class="nc" id="L288">                this.sb.append(&quot;break_loop&quot; + this.currenLoop.getLast() + &quot;:&quot;);</span>
<span class="nc" id="L289">                nlIndent();</span>
            }
<span class="nc" id="L291">            this.currenLoop.removeLast();</span>
        }
<span class="nc" id="L293">    }</span>

    @Override
    protected String getLanguageVarTypeFromBlocklyType(BlocklyType type) {
<span class="nc bnc" id="L297" title="All 14 branches missed.">        switch ( type ) {</span>
            case ANY:
            case COMPARABLE:
            case ADDABLE:
            case NULL:
            case REF:
            case PRIM:
            case NOTHING:
            case CAPTURED_TYPE:
            case R:
            case S:
            case T:
<span class="nc" id="L309">                return &quot;&quot;;</span>
            case ARRAY:
<span class="nc" id="L311">                return &quot;double&quot;;</span>
            case ARRAY_NUMBER:
<span class="nc" id="L313">                return &quot;double&quot;;</span>
            case ARRAY_STRING:
<span class="nc" id="L315">                return &quot;String&quot;;</span>
            case ARRAY_BOOLEAN:
<span class="nc" id="L317">                return &quot;bool&quot;;</span>
            case ARRAY_COLOUR:
<span class="nc" id="L319">                return &quot;String&quot;;</span>
            case BOOLEAN:
<span class="nc" id="L321">                return &quot;bool&quot;;</span>
            case NUMBER:
<span class="nc" id="L323">                return &quot;double&quot;;</span>
            case NUMBER_INT:
<span class="nc" id="L325">                return &quot;int&quot;;</span>
            case STRING:
<span class="nc" id="L327">                return &quot;String&quot;;</span>
            case VOID:
<span class="nc" id="L329">                return &quot;void&quot;;</span>
            case COLOR:
<span class="nc" id="L331">                return &quot;String&quot;;</span>
            case CONNECTION:
<span class="nc" id="L333">                return &quot;int&quot;;</span>
            default:
<span class="nc" id="L335">                throw new IllegalArgumentException(&quot;unhandled type&quot;);</span>
        }
    }

    @Override
    protected void generateCodeFromTernary(IfStmt&lt;Void&gt; ifStmt) {
<span class="nc" id="L341">        this.sb.append(&quot;(&quot; + whitespace() + &quot;(&quot; + whitespace());</span>
<span class="nc" id="L342">        ifStmt.getExpr().get(0).visit(this);</span>
<span class="nc" id="L343">        this.sb.append(whitespace() + &quot;)&quot; + whitespace() + &quot;?&quot; + whitespace() + &quot;(&quot; + whitespace());</span>
<span class="nc" id="L344">        ((ExprStmt&lt;Void&gt;) ifStmt.getThenList().get(0).get().get(0)).getExpr().visit(this);</span>
<span class="nc" id="L345">        this.sb.append(whitespace() + &quot;)&quot; + whitespace() + &quot;:&quot; + whitespace() + &quot;(&quot; + whitespace());</span>
<span class="nc" id="L346">        ((ExprStmt&lt;Void&gt;) ifStmt.getElseList().get().get(0)).getExpr().visit(this);</span>
<span class="nc" id="L347">        this.sb.append(&quot;)&quot; + whitespace() + &quot;)&quot;);</span>
<span class="nc" id="L348">    }</span>

    @Override
    protected void generateCodeFromIfElse(IfStmt&lt;Void&gt; ifStmt) {
<span class="nc" id="L352">        int exprSize = ifStmt.getExpr().size();</span>
<span class="nc" id="L353">        String conditionStmt = &quot;if&quot;;</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">        for ( int i = 0; i &lt; exprSize; i++ ) {</span>
<span class="nc" id="L355">            generateCodeFromStmtCondition(conditionStmt, ifStmt.getExpr().get(i));</span>
<span class="nc" id="L356">            conditionStmt = &quot;else&quot; + whitespace() + &quot;if&quot;;</span>
<span class="nc" id="L357">            incrIndentation();</span>
<span class="nc" id="L358">            ifStmt.getThenList().get(i).visit(this);</span>
<span class="nc" id="L359">            decrIndentation();</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">            if ( (i + 1) &lt; exprSize ) {</span>
<span class="nc" id="L361">                nlIndent();</span>
<span class="nc" id="L362">                this.sb.append(&quot;}&quot;).append(whitespace());</span>
            }
        }

<span class="nc" id="L366">    }</span>

    @Override
    protected void generateCodeFromElse(IfStmt&lt;Void&gt; ifStmt) {
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if ( !ifStmt.getElseList().get().isEmpty() ) {</span>
<span class="nc" id="L371">            nlIndent();</span>
<span class="nc" id="L372">            this.sb.append(&quot;}&quot;).append(whitespace()).append(&quot;else&quot;).append(whitespace() + &quot;{&quot;);</span>
<span class="nc" id="L373">            incrIndentation();</span>
<span class="nc" id="L374">            ifStmt.getElseList().visit(this);</span>
<span class="nc" id="L375">            decrIndentation();</span>
        }
<span class="nc" id="L377">        nlIndent();</span>
<span class="nc" id="L378">        this.sb.append(&quot;}&quot;);</span>
<span class="nc" id="L379">    }</span>

    protected void generateSignaturesOfUserDefinedMethods() {
<span class="nc bnc" id="L382" title="All 2 branches missed.">        for ( Method&lt;Void&gt; phrase : this.userDefinedMethods ) {</span>
<span class="nc" id="L383">            this.sb.append(getLanguageVarTypeFromBlocklyType(phrase.getReturnType()) + &quot; &quot;);</span>
<span class="nc" id="L384">            this.sb.append(phrase.getMethodName() + &quot;(&quot;);</span>
<span class="nc" id="L385">            phrase.getParameters().visit(this);</span>
<span class="nc" id="L386">            this.sb.append(&quot;);&quot;);</span>
<span class="nc" id="L387">            nlIndent();</span>
<span class="nc" id="L388">        }</span>
<span class="nc" id="L389">    }</span>

    protected void generateCodeFromStmtCondition(String stmtType, Expr&lt;Void&gt; expr) {
<span class="nc" id="L392">        this.sb.append(stmtType + whitespace() + &quot;(&quot; + whitespace());</span>
<span class="nc" id="L393">        expr.visit(this);</span>
<span class="nc" id="L394">        this.sb.append(whitespace() + &quot;)&quot; + whitespace() + &quot;{&quot;);</span>
<span class="nc" id="L395">    }</span>

    protected void generateCodeFromStmtConditionFor(String stmtType, Expr&lt;Void&gt; expr) {
<span class="nc" id="L398">        this.sb.append(stmtType + whitespace() + &quot;(&quot; + &quot;int&quot; + whitespace());</span>
<span class="nc" id="L399">        final ExprList&lt;Void&gt; expressions = (ExprList&lt;Void&gt;) expr;</span>
<span class="nc" id="L400">        expressions.get().get(0).visit(this);</span>
<span class="nc" id="L401">        this.sb.append(whitespace() + &quot;=&quot; + whitespace());</span>
<span class="nc" id="L402">        expressions.get().get(1).visit(this);</span>
<span class="nc" id="L403">        this.sb.append(&quot;;&quot; + whitespace());</span>
<span class="nc" id="L404">        expressions.get().get(0).visit(this);</span>
<span class="nc" id="L405">        this.sb.append(whitespace());</span>
<span class="nc" id="L406">        this.sb.append(&quot;&lt;&quot; + whitespace());</span>
<span class="nc" id="L407">        expressions.get().get(2).visit(this);</span>
<span class="nc" id="L408">        this.sb.append(&quot;;&quot; + whitespace());</span>
<span class="nc" id="L409">        expressions.get().get(0).visit(this);</span>
<span class="nc" id="L410">        this.sb.append(whitespace());</span>
<span class="nc" id="L411">        this.sb.append(&quot;+=&quot; + whitespace());</span>
<span class="nc" id="L412">        expressions.get().get(3).visit(this);</span>
<span class="nc" id="L413">        this.sb.append(&quot;)&quot; + whitespace() + &quot;{&quot;);</span>
<span class="nc" id="L414">    }</span>

    protected void appendBreakStmt() {
<span class="nc" id="L417">        nlIndent();</span>
<span class="nc" id="L418">        this.sb.append(&quot;break;&quot;);</span>
<span class="nc" id="L419">    }</span>

    @Override
    protected String getBinaryOperatorSymbol(Binary.Op op) {
<span class="nc" id="L423">        return binaryOpSymbols().get(op);</span>
    }

    @Override
    protected String getUnaryOperatorSymbol(Unary.Op op) {
<span class="nc" id="L428">        return unaryOpSymbols().get(op);</span>
    }

    protected static Map&lt;Binary.Op, String&gt; binaryOpSymbols() {
<span class="nc" id="L432">        return Collections.unmodifiableMap(</span>
            Stream
<span class="nc" id="L434">                .of(</span>

<span class="nc" id="L436">                    entry(Binary.Op.ADD, &quot;+&quot;),</span>
<span class="nc" id="L437">                    entry(Binary.Op.MINUS, &quot;-&quot;),</span>
<span class="nc" id="L438">                    entry(Binary.Op.MULTIPLY, &quot;*&quot;),</span>
<span class="nc" id="L439">                    entry(Binary.Op.DIVIDE, &quot;/&quot;),</span>
<span class="nc" id="L440">                    entry(Binary.Op.MOD, &quot;%&quot;),</span>
<span class="nc" id="L441">                    entry(Binary.Op.EQ, &quot;==&quot;),</span>
<span class="nc" id="L442">                    entry(Binary.Op.NEQ, &quot;!=&quot;),</span>
<span class="nc" id="L443">                    entry(Binary.Op.LT, &quot;&lt;&quot;),</span>
<span class="nc" id="L444">                    entry(Binary.Op.LTE, &quot;&lt;=&quot;),</span>
<span class="nc" id="L445">                    entry(Binary.Op.GT, &quot;&gt;&quot;),</span>
<span class="nc" id="L446">                    entry(Binary.Op.GTE, &quot;&gt;=&quot;),</span>
<span class="nc" id="L447">                    entry(Binary.Op.AND, &quot;&amp;&amp;&quot;),</span>
<span class="nc" id="L448">                    entry(Binary.Op.OR, &quot;||&quot;),</span>
<span class="nc" id="L449">                    entry(Binary.Op.MATH_CHANGE, &quot;+=&quot;),</span>
<span class="nc" id="L450">                    entry(Binary.Op.TEXT_APPEND, &quot;+=&quot;),</span>
<span class="nc" id="L451">                    entry(Binary.Op.IN, &quot;:&quot;),</span>
<span class="nc" id="L452">                    entry(Binary.Op.ASSIGNMENT, &quot;=&quot;),</span>
<span class="nc" id="L453">                    entry(Binary.Op.ADD_ASSIGNMENT, &quot;+=&quot;),</span>
<span class="nc" id="L454">                    entry(Binary.Op.MINUS_ASSIGNMENT, &quot;-=&quot;),</span>
<span class="nc" id="L455">                    entry(Binary.Op.MULTIPLY_ASSIGNMENT, &quot;*=&quot;),</span>
<span class="nc" id="L456">                    entry(Binary.Op.DIVIDE_ASSIGNMENT, &quot;/=&quot;),</span>
<span class="nc" id="L457">                    entry(Binary.Op.MOD_ASSIGNMENT, &quot;%=&quot;)</span>

                )
<span class="nc" id="L460">                .collect(entriesToMap()));</span>
    }

    protected static Map&lt;Unary.Op, String&gt; unaryOpSymbols() {
<span class="nc" id="L464">        return Collections.unmodifiableMap(</span>
            Stream
<span class="nc" id="L466">                .of(</span>

<span class="nc" id="L468">                    entry(Unary.Op.PLUS, &quot;+&quot;),</span>
<span class="nc" id="L469">                    entry(Unary.Op.NEG, &quot;-&quot;),</span>
<span class="nc" id="L470">                    entry(Unary.Op.NOT, &quot;!&quot;),</span>
<span class="nc" id="L471">                    entry(Unary.Op.POSTFIX_INCREMENTS, &quot;++&quot;),</span>
<span class="nc" id="L472">                    entry(Unary.Op.PREFIX_INCREMENTS, &quot;++&quot;)</span>

                )
<span class="nc" id="L475">                .collect(entriesToMap()));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>