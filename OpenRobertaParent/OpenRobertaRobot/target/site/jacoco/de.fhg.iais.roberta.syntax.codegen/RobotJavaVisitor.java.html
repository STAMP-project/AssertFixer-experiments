<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RobotJavaVisitor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenRobertaRobot</a> &gt; <a href="index.source.html" class="el_package">de.fhg.iais.roberta.syntax.codegen</a> &gt; <span class="el_source">RobotJavaVisitor.java</span></div><h1>RobotJavaVisitor.java</h1><pre class="source lang-java linenums">package de.fhg.iais.roberta.syntax.codegen;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Map;
import java.util.stream.Stream;

import de.fhg.iais.roberta.syntax.BlockTypeContainer.BlockType;
import de.fhg.iais.roberta.syntax.Phrase;
import de.fhg.iais.roberta.syntax.action.Action;
import de.fhg.iais.roberta.syntax.lang.expr.ActionExpr;
import de.fhg.iais.roberta.syntax.lang.expr.Binary;
import de.fhg.iais.roberta.syntax.lang.expr.Binary.Op;
import de.fhg.iais.roberta.syntax.lang.expr.EmptyExpr;
import de.fhg.iais.roberta.syntax.lang.expr.EmptyList;
import de.fhg.iais.roberta.syntax.lang.expr.Expr;
import de.fhg.iais.roberta.syntax.lang.expr.ExprList;
import de.fhg.iais.roberta.syntax.lang.expr.FunctionExpr;
import de.fhg.iais.roberta.syntax.lang.expr.MathConst;
import de.fhg.iais.roberta.syntax.lang.expr.MethodExpr;
import de.fhg.iais.roberta.syntax.lang.expr.NullConst;
import de.fhg.iais.roberta.syntax.lang.expr.NumConst;
import de.fhg.iais.roberta.syntax.lang.expr.Unary;
import de.fhg.iais.roberta.syntax.lang.expr.Var;
import de.fhg.iais.roberta.syntax.lang.functions.MathSingleFunct;
import de.fhg.iais.roberta.syntax.lang.functions.TextPrintFunct;
import de.fhg.iais.roberta.syntax.lang.methods.MethodCall;
import de.fhg.iais.roberta.syntax.lang.methods.MethodIfReturn;
import de.fhg.iais.roberta.syntax.lang.methods.MethodReturn;
import de.fhg.iais.roberta.syntax.lang.methods.MethodVoid;
import de.fhg.iais.roberta.syntax.lang.stmt.AssignStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.ExprStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.FunctionStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.IfStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.MethodStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.RepeatStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.StmtFlowCon;
import de.fhg.iais.roberta.syntax.lang.stmt.StmtTextComment;
import de.fhg.iais.roberta.typecheck.BlocklyType;
import de.fhg.iais.roberta.visitor.AstVisitor;

/**
 * This class is implementing {@link AstVisitor}. All methods are implemented and they append a human-readable JAVA code representation of a phrase to a
 * StringBuilder. &lt;b&gt;This representation is correct JAVA code.&lt;/b&gt; &lt;br&gt;
 */
public abstract class RobotJavaVisitor extends CommonLanguageVisitor {
    protected final String programName;
<span class="nc" id="L48">    protected boolean isInDebugMode = false;</span>

    /**
     * initialize the Java code generator visitor.
     *
     * @param programName name of the program
     * @param brickConfiguration hardware configuration of the brick
     * @param usedSensors in the current program
     * @param indentation to start with. Will be ince/decr depending on block structure
     */
    protected RobotJavaVisitor(ArrayList&lt;ArrayList&lt;Phrase&lt;Void&gt;&gt;&gt; programPhrases, String programName, int indentation) {
<span class="nc" id="L59">        super(programPhrases, indentation);</span>
<span class="nc" id="L60">        this.programName = programName;</span>
<span class="nc" id="L61">    }</span>

    @Override
    public Void visitNumConst(NumConst&lt;Void&gt; numConst) {
        // TODO Do we have always to cast to float
<span class="nc bnc" id="L66" title="All 2 branches missed.">        if ( isInteger(numConst.getValue()) ) {</span>
<span class="nc" id="L67">            super.visitNumConst(numConst);</span>
        } else {
<span class="nc" id="L69">            this.sb.append(&quot;((float) &quot;);</span>
<span class="nc" id="L70">            super.visitNumConst(numConst);</span>
<span class="nc" id="L71">            this.sb.append(&quot;)&quot;);</span>
        }
<span class="nc" id="L73">        return null;</span>
    }

    @Override
    public Void visitNullConst(NullConst&lt;Void&gt; nullConst) {
<span class="nc" id="L78">        this.sb.append(&quot;null&quot;);</span>
<span class="nc" id="L79">        return null;</span>
    }

    @Override
    public Void visitMathConst(MathConst&lt;Void&gt; mathConst) {
<span class="nc bnc" id="L84" title="All 7 branches missed.">        switch ( mathConst.getMathConst() ) {</span>
            case PI:
<span class="nc" id="L86">                this.sb.append(&quot;BlocklyMethods.PI&quot;);</span>
<span class="nc" id="L87">                break;</span>
            case E:
<span class="nc" id="L89">                this.sb.append(&quot;BlocklyMethods.E&quot;);</span>
<span class="nc" id="L90">                break;</span>
            case GOLDEN_RATIO:
<span class="nc" id="L92">                this.sb.append(&quot;BlocklyMethods.GOLDEN_RATIO&quot;);</span>
<span class="nc" id="L93">                break;</span>
            case SQRT2:
<span class="nc" id="L95">                this.sb.append(&quot;BlocklyMethods.sqrt(2)&quot;);</span>
<span class="nc" id="L96">                break;</span>
            case SQRT1_2:
<span class="nc" id="L98">                this.sb.append(&quot;BlocklyMethods.sqrt(1.0/2.0)&quot;);</span>
<span class="nc" id="L99">                break;</span>
            case INFINITY:
<span class="nc" id="L101">                this.sb.append(&quot;Float.POSITIVE_INFINITY&quot;);</span>
<span class="nc" id="L102">                break;</span>
            default:
                break;
        }
<span class="nc" id="L106">        return null;</span>
    }

    @Override
    public Void visitBinary(Binary&lt;Void&gt; binary) {
<span class="nc" id="L111">        Op op = binary.getOp();</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">        if ( isEqualityOpOnStrings(binary) ) {</span>
<span class="nc" id="L113">            generateCodeForStringEqualityOp(binary);</span>
<span class="nc" id="L114">            return null;</span>
        }
<span class="nc" id="L116">        generateSubExpr(this.sb, false, binary.getLeft(), binary);</span>
<span class="nc" id="L117">        String sym = getBinaryOperatorSymbol(op);</span>
<span class="nc" id="L118">        this.sb.append(whitespace() + sym + whitespace());</span>
<span class="nc bnc" id="L119" title="All 3 branches missed.">        switch ( op ) {</span>
            case TEXT_APPEND:
<span class="nc" id="L121">                generateCodeToStringCastOnExpr(binary);</span>
<span class="nc" id="L122">                break;</span>
            case DIVIDE:
<span class="nc" id="L124">                this.sb.append(&quot;((float) &quot;);</span>
<span class="nc" id="L125">                generateSubExpr(this.sb, parenthesesCheck(binary), binary.getRight(), binary);</span>
<span class="nc" id="L126">                this.sb.append(&quot;)&quot;);</span>
<span class="nc" id="L127">                break;</span>
            default:
<span class="nc" id="L129">                generateSubExpr(this.sb, parenthesesCheck(binary), binary.getRight(), binary);</span>
                break;
        }
<span class="nc" id="L132">        return null;</span>
    }

    @Override
    public Void visitEmptyExpr(EmptyExpr&lt;Void&gt; emptyExpr) {
<span class="nc bnc" id="L137" title="All 6 branches missed.">        switch ( emptyExpr.getDefVal() ) {</span>
            case STRING:
<span class="nc" id="L139">                this.sb.append(&quot;\&quot;\&quot;&quot;);</span>
<span class="nc" id="L140">                break;</span>
            case BOOLEAN:
<span class="nc" id="L142">                this.sb.append(&quot;true&quot;);</span>
<span class="nc" id="L143">                break;</span>
            case NUMBER_INT:
<span class="nc" id="L145">                this.sb.append(&quot;0&quot;);</span>
<span class="nc" id="L146">                break;</span>
            case ARRAY:
<span class="nc" id="L148">                break;</span>
            case NULL:
<span class="nc" id="L150">                break;</span>
            default:
<span class="nc" id="L152">                this.sb.append(&quot;null&quot;);</span>
                break;
        }
<span class="nc" id="L155">        return null;</span>
    }

    @Override
    public Void visitAssignStmt(AssignStmt&lt;Void&gt; assignStmt) {
<span class="nc" id="L160">        super.visitAssignStmt(assignStmt);</span>
<span class="nc" id="L161">        this.sb.append(&quot;;&quot;);</span>
<span class="nc" id="L162">        return null;</span>
    }

    @Override
    public Void visitExprStmt(ExprStmt&lt;Void&gt; exprStmt) {
<span class="nc" id="L167">        super.visitExprStmt(exprStmt);</span>
<span class="nc" id="L168">        this.sb.append(&quot;;&quot;);</span>
<span class="nc" id="L169">        return null;</span>
    }

    @Override
    public Void visitRepeatStmt(RepeatStmt&lt;Void&gt; repeatStmt) {
<span class="nc" id="L174">        boolean additionalClosingBracket = false;</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        boolean isWaitStmt = repeatStmt.getMode() == RepeatStmt.Mode.WAIT;</span>
<span class="nc bnc" id="L176" title="All 6 branches missed.">        switch ( repeatStmt.getMode() ) {</span>
            case FOREVER:
                /*
                 *This &quot;&quot;if ( true ) {&quot; statement is needed because when we have code after the &quot;while ( true ) &quot;
                 *statement is unreachable
                 */
<span class="nc" id="L182">                this.sb.append(&quot;if ( true ) {&quot;);</span>
<span class="nc" id="L183">                additionalClosingBracket = true;</span>
<span class="nc" id="L184">                incrIndentation();</span>
<span class="nc" id="L185">                nlIndent();</span>
            case UNTIL:
            case WHILE:
<span class="nc" id="L188">                addLabelToLoop();</span>
<span class="nc" id="L189">                generateCodeFromStmtCondition(&quot;while&quot;, repeatStmt.getExpr());</span>
<span class="nc" id="L190">                break;</span>
            case TIMES:
            case FOR:
<span class="nc" id="L193">                addLabelToLoop();</span>
<span class="nc" id="L194">                generateCodeFromStmtConditionFor(&quot;for&quot;, repeatStmt.getExpr());</span>
<span class="nc" id="L195">                break;</span>
            case WAIT:
<span class="nc" id="L197">                generateCodeFromStmtCondition(&quot;if&quot;, repeatStmt.getExpr());</span>
<span class="nc" id="L198">                break;</span>
            case FOR_EACH:
<span class="nc" id="L200">                addLabelToLoop();</span>
<span class="nc" id="L201">                generateCodeFromStmtCondition(&quot;for&quot;, repeatStmt.getExpr());</span>
<span class="nc" id="L202">                break;</span>
            default:
                break;
        }
<span class="nc" id="L206">        incrIndentation();</span>
<span class="nc" id="L207">        repeatStmt.getList().visit(this);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if ( !isWaitStmt ) {</span>
<span class="nc" id="L209">            this.currenLoop.removeLast();</span>
        } else {
<span class="nc" id="L211">            appendBreakStmt();</span>
        }
<span class="nc" id="L213">        decrIndentation();</span>
<span class="nc" id="L214">        nlIndent();</span>
<span class="nc" id="L215">        this.sb.append(&quot;}&quot;);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if ( additionalClosingBracket ) {</span>
<span class="nc" id="L217">            decrIndentation();</span>
<span class="nc" id="L218">            nlIndent();</span>
<span class="nc" id="L219">            this.sb.append(&quot;}&quot;);</span>
        }
<span class="nc" id="L221">        return null;</span>
    }

    @Override
    public Void visitFunctionStmt(FunctionStmt&lt;Void&gt; functionStmt) {
<span class="nc" id="L226">        super.visitFunctionStmt(functionStmt);</span>
<span class="nc" id="L227">        this.sb.append(&quot;;&quot;);</span>
<span class="nc" id="L228">        return null;</span>
    }

    @Override
    public Void visitStmtFlowCon(StmtFlowCon&lt;Void&gt; stmtFlowCon) {
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if ( this.loopsLabels.get(this.currenLoop.getLast()) != null ) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">            if ( this.loopsLabels.get(this.currenLoop.getLast()) ) {</span>
<span class="nc" id="L235">                this.sb.append(&quot;if (true) &quot; + stmtFlowCon.getFlow().toString().toLowerCase() + &quot; loop&quot; + this.currenLoop.getLast() + &quot;;&quot;);</span>
<span class="nc" id="L236">                return null;</span>
            }
        }
<span class="nc" id="L239">        this.sb.append(stmtFlowCon.getFlow().toString().toLowerCase() + &quot;;&quot;);</span>
<span class="nc" id="L240">        return null;</span>
    }

    @Override
    public Void visitTextPrintFunct(TextPrintFunct&lt;Void&gt; textPrintFunct) {
<span class="nc" id="L245">        this.sb.append(&quot;System.out.println(&quot;);</span>
<span class="nc" id="L246">        textPrintFunct.getParam().get(0).visit(this);</span>
<span class="nc" id="L247">        this.sb.append(&quot;)&quot;);</span>
<span class="nc" id="L248">        return null;</span>
    }

    @Override
    public Void visitStmtTextComment(StmtTextComment&lt;Void&gt; stmtTextComment) {
<span class="nc" id="L253">        this.sb.append(&quot;// &quot; + stmtTextComment.getTextComment());</span>
<span class="nc" id="L254">        return null;</span>
    };

    @Override
    public Void visitEmptyList(EmptyList&lt;Void&gt; emptyList) {
<span class="nc" id="L259">        this.sb.append(</span>
            &quot;new ArrayList&lt;&quot;
<span class="nc" id="L261">                + getLanguageVarTypeFromBlocklyType(emptyList.getTypeVar()).substring(0, 1).toUpperCase()</span>
<span class="nc" id="L262">                + getLanguageVarTypeFromBlocklyType(emptyList.getTypeVar()).substring(1).toLowerCase()</span>
                + &quot;&gt;()&quot;);
<span class="nc" id="L264">        return null;</span>
    }

    @Override
    public Void visitMathSingleFunct(MathSingleFunct&lt;Void&gt; mathSingleFunct) {
<span class="nc" id="L269">        this.sb.append(&quot;BlocklyMethods.&quot;);</span>
<span class="nc bnc" id="L270" title="All 16 branches missed.">        switch ( mathSingleFunct.getFunctName() ) {</span>
            case ROOT:
<span class="nc" id="L272">                this.sb.append(&quot;sqrt(&quot;);</span>
<span class="nc" id="L273">                break;</span>
            case ABS:
<span class="nc" id="L275">                this.sb.append(&quot;abs(&quot;);</span>
<span class="nc" id="L276">                break;</span>
            case LN:
<span class="nc" id="L278">                this.sb.append(&quot;log(&quot;);</span>
<span class="nc" id="L279">                break;</span>
            case LOG10:
<span class="nc" id="L281">                this.sb.append(&quot;log10(&quot;);</span>
<span class="nc" id="L282">                break;</span>
            case EXP:
<span class="nc" id="L284">                this.sb.append(&quot;exp(&quot;);</span>
<span class="nc" id="L285">                break;</span>
            case POW10:
<span class="nc" id="L287">                this.sb.append(&quot;pow(10, &quot;);</span>
<span class="nc" id="L288">                break;</span>
            case SIN:
<span class="nc" id="L290">                this.sb.append(&quot;sin(&quot;);</span>
<span class="nc" id="L291">                break;</span>
            case COS:
<span class="nc" id="L293">                this.sb.append(&quot;cos(&quot;);</span>
<span class="nc" id="L294">                break;</span>
            case TAN:
<span class="nc" id="L296">                this.sb.append(&quot;tan(&quot;);</span>
<span class="nc" id="L297">                break;</span>
            case ASIN:
<span class="nc" id="L299">                this.sb.append(&quot;asin(&quot;);</span>
<span class="nc" id="L300">                break;</span>
            case ATAN:
<span class="nc" id="L302">                this.sb.append(&quot;atan(&quot;);</span>
<span class="nc" id="L303">                break;</span>
            case ACOS:
<span class="nc" id="L305">                this.sb.append(&quot;acos(&quot;);</span>
<span class="nc" id="L306">                break;</span>
            case ROUND:
<span class="nc" id="L308">                this.sb.append(&quot;round(&quot;);</span>
<span class="nc" id="L309">                break;</span>
            case ROUNDUP:
<span class="nc" id="L311">                this.sb.append(&quot;ceil(&quot;);</span>
<span class="nc" id="L312">                break;</span>
            case ROUNDDOWN:
<span class="nc" id="L314">                this.sb.append(&quot;floor(&quot;);</span>
<span class="nc" id="L315">                break;</span>
            default:
                break;
        }
<span class="nc" id="L319">        mathSingleFunct.getParam().get(0).visit(this);</span>
<span class="nc" id="L320">        this.sb.append(&quot;)&quot;);</span>

<span class="nc" id="L322">        return null;</span>
    }

    @Override
    public Void visitMethodVoid(MethodVoid&lt;Void&gt; methodVoid) {
<span class="nc" id="L327">        this.sb.append(&quot;\n&quot;).append(INDENT).append(&quot;private void &quot;);</span>
<span class="nc" id="L328">        this.sb.append(methodVoid.getMethodName() + &quot;(&quot;);</span>
<span class="nc" id="L329">        methodVoid.getParameters().visit(this);</span>
<span class="nc" id="L330">        this.sb.append(&quot;) {&quot;);</span>
<span class="nc" id="L331">        methodVoid.getBody().visit(this);</span>
<span class="nc" id="L332">        this.sb.append(&quot;\n&quot;).append(INDENT).append(&quot;}&quot;);</span>
<span class="nc" id="L333">        return null;</span>
    }

    @Override
    public Void visitMethodReturn(MethodReturn&lt;Void&gt; methodReturn) {
<span class="nc" id="L338">        this.sb.append(&quot;\n&quot;).append(INDENT).append(&quot;private &quot; + getLanguageVarTypeFromBlocklyType(methodReturn.getReturnType()));</span>
<span class="nc" id="L339">        this.sb.append(&quot; &quot; + methodReturn.getMethodName() + &quot;(&quot;);</span>
<span class="nc" id="L340">        methodReturn.getParameters().visit(this);</span>
<span class="nc" id="L341">        this.sb.append(&quot;) {&quot;);</span>
<span class="nc" id="L342">        methodReturn.getBody().visit(this);</span>
<span class="nc" id="L343">        nlIndent();</span>
<span class="nc" id="L344">        this.sb.append(&quot;return &quot;);</span>
<span class="nc" id="L345">        methodReturn.getReturnValue().visit(this);</span>
<span class="nc" id="L346">        this.sb.append(&quot;;\n&quot;).append(INDENT).append(&quot;}&quot;);</span>
<span class="nc" id="L347">        return null;</span>
    }

    @Override
    public Void visitMethodIfReturn(MethodIfReturn&lt;Void&gt; methodIfReturn) {
<span class="nc" id="L352">        this.sb.append(&quot;if (&quot;);</span>
<span class="nc" id="L353">        methodIfReturn.getCondition().visit(this);</span>
<span class="nc" id="L354">        this.sb.append(&quot;) &quot;);</span>
<span class="nc" id="L355">        this.sb.append(&quot;return &quot;);</span>
<span class="nc" id="L356">        methodIfReturn.getReturnValue().visit(this);</span>
<span class="nc" id="L357">        return null;</span>
    }

    @Override
    public Void visitMethodStmt(MethodStmt&lt;Void&gt; methodStmt) {
<span class="nc" id="L362">        super.visitMethodStmt(methodStmt);</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if ( methodStmt.getProperty().getBlockType().equals(&quot;robProcedures_ifreturn&quot;) ) {</span>
<span class="nc" id="L364">            this.sb.append(&quot;;&quot;);</span>
        }
<span class="nc" id="L366">        return null;</span>
    }

    @Override
    public Void visitMethodCall(MethodCall&lt;Void&gt; methodCall) {
<span class="nc" id="L371">        super.visitMethodCall(methodCall);</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">        if ( methodCall.getReturnType() == BlocklyType.VOID ) {</span>
<span class="nc" id="L373">            this.sb.append(&quot;;&quot;);</span>
        }
<span class="nc" id="L375">        return null;</span>
    }

    @Override
    protected String getLanguageVarTypeFromBlocklyType(BlocklyType type) {
<span class="nc bnc" id="L380" title="All 15 branches missed.">        switch ( type ) {</span>
            case ANY:
            case COMPARABLE:
            case ADDABLE:
            case NULL:
            case REF:
            case PRIM:
            case NOTHING:
            case CAPTURED_TYPE:
            case R:
            case S:
            case T:
<span class="nc" id="L392">                return &quot;&quot;;</span>
            case ARRAY:
<span class="nc" id="L394">                return &quot;List&quot;;</span>
            case ARRAY_NUMBER:
<span class="nc" id="L396">                return &quot;ArrayList&lt;Float&gt;&quot;;</span>
            case ARRAY_STRING:
<span class="nc" id="L398">                return &quot;ArrayList&lt;String&gt;&quot;;</span>
            case ARRAY_COLOUR:
<span class="nc" id="L400">                return &quot;ArrayList&lt;PickColor&gt;&quot;;</span>
            case ARRAY_BOOLEAN:
<span class="nc" id="L402">                return &quot;ArrayList&lt;Boolean&gt;&quot;;</span>
            case ARRAY_CONNECTION:
<span class="nc" id="L404">                return &quot;ArrayList&lt;NXTConnection&gt;&quot;;</span>
            case BOOLEAN:
<span class="nc" id="L406">                return &quot;boolean&quot;;</span>
            case NUMBER:
<span class="nc" id="L408">                return &quot;float&quot;;</span>
            case NUMBER_INT:
<span class="nc" id="L410">                return &quot;int&quot;;</span>
            case STRING:
<span class="nc" id="L412">                return &quot;String&quot;;</span>
            case COLOR:
<span class="nc" id="L414">                return &quot;PickColor&quot;;</span>
            case VOID:
<span class="nc" id="L416">                return &quot;void&quot;;</span>
            case CONNECTION:
<span class="nc" id="L418">                return &quot;NXTConnection&quot;;</span>
            default:
<span class="nc" id="L420">                throw new IllegalArgumentException(&quot;unhandled type&quot;);</span>
        }
    }

    private boolean isStringExpr(Expr&lt;Void&gt; e) {
<span class="nc bnc" id="L425" title="All 22 branches missed.">        switch ( e.getKind().getName() ) {</span>
            case &quot;STRING_CONST&quot;:
<span class="nc" id="L427">                return true;</span>
            case &quot;VAR&quot;:
<span class="nc bnc" id="L429" title="All 2 branches missed.">                return ((Var&lt;?&gt;) e).getVarType() == BlocklyType.STRING;</span>
            case &quot;FUNCTION_EXPR&quot;:
<span class="nc" id="L431">                BlockType functionKind = ((FunctionExpr&lt;?&gt;) e).getFunction().getKind();</span>
<span class="nc" id="L432">                return functionKind.hasName(&quot;TEXT_JOIN_FUNCT&quot;, &quot;LIST_INDEX_OF&quot;);</span>
            case &quot;METHOD_EXPR&quot;:
<span class="nc" id="L434">                MethodCall&lt;?&gt; methodCall = (MethodCall&lt;?&gt;) ((MethodExpr&lt;?&gt;) e).getMethod();</span>
<span class="nc bnc" id="L435" title="All 4 branches missed.">                return methodCall.getKind().hasName(&quot;METHOD_CALL&quot;) &amp;&amp; methodCall.getReturnType() == BlocklyType.STRING;</span>
            case &quot;ACTION_EXPR&quot;:
<span class="nc" id="L437">                Action&lt;?&gt; action = ((ActionExpr&lt;?&gt;) e).getAction();</span>
<span class="nc" id="L438">                return action.getKind().hasName(&quot;BLUETOOTH_RECEIVED_ACTION&quot;);</span>

            default:
<span class="nc" id="L441">                return false;</span>
        }
    }

    @Override
    protected void generateCodeFromTernary(IfStmt&lt;Void&gt; ifStmt) {
<span class="nc" id="L447">        this.sb.append(&quot;(&quot; + whitespace());</span>
<span class="nc" id="L448">        ifStmt.getExpr().get(0).visit(this);</span>
<span class="nc" id="L449">        this.sb.append(whitespace() + &quot;)&quot; + whitespace() + &quot;?&quot; + whitespace());</span>
<span class="nc" id="L450">        ((ExprStmt&lt;Void&gt;) ifStmt.getThenList().get(0).get().get(0)).getExpr().visit(this);</span>
<span class="nc" id="L451">        this.sb.append(whitespace() + &quot;:&quot; + whitespace());</span>
<span class="nc" id="L452">        ((ExprStmt&lt;Void&gt;) ifStmt.getElseList().get().get(0)).getExpr().visit(this);</span>
<span class="nc" id="L453">    }</span>

    @Override
    protected void generateCodeFromIfElse(IfStmt&lt;Void&gt; ifStmt) {
<span class="nc" id="L457">        int exprSize = ifStmt.getExpr().size();</span>
<span class="nc" id="L458">        String conditionStmt = &quot;if&quot;;</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">        for ( int i = 0; i &lt; exprSize; i++ ) {</span>
<span class="nc" id="L460">            generateCodeFromStmtCondition(conditionStmt, ifStmt.getExpr().get(i));</span>
<span class="nc" id="L461">            conditionStmt = &quot;else&quot; + whitespace() + &quot;if&quot;;</span>
<span class="nc" id="L462">            incrIndentation();</span>
<span class="nc" id="L463">            ifStmt.getThenList().get(i).visit(this);</span>
<span class="nc" id="L464">            decrIndentation();</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">            if ( i + 1 &lt; exprSize ) {</span>
<span class="nc" id="L466">                nlIndent();</span>
<span class="nc" id="L467">                this.sb.append(&quot;}&quot;).append(whitespace());</span>
            }
        }
<span class="nc" id="L470">    }</span>

    @Override
    protected void generateCodeFromElse(IfStmt&lt;Void&gt; ifStmt) {
<span class="nc bnc" id="L474" title="All 2 branches missed.">        if ( !ifStmt.getElseList().get().isEmpty() ) {</span>
<span class="nc" id="L475">            nlIndent();</span>
<span class="nc" id="L476">            this.sb.append(&quot;}&quot;).append(whitespace()).append(&quot;else&quot;).append(whitespace() + &quot;{&quot;);</span>
<span class="nc" id="L477">            incrIndentation();</span>
<span class="nc" id="L478">            ifStmt.getElseList().visit(this);</span>
<span class="nc" id="L479">            decrIndentation();</span>
        }
<span class="nc" id="L481">        nlIndent();</span>
<span class="nc" id="L482">        this.sb.append(&quot;}&quot;);</span>
<span class="nc" id="L483">    }</span>

    private void generateCodeFromStmtCondition(String stmtType, Expr&lt;Void&gt; expr) {
<span class="nc" id="L486">        this.sb.append(stmtType + whitespace() + &quot;(&quot; + whitespace());</span>
<span class="nc" id="L487">        expr.visit(this);</span>
<span class="nc" id="L488">        this.sb.append(whitespace() + &quot;)&quot; + whitespace() + &quot;{&quot;);</span>
<span class="nc" id="L489">    }</span>

    private void generateCodeFromStmtConditionFor(String stmtType, Expr&lt;Void&gt; expr) {
<span class="nc" id="L492">        this.sb.append(stmtType + whitespace() + &quot;(&quot; + whitespace() + &quot;float&quot; + whitespace());</span>
<span class="nc" id="L493">        ExprList&lt;Void&gt; expressions = (ExprList&lt;Void&gt;) expr;</span>
<span class="nc" id="L494">        expressions.get().get(0).visit(this);</span>
<span class="nc" id="L495">        this.sb.append(whitespace() + &quot;=&quot; + whitespace());</span>
<span class="nc" id="L496">        expressions.get().get(1).visit(this);</span>
<span class="nc" id="L497">        this.sb.append(&quot;;&quot; + whitespace());</span>
<span class="nc" id="L498">        expressions.get().get(0).visit(this);</span>
<span class="nc" id="L499">        int posOpenBracket = expressions.get().toString().lastIndexOf(&quot;[&quot;);</span>
<span class="nc" id="L500">        int posClosedBracket = expressions.get().toString().lastIndexOf(&quot;]&quot;);</span>
<span class="nc" id="L501">        int counterPos = expressions.get().toString().lastIndexOf(&quot;-&quot;);</span>
<span class="nc bnc" id="L502" title="All 4 branches missed.">        if ( counterPos &gt; posOpenBracket &amp;&amp; counterPos &lt; posClosedBracket ) {</span>
<span class="nc" id="L503">            this.sb.append(&quot;&gt;&quot; + whitespace());</span>
        } else {
<span class="nc" id="L505">            this.sb.append(&quot;&lt;&quot; + whitespace());</span>
        }
<span class="nc" id="L507">        expressions.get().get(2).visit(this);</span>
<span class="nc" id="L508">        this.sb.append(&quot;;&quot; + whitespace());</span>
<span class="nc" id="L509">        expressions.get().get(0).visit(this);</span>
<span class="nc" id="L510">        this.sb.append(&quot;+=&quot; + whitespace());</span>
<span class="nc" id="L511">        expressions.get().get(3).visit(this);</span>
<span class="nc" id="L512">        this.sb.append(whitespace() + &quot;)&quot; + whitespace() + &quot;{&quot;);</span>
<span class="nc" id="L513">    }</span>

    private boolean isEqualityOpOnStrings(Binary&lt;Void&gt; binary) {
<span class="nc bnc" id="L516" title="All 4 branches missed.">        boolean isLeftAndRightString = isStringExpr(binary.getLeft()) &amp;&amp; isStringExpr(binary.getRight());</span>
<span class="nc bnc" id="L517" title="All 4 branches missed.">        boolean isEqualityOp = binary.getOp() == Op.EQ || binary.getOp() == Op.NEQ;</span>
<span class="nc bnc" id="L518" title="All 4 branches missed.">        return isEqualityOp &amp;&amp; isLeftAndRightString;</span>
    }

    private void generateCodeToStringCastOnExpr(Binary&lt;Void&gt; binary) {
<span class="nc" id="L522">        this.sb.append(&quot;String.valueOf(&quot;);</span>
<span class="nc" id="L523">        generateSubExpr(this.sb, false, binary.getRight(), binary);</span>
<span class="nc" id="L524">        this.sb.append(&quot;)&quot;);</span>
<span class="nc" id="L525">    }</span>

    private void generateCodeForStringEqualityOp(Binary&lt;Void&gt; binary) {
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if ( binary.getOp() == Op.NEQ ) {</span>
<span class="nc" id="L529">            this.sb.append(&quot;!&quot;);</span>
        }
<span class="nc" id="L531">        generateSubExpr(this.sb, false, binary.getLeft(), binary);</span>
<span class="nc" id="L532">        this.sb.append(&quot;.equals(&quot;);</span>
<span class="nc" id="L533">        generateSubExpr(this.sb, false, binary.getRight(), binary);</span>
<span class="nc" id="L534">        this.sb.append(&quot;)&quot;);</span>
<span class="nc" id="L535">    }</span>

    private void appendBreakStmt() {
<span class="nc" id="L538">        nlIndent();</span>
<span class="nc" id="L539">        this.sb.append(&quot;break;&quot;);</span>
<span class="nc" id="L540">    }</span>

    private void addLabelToLoop() {
<span class="nc" id="L543">        increaseLoopCounter();</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">        if ( this.loopsLabels.get(this.currenLoop.getLast()) ) {</span>
<span class="nc" id="L545">            this.sb.append(&quot;loop&quot; + this.currenLoop.getLast() + &quot;:&quot;);</span>
<span class="nc" id="L546">            nlIndent();</span>
        }
<span class="nc" id="L548">    }</span>

    @Override
    protected String getBinaryOperatorSymbol(Binary.Op op) {
<span class="nc" id="L552">        return binaryOpSymbols().get(op);</span>
    }

    @Override
    protected String getUnaryOperatorSymbol(Unary.Op op) {
<span class="nc" id="L557">        return unaryOpSymbols().get(op);</span>
    }

    protected static Map&lt;Binary.Op, String&gt; binaryOpSymbols() {
<span class="nc" id="L561">        return Collections.unmodifiableMap(</span>
            Stream
<span class="nc" id="L563">                .of(</span>

<span class="nc" id="L565">                    entry(Binary.Op.ADD, &quot;+&quot;),</span>
<span class="nc" id="L566">                    entry(Binary.Op.MINUS, &quot;-&quot;),</span>
<span class="nc" id="L567">                    entry(Binary.Op.MULTIPLY, &quot;*&quot;),</span>
<span class="nc" id="L568">                    entry(Binary.Op.DIVIDE, &quot;/&quot;),</span>
<span class="nc" id="L569">                    entry(Binary.Op.MOD, &quot;%&quot;),</span>
<span class="nc" id="L570">                    entry(Binary.Op.EQ, &quot;==&quot;),</span>
<span class="nc" id="L571">                    entry(Binary.Op.NEQ, &quot;!=&quot;),</span>
<span class="nc" id="L572">                    entry(Binary.Op.LT, &quot;&lt;&quot;),</span>
<span class="nc" id="L573">                    entry(Binary.Op.LTE, &quot;&lt;=&quot;),</span>
<span class="nc" id="L574">                    entry(Binary.Op.GT, &quot;&gt;&quot;),</span>
<span class="nc" id="L575">                    entry(Binary.Op.GTE, &quot;&gt;=&quot;),</span>
<span class="nc" id="L576">                    entry(Binary.Op.AND, &quot;&amp;&amp;&quot;),</span>
<span class="nc" id="L577">                    entry(Binary.Op.OR, &quot;||&quot;),</span>
<span class="nc" id="L578">                    entry(Binary.Op.MATH_CHANGE, &quot;+=&quot;),</span>
<span class="nc" id="L579">                    entry(Binary.Op.TEXT_APPEND, &quot;+=&quot;),</span>
<span class="nc" id="L580">                    entry(Binary.Op.IN, &quot;:&quot;),</span>
<span class="nc" id="L581">                    entry(Binary.Op.ASSIGNMENT, &quot;=&quot;),</span>
<span class="nc" id="L582">                    entry(Binary.Op.ADD_ASSIGNMENT, &quot;+=&quot;),</span>
<span class="nc" id="L583">                    entry(Binary.Op.MINUS_ASSIGNMENT, &quot;-=&quot;),</span>
<span class="nc" id="L584">                    entry(Binary.Op.MULTIPLY_ASSIGNMENT, &quot;*=&quot;),</span>
<span class="nc" id="L585">                    entry(Binary.Op.DIVIDE_ASSIGNMENT, &quot;/=&quot;),</span>
<span class="nc" id="L586">                    entry(Binary.Op.MOD_ASSIGNMENT, &quot;%=&quot;)</span>

                )
<span class="nc" id="L589">                .collect(entriesToMap()));</span>
    }

    protected static Map&lt;Unary.Op, String&gt; unaryOpSymbols() {
<span class="nc" id="L593">        return Collections.unmodifiableMap(</span>
            Stream
<span class="nc" id="L595">                .of(</span>

<span class="nc" id="L597">                    entry(Unary.Op.PLUS, &quot;+&quot;),</span>
<span class="nc" id="L598">                    entry(Unary.Op.NEG, &quot;-&quot;),</span>
<span class="nc" id="L599">                    entry(Unary.Op.NOT, &quot;!&quot;),</span>
<span class="nc" id="L600">                    entry(Unary.Op.POSTFIX_INCREMENTS, &quot;++&quot;),</span>
<span class="nc" id="L601">                    entry(Unary.Op.PREFIX_INCREMENTS, &quot;++&quot;)</span>

                )
<span class="nc" id="L604">                .collect(entriesToMap()));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>