<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CommonLanguageVisitor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenRobertaRobot</a> &gt; <a href="index.source.html" class="el_package">de.fhg.iais.roberta.syntax.codegen</a> &gt; <span class="el_source">CommonLanguageVisitor.java</span></div><h1>CommonLanguageVisitor.java</h1><pre class="source lang-java linenums">package de.fhg.iais.roberta.syntax.codegen;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentMap;
import java.util.stream.Collector;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringEscapeUtils;

import de.fhg.iais.roberta.components.Category;
import de.fhg.iais.roberta.inter.mode.general.IMode;
import de.fhg.iais.roberta.syntax.Phrase;
import de.fhg.iais.roberta.syntax.lang.expr.Binary;
import de.fhg.iais.roberta.syntax.lang.expr.Binary.Op;
import de.fhg.iais.roberta.syntax.lang.expr.BoolConst;
import de.fhg.iais.roberta.syntax.lang.expr.ColorConst;
import de.fhg.iais.roberta.syntax.lang.expr.Expr;
import de.fhg.iais.roberta.syntax.lang.expr.ExprList;
import de.fhg.iais.roberta.syntax.lang.expr.NumConst;
import de.fhg.iais.roberta.syntax.lang.expr.RgbColor;
import de.fhg.iais.roberta.syntax.lang.expr.StringConst;
import de.fhg.iais.roberta.syntax.lang.expr.Unary;
import de.fhg.iais.roberta.syntax.lang.expr.Var;
import de.fhg.iais.roberta.syntax.lang.expr.VarDeclaration;
import de.fhg.iais.roberta.syntax.lang.functions.MathPowerFunct;
import de.fhg.iais.roberta.syntax.lang.methods.MethodCall;
import de.fhg.iais.roberta.syntax.lang.stmt.ActionStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.AssignStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.IfStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.MethodStmt;
import de.fhg.iais.roberta.syntax.lang.stmt.StmtList;
import de.fhg.iais.roberta.typecheck.BlocklyType;
import de.fhg.iais.roberta.util.dbc.Assert;
import de.fhg.iais.roberta.visitor.lang.AstLanguageVisitor;

public abstract class CommonLanguageVisitor implements AstLanguageVisitor&lt;Void&gt; {
    //TODO find more simple way of handling the loops
<span class="nc" id="L42">    protected int loopCounter = 0;</span>
<span class="nc" id="L43">    protected LinkedList&lt;Integer&gt; currenLoop = new LinkedList&lt;&gt;();</span>
    protected Map&lt;Integer, Boolean&gt; loopsLabels;

<span class="nc" id="L46">    protected final StringBuilder sb = new StringBuilder();</span>
    protected final List&lt;Phrase&lt;Void&gt;&gt; programPhrases;

    private int indentation;
<span class="nc" id="L50">    private final StringBuilder indent = new StringBuilder();</span>

    /**
     * initialize the common language code generator visitor.
     *
     * @param indentation to start with. Will be ince/decr depending on block structure
     */
<span class="nc" id="L57">    public CommonLanguageVisitor(ArrayList&lt;ArrayList&lt;Phrase&lt;Void&gt;&gt;&gt; programPhrases, int indentation) {</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">        Assert.isTrue(!programPhrases.isEmpty());</span>
<span class="nc" id="L59">        this.indentation = indentation;</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">        for ( int i = 0; i &lt; indentation; i++ ) {</span>
<span class="nc" id="L61">            this.indent.append(INDENT);</span>
        }
<span class="nc" id="L63">        this.programPhrases =</span>
            programPhrases
<span class="nc" id="L65">                .stream()</span>
<span class="nc" id="L66">                .flatMap(e -&gt; e.subList(1, e.size()).stream())</span>
<span class="nc bnc" id="L67" title="All 6 branches missed.">                .filter(p -&gt; p.getProperty().isInTask() == null ? true : p.getProperty().isInTask() &amp;&amp; !p.getProperty().isDisabled()) //TODO check if we can avoid null value for inTask</span>
<span class="nc" id="L68">                .collect(Collectors.toList());</span>
<span class="nc" id="L69">    }</span>

    /**
     * Get the current indentation of the visitor. Meaningful for tests only.
     *
     * @return indentation value of the visitor.
     */
    public int getIndentation() {
<span class="nc" id="L77">        return this.indentation;</span>
    }

    /**
     * Get the string builder of the visitor. Meaningful for tests only.
     *
     * @return (current state of) the string builder
     */
    public StringBuilder getSb() {
<span class="nc" id="L86">        return this.sb;</span>
    }

    protected void generateCode(boolean withWrapping) {
<span class="nc" id="L90">        generateProgramPrefix(withWrapping);</span>
<span class="nc" id="L91">        generateProgramMainBody();</span>
<span class="nc" id="L92">        generateProgramSuffix(withWrapping);</span>
<span class="nc" id="L93">    }</span>

    private void generateProgramMainBody() {
<span class="nc bnc" id="L96" title="All 4 branches missed.">        this.programPhrases.stream().filter(phrase -&gt; phrase.getKind().getCategory() != Category.METHOD || phrase.getKind().hasName(&quot;METHOD_CALL&quot;)).forEach(</span>
            p -&gt; {
<span class="nc" id="L98">                this.nlIndent();</span>
<span class="nc" id="L99">                p.visit(this);</span>
<span class="nc" id="L100">            });</span>
<span class="nc" id="L101">    }</span>

    protected void generateUserDefinedMethods() {
<span class="nc" id="L104">        this.incrIndentation();</span>
<span class="nc bnc" id="L105" title="All 4 branches missed.">        this.programPhrases.stream().filter(phrase -&gt; phrase.getKind().getCategory() == Category.METHOD &amp;&amp; !phrase.getKind().hasName(&quot;METHOD_CALL&quot;)).forEach(</span>
            e -&gt; {
<span class="nc" id="L107">                e.visit(this);</span>
<span class="nc" id="L108">                this.sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L109">            });</span>
<span class="nc" id="L110">        this.decrIndentation();</span>
<span class="nc" id="L111">    }</span>

    @Override
    public Void visitNumConst(NumConst&lt;Void&gt; numConst) {
<span class="nc" id="L115">        this.sb.append(numConst.getValue());</span>
<span class="nc" id="L116">        return null;</span>
    }

    @Override
    public Void visitBoolConst(BoolConst&lt;Void&gt; boolConst) {
<span class="nc" id="L121">        this.sb.append(boolConst.isValue());</span>
<span class="nc" id="L122">        return null;</span>
    }

    @Override
    public Void visitStringConst(StringConst&lt;Void&gt; stringConst) {
<span class="nc" id="L127">        this.sb.append(&quot;\&quot;&quot;).append(StringEscapeUtils.escapeEcmaScript(stringConst.getValue().replaceAll(&quot;[&lt;&gt;\\$]&quot;, &quot;&quot;))).append(&quot;\&quot;&quot;);</span>
<span class="nc" id="L128">        return null;</span>
    }

    @Override
    public Void visitColorConst(ColorConst&lt;Void&gt; colorConst) {
<span class="nc" id="L133">        this.sb.append(getEnumCode(colorConst.getValue()));</span>
<span class="nc" id="L134">        return null;</span>
    }

    @Override
    public Void visitRgbColor(RgbColor&lt;Void&gt; rgbColor) {
<span class="nc" id="L139">        rgbColor.getR().visit(this);</span>
<span class="nc" id="L140">        this.sb.append(&quot;, &quot;);</span>
<span class="nc" id="L141">        rgbColor.getG().visit(this);</span>
<span class="nc" id="L142">        this.sb.append(&quot;, &quot;);</span>
<span class="nc" id="L143">        rgbColor.getB().visit(this);</span>
<span class="nc" id="L144">        this.sb.append(&quot;, &quot;);</span>
<span class="nc" id="L145">        rgbColor.getA().visit(this);</span>
<span class="nc" id="L146">        return null;</span>
    }

    @Override
    public Void visitVar(Var&lt;Void&gt; var) {
<span class="nc" id="L151">        this.sb.append(var.getValue());</span>
<span class="nc" id="L152">        return null;</span>
    }

    @Override
    public Void visitVarDeclaration(VarDeclaration&lt;Void&gt; var) {
<span class="nc" id="L157">        this.sb.append(getLanguageVarTypeFromBlocklyType(var.getTypeVar())).append(&quot; &quot;);</span>
<span class="nc" id="L158">        this.sb.append(var.getName());</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if ( !var.getValue().getKind().hasName(&quot;EMPTY_EXPR&quot;) ) {</span>
<span class="nc" id="L160">            this.sb.append(&quot; = &quot;);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            if ( var.getValue().getKind().hasName(&quot;EXPR_LIST&quot;) ) {</span>
<span class="nc" id="L162">                ExprList&lt;Void&gt; list = (ExprList&lt;Void&gt;) var.getValue();</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">                if ( list.get().size() == 2 ) {</span>
<span class="nc" id="L164">                    list.get().get(1).visit(this);</span>
                } else {
<span class="nc" id="L166">                    list.get().get(0).visit(this);</span>
                }
<span class="nc" id="L168">            } else {</span>
<span class="nc" id="L169">                var.getValue().visit(this);</span>
            }
        }
<span class="nc" id="L172">        return null;</span>
    }

    @Override
    public Void visitUnary(Unary&lt;Void&gt; unary) {
<span class="nc" id="L177">        Unary.Op op = unary.getOp();</span>
<span class="nc" id="L178">        String sym = getUnaryOperatorSymbol(op);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if ( op == Unary.Op.POSTFIX_INCREMENTS ) {</span>
<span class="nc" id="L180">            generateExprCode(unary, this.sb);</span>
<span class="nc" id="L181">            this.sb.append(sym);</span>
        } else {
<span class="nc" id="L183">            this.sb.append(sym + whitespace());</span>
<span class="nc" id="L184">            generateExprCode(unary, this.sb);</span>
        }
<span class="nc" id="L186">        return null;</span>
    }

    @Override
    public Void visitExprList(ExprList&lt;Void&gt; exprList) {
<span class="nc" id="L191">        boolean first = true;</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        for ( Expr&lt;Void&gt; expr : exprList.get() ) {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">            if ( !expr.getKind().hasName(&quot;EMPTY_EXPR&quot;) ) {</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">                if ( first ) {</span>
<span class="nc" id="L195">                    first = false;</span>
                } else {
<span class="nc" id="L197">                    this.sb.append(&quot;, &quot;);</span>
                }
<span class="nc" id="L199">                expr.visit(this);</span>
            }
<span class="nc" id="L201">        }</span>
<span class="nc" id="L202">        return null;</span>
    }

    @Override
    public Void visitActionStmt(ActionStmt&lt;Void&gt; actionStmt) {
<span class="nc" id="L207">        actionStmt.getAction().visit(this);</span>
<span class="nc" id="L208">        return null;</span>
    }

    @Override
    public Void visitAssignStmt(AssignStmt&lt;Void&gt; assignStmt) {
<span class="nc" id="L213">        assignStmt.getName().visit(this);</span>
<span class="nc" id="L214">        this.sb.append(&quot; = &quot;);</span>
<span class="nc" id="L215">        assignStmt.getExpr().visit(this);</span>
<span class="nc" id="L216">        return null;</span>
    }

    @Override
    public Void visitIfStmt(IfStmt&lt;Void&gt; ifStmt) {
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if ( ifStmt.isTernary() ) {</span>
<span class="nc" id="L222">            generateCodeFromTernary(ifStmt);</span>
        } else {
<span class="nc" id="L224">            generateCodeFromIfElse(ifStmt);</span>
<span class="nc" id="L225">            generateCodeFromElse(ifStmt);</span>
        }
<span class="nc" id="L227">        return null;</span>
    }

    @Override
    public Void visitStmtList(StmtList&lt;Void&gt; stmtList) {
<span class="nc" id="L232">        stmtList.get().stream().forEach(stmt -&gt; {</span>
<span class="nc" id="L233">            nlIndent();</span>
<span class="nc" id="L234">            stmt.visit(this);</span>
<span class="nc" id="L235">        });</span>
<span class="nc" id="L236">        return null;</span>
    }

    @Override
    public Void visitMethodCall(MethodCall&lt;Void&gt; methodCall) {
<span class="nc" id="L241">        this.sb.append(methodCall.getMethodName() + &quot;(&quot;);</span>
<span class="nc" id="L242">        methodCall.getParametersValues().visit(this);</span>
<span class="nc" id="L243">        this.sb.append(&quot;)&quot;);</span>
<span class="nc" id="L244">        return null;</span>
    }

    @Override
    public Void visitMethodStmt(MethodStmt&lt;Void&gt; methodStmt) {
<span class="nc" id="L249">        methodStmt.getMethod().visit(this);</span>
<span class="nc" id="L250">        return null;</span>
    }

    @Override
    public Void visitMathPowerFunct(MathPowerFunct&lt;Void&gt; mathPowerFunct) {
<span class="nc" id="L255">        mathPowerFunct.getParam().get(0).visit(this);</span>
<span class="nc" id="L256">        this.sb.append(&quot;, &quot;);</span>
<span class="nc" id="L257">        mathPowerFunct.getParam().get(1).visit(this);</span>
<span class="nc" id="L258">        this.sb.append(&quot;)&quot;);</span>
<span class="nc" id="L259">        return null;</span>
    }

    protected void generateExprCode(Unary&lt;Void&gt; unary, StringBuilder sb) {
<span class="nc bnc" id="L263" title="All 4 branches missed.">        if ( unary.getExpr().getPrecedence() &lt; unary.getPrecedence() || unary.getOp() == Unary.Op.NEG ) {</span>
<span class="nc" id="L264">            sb.append(&quot;(&quot;);</span>
<span class="nc" id="L265">            unary.getExpr().visit(this);</span>
<span class="nc" id="L266">            sb.append(&quot;)&quot;);</span>
        } else {
<span class="nc" id="L268">            unary.getExpr().visit(this);</span>
        }
<span class="nc" id="L270">    }</span>

    protected void incrIndentation() {
<span class="nc" id="L273">        this.indentation += 1;</span>
<span class="nc" id="L274">        this.indent.append(INDENT);</span>
<span class="nc" id="L275">    }</span>

    protected void decrIndentation() {
<span class="nc" id="L278">        this.indentation -= 1;</span>
<span class="nc" id="L279">        this.indent.delete(0, INDENT.length());</span>
<span class="nc" id="L280">    }</span>

    protected void indent() {
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if ( this.indentation &lt;= 0 ) {</span>
<span class="nc" id="L284">            return;</span>
        } else {
<span class="nc bnc" id="L286" title="All 2 branches missed.">            for ( int i = 0; i &lt; this.indentation; i++ ) {</span>
<span class="nc" id="L287">                this.sb.append(INDENT);</span>
            }
        }
<span class="nc" id="L290">    }</span>

    public void nlIndent() {
<span class="nc" id="L293">        this.sb.append(&quot;\n&quot;).append(this.indent);</span>
<span class="nc" id="L294">    }</span>

    protected boolean isInteger(String str) {
        try {
<span class="nc" id="L298">            Integer.parseInt(str); //NOSONAR : her it is checked if the string is a parseable Integer. Result is NOT used.</span>
<span class="nc" id="L299">            return true;</span>
<span class="nc" id="L300">        } catch ( NumberFormatException e ) {</span>
<span class="nc" id="L301">            return false;</span>
        }
    }

    protected void increaseLoopCounter() {
<span class="nc" id="L306">        this.loopCounter++;</span>
<span class="nc" id="L307">        this.currenLoop.add(this.loopCounter);</span>
<span class="nc" id="L308">    }</span>

    protected String whitespace() {
<span class="nc" id="L311">        return &quot; &quot;;</span>
    }

    protected String getEnumCode(IMode value) {
<span class="nc" id="L315">        return value.getClass().getSimpleName() + &quot;.&quot; + value;</span>
    }

    protected boolean isMainBlock(Phrase&lt;Void&gt; phrase) {
<span class="nc" id="L319">        return phrase.getKind().getName().equals(&quot;MAIN_TASK&quot;);</span>
    }

    protected boolean parenthesesCheck(Binary&lt;Void&gt; binary) {
<span class="nc bnc" id="L323" title="All 6 branches missed.">        return binary.getOp() == Op.MINUS &amp;&amp; binary.getRight().getKind().hasName(&quot;BINARY&quot;) &amp;&amp; binary.getRight().getPrecedence() &lt;= binary.getPrecedence();</span>
    }

    protected void generateSubExpr(StringBuilder sb, boolean minusAdaption, Expr&lt;Void&gt; expr, Binary&lt;Void&gt; binary) {
<span class="nc bnc" id="L327" title="All 6 branches missed.">        if ( expr.getPrecedence() &gt;= binary.getPrecedence() &amp;&amp; !minusAdaption &amp;&amp; !expr.getKind().hasName(&quot;BINARY&quot;) ) {</span>
            // parentheses are omitted
<span class="nc" id="L329">            expr.visit(this);</span>
        } else {
<span class="nc" id="L331">            sb.append(&quot;(&quot; + whitespace());</span>
<span class="nc" id="L332">            expr.visit(this);</span>
<span class="nc" id="L333">            sb.append(whitespace() + &quot;)&quot;);</span>
        }
<span class="nc" id="L335">    }</span>

    abstract protected String getLanguageVarTypeFromBlocklyType(BlocklyType type);

    abstract protected void generateCodeFromTernary(IfStmt&lt;Void&gt; ifStmt);

    abstract protected void generateCodeFromIfElse(IfStmt&lt;Void&gt; ifStmt);

    abstract protected void generateCodeFromElse(IfStmt&lt;Void&gt; ifStmt);

    abstract protected void generateProgramPrefix(boolean withWrapping);

    abstract protected void generateProgramSuffix(boolean withWrapping);

    abstract protected String getBinaryOperatorSymbol(Binary.Op op);

    abstract protected String getUnaryOperatorSymbol(Unary.Op op);

    protected static &lt;K, V&gt; Map.Entry&lt;K, V&gt; entry(K key, V value) {
<span class="nc" id="L354">        return new AbstractMap.SimpleEntry&lt;&gt;(key, value);</span>
    }

    protected static &lt;K, U&gt; Collector&lt;Map.Entry&lt;K, U&gt;, ?, Map&lt;K, U&gt;&gt; entriesToMap() {
<span class="nc" id="L358">        return Collectors.toMap((e) -&gt; e.getKey(), (e) -&gt; e.getValue());</span>
    }

    protected static &lt;K, U&gt; Collector&lt;Map.Entry&lt;K, U&gt;, ?, ConcurrentMap&lt;K, U&gt;&gt; entriesToConcurrentMap() {
<span class="nc" id="L362">        return Collectors.toConcurrentMap((e) -&gt; e.getKey(), (e) -&gt; e.getValue());</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>