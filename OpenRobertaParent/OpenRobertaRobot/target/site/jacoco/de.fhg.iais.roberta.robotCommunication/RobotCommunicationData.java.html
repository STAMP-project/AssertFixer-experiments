<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RobotCommunicationData.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenRobertaRobot</a> &gt; <a href="index.source.html" class="el_package">de.fhg.iais.roberta.robotCommunication</a> &gt; <span class="el_source">RobotCommunicationData.java</span></div><h1>RobotCommunicationData.java</h1><pre class="source lang-java linenums">package de.fhg.iais.roberta.robotCommunication;

import org.codehaus.jettison.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import de.fhg.iais.roberta.util.Clock;

/**
 * This class is responsible for the synchronisation between the one browser client and one robot. The synchronisation is based on a agreed upon token. This
 * token is stored redundantly in objects of this class.&lt;br&gt;
 * As no push technology to the robot is available, the robot issues a push request command, the thread acting upon this request is frozen and waits until the
 * user has issued a command in the browser (in most cases a run) or a timer expires . This unfreezes the thread and the responses tells the robot what to do.
 * E.g. if a run command has been issued, the already generated jar is requested to be downloaded to the robot.&lt;br&gt;
 * &lt;br&gt;
 * TODO: This implementation is resource intensive as it freezes an expensive resource, namely a thread. It should be replaced later by async technology.
 *
 * @author rbudde
 */
public class RobotCommunicationData {
<span class="fc" id="L21">    private static final Logger LOG = LoggerFactory.getLogger(RobotCommunicationData.class);</span>
    private static final int TIMEOUT_UNTIL_TOKEN_EXPIRES_WHEN_USER_DOESNT_APPROVE = 300000;
    private static final int WAIT_FOR_A_ROBOT_PUSH_COMMAND = 1000;
    private static final int TIMEOUT_UNTIL_ASSUME_DISCONNECTED_IF_ROBOT_DOESNT_PUSH = 10000;

    private final String token;
    private final String robot;
    private final String robotIdentificator;
    private final String robotName;
    private final String menuversion;
    private final String runtimeversion;
    private final String firmwarename;
    private final String firmwareversion;
    private JSONObject sensorvalues;
    private int nepoExitValue;

    private Clock timerStartedByLastRequest;
    private Clock timerStartedByTokenApproval;
    private State state;

    private String battery;

    private String command;
    private String programName;

    public RobotCommunicationData(
        String token,
        String robot,
        String robotIdentificator,
        String robotName,
        String battery,
        String menuversion,
        String runtimeveriosn,
        String firmwarename,
<span class="fc" id="L55">        String firmwareversion) {</span>
        // the per session token
<span class="fc" id="L57">        this.token = token;</span>
        // the robot group, such as 'ev3' ...
<span class="fc" id="L59">        this.robot = robot;</span>
<span class="fc" id="L60">        this.robotIdentificator = robotIdentificator;</span>
        // the name of the robot, can be changed by the user in some cases
<span class="fc" id="L62">        this.robotName = robotName;</span>
<span class="fc" id="L63">        this.battery = battery;</span>
<span class="fc" id="L64">        this.menuversion = menuversion;</span>
<span class="fc" id="L65">        this.runtimeversion = runtimeveriosn;</span>
        // the robot variant, such as 'ev3dev' or 'lejos'
<span class="fc" id="L67">        this.firmwarename = firmwarename;</span>
        // informal robot firmware version details
<span class="fc" id="L69">        this.firmwareversion = firmwareversion;</span>
<span class="fc" id="L70">        this.sensorvalues = new JSONObject();</span>

<span class="fc" id="L72">        this.timerStartedByLastRequest = Clock.start();</span>
<span class="fc" id="L73">        this.state = State.WAIT_FOR_TOKENAPPROVAL_FROM_USER;</span>
<span class="fc" id="L74">    }</span>

    /**
     * method called from a thread, which is triggered by a robot request. This method blocks until the user has approved the robot token or a timeout occurs.
     *
     * @return true, if user approved the token; false otherwise
     */
    public synchronized boolean robotTokenAgreementRequest() {
<span class="nc" id="L82">        LOG.info(&quot;Robot [&quot; + this.robotIdentificator + &quot;] token &quot; + this.token + &quot; starts waiting for the client to approve the token&quot;);</span>
<span class="nc" id="L83">        this.state = State.WAIT_FOR_TOKENAPPROVAL_FROM_USER;</span>
<span class="nc" id="L84">        this.timerStartedByLastRequest = Clock.start();</span>
<span class="nc bnc" id="L85" title="All 4 branches missed.">        while ( this.timerStartedByLastRequest.elapsedMsec() &lt; TIMEOUT_UNTIL_TOKEN_EXPIRES_WHEN_USER_DOESNT_APPROVE</span>
            &amp;&amp; this.state == State.WAIT_FOR_TOKENAPPROVAL_FROM_USER ) //
        {
            try {
<span class="nc" id="L89">                wait(TIMEOUT_UNTIL_TOKEN_EXPIRES_WHEN_USER_DOESNT_APPROVE);</span>
<span class="nc" id="L90">            } catch ( InterruptedException e ) { //NOSONAR : repeat the loop until timer elapses or another thread changed the state</span>
<span class="nc" id="L91">            }</span>
        }
<span class="nc bnc" id="L93" title="All 2 branches missed.">        if ( this.state == State.WAIT_FOR_PUSH_CMD_FROM_ROBOT ) {</span>
<span class="nc" id="L94">            LOG.info(&quot;Robot [&quot; + this.robotIdentificator + &quot;] token &quot; + this.token + &quot; approval terminated SUCCESSFULLY.&quot;);</span>
<span class="nc" id="L95">            return true;</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">        } else if ( this.state == State.GARBAGE ) {</span>
<span class="nc" id="L97">            LOG.info(</span>
                &quot;Robot [&quot;
                    + this.robotIdentificator
                    + &quot;] token &quot;
                    + this.token
                    + &quot; was disconnected. The request is aborted. Time elapsed: &quot;
<span class="nc" id="L103">                    + this.timerStartedByLastRequest.elapsedMsecFormatted());</span>
<span class="nc" id="L104">            return false;</span>
        } else {
<span class="nc" id="L106">            this.state = State.GARBAGE;</span>
<span class="nc" id="L107">            LOG.info(</span>
                &quot;Robot [&quot;
                    + this.robotIdentificator
                    + &quot;] token &quot;
                    + this.token
                    + &quot; approval FAILED. The robot is disconnected. Time elapsed: &quot;
<span class="nc" id="L113">                    + this.timerStartedByLastRequest.elapsedMsecFormatted());</span>
<span class="nc" id="L114">            return false;</span>
        }
    }

    /**
     * method called from a server thread. This method terminates immediately and wakes up the thread, which runs on behalf of a token approval request from the
     * robot.
     */
    public synchronized void userApprovedTheRobotToken() {
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if ( this.state == State.WAIT_FOR_TOKENAPPROVAL_FROM_USER ) {</span>
<span class="nc" id="L124">            LOG.info(&quot;user approved the token. The approval request was scheduled &quot; + this.timerStartedByLastRequest.elapsedSecFormatted() + &quot; ago&quot;);</span>
<span class="nc" id="L125">            this.state = State.WAIT_FOR_PUSH_CMD_FROM_ROBOT;</span>
<span class="nc" id="L126">            this.timerStartedByLastRequest = Clock.start();</span>
<span class="nc" id="L127">            this.timerStartedByTokenApproval = Clock.start();</span>
<span class="nc" id="L128">            notifyAll();</span>
        } else {
<span class="nc" id="L130">            LOG.info(</span>
<span class="nc" id="L131">                &quot;user approval lost. Nobody is waiting. The approval request was scheduled &quot; + this.timerStartedByLastRequest.elapsedSecFormatted() + &quot; ago&quot;);</span>
        }
<span class="nc" id="L133">    }</span>

    /**
     * method called from a thread, which is triggered by a ROBOT push command request. This method blocks until either the server issues a push command or a
     * timer thread triggers a timeout.
     *
     * @return true, if user approved the token; false otherwise
     */
    public synchronized void robotHasSentAPushRequest() {
<span class="nc bnc" id="L142" title="All 2 branches missed.">        if ( this.state == State.WAIT_FOR_TOKENAPPROVAL_FROM_USER ) {</span>
<span class="nc" id="L143">            LOG.error(</span>
                &quot;Robot has sent a push request, but the server waits for a token approval by an user. The request ist ignored. &quot;
                    + &quot;Waiting started &quot;
<span class="nc" id="L146">                    + this.timerStartedByLastRequest.elapsedSecFormatted()</span>
                    + &quot; ago. &quot;);
        } else {
<span class="nc bnc" id="L149" title="All 4 branches missed.">            if ( this.state != State.WAIT_FOR_PUSH_CMD_FROM_ROBOT &amp;&amp; this.state != State.ROBOT_IS_BUSY ) {</span>
<span class="nc" id="L150">                LOG.error(</span>
                    &quot;Robot has sent a push request not awaited for. Programming error: Logic or Time race? The request is ACCEPTED. State is &quot;
                        + this.state
                        + &quot;. The state setting request was scheduled &quot;
<span class="nc" id="L154">                        + this.timerStartedByLastRequest.elapsedSecFormatted()</span>
                        + &quot; ago. &quot;);
            }
<span class="nc" id="L157">            this.state = State.ROBOT_WAITING_FOR_PUSH_FROM_SERVER;</span>
<span class="nc" id="L158">            this.timerStartedByLastRequest = Clock.start();</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">            while ( this.state == State.ROBOT_WAITING_FOR_PUSH_FROM_SERVER ) {</span>
                try {
<span class="nc" id="L161">                    wait();</span>
<span class="nc" id="L162">                } catch ( InterruptedException e ) { //NOSONAR : repeat the loop until another thread changed the state</span>
<span class="nc" id="L163">                }</span>
            }
        }
<span class="nc" id="L166">        LOG.debug(&quot;ROBOT push request terminated.&quot;);</span>
<span class="nc" id="L167">    }</span>

    /**
     * this object is outdated. This method is called to abort an eventually pending request from a robot should be aborted. The notifyAll is for that. This
     * object will be removed from the map holding all valid robot-server connection. The state is set to GARBAGE to express that.
     */
    public synchronized void abortPush() {
<span class="fc" id="L174">        this.state = State.GARBAGE;</span>
<span class="fc" id="L175">        notifyAll();</span>
<span class="fc" id="L176">    }</span>

    /**
     * method called from a timer thread. This method terminates immediately and wakes up a waiting thread, which runs on behalf of a push command from the
     * robot.
     */
    public synchronized void terminatePushAndRequestNextPush() {
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if ( this.state == State.ROBOT_WAITING_FOR_PUSH_FROM_SERVER ) {</span>
<span class="nc" id="L184">            this.state = State.WAIT_FOR_PUSH_CMD_FROM_ROBOT;</span>
<span class="nc" id="L185">            this.command = &quot;repeat&quot;;</span>
<span class="nc" id="L186">            this.timerStartedByLastRequest = Clock.start();</span>
<span class="nc" id="L187">            notifyAll();</span>
        }
<span class="nc" id="L189">    }</span>

    /**
     * method called from a server thread. This method terminates immediately (if the robot waits for a push command) or after 1 sec (if we expect a push
     * command in the very near future. It wakes up the thread, which runs on behalf of a push command request from the robot.
     *
     * @return true, if the robot was waiting for a &quot;run&quot; command, false otherwise
     */
    public synchronized boolean runButtonPressed(String programName) {
<span class="nc bnc" id="L198" title="All 2 branches missed.">        if ( !isRobotWaitingForPushCommand() ) {</span>
<span class="nc" id="L199">            LOG.error(&quot;RUN button pressed, but robot is not waiting for that event. Bad luck!&quot;);</span>
<span class="nc" id="L200">            return false;</span>
        } else {
<span class="nc" id="L202">            LOG.info(</span>
<span class="nc" id="L203">                &quot;RUN button pressed and robot is waiting for that event. Wait state entered &quot; + this.timerStartedByLastRequest.elapsedSecFormatted() + &quot; ago&quot;);</span>
<span class="nc" id="L204">            this.command = &quot;download&quot;;</span>
<span class="nc" id="L205">            this.programName = programName;</span>
<span class="nc" id="L206">            this.timerStartedByLastRequest = Clock.start();</span>
<span class="nc" id="L207">            this.state = State.ROBOT_IS_BUSY;</span>
<span class="nc" id="L208">            notifyAll();</span>
<span class="nc" id="L209">            return true;</span>
        }
    }

    /**
     * method called from a server thread. This method terminates immediately (if the robot waits for a push command) or after 1 sec (if we expect a push
     * command in the very near future. It wakes up the thread, which runs on behalf of a push command request from the robot.
     *
     * @return the state of the robot
     */
    public synchronized boolean firmwareUpdate() {
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if ( !isRobotWaitingForPushCommand() ) {</span>
<span class="nc" id="L221">            LOG.error(&quot;UPDATE button pressed, but the robot is not waiting. Bad luck!&quot;);</span>
<span class="nc" id="L222">            return false;</span>
        } else {
<span class="nc" id="L224">            LOG.debug(&quot;UPDATE button pressed. Wait state entered &quot; + this.timerStartedByLastRequest.elapsedSecFormatted() + &quot; ago&quot;);</span>
<span class="nc" id="L225">            this.command = &quot;update&quot;;</span>
<span class="nc" id="L226">            this.timerStartedByLastRequest = Clock.start();</span>

            // the robot is disconnected after firmware update
<span class="nc" id="L229">            abortPush();</span>
<span class="nc" id="L230">            return true;</span>
        }
    }

    private boolean isRobotWaitingForPushCommand() {
<span class="nc bnc" id="L235" title="All 2 branches missed.">        if ( this.state == State.WAIT_FOR_PUSH_CMD_FROM_ROBOT ) {</span>
            try {
<span class="nc" id="L237">                Thread.sleep(WAIT_FOR_A_ROBOT_PUSH_COMMAND);</span>
<span class="nc" id="L238">            } catch ( InterruptedException e ) { //NOSONAR : expect, that the robot is waiting for a server push</span>
<span class="nc" id="L239">            }</span>
        }
<span class="nc bnc" id="L241" title="All 2 branches missed.">        return this.state == State.ROBOT_WAITING_FOR_PUSH_FROM_SERVER;</span>
    }

    /**
     * return true, if the robot is probably disconnected. But the robot may reconnect in the future (if USB cable is plugged in, for instance)
     *
     * @return true, if the robot didn't send a push command within a reasonable long interval after being requested to do so
     */
    public boolean isRobotProbablyDisconnected() {
<span class="nc bnc" id="L250" title="All 2 branches missed.">        return this.state == State.WAIT_FOR_PUSH_CMD_FROM_ROBOT</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            &amp;&amp; getElapsedMsecOfStartOfLastRequest() &gt; TIMEOUT_UNTIL_ASSUME_DISCONNECTED_IF_ROBOT_DOESNT_PUSH;</span>
    }

    public String getToken() {
<span class="fc" id="L255">        return this.token;</span>
    }

    public String getRobot() {
<span class="nc" id="L259">        return this.robot;</span>
    }

    public String getRobotIdentificator() {
<span class="fc" id="L263">        return this.robotIdentificator;</span>
    }

    public String getRobotName() {
<span class="nc" id="L267">        return this.robotName;</span>
    }

    public String getBattery() {
<span class="nc" id="L271">        return this.battery;</span>
    }

    public void setBattery(String battery) {
<span class="nc" id="L275">        this.battery = battery;</span>
<span class="nc" id="L276">    }</span>

    public void setSensorValues(JSONObject sensorvalues) {
<span class="nc" id="L279">        this.sensorvalues = sensorvalues;</span>
<span class="nc" id="L280">    }</span>

    public void setNepoExitValue(int nepoExitValue) {
<span class="nc" id="L283">        this.nepoExitValue = nepoExitValue;</span>
<span class="nc" id="L284">    }</span>

    public String getCommand() {
<span class="nc" id="L287">        return this.command;</span>
    }

    public String getProgramName() {
<span class="nc" id="L291">        return this.programName;</span>
    }

    public long getElapsedMsecOfStartOfLastRequest() {
<span class="nc" id="L295">        return this.timerStartedByLastRequest.elapsedMsec();</span>
    }

    public long getRobotConnectionTime() {
<span class="nc" id="L299">        return this.timerStartedByTokenApproval.elapsedMsec();</span>
    }

    public String getMenuVersion() {
<span class="nc" id="L303">        return this.menuversion;</span>
    }

    public State getState() {
<span class="nc" id="L307">        return this.state;</span>
    }

    public String getFirmwareName() {
<span class="nc" id="L311">        return this.firmwarename;</span>
    }

    public String getFirmwareVersion() {
<span class="nc" id="L315">        return this.firmwareversion;</span>
    }

    public String getRuntimeVersion() {
<span class="nc" id="L319">        return runtimeversion;</span>
    }

    public JSONObject getSensorValues() {
<span class="nc" id="L323">        return this.sensorvalues;</span>
    }

    public int getNepoExitValue() {
<span class="nc" id="L327">        return this.nepoExitValue;</span>
    }

    /**
     * the states of communication between the robot and the browser client.
     */
<span class="pc" id="L333">    public enum State {</span>
<span class="fc" id="L334">        WAIT_FOR_TOKENAPPROVAL_FROM_USER, WAIT_FOR_PUSH_CMD_FROM_ROBOT, ROBOT_WAITING_FOR_PUSH_FROM_SERVER, ROBOT_IS_BUSY, GARBAGE;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>