<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>IRobotFactory.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenRobertaRobot</a> &gt; <a href="index.source.html" class="el_package">de.fhg.iais.roberta.factory</a> &gt; <span class="el_source">IRobotFactory.java</span></div><h1>IRobotFactory.java</h1><pre class="source lang-java linenums">package de.fhg.iais.roberta.factory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;

import com.google.inject.AbstractModule;

import de.fhg.iais.roberta.components.Configuration;
import de.fhg.iais.roberta.inter.mode.action.IActorPort;
import de.fhg.iais.roberta.inter.mode.action.IBrickLedColor;
import de.fhg.iais.roberta.inter.mode.action.IDriveDirection;
import de.fhg.iais.roberta.inter.mode.action.ILanguage;
import de.fhg.iais.roberta.inter.mode.action.ILightMode;
import de.fhg.iais.roberta.inter.mode.action.IMotorMoveMode;
import de.fhg.iais.roberta.inter.mode.action.IMotorSide;
import de.fhg.iais.roberta.inter.mode.action.IMotorStopMode;
import de.fhg.iais.roberta.inter.mode.action.IRelayMode;
import de.fhg.iais.roberta.inter.mode.action.IShowPicture;
import de.fhg.iais.roberta.inter.mode.action.ITurnDirection;
import de.fhg.iais.roberta.inter.mode.general.IDirection;
import de.fhg.iais.roberta.inter.mode.general.IIndexLocation;
import de.fhg.iais.roberta.inter.mode.general.IListElementOperations;
import de.fhg.iais.roberta.inter.mode.general.IMode;
import de.fhg.iais.roberta.inter.mode.general.IPickColor;
import de.fhg.iais.roberta.inter.mode.general.IWorkingState;
import de.fhg.iais.roberta.inter.mode.sensor.IBirckKeyPressMode;
import de.fhg.iais.roberta.inter.mode.sensor.IBrickKey;
import de.fhg.iais.roberta.inter.mode.sensor.IColorSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.ICompassSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.ICoordinatesMode;
import de.fhg.iais.roberta.inter.mode.sensor.IDropSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.IGestureSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.IGyroSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.IHumiditySensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.IIRSeekerSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.IInfraredSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.IJoystickMode;
import de.fhg.iais.roberta.inter.mode.sensor.ILightSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.IMoistureSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.IMotionSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.IMotorTachoMode;
import de.fhg.iais.roberta.inter.mode.sensor.IPinPull;
import de.fhg.iais.roberta.inter.mode.sensor.IPinValue;
import de.fhg.iais.roberta.inter.mode.sensor.IPulseSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.IRSeekerSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.IRfidSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.ISensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.ISensorPort;
import de.fhg.iais.roberta.inter.mode.sensor.ISlot;
import de.fhg.iais.roberta.inter.mode.sensor.ISoundSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.ITemperatureSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.ITimerSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.ITouchSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.IUltrasonicSensorMode;
import de.fhg.iais.roberta.inter.mode.sensor.IVoltageSensorMode;
import de.fhg.iais.roberta.mode.action.ActorPort;
import de.fhg.iais.roberta.mode.action.BrickLedColor;
import de.fhg.iais.roberta.mode.action.DriveDirection;
import de.fhg.iais.roberta.mode.action.Language;
import de.fhg.iais.roberta.mode.action.LightMode;
import de.fhg.iais.roberta.mode.action.MotorMoveMode;
import de.fhg.iais.roberta.mode.action.MotorSide;
import de.fhg.iais.roberta.mode.action.MotorStopMode;
import de.fhg.iais.roberta.mode.action.RelayMode;
import de.fhg.iais.roberta.mode.action.TurnDirection;
import de.fhg.iais.roberta.mode.general.Direction;
import de.fhg.iais.roberta.mode.general.IndexLocation;
import de.fhg.iais.roberta.mode.general.ListElementOperations;
import de.fhg.iais.roberta.mode.general.PickColor;
import de.fhg.iais.roberta.mode.general.PlaceholderSensorMode;
import de.fhg.iais.roberta.mode.general.WorkingState;
import de.fhg.iais.roberta.mode.sensor.Axis;
import de.fhg.iais.roberta.mode.sensor.BrickKeyPressMode;
import de.fhg.iais.roberta.mode.sensor.ColorSensorMode;
import de.fhg.iais.roberta.mode.sensor.CompassSensorMode;
import de.fhg.iais.roberta.mode.sensor.DropSensorMode;
import de.fhg.iais.roberta.mode.sensor.GestureSensorMode;
import de.fhg.iais.roberta.mode.sensor.GyroSensorMode;
import de.fhg.iais.roberta.mode.sensor.HumiditySensorMode;
import de.fhg.iais.roberta.mode.sensor.InfraredSensorMode;
import de.fhg.iais.roberta.mode.sensor.LightSensorMode;
import de.fhg.iais.roberta.mode.sensor.MoistureSensorMode;
import de.fhg.iais.roberta.mode.sensor.MotionSensorMode;
import de.fhg.iais.roberta.mode.sensor.MotorTachoMode;
import de.fhg.iais.roberta.mode.sensor.PinPull;
import de.fhg.iais.roberta.mode.sensor.PinValue;
import de.fhg.iais.roberta.mode.sensor.PulseSensorMode;
import de.fhg.iais.roberta.mode.sensor.RfidSensorMode;
import de.fhg.iais.roberta.mode.sensor.SensorPort;
import de.fhg.iais.roberta.mode.sensor.Slot;
import de.fhg.iais.roberta.mode.sensor.SoundSensorMode;
import de.fhg.iais.roberta.mode.sensor.TemperatureSensorMode;
import de.fhg.iais.roberta.mode.sensor.TimerSensorMode;
import de.fhg.iais.roberta.mode.sensor.TouchSensorMode;
import de.fhg.iais.roberta.mode.sensor.UltrasonicSensorMode;
import de.fhg.iais.roberta.mode.sensor.VoltageSensorMode;
import de.fhg.iais.roberta.syntax.BlocklyBlockProperties;
import de.fhg.iais.roberta.syntax.BlocklyComment;
import de.fhg.iais.roberta.syntax.BlocklyConstants;
import de.fhg.iais.roberta.syntax.Phrase;
import de.fhg.iais.roberta.syntax.check.program.RobotCommonCheckVisitor;
import de.fhg.iais.roberta.syntax.check.program.RobotSimulationCheckVisitor;
import de.fhg.iais.roberta.syntax.sensor.GetSampleType;
import de.fhg.iais.roberta.syntax.sensor.Sensor;
import de.fhg.iais.roberta.syntax.sensor.SensorMetaDataBean;
import de.fhg.iais.roberta.syntax.sensor.generic.AccelerometerSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.BrickSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.ColorSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.CompassSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.DropSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.EncoderSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.GestureSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.GyroSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.HumiditySensor;
import de.fhg.iais.roberta.syntax.sensor.generic.InfraredSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.LightSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.MoistureSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.MotionSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.PinGetValueSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.PinTouchSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.PulseSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.RfidSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.SoundSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.TemperatureSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.TimerSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.TouchSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.UltrasonicSensor;
import de.fhg.iais.roberta.syntax.sensor.generic.VoltageSensor;
import de.fhg.iais.roberta.util.dbc.DbcException;

public interface IRobotFactory {

    static &lt;E extends IMode&gt; E getModeValue(String modeName, Class&lt;E&gt; modes) {
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">        if ( modeName == null ) {</span>
<span class="nc" id="L139">            throw new DbcException(&quot;Invalid &quot; + modes.getName() + &quot;: &quot; + modeName);</span>
        }
<span class="fc" id="L141">        final String sUpper = modeName.trim().toUpperCase(Locale.GERMAN);</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        for ( final E mode : modes.getEnumConstants() ) {</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">            if ( mode.toString().equals(sUpper) ) {</span>
<span class="fc" id="L144">                return mode;</span>
            }
<span class="fc bfc" id="L146" title="All 2 branches covered.">            for ( final String value : mode.getValues() ) {</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">                if ( sUpper.equals(value.toUpperCase()) ) {</span>
<span class="fc" id="L148">                    return mode;</span>
                }
            }
        }
<span class="nc" id="L152">        throw new DbcException(&quot;Invalid &quot; + modes.getName() + &quot;: &quot; + modeName);</span>
    }

    static Map&lt;String, SensorPort&gt; getSensorPortsFromProperties(Properties properties) {
<span class="fc" id="L156">        Map&lt;String, SensorPort&gt; sensorToPorts = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        for ( Entry&lt;Object, Object&gt; property : properties.entrySet() ) {</span>
<span class="fc" id="L158">            SensorPort sensorPort = new SensorPort((String) property.getKey(), (String) property.getValue());</span>
<span class="fc" id="L159">            sensorToPorts.put((String) property.getKey(), sensorPort);</span>
<span class="fc" id="L160">        }</span>
<span class="fc" id="L161">        return sensorToPorts;</span>
    }

    /**
     * Get a sensor port from {@link ISensorPort} given string parameter and mapping from a port to SensorPort. It is possible for one sensor port to have
     * multiple string mappings. Throws exception if the sensor port does not exists. &lt;br&gt;
     * It can only be used by subclasses of IRobotFactory.
     *
     * @param name of the sensor port
     * @param port-SensorPort map
     * @return SensorPort {@link ISensorPort}
     */
    default ISensorPort getSensorPortValue(String port, Map&lt;String, SensorPort&gt; sensorToPorts) {
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        if ( port == null ) {</span>
<span class="nc" id="L175">            throw new DbcException(&quot;Null sensor port!&quot;);</span>
        }
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if ( port.isEmpty() ) {</span>
<span class="nc" id="L178">            return sensorToPorts.get(&quot;NO_PORT&quot;);</span>
        }
<span class="fc" id="L180">        final String sUpper = port.trim().toUpperCase(Locale.GERMAN);</span>
<span class="fc" id="L181">        SensorPort sensorPort = sensorToPorts.get(sUpper);</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">        if ( sensorPort != null ) {</span>
<span class="fc" id="L183">            return sensorPort;</span>
        }
<span class="nc" id="L185">        sensorPort = sensorToPorts.get(port);</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if ( sensorPort != null ) {</span>
<span class="nc" id="L187">            return sensorPort;</span>
        }
<span class="nc bnc" id="L189" title="All 2 branches missed.">        for ( Map.Entry&lt;String, SensorPort&gt; portName : sensorToPorts.entrySet() ) {</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">            if ( portName.getValue().getCodeName().equals(port) ) {</span>
<span class="nc" id="L191">                return portName.getValue();</span>
            }
<span class="nc" id="L193">        }</span>
<span class="nc" id="L194">        throw new DbcException(&quot;Invalid sensor port: &quot; + port);</span>
    }

    /**
     * Get a sensor port from {@link ISensorPort} given its name as a string parameter. It is possible for one sensor port to have
     * multiple
     * string mappings. Throws exception
     * if the sensor port does not exists.
     *
     * @param port name of the sensor
     * @return SensorPort {@link ISensorPort}
     */
    ISensorPort getSensorPort(String port);

    static Map&lt;String, ActorPort&gt; getActorPortsFromProperties(Properties properties) {
<span class="nc" id="L209">        Map&lt;String, ActorPort&gt; actorToPorts = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        for ( Entry&lt;Object, Object&gt; property : properties.entrySet() ) {</span>
<span class="nc" id="L211">            ActorPort actorPort = new ActorPort((String) property.getKey(), (String) property.getValue());</span>
<span class="nc" id="L212">            actorToPorts.put((String) property.getKey(), actorPort);</span>
<span class="nc" id="L213">        }</span>
<span class="nc" id="L214">        return actorToPorts;</span>
    }

    /**
     * Get a actor port from {@link IActorPort} given string parameter and mapping from a port to ActorPort. It is possible for one sensor port to have
     * multiple string mappings. Throws exception if the sensor port does not exists. &lt;br&gt;
     * It can only be used by subclasses of IRobotFactory.
     *
     * @param name of the sensor port
     * @param port-ActorPort map
     * @return ActorPort {@link IActorPort}
     */
    default IActorPort getActorPortValue(String port, Map&lt;String, ActorPort&gt; actorToPorts) {
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if ( port == null ) {</span>
<span class="nc" id="L228">            throw new DbcException(&quot;Null actor port!&quot;);</span>
        }
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if ( port.isEmpty() ) {</span>
<span class="nc" id="L231">            return actorToPorts.get(&quot;NO_PORT&quot;);</span>
        }
<span class="nc" id="L233">        final String sUpper = port.trim().toUpperCase(Locale.GERMAN);</span>
<span class="nc" id="L234">        ActorPort actorPort = actorToPorts.get(sUpper);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">        if ( actorPort != null ) {</span>
<span class="nc" id="L236">            return actorPort;</span>
        }
<span class="nc bnc" id="L238" title="All 2 branches missed.">        for ( Map.Entry&lt;String, ActorPort&gt; portName : actorToPorts.entrySet() ) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if ( portName.getValue().getCodeName().equals(port) ) {</span>
<span class="nc" id="L240">                return portName.getValue();</span>
            }
<span class="nc" id="L242">        }</span>
<span class="nc" id="L243">        throw new DbcException(&quot;Invalid actor port: &quot; + port);</span>
    }

    /**
     * Get actor port from {@link IActorPort} enumeration given string parameter. It is possible for actor port to have multiple string mappings. Throws
     * exception if the actor port does not exists.
     *
     * @param name of the actor port
     * @return actor port from the enum {@link IActorPort}
     */
    IActorPort getActorPort(String port);

    /**
     * Get index location enumeration from {@link IIndexLocation} given string parameter. It is possible for one index location to have multiple string
     * mappings. Throws exception if the operator does not exists.
     *
     * @param indexLocation of the function
     * @return index location from the enum {@link IIndexLocation}
     */
    default IIndexLocation getIndexLocation(String indexLocation) {
<span class="fc" id="L263">        return IRobotFactory.getModeValue(indexLocation, IndexLocation.class);</span>
    }

    /**
     * Direction in space enumeration from {@link IDirection} given string parameter. It is possible for one direction to have multiple string mappings. Throws
     * exception if the operator does not exists.
     *
     * @param direction of the function
     * @return direction location from the enum {@link IDirection}
     */
    default IDirection getDirection(String direction) {
<span class="nc" id="L274">        return IRobotFactory.getModeValue(direction, Direction.class);</span>
    }

    /**
     * Get array element operation enumeration from {@link IListElementOperations} given string parameter. It is possible for one operation to have multiple
     * string mappings. Throws exception if the operator does not exists.
     *
     * @param operation string name
     * @return operation from the enum {@link IListElementOperations}
     */
    default IListElementOperations getListElementOpertaion(String operation) {
<span class="fc" id="L285">        return IRobotFactory.getModeValue(operation, ListElementOperations.class);</span>
    }

    /**
     * Get a {@link IPickColor} enumeration given string parameter. It is possible for one color to have multiple string mappings. Throws exception if the color
     * cannot be found.
     *
     * @param name of the color
     * @return enum {@link IPickColor}
     */
    default IPickColor getPickColor(String color) {
<span class="fc" id="L296">        return IRobotFactory.getModeValue(color, PickColor.class);</span>
    }

    /**
     * Get a {@link IPickColor} enumeration given a color id.
     *
     * @param id of the color
     * @return enum {@link IPickColor}
     */
    default IPickColor getPickColor(int colorId) {
<span class="nc bnc" id="L306" title="All 2 branches missed.">        for ( final PickColor sp : PickColor.values() ) {</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">            if ( sp.getColorID() == colorId ) {</span>
<span class="nc" id="L308">                return sp;</span>
            }
        }
<span class="nc" id="L311">        throw new DbcException(&quot;Invalid color: &quot; + colorId);</span>
    }

    /**
     * Get a {@link ILightMode} enumeration given string parameter. It is possible for one mode to have multiple string mappings. Throws exception if the mode
     * does not exists.
     *
     * @param name of the mode
     * @return mode from the enum {@link LightMode}
     */
    default ILightMode getBlinkMode(String mode) {
<span class="nc" id="L322">        return IRobotFactory.getModeValue(mode, LightMode.class);</span>
    }

    /**
     * Get a {@link IBrickLedColor} enumeration given string parameter. It is possible for one mode to have multiple string mappings. Throws exception if the
     * mode does not exists.
     *
     * @param name of the mode
     * @return mode from the enum {@link ILightMode}
     */
    default IBrickLedColor getBrickLedColor(String mode) {
<span class="nc" id="L333">        return IRobotFactory.getModeValue(mode, BrickLedColor.class);</span>
    }

    /**
     * Get a {@link ISensorMode} enumeration given string parameter. It is possible for one color to have multiple string mappings. Throws exception if the
     * color
     * cannot be found.
     *
     * @param name of the color
     * @return enum {@link ISensorMode}
     */
    default ISensorMode getPlaceholderSensorMode(String color) {
<span class="nc" id="L345">        return IRobotFactory.getModeValue(color, PlaceholderSensorMode.class);</span>
    }

    /**
     * Get a {@link ILightSensorMode} enumeration given string parameter. It is possible for one mode to have multiple string mappings. Throws exception if the
     * mode does not exists.
     */
    default ILightSensorMode getLightColor(String mode) {
<span class="nc" id="L353">        return IRobotFactory.getModeValue(mode, LightSensorMode.class);</span>
    }

    default IWorkingState getWorkingState(String mode) {
<span class="nc" id="L357">        return IRobotFactory.getModeValue(mode, WorkingState.class);</span>
    }

    /**
     * Get a {@link IShowPicture} enumeration given string parameter. It is possible for one picture to have multiple string mappings. Throws exception if the
     * mode does not exists.
     *
     * @param name of the picture
     * @return picture from the enum {@link IShowPicture}
     */
    IShowPicture getShowPicture(String picture);

    /**
     * Get a {@link ITurnDirection} enumeration given string parameter. It is possible for one turn direction to have multiple string mappings. Throws exception
     * if the mode does not exists.
     *
     * @param name of the turn direction
     * @return turn direction from the enum {@link ITurnDirection}
     */
    default ITurnDirection getTurnDirection(String direction) {
<span class="nc" id="L377">        return IRobotFactory.getModeValue(direction, TurnDirection.class);</span>
    }

    /**
     * Get a {@link IMotorMoveMode} enumeration given string parameter. It is possible for one motor move mode to have multiple string mappings. Throws
     * exception if the mode does not exists.
     *
     * @param name of the motor move mode
     * @return motor move mode from the enum {@link IMotorMoveMode}
     */
    default IMotorMoveMode getMotorMoveMode(String mode) {
<span class="fc" id="L388">        return IRobotFactory.getModeValue(mode, MotorMoveMode.class);</span>
    }

    /**
     * Get stopping mode from {@link IMotorStopMode} from string parameter. It is possible for one stopping mode to have multiple string mappings. Throws
     * exception if the stopping mode does not exists.
     *
     * @param name of the stopping mode
     * @return name of the stopping mode from the enum {@link IMotorStopMode}
     */
    default IMotorStopMode getMotorStopMode(String mode) {
<span class="nc" id="L399">        return IRobotFactory.getModeValue(mode, MotorStopMode.class);</span>
    }

    /**
     * Get motor side from {@link IMotorSide} given string parameter. It is possible for one motor side to have multiple string mappings. Throws exception if
     * the motor side does not exists.
     *
     * @param name of the motor side
     * @return the motor side from the enum {@link IMotorSide}
     */
    default IMotorSide getMotorSide(String motorSide) {
<span class="nc" id="L410">        return IRobotFactory.getModeValue(motorSide, MotorSide.class);</span>
    }

    /**
     * Get drive direction from {@link IDriveDirection} given string parameter. It is possible for one drive direction to have multiple string mappings. Throws
     * exception if the motor side does not exists.
     *
     * @param name of the drive direction
     * @return the drive direction from the enum {@link IDriveDirection}
     */
    default IDriveDirection getDriveDirection(String driveDirection) {
<span class="fc" id="L421">        return IRobotFactory.getModeValue(driveDirection, DriveDirection.class);</span>
    }

    /**
     * Get relay mode {@link IRelayMode} given string parameter. Throws exception if the mode does not exists.
     *
     * @param name of the mode
     * @return the drelay mode from the enum {@link IRelayMode}
     */
    default IRelayMode getRelayMode(String relayMode) {
<span class="nc" id="L431">        return IRobotFactory.getModeValue(relayMode, RelayMode.class);</span>
    }

    /**
     * Get a robot key from {@link IBrickKey} given string parameter. It is possible for one robot key to have multiple string mappings. Throws exception if the
     * robot key does not exists.
     *
     * @param name of the robot key
     * @return the robot keys from the enum {@link IBrickKey}
     */
    default IBirckKeyPressMode getBrickKeyPressMode(String brickKey) {
<span class="nc" id="L442">        return IRobotFactory.getModeValue(brickKey, BrickKeyPressMode.class);</span>
    }

    /**
     * Get a color sensor mode from {@link IColorSensorMode} given string parameter. It is possible for one color sensor mode to have multiple string mappings.
     * Throws exception if the color sensor mode does not exists.
     *
     * @param name of the color sensor mode
     * @return the color sensor mode from the enum {@link IColorSensorMode}
     */
    default IColorSensorMode getColorSensorMode(String mode) {
<span class="nc" id="L453">        return IRobotFactory.getModeValue(mode, ColorSensorMode.class);</span>
    }

    default IJoystickMode getJoystickMode(String mode) {
<span class="nc" id="L457">        return IRobotFactory.getModeValue(mode, Axis.class);</span>
    }

    default ILightSensorMode getLightSensorMode(String mode) {
<span class="nc" id="L461">        return IRobotFactory.getModeValue(mode, LightSensorMode.class);</span>
    }

    default ICompassSensorMode getCompassSensorMode(String mode) {
<span class="nc" id="L465">        return IRobotFactory.getModeValue(mode, CompassSensorMode.class);</span>
    }

    default IPinValue getPinGetValueSensorMode(String mode) {
<span class="nc" id="L469">        return IRobotFactory.getModeValue(mode, PinValue.class);</span>
    }

    default IPinPull getPinPullMode(String mode) {
<span class="nc" id="L473">        return IRobotFactory.getModeValue(mode, PinPull.class);</span>
    }

    default ITemperatureSensorMode getTemperatureSensorMode(String mode) {
<span class="nc" id="L477">        return IRobotFactory.getModeValue(mode, TemperatureSensorMode.class);</span>
    }

    default ICoordinatesMode getAxis(String mode) {
<span class="nc" id="L481">        return IRobotFactory.getModeValue(mode, Axis.class);</span>
    }

    default ISoundSensorMode getSoundSensorMode(String mode) {
<span class="nc" id="L485">        return IRobotFactory.getModeValue(mode, SoundSensorMode.class);</span>
    }

    default ILanguage getLanguageMode(String mode) {
<span class="fc" id="L489">        return IRobotFactory.getModeValue(mode, Language.class);</span>
    }

    /**
     * Get a gyro sensor mode from {@link IGyroSensorMode} given string parameter. It is possible for one gyro sensor mode to have multiple string mappings.
     * Throws exception if the gyro sensor mode does not exists.
     *
     * @param name of the gyro sensor mode
     * @return the gyro sensor mode from the enum {@link IGyroSensorMode}
     */
    default IGyroSensorMode getGyroSensorMode(String mode) {
<span class="nc" id="L500">        return IRobotFactory.getModeValue(mode, GyroSensorMode.class);</span>
    }

    /**
     * Get a infrared sensor mode from {@link IInfraredSensorMode} given string parameter. It is possible for one infrared sensor mode to have multiple string
     * mappings. Throws exception if the infrared sensor mode does not exists.
     *
     * @param name of the infrared sensor mode
     * @return the infrared sensor mode from the enum {@link IInfraredSensorMode}
     */
    default IInfraredSensorMode getInfraredSensorMode(String mode) {
<span class="nc" id="L511">        return IRobotFactory.getModeValue(mode, InfraredSensorMode.class);</span>
    }

    /**
     * Get a IRSeeker sensor mode from {@link IIRSeekerSensorMode} given string parameter. It is possible for one IRSeeker sensor mode to have multiple string
     * mappings. Throws exception if the IRSeeker sensor mode does not exists.
     *
     * @param name of the IRSeeker sensor mode
     * @return the IRSeeker sensor mode from the enum {@link IRSeekerSensorMode}
     */
    default IRSeekerSensorMode getIRSeekerSensorMode(String mode) {
<span class="nc" id="L522">        return IRobotFactory.getModeValue(mode, IRSeekerSensorMode.class);</span>
    }

    /**
     * Get a timer sensor mode from {@link ITimerSensorMode} given string parameter. It is possible for one timer sensor mode to have multiple string mappings.
     * Throws exception if the timer sensor mode does not exists.
     *
     * @param name of the timer sensor mode
     * @return the timer sensor mode from the enum {@link ITimerSensorMode}
     */
    default ITimerSensorMode getTimerSensorMode(String modeName) {
<span class="nc" id="L533">        return IRobotFactory.getModeValue(modeName, TimerSensorMode.class);</span>
    }

    /**
     * Get a motor tacho sensor mode from {@link IMotorTachoMode} given string parameter. It is possible for one motor tacho sensor mode to have multiple string
     * mappings. Throws exception if the motor tacho sensor mode does not exists.
     *
     * @param name of the motor tacho sensor mode
     * @return the motor tacho sensor mode from the enum {@link IMotorTachoMode}
     */
    default IMotorTachoMode getMotorTachoMode(String mode) {
<span class="nc" id="L544">        return IRobotFactory.getModeValue(mode, MotorTachoMode.class);</span>
    }

    /**
     * Get a ultrasonic sensor mode from {@link IUltrasonicSensorMode} given string parameter. It is possible for one ultrasonic sensor mode to have multiple
     * string mappings. Throws exception if the ultrasonic sensor mode does not exists.
     *
     * @param name of the ultrasonic sensor mode
     * @return the ultrasonic sensor mode from the enum {@link IUltrasonicSensorMode}
     */
    default IUltrasonicSensorMode getUltrasonicSensorMode(String mode) {
<span class="nc" id="L555">        return IRobotFactory.getModeValue(mode, UltrasonicSensorMode.class);</span>
    }

    /**
     * Get a touch sensor mode from {@link ITouchSensorMode} given string parameter. It is possible for one touch sensor mode to have multiple string mappings.
     * Throws exception if the touch sensor mode does not exists.
     *
     * @param name of the touch sensor mode
     * @return the touch sensor mode from the enum {@link ITouchSensorMode}
     */
    default ITouchSensorMode getTouchSensorMode(String mode) {
<span class="fc" id="L566">        return IRobotFactory.getModeValue(mode, TouchSensorMode.class);</span>
    }

    /**
     * Get a voltage sensor mode from {@link IVoltageSensorMode} given string parameter. It is possible for one voltage sensor mode to have multiple string
     * mappings. Throws exception if the voltage sensor mode does not exists.
     *
     * @param name of the voltage sensor mode
     * @return the volatage sensor mode from the enum {@link IVoltageSensorMode}
     */
    default IVoltageSensorMode getVoltageSensorMode(String mode) {
<span class="nc" id="L577">        return IRobotFactory.getModeValue(mode, VoltageSensorMode.class);</span>
    }

    /**
     * Get a moisture sensor mode from {@link IMoistureSensorMode} given string parameter. It is possible for one motion sensor mode to have multiple string
     * mappings. Throws exception if the moisture sensor mode does not exists.
     *
     * @param name of the moisture sensor mode
     * @return the moisture sensor mode from the enum {@link IMoistureSensorMode}
     */
    default IMoistureSensorMode getMoistureSensorMode(String mode) {
<span class="nc" id="L588">        return IRobotFactory.getModeValue(mode, MoistureSensorMode.class);</span>
    }

    /**
     * Get a motion sensor mode from {@link IMoistureSensorMode} given string parameter. It is possible for one motion sensor mode to have multiple string
     * mappings. Throws exception if the motion sensor mode does not exists.
     *
     * @param name of the motion sensor mode
     * @return the motion sensor mode from the enum {@link IMoistureSensorMode}
     */
    default IMotionSensorMode getMotionSensorMode(String mode) {
<span class="nc" id="L599">        return IRobotFactory.getModeValue(mode, MotionSensorMode.class);</span>
    }

    /**
     * Get a motion sensor mode from {@link IHumiditySensorMode} given string parameter. It is possible for one humidity sensor mode to have multiple string
     * mappings. Throws exception if the humidity sensor mode does not exists.
     *
     * @param name of the humidity sensor mode
     * @return the motion sensor mode from the enum {@link IMoistureSensorMode}
     */
    default IHumiditySensorMode getHumiditySensorMode(String mode) {
<span class="nc" id="L610">        return IRobotFactory.getModeValue(mode, HumiditySensorMode.class);</span>
    }

    /**
     * Get a drop sensor mode from {@link IHumiditySensorMode} given string parameter.
     * It is possible for one drop sensor mode to have multiple string
     * mappings. Throws exception if the drop sensor mode does not exists.
     *
     * @param name of the drop sensor mode
     * @return the drop sensor mode from the enum {@link IHumiditySensorMode}
     */
    default IDropSensorMode getDropSensorMode(String mode) {
<span class="nc" id="L622">        return IRobotFactory.getModeValue(mode, DropSensorMode.class);</span>
    }

    /**
     * Get a pulse sensor mode from {@link IPulseSensorMode} given string parameter.
     * It is possible for one pulse sensor mode to have multiple string
     * mappings. Throws exception if the pulse sensor mode does not exists.
     *
     * @param name of the pulse sensor mode
     * @return the pulse sensor mode from the enum {@link IPulseSensorMode}
     */
    default IPulseSensorMode getPulseSensorMode(String mode) {
<span class="nc" id="L634">        return IRobotFactory.getModeValue(mode, PulseSensorMode.class);</span>
    }

    /**
     * Get a RFID sensor mode from {@link IRfidSensorMode} given string parameter.
     * It is possible for one RFID sensor mode to have multiple string
     * mappings. Throws exception if the RFID sensor mode does not exists.
     *
     * @param name of the RFID sensor mode
     * @return the RFID sensor mode from the enum {@link IDropSensorMode}
     */
    default IRfidSensorMode getRfidSensorMode(String mode) {
<span class="nc" id="L646">        return IRobotFactory.getModeValue(mode, RfidSensorMode.class);</span>
    }

    /**
     * Get a gesture sensor mode from {@link IGestureSensorMode} given string parameter. It is possible for one gesture sensor mode to have multiple string
     * mappings. Throws exception if the gesture sensor mode does not exists.
     *
     * @param name of the gesture sensor mode
     * @return the volatage sensor mode from the enum {@link IGestureSensorMode}
     */
    default IGestureSensorMode getGestureSensorMode(String mode) {
<span class="nc" id="L657">        return IRobotFactory.getModeValue(mode, GestureSensorMode.class);</span>
    }

    /**
     * Get a sensor port from {@link ISensorPort} given string parameter. It is possible for one sensor port to have multiple string mappings. Throws exception
     * if the sensor port does not exists.
     *
     * @param name of the sensor port
     * @return the sensor port from the enum {@link ISensorPort}
     */
    default ISlot getSlot(String slot) {
<span class="fc" id="L668">        return IRobotFactory.getModeValue(slot, Slot.class);</span>
    }

    /**
     * Creates an AST object representing sensor of specific type. If the type of the sensor does not exists it trows an exception.
     *
     * @param sensorType see {@link GetSampleType}
     * @param port on which the sensor is connected
     * @param slot on which the sensor is connected
     * @param properties of the block
     * @param comment of the block
     * @return returns instance of the specific sensor {@link Sensor}
     */
    default Sensor&lt;?&gt; createSensor(
        GetSampleType sensorType,
        String port,
        String slot,
        boolean isPortInMutation,
        BlocklyBlockProperties properties,
        BlocklyComment comment) {
        SensorMetaDataBean sensorMetaDataBean;
<span class="pc bpc" id="L689" title="103 of 106 branches missed.">        switch ( sensorType.getSensorType() ) {</span>
            case BlocklyConstants.TOUCH:
<span class="fc" id="L691">                sensorMetaDataBean = new SensorMetaDataBean(getSensorPort(port), getTouchSensorMode(&quot;TOUCH&quot;), getSlot(slot), isPortInMutation);</span>
<span class="fc" id="L692">                return TouchSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.PINTOUCH:
<span class="nc" id="L694">                sensorMetaDataBean = new SensorMetaDataBean(getSensorPort(port), getTouchSensorMode(&quot;PINTOUCH&quot;), getSlot(slot), isPortInMutation);</span>
<span class="nc" id="L695">                return PinTouchSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.ULTRASONIC:
<span class="nc" id="L697">                sensorMetaDataBean =</span>
<span class="nc" id="L698">                    new SensorMetaDataBean(getSensorPort(port), getUltrasonicSensorMode(sensorType.getSensorMode()), getSlot(slot), isPortInMutation);</span>
<span class="nc" id="L699">                return UltrasonicSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.COLOUR:
<span class="nc" id="L701">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L703">                        getSensorPort(port),</span>
<span class="nc" id="L704">                        getColorSensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L705">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L707">                return ColorSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.INFRARED:
<span class="nc" id="L709">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L711">                        getSensorPort(port),</span>
<span class="nc" id="L712">                        getInfraredSensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L713">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L715">                return InfraredSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.ENCODER:
<span class="nc" id="L717">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L719">                        getActorPort(port),</span>
<span class="nc" id="L720">                        getMotorTachoMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L721">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L723">                return EncoderSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.KEY_PRESSED:
<span class="nc" id="L725">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L727">                        getSensorPort(port),</span>
<span class="nc" id="L728">                        getBrickKeyPressMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L729">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L731">                return BrickSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.GYRO:
<span class="nc" id="L733">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L735">                        getSensorPort(port),</span>
<span class="nc" id="L736">                        getGyroSensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L737">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L739">                return GyroSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.TIME:
<span class="nc" id="L741">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L743">                        getSensorPort(port),</span>
<span class="nc" id="L744">                        getTimerSensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L745">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L747">                return TimerSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.SOUND:
<span class="nc" id="L749">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L751">                        getSensorPort(port),</span>
<span class="nc" id="L752">                        getSoundSensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L753">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L755">                return SoundSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.LIGHT_VALUE:
            case BlocklyConstants.LIGHT:
<span class="nc" id="L758">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L760">                        getSensorPort(port),</span>
<span class="nc" id="L761">                        getLightSensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L762">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L764">                return LightSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.COMPASS:
<span class="nc" id="L766">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L768">                        getSensorPort(port),</span>
<span class="nc" id="L769">                        getCompassSensorMode(BlocklyConstants.DEFAULT),</span>
<span class="nc" id="L770">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L772">                return CompassSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.TEMPERATURE:
<span class="nc" id="L774">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L776">                        getSensorPort(port),</span>
<span class="nc" id="L777">                        getTemperatureSensorMode(BlocklyConstants.DEFAULT),</span>
<span class="nc" id="L778">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L780">                return TemperatureSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.PIN_ANALOG:
            case BlocklyConstants.PIN_DIGITAL:
            case BlocklyConstants.PIN_PULSE_HIGH:
            case BlocklyConstants.PIN_PULSE_LOW:
<span class="nc" id="L785">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L787">                        getSensorPort(port),</span>
<span class="nc" id="L788">                        getPinGetValueSensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L789">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L791">                return PinGetValueSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.ACCELERATION:
<span class="nc" id="L793">                sensorMetaDataBean =</span>
<span class="nc" id="L794">                    new SensorMetaDataBean(getSensorPort(port), getAxis(BlocklyConstants.DEFAULT), getSlot(BlocklyConstants.EMPTY_SLOT), isPortInMutation);</span>
<span class="nc" id="L795">                return AccelerometerSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.GESTURE:
<span class="nc" id="L797">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L799">                        getSensorPort(port),</span>
<span class="nc" id="L800">                        getGestureSensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L801">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L803">                return GestureSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.MOISTURE:
<span class="nc" id="L805">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L807">                        getSensorPort(port),</span>
<span class="nc" id="L808">                        getMoistureSensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L809">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L811">                return MoistureSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.POTENTIOMETER:
<span class="nc" id="L813">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L815">                        getSensorPort(port),</span>
<span class="nc" id="L816">                        getVoltageSensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L817">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L819">                return VoltageSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.HUMIDITY:
<span class="nc" id="L821">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L823">                        getSensorPort(port),</span>
<span class="nc" id="L824">                        getHumiditySensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L825">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L827">                return HumiditySensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.MOTION:
<span class="nc" id="L829">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L831">                        getSensorPort(port),</span>
<span class="nc" id="L832">                        getMotionSensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L833">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L835">                return MotionSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.PULSE:
<span class="nc" id="L837">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L839">                        getSensorPort(port),</span>
<span class="nc" id="L840">                        getPulseSensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L841">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L843">                return PulseSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.DROP:
<span class="nc" id="L845">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L847">                        getSensorPort(port),</span>
<span class="nc" id="L848">                        getDropSensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L849">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L851">                return DropSensor.make(sensorMetaDataBean, properties, comment);</span>
            case BlocklyConstants.RFID:
<span class="nc" id="L853">                sensorMetaDataBean =</span>
                    new SensorMetaDataBean(
<span class="nc" id="L855">                        getSensorPort(port),</span>
<span class="nc" id="L856">                        getRfidSensorMode(sensorType.getSensorMode()),</span>
<span class="nc" id="L857">                        getSlot(BlocklyConstants.EMPTY_SLOT),</span>
                        isPortInMutation);
<span class="nc" id="L859">                return RfidSensor.make(sensorMetaDataBean, properties, comment);</span>
            default:
<span class="nc" id="L861">                throw new DbcException(&quot;Invalid sensor &quot; + sensorType.getSensorType() + &quot;!&quot;);</span>
        }
    }

    /**
     * Get the compiler workflow object for this robot.
     *
     * @return
     */
    ICompilerWorkflow getRobotCompilerWorkflow();

    /**
     * Get the compiler workflow object for this simulation.
     *
     * @return
     */
    ICompilerWorkflow getSimCompilerWorkflow();

    /**
     * Get the guice module for this robot. This is used to add bindings to guice. It should not be used often.&lt;br&gt;
     * Example: the /download REST resource needs access to the directory, in which binaries are stored (EV3 lejos robot)
     *
     * @return the guice module for this robot or &lt;code&gt;null&lt;/code&gt;, if this robot doesn't need to inject resources
     */
    default AbstractModule getGuiceModule() {
<span class="nc" id="L886">        return null;</span>
    }

    /**
     * Get the file extension of the specific language for this robot. This is used when we want to download locally the source code into a file.
     */
    String getFileExtension();

    String getProgramToolboxBeginner();

    String getProgramToolboxExpert();

    String getProgramDefault();

    String getConfigurationToolbox();

    String getConfigurationDefault();

    String getRealName();

    Boolean hasSim();

    String getInfo();

    Boolean isBeta();

    String getConnectionType();

    default String getVendorId() {
<span class="nc" id="L915">        return null;</span>
    }

    default String getCommandline() {
<span class="nc" id="L919">        return null;</span>
    }

    default String getSignature() {
<span class="nc" id="L923">        return null;</span>
    }

    Boolean hasConfiguration();

    RobotSimulationCheckVisitor getSimProgramCheckVisitor(Configuration brickConfiguration);

    RobotCommonCheckVisitor getRobotProgramCheckVisitor(Configuration brickConfiguration);

    String getGroup();

    String generateCode(Configuration brickConfiguration, ArrayList&lt;ArrayList&lt;Phrase&lt;Void&gt;&gt;&gt; phrasesSet, boolean withWrapping);

    default String getMenuVersion() {
<span class="nc" id="L937">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>