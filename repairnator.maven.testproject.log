[INFO] Scanning for projects...
[WARNING] 
[WARNING] Some problems were encountered while building the effective model for fr.inria.gforge.spoon:spoon-core:jar:7.2.0-SNAPSHOT
[WARNING] 'build.plugins.plugin.version' for org.pitest:pitest-maven is missing. @ line 546, column 15
[WARNING] 
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING] 
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING] 
[INFO] Inspecting build with total of 1 modules...
[INFO] Installing Nexus Staging features:
[INFO]   ... total of 1 executions of maven-deploy-plugin replaced with nexus-staging-maven-plugin
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building Spoon Core 7.2.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-enforcer-plugin:1.0:enforce (enforce-maven) @ spoon-core ---
[INFO] Skipping Rule Enforcement.
[INFO] 
[INFO] --- jacoco-maven-plugin:0.8.1:prepare-agent (default) @ spoon-core ---
[INFO] argLine set to -javaagent:/root/./workspace/INRIA/spoon/441002125/.m2/org/jacoco/org.jacoco.agent/0.8.1/org.jacoco.agent-0.8.1-runtime.jar=destfile=/root/workspace/INRIA/spoon/441002125/target/jacoco.exec
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ spoon-core ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 3 resources
[INFO] Copying 1 resource
[INFO] 
[INFO] --- maven-compiler-plugin:3.7.0:compile (default-compile) @ spoon-core ---
[INFO] Nothing to compile - all classes are up to date
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ spoon-core ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 185 resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.7.0:testCompile (default-testCompile) @ spoon-core ---
[INFO] Nothing to compile - all classes are up to date
[INFO] 
[INFO] --- maven-surefire-plugin:2.21.0:test (default-test) @ spoon-core ---
[INFO] Downloading: https://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-junit4/2.21.0/surefire-junit4-2.21.0.pom
[INFO] Downloaded: https://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-junit4/2.21.0/surefire-junit4-2.21.0.pom (4 KB at 6.7 KB/sec)
[INFO] Downloading: https://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-providers/2.21.0/surefire-providers-2.21.0.pom
[INFO] Downloaded: https://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-providers/2.21.0/surefire-providers-2.21.0.pom (3 KB at 62.9 KB/sec)
[INFO] Downloading: https://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-junit4/2.21.0/surefire-junit4-2.21.0.jar
[INFO] Downloaded: https://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-junit4/2.21.0/surefire-junit4-2.21.0.jar (83 KB at 995.9 KB/sec)
[INFO] 
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running spoon.test.api.APITest
./target/nooutput_e2b31eda-2b8c-4564-baaa-db702337cbd9
[INFO] Tests run: 23, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 25.919 s - in spoon.test.api.APITest
[INFO] Running spoon.test.api.FileSystemFolderTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.test.api.FileSystemFolderTest
[INFO] Running spoon.test.api.NoClasspathTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.236 s - in spoon.test.api.NoClasspathTest
[INFO] Running spoon.test.api.MetamodelTest
[INFO] Tests run: 16, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4.622 s - in spoon.test.api.MetamodelTest
[INFO] Running spoon.test.exceptions.ExceptionTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.316 s - in spoon.test.exceptions.ExceptionTest
[INFO] Running spoon.test.module.TestModule
[ERROR] Tests run: 8, Failures: 1, Errors: 0, Skipped: 2, Time elapsed: 0.121 s <<< FAILURE! - in spoon.test.module.TestModule
[ERROR] testModuleInfoWithComments(spoon.test.module.TestModule)  Time elapsed: 0.044 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:<...e of the application[]> but was:<...e of the application[
]>
	at spoon.test.module.TestModule.testModuleInfoWithComments(TestModule.java:219)

[INFO] Running spoon.test.imports.ImportAndExtendWithPackageNameTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.039 s - in spoon.test.imports.ImportAndExtendWithPackageNameTest
[INFO] Running spoon.test.imports.ImportTest
[INFO] Tests run: 47, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 6.272 s - in spoon.test.imports.ImportTest
[INFO] Running spoon.test.imports.ImportScannerTest
2018-10-13 16:18:29,704 WARN spoon.Launcher - ImportScannerTest: Import scanner imports 589 unused imports and misses 11 imports
[ERROR] Tests run: 7, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 18.184 s <<< FAILURE! - in spoon.test.imports.ImportScannerTest
[ERROR] testImportOnSpoon(spoon.test.imports.ImportScannerTest)  Time elapsed: 17.915 s  <<< FAILURE!
java.lang.AssertionError: Import scanner missed 11 imports expected:<0> but was:<11>
	at spoon.test.imports.ImportScannerTest.testImportOnSpoon(ImportScannerTest.java:178)

[INFO] Running spoon.test.prettyprinter.TestSniperPrinter
[ERROR] Tests run: 9, Failures: 8, Errors: 0, Skipped: 0, Time elapsed: 0.697 s <<< FAILURE! - in spoon.test.prettyprinter.TestSniperPrinter
[ERROR] testPrintAfterRemoveOfLastTypeMember(spoon.test.prettyprinter.TestSniperPrinter)  Time elapsed: 0.125 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again ]
 */
public
@Depreca...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again]
 */
public
@Depreca...>
	at spoon.test.prettyprinter.TestSniperPrinter.assertIsPrintedWithExpectedChanges(TestSniperPrinter.java:245)
	at spoon.test.prettyprinter.TestSniperPrinter.lambda$testPrintAfterRemoveOfLastTypeMember$15(TestSniperPrinter.java:129)
	at spoon.test.prettyprinter.TestSniperPrinter.testSniper(TestSniperPrinter.java:192)
	at spoon.test.prettyprinter.TestSniperPrinter.testPrintAfterRemoveOfLastTypeMember(TestSniperPrinter.java:125)

[ERROR] testPrintAfterRemoveOfFirstParameter(spoon.test.prettyprinter.TestSniperPrinter)  Time elapsed: 0.066 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again ]
 */
public
@Depreca...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again]
 */
public
@Depreca...>
	at spoon.test.prettyprinter.TestSniperPrinter.assertIsPrintedWithExpectedChanges(TestSniperPrinter.java:245)
	at spoon.test.prettyprinter.TestSniperPrinter.lambda$testPrintAfterRemoveOfFirstParameter$9(TestSniperPrinter.java:96)
	at spoon.test.prettyprinter.TestSniperPrinter.testSniper(TestSniperPrinter.java:192)
	at spoon.test.prettyprinter.TestSniperPrinter.testPrintAfterRemoveOfFirstParameter(TestSniperPrinter.java:92)

[ERROR] testPrintAfterRenameOfField(spoon.test.prettyprinter.TestSniperPrinter)  Time elapsed: 0.058 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again ]
 */
public
@Depreca...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again]
 */
public
@Depreca...>
	at spoon.test.prettyprinter.TestSniperPrinter.assertIsPrintedWithExpectedChanges(TestSniperPrinter.java:245)
	at spoon.test.prettyprinter.TestSniperPrinter.lambda$testPrintAfterRenameOfField$3(TestSniperPrinter.java:66)
	at spoon.test.prettyprinter.TestSniperPrinter.testSniper(TestSniperPrinter.java:192)
	at spoon.test.prettyprinter.TestSniperPrinter.testPrintAfterRenameOfField(TestSniperPrinter.java:61)

[ERROR] testPrintAfterRemoveOfFormalTypeParamsAndChangeOfReturnType(spoon.test.prettyprinter.TestSniperPrinter)  Time elapsed: 0.054 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again ]
 */
public
@Depreca...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again]
 */
public
@Depreca...>
	at spoon.test.prettyprinter.TestSniperPrinter.assertIsPrintedWithExpectedChanges(TestSniperPrinter.java:245)
	at spoon.test.prettyprinter.TestSniperPrinter.lambda$testPrintAfterRemoveOfFormalTypeParamsAndChangeOfReturnType$19(TestSniperPrinter.java:162)
	at spoon.test.prettyprinter.TestSniperPrinter.testSniper(TestSniperPrinter.java:192)
	at spoon.test.prettyprinter.TestSniperPrinter.testPrintAfterRemoveOfFormalTypeParamsAndChangeOfReturnType(TestSniperPrinter.java:155)

[ERROR] testPrintAfterAddOfLastTypeMember(spoon.test.prettyprinter.TestSniperPrinter)  Time elapsed: 0.054 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again ]
 */
public
@Depreca...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again]
 */
public
@Depreca...>
	at spoon.test.prettyprinter.TestSniperPrinter.assertIsPrintedWithExpectedChanges(TestSniperPrinter.java:245)
	at spoon.test.prettyprinter.TestSniperPrinter.lambda$testPrintAfterAddOfLastTypeMember$17(TestSniperPrinter.java:148)
	at spoon.test.prettyprinter.TestSniperPrinter.testSniper(TestSniperPrinter.java:192)
	at spoon.test.prettyprinter.TestSniperPrinter.testPrintAfterAddOfLastTypeMember(TestSniperPrinter.java:141)

[ERROR] testPrintAfterRemoveOfLastParameter(spoon.test.prettyprinter.TestSniperPrinter)  Time elapsed: 0.054 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again ]
 */
public
@Depreca...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again]
 */
public
@Depreca...>
	at spoon.test.prettyprinter.TestSniperPrinter.assertIsPrintedWithExpectedChanges(TestSniperPrinter.java:245)
	at spoon.test.prettyprinter.TestSniperPrinter.lambda$testPrintAfterRemoveOfLastParameter$13(TestSniperPrinter.java:118)
	at spoon.test.prettyprinter.TestSniperPrinter.testSniper(TestSniperPrinter.java:192)
	at spoon.test.prettyprinter.TestSniperPrinter.testPrintAfterRemoveOfLastParameter(TestSniperPrinter.java:114)

[ERROR] testPrintAfterRemoveOfMiddleParameter(spoon.test.prettyprinter.TestSniperPrinter)  Time elapsed: 0.053 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again ]
 */
public
@Depreca...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again]
 */
public
@Depreca...>
	at spoon.test.prettyprinter.TestSniperPrinter.assertIsPrintedWithExpectedChanges(TestSniperPrinter.java:245)
	at spoon.test.prettyprinter.TestSniperPrinter.lambda$testPrintAfterRemoveOfMiddleParameter$11(TestSniperPrinter.java:107)
	at spoon.test.prettyprinter.TestSniperPrinter.testSniper(TestSniperPrinter.java:192)
	at spoon.test.prettyprinter.TestSniperPrinter.testPrintAfterRemoveOfMiddleParameter(TestSniperPrinter.java:103)

[ERROR] testPrintUnchaged(spoon.test.prettyprinter.TestSniperPrinter)  Time elapsed: 0.05 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again 
 */
public
@Deprecated
abstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged<T, K> /*before extends*/ 
	extends ArrayList<T /* let's confuse > it */ > implements List<T>,
	Cloneable
{
	
	
	/**/
	final
	//
	private String string = "a"
			+ "b" + "c"+"d";
	
	//and spaces here are wanted too
	
	
	public <T, K> void andSomeOtherMethod(
			int param1,
			String param2         , List<?>[][] ... twoDArrayOfLists)
	{/**/
		System.out.println("aaa"
				+ "xyz");
	/*x*/}
	List<?>[][] twoDArrayOfLists = new List<?>[7][];
}

]//and what about thi...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again
 */
public
@Deprecated
abstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged<T, K> /*before extends*/ 
	extends ArrayList<T /* let's confuse > it */ > implements List<T>,
	Cloneable
{
	
	
	/**/
	final
	//
	private String string = "a"
			+ "b" + "c"+"d";
	
	//and spaces here are wanted too
	
	
	public <T, K> void andSomeOtherMethod(
			int param1,
			String param2         , List<?>[][] ... twoDArrayOfLists)
	{/**/
		System.out.println("aaa"
				+ "xyz");
	/*x*/}
	List<?>[][] twoDArrayOfLists = new List<?>[7][];
}

	]//and what about thi...>
	at spoon.test.prettyprinter.TestSniperPrinter.assertIsPrintedWithExpectedChanges(TestSniperPrinter.java:245)
	at spoon.test.prettyprinter.TestSniperPrinter.lambda$testPrintUnchaged$1(TestSniperPrinter.java:54)
	at spoon.test.prettyprinter.TestSniperPrinter.testSniper(TestSniperPrinter.java:192)
	at spoon.test.prettyprinter.TestSniperPrinter.testPrintUnchaged(TestSniperPrinter.java:51)

[INFO] Running spoon.test.prettyprinter.QualifiedThisRefTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.25 s - in spoon.test.prettyprinter.QualifiedThisRefTest
[INFO] Running spoon.test.prettyprinter.PrinterTest
[INFO] Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.646 s - in spoon.test.prettyprinter.PrinterTest
[INFO] Running spoon.test.prettyprinter.DefaultPrettyPrinterTest
[INFO] Tests run: 12, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.732 s - in spoon.test.prettyprinter.DefaultPrettyPrinterTest
[INFO] Running spoon.test.prettyprinter.LinesTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.419 s - in spoon.test.prettyprinter.LinesTest
[INFO] Running spoon.test.visitor.VisitorTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.042 s - in spoon.test.visitor.VisitorTest
[INFO] Running spoon.test.visitor.AssignmentsEqualsTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.04 s - in spoon.test.visitor.AssignmentsEqualsTest
[INFO] Running spoon.test.loop.LoopTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.14 s - in spoon.test.loop.LoopTest
[INFO] Running spoon.test.intercession.insertBefore.InsertMethodsTest
[INFO] Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.834 s - in spoon.test.intercession.insertBefore.InsertMethodsTest
[INFO] Running spoon.test.intercession.IntercessionTest
[WARNING] Tests run: 8, Failures: 0, Errors: 0, Skipped: 1, Time elapsed: 5.876 s - in spoon.test.intercession.IntercessionTest
[INFO] Running spoon.test.intercession.OneCanCallSetterWithNullParameterizedTest
[INFO] Tests run: 116, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.426 s - in spoon.test.intercession.OneCanCallSetterWithNullParameterizedTest
[INFO] Running spoon.test.intercession.RemoveTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.04 s - in spoon.test.intercession.RemoveTest
[INFO] Running spoon.test.variable.AccessFullyQualifiedFieldTest
[INFO] Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.972 s - in spoon.test.variable.AccessFullyQualifiedFieldTest
[INFO] Running spoon.test.variable.AccessTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.337 s - in spoon.test.variable.AccessTest
[INFO] Running spoon.test.variable.InferredVariableTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.117 s - in spoon.test.variable.InferredVariableTest
[INFO] Running spoon.test.annotation.AnnotationLoopTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.039 s - in spoon.test.annotation.AnnotationLoopTest
[INFO] Running spoon.test.annotation.AnnotationTest
[INFO] Tests run: 52, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.225 s - in spoon.test.annotation.AnnotationTest
[INFO] Running spoon.test.annotation.AnnotationValuesTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.139 s - in spoon.test.annotation.AnnotationValuesTest
[INFO] Running spoon.test.pkg.PackageTest
[ERROR] Tests run: 12, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.689 s <<< FAILURE! - in spoon.test.pkg.PackageTest
[ERROR] testPackage(spoon.test.pkg.PackageTest)  Time elapsed: 0.041 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:<...his is test
JavaDoc.[]> but was:<...his is test
JavaDoc.[
]>
	at spoon.test.pkg.PackageTest.testPackage(PackageTest.java:87)

[INFO] Running spoon.test.comment.CommentTest
[ERROR] Tests run: 21, Failures: 9, Errors: 0, Skipped: 0, Time elapsed: 28.852 s <<< FAILURE! - in spoon.test.comment.CommentTest
[ERROR] testEnumValueComment(spoon.test.comment.CommentTest)  Time elapsed: 0.042 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:<...ing the other modes.[]> but was:<...ing the other modes.[
]>
	at spoon.test.comment.CommentTest.testEnumValueComment(CommentTest.java:943)

[ERROR] testJavaDocCommentOnUnix(spoon.test.comment.CommentTest)  Time elapsed: 0.102 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:<...s.

Long description[]> but was:<...s.

Long description[

@deprecated
@since 1.3
@author Thomas Durieux
@version 1.0
]>
	at spoon.test.comment.CommentTest.testJavaDocComment(CommentTest.java:185)
	at spoon.test.comment.CommentTest.testJavaDocCommentOnUnix(CommentTest.java:153)

[ERROR] testJavaDocEmptyCommentAndTag(spoon.test.comment.CommentTest)  Time elapsed: 0.133 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:<[]> but was:<[
@author there is tag, but there is no comment
]>
	at spoon.test.comment.CommentTest.testJavaDocEmptyCommentAndTag(CommentTest.java:243)

[ERROR] testWildComments(spoon.test.comment.CommentTest)  Time elapsed: 0.134 s  <<< FAILURE!
org.junit.ComparisonFailure: 
(/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/comment/testclasses/WildComments.java:85) expected:<*[]> but was:<*[
]>
	at spoon.test.comment.CommentTest.testWildComments(CommentTest.java:919)

[ERROR] testCommentsInResourcesWithWindowsEOL(spoon.test.comment.CommentTest)  Time elapsed: 0.069 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:<...ed well
in this case[]> but was:<...ed well
in this case[

@author pvojtechovsky
]>
	at spoon.test.comment.CommentTest.testCommentsInResourcesWithWindowsEOL(CommentTest.java:900)

[ERROR] testCombinedPackageInfoComment(spoon.test.comment.CommentTest)  Time elapsed: 0.239 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:<...omment2
/**
Comment3[] */
@java.lang.Depre...> but was:<...omment2
/**
Comment3[
] */
@java.lang.Depre...>
	at spoon.test.comment.CommentTest.testCombinedPackageInfoComment(CommentTest.java:128)

[ERROR] testJavaDocCommentOnMac(spoon.test.comment.CommentTest)  Time elapsed: 0.073 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:<...s.

Long description[]> but was:<...s.

Long description[

@deprecated
@since 1.3
@author Thomas Durieux
@version 1.0
]>
	at spoon.test.comment.CommentTest.testJavaDocComment(CommentTest.java:185)
	at spoon.test.comment.CommentTest.testJavaDocCommentOnMac(CommentTest.java:178)

[ERROR] testSnippedWithComments(spoon.test.comment.CommentTest)  Time elapsed: 0.067 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:<...thod javadoc comment[]> but was:<...thod javadoc comment[
]>
	at spoon.test.comment.CommentTest.testSnippedWithComments(CommentTest.java:724)

[ERROR] testDocumentationContract(spoon.test.comment.CommentTest)  Time elapsed: 26.718 s  <<< FAILURE!
org.junit.ComparisonFailure: 
doc outdated, please commit doc/code_elements.md expected:<...va

/**
Description
[@see 
		]a tag in the javadoc...> but was:<...va

/**
Description
[
@see ]a tag in the javadoc...>
	at spoon.test.comment.CommentTest.testDocumentationContract(CommentTest.java:850)

[INFO] Running spoon.test.generics.GenericsTest
[INFO] Tests run: 47, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.075 s - in spoon.test.generics.GenericsTest
[INFO] Running spoon.test.jdtimportbuilder.ImportBuilderTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.457 s - in spoon.test.jdtimportbuilder.ImportBuilderTest
[INFO] Running spoon.test.OutputTypeTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.test.OutputTypeTest
[INFO] Running spoon.test.staticFieldAccess2.ImplicitStaticFieldReferenceTest
[INFO] Tests run: 16, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.46 s - in spoon.test.staticFieldAccess2.ImplicitStaticFieldReferenceTest
[INFO] Running spoon.test.trycatch.TryCatchTest
[INFO] Tests run: 12, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.692 s - in spoon.test.trycatch.TryCatchTest
[INFO] Running spoon.test.path.PathTest
[INFO] Tests run: 16, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.757 s - in spoon.test.path.PathTest
[INFO] Running spoon.test.invocations.InvocationTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.162 s - in spoon.test.invocations.InvocationTest
[INFO] Running spoon.test.executable.ExecutableRefTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.29 s - in spoon.test.executable.ExecutableRefTest
[INFO] Running spoon.test.executable.ExecutableTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.183 s - in spoon.test.executable.ExecutableTest
[INFO] Running spoon.test.constructorcallnewclass.NewClassTest
[INFO] Tests run: 7, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.504 s - in spoon.test.constructorcallnewclass.NewClassTest
[INFO] Running spoon.test.constructorcallnewclass.ConstructorCallTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.348 s - in spoon.test.constructorcallnewclass.ConstructorCallTest
[INFO] Running spoon.test.reference.ElasticsearchStackoverflowTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.063 s - in spoon.test.reference.ElasticsearchStackoverflowTest
[INFO] Running spoon.test.reference.AnnotationFieldReferenceTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.038 s - in spoon.test.reference.AnnotationFieldReferenceTest
[INFO] Running spoon.test.reference.ExecutableReferenceTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.421 s - in spoon.test.reference.ExecutableReferenceTest
[INFO] Running spoon.test.reference.ExecutableReferenceGenericTest
[INFO] Tests run: 12, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.539 s - in spoon.test.reference.ExecutableReferenceGenericTest
[INFO] Running spoon.test.reference.VariableAccessTest
2018-10-13 16:19:25,901 ERROR spoon.support.compiler.jdt.JDTTreeBuilder - Could not find declaration for variable e at (/root/workspace/INRIA/spoon/441002125/src/test/resources/noclasspath/org/elasticsearch/indices/analysis/HunspellService.java:100)
[INFO] Tests run: 11, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.458 s - in spoon.test.reference.VariableAccessTest
[INFO] Running spoon.test.reference.CloneReferenceTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.083 s - in spoon.test.reference.CloneReferenceTest
[INFO] Running spoon.test.reference.TypeReferenceTest
[INFO] Tests run: 28, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.255 s - in spoon.test.reference.TypeReferenceTest
[INFO] Running spoon.test.lambda.LambdaTest
2018-10-13 16:19:29,110 ERROR spoon.support.compiler.jdt.JDTTreeBuilder - Could not find declaration for variable Strings at (/root/workspace/INRIA/spoon/441002125/src/test/resources/noclasspath/lambdas/TypeAccessInLambda.java:6)
[INFO] Tests run: 23, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.331 s - in spoon.test.lambda.LambdaTest
[INFO] Running spoon.test.enums.EnumsTest
[ERROR] Tests run: 8, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.349 s <<< FAILURE! - in spoon.test.enums.EnumsTest
[ERROR] testPrintEnumValues(spoon.test.enums.EnumsTest)  Time elapsed: 0.044 s  <<< FAILURE!
java.lang.AssertionError
	at spoon.test.enums.EnumsTest.testPrintEnumValues(EnumsTest.java:157)

[INFO] Running spoon.test.enums.EnumsTypeTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.073 s - in spoon.test.enums.EnumsTypeTest
[INFO] Running spoon.test.ctClass.CtClassTest
2018-10-13 16:19:30,935 ERROR spoon.Launcher - cannot load class: daikon.Runtime
spoon.support.SpoonClassNotFoundException: cannot load class: daikon.Runtime
	at spoon.support.reflect.reference.CtTypeReferenceImpl.findClass(CtTypeReferenceImpl.java:158)
	at spoon.support.reflect.reference.CtTypeReferenceImpl.getActualClass(CtTypeReferenceImpl.java:140)
	at spoon.support.reflect.reference.CtFieldReferenceImpl.getActualField(CtFieldReferenceImpl.java:63)
	at spoon.support.reflect.reference.CtFieldReferenceImpl.getModifiers(CtFieldReferenceImpl.java:227)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.isInitializeStaticFinalField(DefaultJavaPrettyPrinter.java:894)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.printCtFieldAccess(DefaultJavaPrettyPrinter.java:841)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtFieldWrite(DefaultJavaPrettyPrinter.java:800)
	at spoon.support.reflect.code.CtFieldWriteImpl.accept(CtFieldWriteImpl.java:27)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:361)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtAssignment(DefaultJavaPrettyPrinter.java:509)
	at spoon.support.reflect.code.CtAssignmentImpl.accept(CtAssignmentImpl.java:54)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:361)
	at spoon.reflect.visitor.ElementPrinterHelper.writeStatement(ElementPrinterHelper.java:177)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtBlock(DefaultJavaPrettyPrinter.java:542)
	at spoon.support.reflect.code.CtBlockImpl.accept(CtBlockImpl.java:67)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:361)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtAnonymousExecutable(DefaultJavaPrettyPrinter.java:460)
	at spoon.support.reflect.declaration.CtAnonymousExecutableImpl.accept(CtAnonymousExecutableImpl.java:46)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:361)
	at spoon.reflect.visitor.ElementPrinterHelper.writeElementList(ElementPrinterHelper.java:187)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtClass(DefaultJavaPrettyPrinter.java:636)
	at spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:67)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:361)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.printTypes(DefaultJavaPrettyPrinter.java:1980)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.calculate(DefaultJavaPrettyPrinter.java:1975)
	at spoon.support.JavaOutputProcessor.createJavaFile(JavaOutputProcessor.java:120)
	at spoon.support.JavaOutputProcessor.process(JavaOutputProcessor.java:156)
	at spoon.support.JavaOutputProcessor.process(JavaOutputProcessor.java:46)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:74)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:173)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:147)
	at spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:649)
	at spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:97)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:181)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:173)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:147)
	at spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:648)
	at spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:97)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:181)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:173)
	at spoon.reflect.visitor.CtScanner.visitCtModule(CtScanner.java:923)
	at spoon.reflect.factory.ModuleFactory$CtUnnamedModule.accept(ModuleFactory.java:105)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:181)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.support.QueueProcessingManager.process(QueueProcessingManager.java:129)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFilesUsingTypes(JDTBasedSpoonCompiler.java:484)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFiles(JDTBasedSpoonCompiler.java:210)
	at spoon.Launcher.prettyprint(Launcher.java:784)
	at spoon.Launcher.run(Launcher.java:722)
	at spoon.test.ctClass.CtClassTest.testParentOfTheEnclosingClassOfStaticClass(CtClassTest.java:115)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
Caused by: java.lang.ClassNotFoundException: daikon.Runtime
	at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at spoon.support.reflect.reference.CtTypeReferenceImpl.findClass(CtTypeReferenceImpl.java:156)
	... 76 more
[ERROR] Tests run: 8, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 3.589 s <<< FAILURE! - in spoon.test.ctClass.CtClassTest
[ERROR] testDefaultConstructorAreOk(spoon.test.ctClass.CtClassTest)  Time elapsed: 0.127 s  <<< ERROR!
spoon.compiler.ModelBuildingException: Syntax error on token(s), misplaced construct(s) at /root/workspace/INRIA/spoon/441002125/BooleanArrays.java:47
	at spoon.test.ctClass.CtClassTest.testDefaultConstructorAreOk(CtClassTest.java:219)

[INFO] Running spoon.test.support.ResourceTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.198 s - in spoon.test.support.ResourceTest
[INFO] Running spoon.test.template.TemplateInvocationSubstitutionTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.198 s - in spoon.test.template.TemplateInvocationSubstitutionTest
[INFO] Running spoon.test.template.core.ParameterInfoTest
[INFO] Tests run: 21, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.012 s - in spoon.test.template.core.ParameterInfoTest
[INFO] Running spoon.test.template.TemplateArrayAccessTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.103 s - in spoon.test.template.TemplateArrayAccessTest
[INFO] Running spoon.test.template.TemplateClassAccessTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.065 s - in spoon.test.template.TemplateClassAccessTest
[INFO] Running spoon.test.template.TemplateReplaceReturnTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.187 s - in spoon.test.template.TemplateReplaceReturnTest
[INFO] Running spoon.test.template.TemplateEnumAccessTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.102 s - in spoon.test.template.TemplateEnumAccessTest
[INFO] Running spoon.test.template.PatternTest
[INFO] Tests run: 34, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.371 s - in spoon.test.template.PatternTest
[INFO] Running spoon.test.template.TemplateTest
0
[INFO] Tests run: 24, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.178 s - in spoon.test.template.TemplateTest
[INFO] Running spoon.test.visibility.VisibilityTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.521 s - in spoon.test.visibility.VisibilityTest
[INFO] Running spoon.test.targeted.TargetedExpressionTest
[INFO] Tests run: 17, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.783 s - in spoon.test.targeted.TargetedExpressionTest
[INFO] Running spoon.test.staticFieldAccess.StaticAccessTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.128 s - in spoon.test.staticFieldAccess.StaticAccessTest
[INFO] Running spoon.test.refactoring.RefactoringTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.432 s - in spoon.test.refactoring.RefactoringTest
[INFO] Running spoon.test.refactoring.CtRenameLocalVariableRefactoringTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 9.414 s - in spoon.test.refactoring.CtRenameLocalVariableRefactoringTest
[INFO] Running spoon.test.refactoring.MethodsRefactoringTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.474 s - in spoon.test.refactoring.MethodsRefactoringTest
[INFO] Running spoon.test.interfaces.InterfaceTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.263 s - in spoon.test.interfaces.InterfaceTest
[INFO] Running spoon.test.interfaces.TestInterfaceWithoutSetup
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.119 s - in spoon.test.interfaces.TestInterfaceWithoutSetup
[INFO] Running spoon.test.properties.PropertiesTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.039 s - in spoon.test.properties.PropertiesTest
[INFO] Running spoon.test.modifiers.TestModifiers
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.352 s - in spoon.test.modifiers.TestModifiers
[INFO] Running spoon.test.model.BlockTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.077 s - in spoon.test.model.BlockTest
[INFO] Running spoon.test.model.AnonymousExecutableTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.041 s - in spoon.test.model.AnonymousExecutableTest
[INFO] Running spoon.test.model.TypeTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.376 s - in spoon.test.model.TypeTest
[INFO] Running spoon.test.model.IncrementalLauncherTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.072 s - in spoon.test.model.IncrementalLauncherTest
[INFO] Running spoon.test.model.SwitchCaseTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.077 s - in spoon.test.model.SwitchCaseTest
[INFO] Running spoon.test.ctType.CtTypeParameterTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.092 s - in spoon.test.ctType.CtTypeParameterTest
[INFO] Running spoon.test.ctType.CtTypeTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.374 s - in spoon.test.ctType.CtTypeTest
[INFO] Running spoon.test.position.PositionTest
2018-10-13 16:19:56,050 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c2 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:14)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionClass(PositionTest.java:102)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:56,052 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c5 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:17)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionClass(PositionTest.java:102)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:56,053 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c6 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:18)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionClass(PositionTest.java:102)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:56,054 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c7 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:19)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionClass(PositionTest.java:102)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:56,421 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c2 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:14)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionInterface(PositionTest.java:220)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:56,422 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c5 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:17)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionInterface(PositionTest.java:220)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:56,423 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c6 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:18)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionInterface(PositionTest.java:220)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:56,424 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c7 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:19)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionInterface(PositionTest.java:220)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:56,668 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c2 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:14)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionClassWithComments(PositionTest.java:135)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:56,669 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c5 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:17)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionClassWithComments(PositionTest.java:135)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:56,670 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c6 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:18)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionClassWithComments(PositionTest.java:135)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:56,671 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c7 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:19)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionClassWithComments(PositionTest.java:135)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:57,067 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c2 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:14)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionAnnotation(PositionTest.java:254)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:57,068 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c5 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:17)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionAnnotation(PositionTest.java:254)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:57,069 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c6 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:18)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionAnnotation(PositionTest.java:254)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:19:57,069 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c7 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:19)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:105)
	at spoon.test.position.PositionTest.testPositionAnnotation(PositionTest.java:254)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
[INFO] Tests run: 30, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.402 s - in spoon.test.position.PositionTest
[INFO] Running spoon.test.position.TestSourceFragment
[INFO] Tests run: 7, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.042 s - in spoon.test.position.TestSourceFragment
[INFO] Running spoon.test.condition.ConditionalTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.153 s - in spoon.test.condition.ConditionalTest
[INFO] Running spoon.test.main.MainTest
[WARNING] Tests run: 1, Failures: 0, Errors: 0, Skipped: 1, Time elapsed: 0.001 s - in spoon.test.main.MainTest
[INFO] Running spoon.test.type.TypeTest
[INFO] Tests run: 13, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.666 s - in spoon.test.type.TypeTest
[INFO] Running spoon.test.arrays.ArraysTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.428 s - in spoon.test.arrays.ArraysTest
[INFO] Running spoon.test.fieldaccesses.FieldAccessTest
[INFO] Tests run: 16, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.719 s - in spoon.test.fieldaccesses.FieldAccessTest
[INFO] Running spoon.test.parent.ContractOnSettersParametrizedTest
[INFO] Tests run: 67, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.235 s - in spoon.test.parent.ContractOnSettersParametrizedTest
[INFO] Running spoon.test.parent.TopLevelTypeTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.034 s - in spoon.test.parent.TopLevelTypeTest
[INFO] Running spoon.test.parent.NullParentTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.318 s - in spoon.test.parent.NullParentTest
[INFO] Running spoon.test.parent.ParentTest
[WARNING] Tests run: 11, Failures: 0, Errors: 0, Skipped: 1, Time elapsed: 0.639 s - in spoon.test.parent.ParentTest
[INFO] Running spoon.test.parent.SetParentTest
[INFO] Tests run: 67, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.065 s - in spoon.test.parent.SetParentTest
[INFO] Running spoon.test.method_overriding.MethodOverriddingTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.132 s - in spoon.test.method_overriding.MethodOverriddingTest
[INFO] Running spoon.test.filters.FilterTest
2018-10-13 16:20:01,792 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:01,792 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:01,793 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:01,794 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:01,794 INFO spoon.Launcher - start processing...
2018-10-13 16:20:01,844 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:01,844 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:02,026 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:02,027 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:02,028 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:02,028 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:02,028 INFO spoon.Launcher - start processing...
2018-10-13 16:20:02,078 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:02,079 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:02,237 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:02,237 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:02,237 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:02,237 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:02,238 INFO spoon.Launcher - start processing...
2018-10-13 16:20:02,288 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:02,289 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:02,588 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:02,589 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:02,589 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:02,589 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:02,589 INFO spoon.Launcher - start processing...
2018-10-13 16:20:02,637 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:02,637 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:02,723 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:02,724 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:02,724 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:02,724 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:02,725 INFO spoon.Launcher - start processing...
2018-10-13 16:20:02,775 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:02,775 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:03,234 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:03,234 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:03,235 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:03,235 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:03,235 INFO spoon.Launcher - start processing...
2018-10-13 16:20:03,284 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:03,284 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:03,326 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:03,327 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:03,538 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:03,538 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:03,539 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:03,539 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:03,539 INFO spoon.Launcher - start processing...
2018-10-13 16:20:03,587 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:03,587 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:03,797 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:03,797 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:03,797 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:03,798 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:03,798 INFO spoon.Launcher - start processing...
2018-10-13 16:20:03,845 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:03,845 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:03,886 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:03,886 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:03,886 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:03,887 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:03,887 INFO spoon.Launcher - start processing...
2018-10-13 16:20:03,935 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:03,935 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:04,052 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:04,052 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:04,053 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:04,053 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:04,053 INFO spoon.Launcher - start processing...
2018-10-13 16:20:04,101 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:04,101 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:04,222 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:04,223 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:04,223 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:04,223 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:04,223 INFO spoon.Launcher - start processing...
2018-10-13 16:20:04,271 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:04,271 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:04,311 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:04,311 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:04,312 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:04,312 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:04,312 INFO spoon.Launcher - start processing...
2018-10-13 16:20:04,359 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:04,359 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:04,697 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:04,697 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:04,698 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:04,698 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:04,698 INFO spoon.Launcher - start processing...
2018-10-13 16:20:04,746 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:04,746 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:04,785 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:04,785 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:04,786 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:04,786 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:04,786 INFO spoon.Launcher - start processing...
2018-10-13 16:20:04,834 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:04,834 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:05,164 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:20:05,164 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:20:05,165 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:20:05,165 INFO spoon.Launcher - running Spoon...
2018-10-13 16:20:05,165 INFO spoon.Launcher - start processing...
2018-10-13 16:20:05,212 INFO spoon.Launcher - end of processing: 
2018-10-13 16:20:05,213 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:20:05,215 INFO spoon.Launcher - Step filter CtClass only) spoon.reflect.CtModelImpl$CtRootPackage cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtRootPackage: unnamed package
2018-10-13 16:20:05,215 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtPackageImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageImpl: spoon
2018-10-13 16:20:05,215 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtPackageImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageImpl: spoon.test
2018-10-13 16:20:05,216 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtPackageImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageImpl: spoon.test.filters
2018-10-13 16:20:05,216 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtPackageImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,216 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-10-13 16:20:05,216 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,216 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: AbstractTostada() {
}
2018-10-13 16:20:05,217 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-10-13 16:20:05,217 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-10-13 16:20:05,217 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: java.lang.Object()
2018-10-13 16:20:05,217 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-10-13 16:20:05,217 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,217 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-10-13 16:20:05,217 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,218 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public spoon.test.filters.testclasses.ITostada make() {
    return new spoon.test.filters.testclasses.Tostada() {
        @java.lang.Override
        public void prepare() {
            super.prepare();
        }

        @java.lang.Override
        public spoon.test.filters.testclasses.ITostada make() {
            return super.make();
        }
    };
}
2018-10-13 16:20:05,218 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-10-13 16:20:05,218 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,218 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,218 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,218 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,219 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-10-13 16:20:05,219 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,219 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    return new spoon.test.filters.testclasses.Tostada() {
        @java.lang.Override
        public void prepare() {
            super.prepare();
        }

        @java.lang.Override
        public spoon.test.filters.testclasses.ITostada make() {
            return super.make();
        }
    };
}
2018-10-13 16:20:05,219 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtReturnImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtReturnImpl: return new spoon.test.filters.testclasses.Tostada() {
    @java.lang.Override
    public void prepare() {
        super.prepare();
    }

    @java.lang.Override
    public spoon.test.filters.testclasses.ITostada make() {
        return super.make();
    }
}
2018-10-13 16:20:05,220 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtNewClassImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtNewClassImpl: new spoon.test.filters.testclasses.Tostada() {
    @java.lang.Override
    public void prepare() {
        super.prepare();
    }

    @java.lang.Override
    public spoon.test.filters.testclasses.ITostada make() {
        return super.make();
    }
}
2018-10-13 16:20:05,220 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: spoon.test.filters.testclasses.AbstractTostada$1()
2018-10-13 16:20:05,220 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada.1
2018-10-13 16:20:05,220 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada
2018-10-13 16:20:05,221 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,221 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,221 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,221 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,221 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,221 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: 1() {
}
2018-10-13 16:20:05,221 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-10-13 16:20:05,221 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-10-13 16:20:05,222 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: spoon.test.filters.testclasses.Tostada()
2018-10-13 16:20:05,222 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,222 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,222 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,222 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,222 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public void prepare() {
    super.prepare();
}
2018-10-13 16:20:05,223 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-10-13 16:20:05,223 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,223 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,223 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,223 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,223 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,223 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    super.prepare();
}
2018-10-13 16:20:05,224 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super.prepare()
2018-10-13 16:20:05,224 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtSuperAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtSuperAccessImpl: super
2018-10-13 16:20:05,224 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: 
2018-10-13 16:20:05,224 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,224 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,224 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: prepare()
2018-10-13 16:20:05,224 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,224 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,224 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,225 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public spoon.test.filters.testclasses.ITostada make() {
    return super.make();
}
2018-10-13 16:20:05,225 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-10-13 16:20:05,225 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,225 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,225 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,225 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,226 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-10-13 16:20:05,226 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,226 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    return super.make();
}
2018-10-13 16:20:05,226 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtReturnImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtReturnImpl: return super.make()
2018-10-13 16:20:05,226 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super.make()
2018-10-13 16:20:05,226 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtSuperAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtSuperAccessImpl: super
2018-10-13 16:20:05,226 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: 
2018-10-13 16:20:05,227 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,227 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,227 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: make()
2018-10-13 16:20:05,227 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,227 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,227 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-10-13 16:20:05,227 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,227 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: public abstract void prepare();
2018-10-13 16:20:05,228 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,228 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: public void honey() {
}
2018-10-13 16:20:05,228 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,228 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-10-13 16:20:05,228 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCommentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCommentImpl: /**
Copyright (C) 2006-2015 INRIA and contributors
Spoon - http://spoon.gforge.inria.fr/

This software is governed by the CeCILL-C License under French law and
abiding by the rules of distribution of free software. You can use, modify
and/or redistribute the software under the terms of the CeCILL-C license as
circulated by CEA, CNRS and INRIA at http://www.cecill.info.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.

The fact that you are presently reading this means that you have had
knowledge of the CeCILL-C license and that you accept its terms. */
2018-10-13 16:20:05,228 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada
2018-10-13 16:20:05,228 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,229 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: Antojito() {
}
2018-10-13 16:20:05,229 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-10-13 16:20:05,229 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-10-13 16:20:05,229 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: spoon.test.filters.testclasses.AbstractTostada()
2018-10-13 16:20:05,229 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada
2018-10-13 16:20:05,229 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,229 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada
2018-10-13 16:20:05,230 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,230 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public void prepare() {
    java.lang.System.out.println("Antojito");
}
2018-10-13 16:20:05,230 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-10-13 16:20:05,230 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,230 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,230 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,230 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,231 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,231 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    java.lang.System.out.println("Antojito");
}
2018-10-13 16:20:05,231 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: java.lang.System.out.println("Antojito")
2018-10-13 16:20:05,231 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: java.lang.System.out
2018-10-13 16:20:05,231 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: java.lang.System
2018-10-13 16:20:05,232 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,232 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,232 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: java.lang.System.out
2018-10-13 16:20:05,232 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,232 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,232 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,232 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,233 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: println(java.lang.String)
2018-10-13 16:20:05,233 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,233 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,233 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,233 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,233 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,233 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: "Antojito"
2018-10-13 16:20:05,234 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,234 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,234 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: public void prepare(java.lang.String ingredient) {
}
2018-10-13 16:20:05,234 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,234 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtParameterImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtParameterImpl: java.lang.String ingredient
2018-10-13 16:20:05,234 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,234 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,235 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-10-13 16:20:05,235 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCommentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCommentImpl: /**
Copyright (C) 2006-2015 INRIA and contributors
Spoon - http://spoon.gforge.inria.fr/

This software is governed by the CeCILL-C License under French law and
abiding by the rules of distribution of free software. You can use, modify
and/or redistribute the software under the terms of the CeCILL-C license as
circulated by CEA, CNRS and INRIA at http://www.cecill.info.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.

The fact that you are presently reading this means that you have had
knowledge of the CeCILL-C license and that you accept its terms. */
2018-10-13 16:20:05,235 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-10-13 16:20:05,235 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-10-13 16:20:05,235 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtFieldImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldImpl: private int myfield = 0;
2018-10-13 16:20:05,235 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,236 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 0
2018-10-13 16:20:05,236 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,236 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: FieldAccessFilterTacos() {
    super();
    this.myfield = 0;
}
2018-10-13 16:20:05,237 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    super();
    this.myfield = 0;
}
2018-10-13 16:20:05,237 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-10-13 16:20:05,237 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: java.util.ArrayList()
2018-10-13 16:20:05,237 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-10-13 16:20:05,237 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-10-13 16:20:05,237 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-10-13 16:20:05,237 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-10-13 16:20:05,238 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtAssignmentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAssignmentImpl: this.myfield = 0
2018-10-13 16:20:05,238 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,238 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldWriteImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldWriteImpl: this.myfield
2018-10-13 16:20:05,238 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtThisAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtThisAccessImpl: this
2018-10-13 16:20:05,238 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-10-13 16:20:05,238 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,238 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-10-13 16:20:05,239 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-10-13 16:20:05,239 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,239 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: myfield
2018-10-13 16:20:05,239 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-10-13 16:20:05,239 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,239 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,239 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 0
2018-10-13 16:20:05,239 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,240 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: public void m() {
    myfield = super.size();
    java.lang.Object o = super.get(myfield);
}
2018-10-13 16:20:05,240 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,241 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    myfield = super.size();
    java.lang.Object o = super.get(myfield);
}
2018-10-13 16:20:05,241 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtAssignmentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAssignmentImpl: myfield = super.size()
2018-10-13 16:20:05,241 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,241 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldWriteImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldWriteImpl: myfield
2018-10-13 16:20:05,242 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtThisAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtThisAccessImpl: 
2018-10-13 16:20:05,242 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-10-13 16:20:05,242 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,242 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-10-13 16:20:05,242 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-10-13 16:20:05,242 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,242 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: myfield
2018-10-13 16:20:05,242 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-10-13 16:20:05,243 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,243 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,243 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super.size()
2018-10-13 16:20:05,243 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtSuperAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtSuperAccessImpl: super
2018-10-13 16:20:05,243 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: 
2018-10-13 16:20:05,243 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-10-13 16:20:05,243 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-10-13 16:20:05,244 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: size()
2018-10-13 16:20:05,244 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-10-13 16:20:05,244 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-10-13 16:20:05,244 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,244 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLocalVariableImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableImpl: java.lang.Object o = super.get(myfield)
2018-10-13 16:20:05,244 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-10-13 16:20:05,245 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,245 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super.get(myfield)
2018-10-13 16:20:05,245 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtSuperAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtSuperAccessImpl: super
2018-10-13 16:20:05,245 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: 
2018-10-13 16:20:05,245 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-10-13 16:20:05,245 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-10-13 16:20:05,245 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: get(int)
2018-10-13 16:20:05,246 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-10-13 16:20:05,246 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-10-13 16:20:05,246 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-10-13 16:20:05,246 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,246 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,246 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: myfield
2018-10-13 16:20:05,247 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtThisAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtThisAccessImpl: 
2018-10-13 16:20:05,247 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-10-13 16:20:05,247 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,247 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-10-13 16:20:05,247 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-10-13 16:20:05,247 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,247 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: myfield
2018-10-13 16:20:05,247 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-10-13 16:20:05,248 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,248 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,248 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCommentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCommentImpl: /**
Copyright (C) 2006-2015 INRIA and contributors
Spoon - http://spoon.gforge.inria.fr/

This software is governed by the CeCILL-C License under French law and
abiding by the rules of distribution of free software. You can use, modify
and/or redistribute the software under the terms of the CeCILL-C license as
circulated by CEA, CNRS and INRIA at http://www.cecill.info.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.

The fact that you are presently reading this means that you have had
knowledge of the CeCILL-C license and that you accept its terms. */
2018-10-13 16:20:05,248 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.SuppressWarnings("bar")
2018-10-13 16:20:05,248 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.SuppressWarnings
2018-10-13 16:20:05,248 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,249 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.SuppressWarnings
2018-10-13 16:20:05,249 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,249 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: "bar"
2018-10-13 16:20:05,249 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,249 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,249 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: Foo() {
}
2018-10-13 16:20:05,249 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-10-13 16:20:05,249 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-10-13 16:20:05,250 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: java.lang.Object()
2018-10-13 16:20:05,250 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-10-13 16:20:05,250 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,250 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-10-13 16:20:05,250 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,250 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtFieldImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldImpl: int i;
2018-10-13 16:20:05,250 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,251 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: void foo() {
    int x = 3;
    int z;
    z = x + (i);
    java.lang.System.out.println(z);
}
2018-10-13 16:20:05,251 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,251 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    int x = 3;
    int z;
    z = x + (i);
    java.lang.System.out.println(z);
}
2018-10-13 16:20:05,251 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLocalVariableImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableImpl: int x = 3
2018-10-13 16:20:05,252 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,252 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 3
2018-10-13 16:20:05,252 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,252 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLocalVariableImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableImpl: int z
2018-10-13 16:20:05,252 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,253 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtAssignmentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAssignmentImpl: z = x + (i)
2018-10-13 16:20:05,253 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,253 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtVariableWriteImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtVariableWriteImpl: z
2018-10-13 16:20:05,253 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: z
2018-10-13 16:20:05,253 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,253 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBinaryOperatorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBinaryOperatorImpl: x + (i)
2018-10-13 16:20:05,254 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,254 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtVariableReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtVariableReadImpl: x
2018-10-13 16:20:05,254 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: x
2018-10-13 16:20:05,254 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,254 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: (i)
2018-10-13 16:20:05,255 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtThisAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtThisAccessImpl: 
2018-10-13 16:20:05,255 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Foo
2018-10-13 16:20:05,255 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,255 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: spoon.test.filters.testclasses.Foo
2018-10-13 16:20:05,255 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Foo
2018-10-13 16:20:05,256 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,256 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: i
2018-10-13 16:20:05,256 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Foo
2018-10-13 16:20:05,256 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,256 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,257 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: java.lang.System.out.println(z)
2018-10-13 16:20:05,258 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: java.lang.System.out
2018-10-13 16:20:05,258 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: java.lang.System
2018-10-13 16:20:05,258 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,258 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,259 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: java.lang.System.out
2018-10-13 16:20:05,259 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,259 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,259 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,259 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,260 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: println(int)
2018-10-13 16:20:05,260 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,260 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,260 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,260 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,260 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtVariableReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtVariableReadImpl: z
2018-10-13 16:20:05,261 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: z
2018-10-13 16:20:05,261 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,261 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.SuppressWarnings("foo")
int bar() {
    if (0 == 1) {
        throw new java.lang.RuntimeException();
    }
    return i;
}
2018-10-13 16:20:05,261 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.SuppressWarnings("foo")
2018-10-13 16:20:05,261 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.SuppressWarnings
2018-10-13 16:20:05,262 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,262 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.SuppressWarnings
2018-10-13 16:20:05,262 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,262 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: "foo"
2018-10-13 16:20:05,262 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,262 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,262 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,263 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    if (0 == 1) {
        throw new java.lang.RuntimeException();
    }
    return i;
}
2018-10-13 16:20:05,263 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtIfImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtIfImpl: if (0 == 1) {
    throw new java.lang.RuntimeException();
}
2018-10-13 16:20:05,263 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBinaryOperatorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBinaryOperatorImpl: 0 == 1
2018-10-13 16:20:05,264 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: boolean
2018-10-13 16:20:05,264 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 0
2018-10-13 16:20:05,264 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,264 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 1
2018-10-13 16:20:05,264 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,264 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    throw new java.lang.RuntimeException();
}
2018-10-13 16:20:05,265 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtThrowImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtThrowImpl: throw new java.lang.RuntimeException()
2018-10-13 16:20:05,265 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtConstructorCallImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorCallImpl: new java.lang.RuntimeException()
2018-10-13 16:20:05,265 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: java.lang.RuntimeException()
2018-10-13 16:20:05,265 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.RuntimeException
2018-10-13 16:20:05,265 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,266 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.RuntimeException
2018-10-13 16:20:05,266 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,266 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtReturnImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtReturnImpl: return i
2018-10-13 16:20:05,266 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: i
2018-10-13 16:20:05,267 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtThisAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtThisAccessImpl: 
2018-10-13 16:20:05,267 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Foo
2018-10-13 16:20:05,267 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,267 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: spoon.test.filters.testclasses.Foo
2018-10-13 16:20:05,267 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Foo
2018-10-13 16:20:05,268 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,268 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: i
2018-10-13 16:20:05,268 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Foo
2018-10-13 16:20:05,268 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,268 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,268 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: FooLine() {
}
2018-10-13 16:20:05,269 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-10-13 16:20:05,269 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-10-13 16:20:05,269 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: java.lang.Object()
2018-10-13 16:20:05,269 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-10-13 16:20:05,269 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,269 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-10-13 16:20:05,270 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,270 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: void simple() {
    int x = 3;
    int z = 0;
    java.lang.System.out.println(z);
}
2018-10-13 16:20:05,270 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,271 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    int x = 3;
    int z = 0;
    java.lang.System.out.println(z);
}
2018-10-13 16:20:05,271 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLocalVariableImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableImpl: int x = 3
2018-10-13 16:20:05,271 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,271 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 3
2018-10-13 16:20:05,271 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,272 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLocalVariableImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableImpl: int z = 0
2018-10-13 16:20:05,272 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,272 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 0
2018-10-13 16:20:05,272 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,272 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: java.lang.System.out.println(z)
2018-10-13 16:20:05,272 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: java.lang.System.out
2018-10-13 16:20:05,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: java.lang.System
2018-10-13 16:20:05,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: java.lang.System.out
2018-10-13 16:20:05,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: println(int)
2018-10-13 16:20:05,274 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,274 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,274 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,274 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,274 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtVariableReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtVariableReadImpl: z
2018-10-13 16:20:05,274 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: z
2018-10-13 16:20:05,274 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,275 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: void loopBlock() {
    for (int i = 0; i < 10; i++) {
        java.lang.System.out.println(i);
    }
}
2018-10-13 16:20:05,275 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,275 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    for (int i = 0; i < 10; i++) {
        java.lang.System.out.println(i);
    }
}
2018-10-13 16:20:05,276 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtForImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtForImpl: for (int i = 0; i < 10; i++) {
    java.lang.System.out.println(i);
}
2018-10-13 16:20:05,276 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLocalVariableImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableImpl: int i = 0
2018-10-13 16:20:05,276 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,276 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 0
2018-10-13 16:20:05,276 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,276 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBinaryOperatorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBinaryOperatorImpl: i < 10
2018-10-13 16:20:05,276 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: boolean
2018-10-13 16:20:05,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtVariableReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtVariableReadImpl: i
2018-10-13 16:20:05,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: i
2018-10-13 16:20:05,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 10
2018-10-13 16:20:05,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtUnaryOperatorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtUnaryOperatorImpl: i++
2018-10-13 16:20:05,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtVariableWriteImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtVariableWriteImpl: i
2018-10-13 16:20:05,278 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: i
2018-10-13 16:20:05,278 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,278 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    java.lang.System.out.println(i);
}
2018-10-13 16:20:05,278 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: java.lang.System.out.println(i)
2018-10-13 16:20:05,278 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: java.lang.System.out
2018-10-13 16:20:05,279 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: java.lang.System
2018-10-13 16:20:05,279 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,279 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,279 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: java.lang.System.out
2018-10-13 16:20:05,279 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,279 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,279 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,279 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,280 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: println(int)
2018-10-13 16:20:05,280 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,280 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,280 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,280 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,280 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtVariableReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtVariableReadImpl: i
2018-10-13 16:20:05,280 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: i
2018-10-13 16:20:05,280 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,281 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: void loopNoBlock() {
    for (int i = 0; i < 10; i++)
        java.lang.System.out.println(i);

}
2018-10-13 16:20:05,281 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,281 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    for (int i = 0; i < 10; i++)
        java.lang.System.out.println(i);

}
2018-10-13 16:20:05,282 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtForImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtForImpl: for (int i = 0; i < 10; i++)
    java.lang.System.out.println(i);

2018-10-13 16:20:05,282 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLocalVariableImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableImpl: int i = 0
2018-10-13 16:20:05,282 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,282 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 0
2018-10-13 16:20:05,282 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,282 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBinaryOperatorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBinaryOperatorImpl: i < 10
2018-10-13 16:20:05,282 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: boolean
2018-10-13 16:20:05,282 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtVariableReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtVariableReadImpl: i
2018-10-13 16:20:05,282 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: i
2018-10-13 16:20:05,283 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,283 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 10
2018-10-13 16:20:05,283 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,283 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtUnaryOperatorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtUnaryOperatorImpl: i++
2018-10-13 16:20:05,283 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,283 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtVariableWriteImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtVariableWriteImpl: i
2018-10-13 16:20:05,283 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: i
2018-10-13 16:20:05,283 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,284 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: java.lang.System.out.println(i);

2018-10-13 16:20:05,284 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: java.lang.System.out.println(i)
2018-10-13 16:20:05,284 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: java.lang.System.out
2018-10-13 16:20:05,284 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: java.lang.System
2018-10-13 16:20:05,284 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: java.lang.System.out
2018-10-13 16:20:05,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: println(int)
2018-10-13 16:20:05,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,286 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,286 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,286 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtVariableReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtVariableReadImpl: i
2018-10-13 16:20:05,286 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: i
2018-10-13 16:20:05,286 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,286 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: void loopNoBody() {
    for (int i = 0; i < 10; i++);
}
2018-10-13 16:20:05,286 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    for (int i = 0; i < 10; i++);
}
2018-10-13 16:20:05,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtForImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtForImpl: for (int i = 0; i < 10; i++);
2018-10-13 16:20:05,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLocalVariableImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableImpl: int i = 0
2018-10-13 16:20:05,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 0
2018-10-13 16:20:05,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBinaryOperatorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBinaryOperatorImpl: i < 10
2018-10-13 16:20:05,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: boolean
2018-10-13 16:20:05,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtVariableReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtVariableReadImpl: i
2018-10-13 16:20:05,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: i
2018-10-13 16:20:05,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 10
2018-10-13 16:20:05,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtUnaryOperatorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtUnaryOperatorImpl: i++
2018-10-13 16:20:05,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtVariableWriteImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtVariableWriteImpl: i
2018-10-13 16:20:05,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: i
2018-10-13 16:20:05,289 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,289 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: void ifBlock() {
    if (3 < 4) {
        java.lang.System.out.println("if");
    }
}
2018-10-13 16:20:05,289 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,289 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    if (3 < 4) {
        java.lang.System.out.println("if");
    }
}
2018-10-13 16:20:05,290 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtIfImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtIfImpl: if (3 < 4) {
    java.lang.System.out.println("if");
}
2018-10-13 16:20:05,290 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBinaryOperatorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBinaryOperatorImpl: 3 < 4
2018-10-13 16:20:05,290 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: boolean
2018-10-13 16:20:05,290 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 3
2018-10-13 16:20:05,290 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,290 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 4
2018-10-13 16:20:05,290 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,291 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    java.lang.System.out.println("if");
}
2018-10-13 16:20:05,291 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: java.lang.System.out.println("if")
2018-10-13 16:20:05,291 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: java.lang.System.out
2018-10-13 16:20:05,291 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: java.lang.System
2018-10-13 16:20:05,291 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,291 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: java.lang.System.out
2018-10-13 16:20:05,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: println(java.lang.String)
2018-10-13 16:20:05,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,293 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,293 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,293 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: "if"
2018-10-13 16:20:05,293 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,293 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,293 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: void ifNoBlock() {
    if (3 < 4)
        java.lang.System.out.println("if");

}
2018-10-13 16:20:05,294 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,294 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    if (3 < 4)
        java.lang.System.out.println("if");

}
2018-10-13 16:20:05,294 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtIfImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtIfImpl: if (3 < 4)
    java.lang.System.out.println("if");

2018-10-13 16:20:05,294 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBinaryOperatorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBinaryOperatorImpl: 3 < 4
2018-10-13 16:20:05,294 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: boolean
2018-10-13 16:20:05,294 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 3
2018-10-13 16:20:05,295 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,295 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 4
2018-10-13 16:20:05,295 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,295 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: java.lang.System.out.println("if");

2018-10-13 16:20:05,295 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: java.lang.System.out.println("if")
2018-10-13 16:20:05,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: java.lang.System.out
2018-10-13 16:20:05,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: java.lang.System
2018-10-13 16:20:05,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: java.lang.System.out
2018-10-13 16:20:05,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,297 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,297 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: println(java.lang.String)
2018-10-13 16:20:05,297 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,297 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,297 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,297 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,297 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,297 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: "if"
2018-10-13 16:20:05,297 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,298 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,298 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: void switchBlock() {
    switch ("test") {
        case "test" :
            break;
        default :
            java.lang.System.out.println("switch");
    }
}
2018-10-13 16:20:05,298 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,298 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    switch ("test") {
        case "test" :
            break;
        default :
            java.lang.System.out.println("switch");
    }
}
2018-10-13 16:20:05,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtSwitchImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtSwitchImpl: switch ("test") {
    case "test" :
        break;
    default :
        java.lang.System.out.println("switch");
}
2018-10-13 16:20:05,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: "test"
2018-10-13 16:20:05,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCaseImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCaseImpl: case "test" :
    break;
2018-10-13 16:20:05,300 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: "test"
2018-10-13 16:20:05,300 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,300 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,300 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBreakImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBreakImpl: break
2018-10-13 16:20:05,301 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCaseImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCaseImpl: default :
    java.lang.System.out.println("switch");
2018-10-13 16:20:05,301 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: java.lang.System.out.println("switch")
2018-10-13 16:20:05,301 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: java.lang.System.out
2018-10-13 16:20:05,302 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: java.lang.System
2018-10-13 16:20:05,302 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,302 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,302 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: java.lang.System.out
2018-10-13 16:20:05,302 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,302 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,303 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,303 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,303 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: println(java.lang.String)
2018-10-13 16:20:05,303 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,303 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,303 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,304 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,304 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,304 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: "switch"
2018-10-13 16:20:05,304 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,304 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,305 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtInterfaceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInterfaceImpl: interface Honey {
    void honey();
}
2018-10-13 16:20:05,305 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: void honey();
2018-10-13 16:20:05,305 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,305 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtInterfaceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInterfaceImpl: interface IFoo {}
2018-10-13 16:20:05,306 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtInterfaceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInterfaceImpl: public interface ITostada extends spoon.test.filters.testclasses.IFoo {
    spoon.test.filters.testclasses.ITostada make();
}
2018-10-13 16:20:05,306 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.IFoo
2018-10-13 16:20:05,306 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,307 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: spoon.test.filters.testclasses.ITostada make();
2018-10-13 16:20:05,307 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-10-13 16:20:05,307 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,307 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCommentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCommentImpl: /**
Copyright (C) 2006-2015 INRIA and contributors
Spoon - http://spoon.gforge.inria.fr/

This software is governed by the CeCILL-C License under French law and
abiding by the rules of distribution of free software. You can use, modify
and/or redistribute the software under the terms of the CeCILL-C license as
circulated by CEA, CNRS and INRIA at http://www.cecill.info.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.

The fact that you are presently reading this means that you have had
knowledge of the CeCILL-C license and that you accept its terms. */
2018-10-13 16:20:05,307 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: SubTostada() {
}
2018-10-13 16:20:05,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-10-13 16:20:05,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-10-13 16:20:05,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: spoon.test.filters.testclasses.Tostada()
2018-10-13 16:20:05,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,309 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,309 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public void prepare() {
    java.lang.System.out.println("SubTostada");
    super.prepare();
}
2018-10-13 16:20:05,309 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-10-13 16:20:05,309 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,310 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,310 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,310 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,310 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,310 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    java.lang.System.out.println("SubTostada");
    super.prepare();
}
2018-10-13 16:20:05,310 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: java.lang.System.out.println("SubTostada")
2018-10-13 16:20:05,311 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: java.lang.System.out
2018-10-13 16:20:05,311 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: java.lang.System
2018-10-13 16:20:05,311 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,311 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,311 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: java.lang.System.out
2018-10-13 16:20:05,311 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-10-13 16:20:05,311 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,311 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,311 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,312 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: println(java.lang.String)
2018-10-13 16:20:05,312 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-10-13 16:20:05,312 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-10-13 16:20:05,312 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,312 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,312 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,312 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: "SubTostada"
2018-10-13 16:20:05,312 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,313 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,313 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super.prepare()
2018-10-13 16:20:05,313 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtSuperAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtSuperAccessImpl: super
2018-10-13 16:20:05,313 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: 
2018-10-13 16:20:05,313 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,313 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,313 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: prepare()
2018-10-13 16:20:05,313 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,314 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,314 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,314 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCommentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCommentImpl: /**
Copyright (C) 2006-2015 INRIA and contributors
Spoon - http://spoon.gforge.inria.fr/

This software is governed by the CeCILL-C License under French law and
abiding by the rules of distribution of free software. You can use, modify
and/or redistribute the software under the terms of the CeCILL-C license as
circulated by CEA, CNRS and INRIA at http://www.cecill.info.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.

The fact that you are presently reading this means that you have had
knowledge of the CeCILL-C license and that you accept its terms. */
2018-10-13 16:20:05,314 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-10-13 16:20:05,314 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,315 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: Tacos() {
}
2018-10-13 16:20:05,315 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-10-13 16:20:05,315 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-10-13 16:20:05,315 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: java.lang.Object()
2018-10-13 16:20:05,315 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-10-13 16:20:05,315 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,315 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-10-13 16:20:05,315 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,315 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public spoon.test.filters.testclasses.ITostada make() {
    return null;
}
2018-10-13 16:20:05,315 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-10-13 16:20:05,316 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,316 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,316 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,316 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,316 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-10-13 16:20:05,316 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,316 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    return null;
}
2018-10-13 16:20:05,316 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtReturnImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtReturnImpl: return null
2018-10-13 16:20:05,316 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: null
2018-10-13 16:20:05,316 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: <nulltype>
2018-10-13 16:20:05,317 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: public void prepare() {
    final java.util.ArrayList<java.lang.String> strings = new java.util.ArrayList<java.lang.String>();
    strings.size();
}
2018-10-13 16:20:05,317 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,317 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    final java.util.ArrayList<java.lang.String> strings = new java.util.ArrayList<java.lang.String>();
    strings.size();
}
2018-10-13 16:20:05,317 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLocalVariableImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableImpl: final java.util.ArrayList<java.lang.String> strings = new java.util.ArrayList<java.lang.String>()
2018-10-13 16:20:05,317 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList<java.lang.String>
2018-10-13 16:20:05,317 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-10-13 16:20:05,317 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,317 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,317 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtConstructorCallImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorCallImpl: new java.util.ArrayList<java.lang.String>()
2018-10-13 16:20:05,318 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: java.util.ArrayList()
2018-10-13 16:20:05,318 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-10-13 16:20:05,318 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-10-13 16:20:05,318 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList<java.lang.String>
2018-10-13 16:20:05,318 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-10-13 16:20:05,318 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,318 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,318 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: strings.size()
2018-10-13 16:20:05,318 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtVariableReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtVariableReadImpl: strings
2018-10-13 16:20:05,318 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: strings
2018-10-13 16:20:05,319 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList<java.lang.String>
2018-10-13 16:20:05,319 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-10-13 16:20:05,319 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,319 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,319 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: size()
2018-10-13 16:20:05,319 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-10-13 16:20:05,319 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-10-13 16:20:05,319 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,320 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCommentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCommentImpl: /**
Copyright (C) 2006-2015 INRIA and contributors
Spoon - http://spoon.gforge.inria.fr/

This software is governed by the CeCILL-C License under French law and
abiding by the rules of distribution of free software. You can use, modify
and/or redistribute the software under the terms of the CeCILL-C license as
circulated by CEA, CNRS and INRIA at http://www.cecill.info.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.

The fact that you are presently reading this means that you have had
knowledge of the CeCILL-C license and that you accept its terms. */
2018-10-13 16:20:05,320 INFO spoon.Launcher - Step 6) Skipped element, because CtFunction#accept(input) returned false
Parameter 1) CtMethodImpl: void honey();
2018-10-13 16:20:05,320 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada
2018-10-13 16:20:05,320 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,320 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Honey
2018-10-13 16:20:05,320 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,321 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: Tostada() {
}
2018-10-13 16:20:05,321 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-10-13 16:20:05,321 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-10-13 16:20:05,321 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: spoon.test.filters.testclasses.AbstractTostada()
2018-10-13 16:20:05,321 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada
2018-10-13 16:20:05,321 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,321 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada
2018-10-13 16:20:05,321 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,322 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public spoon.test.filters.testclasses.ITostada make() {
    return new spoon.test.filters.testclasses.Tostada() {
        @java.lang.Override
        public void prepare() {
            int a = 3;
            super.prepare();
        }
    };
}
2018-10-13 16:20:05,322 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-10-13 16:20:05,322 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,322 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,323 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,323 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,323 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-10-13 16:20:05,323 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,323 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    return new spoon.test.filters.testclasses.Tostada() {
        @java.lang.Override
        public void prepare() {
            int a = 3;
            super.prepare();
        }
    };
}
2018-10-13 16:20:05,324 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtReturnImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtReturnImpl: return new spoon.test.filters.testclasses.Tostada() {
    @java.lang.Override
    public void prepare() {
        int a = 3;
        super.prepare();
    }
}
2018-10-13 16:20:05,324 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtNewClassImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtNewClassImpl: new spoon.test.filters.testclasses.Tostada() {
    @java.lang.Override
    public void prepare() {
        int a = 3;
        super.prepare();
    }
}
2018-10-13 16:20:05,324 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: spoon.test.filters.testclasses.Tostada$1()
2018-10-13 16:20:05,325 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada.1
2018-10-13 16:20:05,325 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,325 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,325 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,325 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,325 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,325 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,326 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: 1() {
}
2018-10-13 16:20:05,326 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-10-13 16:20:05,326 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-10-13 16:20:05,326 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: spoon.test.filters.testclasses.Tostada()
2018-10-13 16:20:05,326 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,326 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,326 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,327 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,327 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public void prepare() {
    int a = 3;
    super.prepare();
}
2018-10-13 16:20:05,327 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-10-13 16:20:05,327 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,327 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,327 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,327 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,328 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,328 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    int a = 3;
    super.prepare();
}
2018-10-13 16:20:05,328 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLocalVariableImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableImpl: int a = 3
2018-10-13 16:20:05,328 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,328 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 3
2018-10-13 16:20:05,328 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-10-13 16:20:05,328 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super.prepare()
2018-10-13 16:20:05,329 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtSuperAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtSuperAccessImpl: super
2018-10-13 16:20:05,329 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: 
2018-10-13 16:20:05,329 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,329 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,329 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: prepare()
2018-10-13 16:20:05,330 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-10-13 16:20:05,330 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-10-13 16:20:05,330 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,330 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public void prepare() {
}
2018-10-13 16:20:05,330 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-10-13 16:20:05,330 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,330 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,331 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,331 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,331 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,331 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-10-13 16:20:05,331 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public java.lang.String toString() {
    return "";
}
2018-10-13 16:20:05,331 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-10-13 16:20:05,332 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,332 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,332 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,332 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,332 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,332 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,332 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    return "";
}
2018-10-13 16:20:05,333 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtReturnImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtReturnImpl: return ""
2018-10-13 16:20:05,333 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: ""
2018-10-13 16:20:05,333 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-10-13 16:20:05,333 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,333 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public void honey() {
}
2018-10-13 16:20:05,333 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-10-13 16:20:05,333 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,334 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,334 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-10-13 16:20:05,334 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-10-13 16:20:05,334 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,334 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-10-13 16:20:05,334 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: public void foo() {
}
2018-10-13 16:20:05,334 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-10-13 16:20:05,335 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-10-13 16:20:05,335 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCommentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCommentImpl: /**
Copyright (C) 2006-2015 INRIA and contributors
Spoon - http://spoon.gforge.inria.fr/

This software is governed by the CeCILL-C License under French law and
abiding by the rules of distribution of free software. You can use, modify
and/or redistribute the software under the terms of the CeCILL-C license as
circulated by CEA, CNRS and INRIA at http://www.cecill.info.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.

The fact that you are presently reading this means that you have had
knowledge of the CeCILL-C license and that you accept its terms. */
[INFO] Tests run: 43, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.765 s - in spoon.test.filters.FilterTest
[INFO] Running spoon.test.filters.CUFilterTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.175 s - in spoon.test.filters.CUFilterTest
[INFO] Running spoon.test.constructor.ConstructorTest
[INFO] Tests run: 7, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.606 s - in spoon.test.constructor.ConstructorTest
[INFO] Running spoon.test.sourcePosition.SourcePositionTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.164 s - in spoon.test.sourcePosition.SourcePositionTest
[INFO] Running spoon.test.compilation.CompilationTest
>> Hello: Bar <<
>> Hello: FooEx <<
>> Hello: IBar <<
>> Hello: SimpleProcessor <<
[INFO] Tests run: 13, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.21 s - in spoon.test.compilation.CompilationTest
[INFO] Running spoon.test.serializable.SourcePositionTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.042 s - in spoon.test.serializable.SourcePositionTest
[INFO] Running spoon.test.serializable.ModelStreamerTest
[ERROR] Tests run: 3, Failures: 3, Errors: 0, Skipped: 0, Time elapsed: 1.457 s <<< FAILURE! - in spoon.test.serializable.ModelStreamerTest
[ERROR] testDefaultCompressionType(spoon.test.serializable.ModelStreamerTest)  Time elapsed: 0.463 s  <<< FAILURE!
java.lang.AssertionError: Model before & after serialization must have the same number of elements
	at spoon.test.serializable.ModelStreamerTest.compareFactoryModels(ModelStreamerTest.java:90)
	at spoon.test.serializable.ModelStreamerTest.testDefaultCompressionType(ModelStreamerTest.java:61)

[ERROR] testNoneCompressionType(spoon.test.serializable.ModelStreamerTest)  Time elapsed: 0.643 s  <<< FAILURE!
java.lang.AssertionError: Model before & after serialization must have the same number of elements
	at spoon.test.serializable.ModelStreamerTest.compareFactoryModels(ModelStreamerTest.java:90)
	at spoon.test.serializable.ModelStreamerTest.testNoneCompressionType(ModelStreamerTest.java:77)

[ERROR] testGZipCompressionType(spoon.test.serializable.ModelStreamerTest)  Time elapsed: 0.35 s  <<< FAILURE!
java.lang.AssertionError: Model before & after serialization must have the same number of elements
	at spoon.test.serializable.ModelStreamerTest.compareFactoryModels(ModelStreamerTest.java:90)
	at spoon.test.serializable.ModelStreamerTest.testGZipCompressionType(ModelStreamerTest.java:69)

[INFO] Running spoon.test.serializable.SerializableTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.159 s - in spoon.test.serializable.SerializableTest
[INFO] Running spoon.test.processing.ProcessingTest
[INFO] Tests run: 10, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.471 s - in spoon.test.processing.ProcessingTest
[INFO] Running spoon.test.reflect.visitor.ReferenceQueryTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.067 s - in spoon.test.reflect.visitor.ReferenceQueryTest
[INFO] Running spoon.test.eval.EvalTest
[INFO] Tests run: 10, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.978 s - in spoon.test.eval.EvalTest
[INFO] Running spoon.test.comparison.EqualTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.311 s - in spoon.test.comparison.EqualTest
[INFO] Running spoon.test.architecture.SpoonArchitectureEnforcerTest
2018-10-13 16:20:53,787 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c2 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:14)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.Launcher.buildModel(Launcher.java:767)
	at spoon.test.architecture.SpoonArchitectureEnforcerTest.testGoodTestClassNames(SpoonArchitectureEnforcerTest.java:241)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:20:53,788 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c5 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:17)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.Launcher.buildModel(Launcher.java:767)
	at spoon.test.architecture.SpoonArchitectureEnforcerTest.testGoodTestClassNames(SpoonArchitectureEnforcerTest.java:241)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:20:53,788 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c6 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:18)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.Launcher.buildModel(Launcher.java:767)
	at spoon.test.architecture.SpoonArchitectureEnforcerTest.testGoodTestClassNames(SpoonArchitectureEnforcerTest.java:241)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-10-13 16:20:53,789 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c7 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/position/testclasses/Expressions.java:19)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:375)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:435)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:154)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:114)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:446)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:374)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:339)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:122)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:105)
	at spoon.Launcher.buildModel(Launcher.java:767)
	at spoon.test.architecture.SpoonArchitectureEnforcerTest.testGoodTestClassNames(SpoonArchitectureEnforcerTest.java:241)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
[ERROR] Tests run: 8, Failures: 2, Errors: 0, Skipped: 0, Time elapsed: 46.502 s <<< FAILURE! - in spoon.test.architecture.SpoonArchitectureEnforcerTest
[ERROR] testSrcMainJava(spoon.test.architecture.SpoonArchitectureEnforcerTest)  Time elapsed: 25.095 s  <<< FAILURE!
java.lang.AssertionError: 
6 public methods should be documented with proper API documentation: 
spoon.reflect.visitor.CommentHelper#printComment(spoon.reflect.visitor.PrinterHelper,spoon.reflect.code.CtComment)
spoon.support.javadoc.Javadoc#parse(java.lang.String)
spoon.support.javadoc.JavadocBlockTag#toText()
spoon.support.javadoc.JavadocDescription#parseText(java.lang.String)
spoon.support.javadoc.JavadocDescriptionElement#toText()
spoon.support.javadoc.JavadocInlineTag#fromText(java.lang.String)
	at spoon.test.architecture.SpoonArchitectureEnforcerTest.testSrcMainJava(SpoonArchitectureEnforcerTest.java:191)

[ERROR] testSpecPackage(spoon.test.architecture.SpoonArchitectureEnforcerTest)  Time elapsed: 4.278 s  <<< FAILURE!
java.lang.AssertionError: 
you have created a new package or removed an existing one, please declare it explicitly in SpoonArchitectureEnforcerTest#testSpecPackage

Details: Package spoon.support.javadoc presents in computed but not expected set.
	at spoon.test.architecture.SpoonArchitectureEnforcerTest.assertSetEquals(SpoonArchitectureEnforcerTest.java:437)
	at spoon.test.architecture.SpoonArchitectureEnforcerTest.testSpecPackage(SpoonArchitectureEnforcerTest.java:428)

[INFO] Running spoon.test.ctBodyHolder.CtBodyHolderTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.3 s - in spoon.test.ctBodyHolder.CtBodyHolderTest
[INFO] Running spoon.test.javadoc.JavaDocTest
[ERROR] Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.083 s <<< FAILURE! - in spoon.test.javadoc.JavaDocTest
[ERROR] testJavaDocReprint(spoon.test.javadoc.JavaDocTest)  Time elapsed: 0.044 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:<...s Bar {
    /**
    [ * Creates an annotation type.
     *
     * @param owner
     * 		the package of the annotation type
     * @param simpleName
    ] * 		the name of ann...> but was:<...s Bar {
    /**
    [Creates an annotation type.

    @param owner the package of the annotation type
    @param simpleName the name of annotation
     *
     * @param owner * 		the package of the annotation type
     * @param simpleName * 		the name of annotation
     * @param owner * 		the package of the annotation type
     * @param simpleName * 		the name of annotation
     * @param owner * 		the package of the annotation type
     * @param simpleName * 		the name of annotation
     * @param owner * 		the package of the annotation type
     * @param simpleName * 		the name of annotation
     * @param owner * 		the package of the annotation type
     * @param simpleName] * 		the name of ann...>
	at spoon.test.javadoc.JavaDocTest.testJavaDocReprint(JavaDocTest.java:48)

[INFO] Running spoon.test.literal.LiteralTest
2018-10-13 16:21:02,196 ERROR spoon.support.compiler.jdt.JDTTreeBuilder - Could not find declaration for variable Longs at (/root/workspace/INRIA/spoon/441002125/src/test/resources/noclasspath/SecondaryIndexManager.java:611)
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.689 s - in spoon.test.literal.LiteralTest
[INFO] Running spoon.test.field.FieldTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.198 s - in spoon.test.field.FieldTest
[INFO] Running spoon.test.parameters.ParameterTest
2018-10-13 16:21:03,069 ERROR spoon.support.compiler.jdt.JDTTreeBuilder - Could not find declaration for variable typeRatingFilters at (/root/workspace/INRIA/spoon/441002125/src/test/resources/noclasspath/Tacos.java:4)
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.147 s - in spoon.test.parameters.ParameterTest
[INFO] Running spoon.test.limits.utils.InternalTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.075 s - in spoon.test.limits.utils.InternalTest
[INFO] Running spoon.test.secondaryclasses.ClassesTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.241 s - in spoon.test.secondaryclasses.ClassesTest
[INFO] Running spoon.test.factory.CodeFactoryTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.test.factory.CodeFactoryTest
[INFO] Running spoon.test.factory.ConstructorFactoryTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.036 s - in spoon.test.factory.ConstructorFactoryTest
[INFO] Running spoon.test.factory.FieldFactoryTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.112 s - in spoon.test.factory.FieldFactoryTest
[INFO] Running spoon.test.factory.TypeFactoryTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.139 s - in spoon.test.factory.TypeFactoryTest
[INFO] Running spoon.test.factory.ClassFactoryTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.test.factory.ClassFactoryTest
[INFO] Running spoon.test.factory.AnnotationFactoryTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.047 s - in spoon.test.factory.AnnotationFactoryTest
[INFO] Running spoon.test.factory.FactoryTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.162 s - in spoon.test.factory.FactoryTest
[INFO] Running spoon.test.factory.ExecutableFactoryTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.test.factory.ExecutableFactoryTest
[INFO] Running spoon.test.query_function.testclasses.VariableReferencesModelTest
[INFO] Tests run: 15, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.002 s - in spoon.test.query_function.testclasses.VariableReferencesModelTest
[INFO] Running spoon.test.query_function.VariableReferencesTest
2018-10-13 16:21:03,917 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:21:03,917 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:21:03,917 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:21:03,917 INFO spoon.Launcher - running Spoon...
2018-10-13 16:21:03,917 INFO spoon.Launcher - start processing...
2018-10-13 16:21:03,973 INFO spoon.Launcher - end of processing: 
2018-10-13 16:21:03,973 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:21:04,001 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:21:04,001 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:21:04,002 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:21:04,002 INFO spoon.Launcher - running Spoon...
2018-10-13 16:21:04,002 INFO spoon.Launcher - start processing...
2018-10-13 16:21:04,055 INFO spoon.Launcher - end of processing: 
2018-10-13 16:21:04,056 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:21:04,083 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:21:04,084 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:21:04,084 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:21:04,084 INFO spoon.Launcher - running Spoon...
2018-10-13 16:21:04,084 INFO spoon.Launcher - start processing...
2018-10-13 16:21:04,137 INFO spoon.Launcher - end of processing: 
2018-10-13 16:21:04,138 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:21:04,142 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:21:04,142 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:21:04,143 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:21:04,143 INFO spoon.Launcher - running Spoon...
2018-10-13 16:21:04,143 INFO spoon.Launcher - start processing...
2018-10-13 16:21:04,196 INFO spoon.Launcher - end of processing: 
2018-10-13 16:21:04,196 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:21:04,224 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:21:04,224 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:21:04,224 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:21:04,224 INFO spoon.Launcher - running Spoon...
2018-10-13 16:21:04,224 INFO spoon.Launcher - start processing...
2018-10-13 16:21:04,387 INFO spoon.Launcher - end of processing: 
2018-10-13 16:21:04,387 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:21:04,393 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:21:04,393 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:21:04,393 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:21:04,393 INFO spoon.Launcher - running Spoon...
2018-10-13 16:21:04,393 INFO spoon.Launcher - start processing...
2018-10-13 16:21:04,446 INFO spoon.Launcher - end of processing: 
2018-10-13 16:21:04,446 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:21:04,451 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:21:04,451 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:21:04,452 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:21:04,452 INFO spoon.Launcher - running Spoon...
2018-10-13 16:21:04,452 INFO spoon.Launcher - start processing...
2018-10-13 16:21:04,503 INFO spoon.Launcher - end of processing: 
2018-10-13 16:21:04,503 INFO spoon.Launcher - no errors, no warnings
2018-10-13 16:21:04,544 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:21:04,545 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:21:04,545 INFO spoon.Launcher - Spoon version 7.2.0-SNAPSHOT
2018-10-13 16:21:04,545 INFO spoon.Launcher - running Spoon...
2018-10-13 16:21:04,545 INFO spoon.Launcher - start processing...
2018-10-13 16:21:04,594 INFO spoon.Launcher - end of processing: 
2018-10-13 16:21:04,595 INFO spoon.Launcher - no errors, no warnings
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.719 s - in spoon.test.query_function.VariableReferencesTest
[INFO] Running spoon.test.control.ControlTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.077 s - in spoon.test.control.ControlTest
[INFO] Running spoon.test.change.ChangeCollectorTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.039 s - in spoon.test.change.ChangeCollectorTest
[INFO] Running spoon.test.jar.JarTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.114 s - in spoon.test.jar.JarTest
[INFO] Running spoon.test.method.MethodTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.216 s - in spoon.test.method.MethodTest
[INFO] Running spoon.test.replace.ReplaceTest
[INFO] Tests run: 17, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.039 s - in spoon.test.replace.ReplaceTest
[INFO] Running spoon.test.replace.ReplaceParametrizedTest
[INFO] Tests run: 80, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.132 s - in spoon.test.replace.ReplaceParametrizedTest
[INFO] Running spoon.test.initializers.InitializerTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.08 s - in spoon.test.initializers.InitializerTest
[INFO] Running spoon.test.strings.StringLiteralTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.04 s - in spoon.test.strings.StringLiteralTest
[INFO] Running spoon.test.strings.StringTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.039 s - in spoon.test.strings.StringTest
[INFO] Running spoon.test.delete.DeleteTest
[INFO] Tests run: 14, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.568 s - in spoon.test.delete.DeleteTest
[INFO] Running spoon.test.logging.LogTest
2018-10-13 16:21:06,998 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:21:06,999 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:21:06,999 DEBUG spoon.Launcher - destination: /root/workspace/INRIA/spoon/441002125/spooned-classes
2018-10-13 16:21:06,999 DEBUG spoon.Launcher - source classpath: null
2018-10-13 16:21:06,999 DEBUG spoon.Launcher - template classpath: []
2018-10-13 16:21:06,999 INFO spoon.Launcher - Log info
2018-10-13 16:21:06,999 WARN spoon.Launcher - Log warn
2018-10-13 16:21:06,999 ERROR spoon.Launcher - Log error
2018-10-13 16:21:07,000 DEBUG spoon.Launcher - Log debug
2018-10-13 16:21:07,000 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:21:07,000 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:21:07,000 DEBUG spoon.Launcher - destination: /root/workspace/INRIA/spoon/441002125/spooned-classes
2018-10-13 16:21:07,000 DEBUG spoon.Launcher - source classpath: null
2018-10-13 16:21:07,000 DEBUG spoon.Launcher - template classpath: []
2018-10-13 16:21:07,001 INFO spoon.Launcher - Log info
2018-10-13 16:21:07,001 WARN spoon.Launcher - Log warn
2018-10-13 16:21:07,001 ERROR spoon.Launcher - Log error
2018-10-13 16:21:07,001 DEBUG spoon.Launcher - Log debug
2018-10-13 16:21:07,001 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:21:07,001 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:21:07,002 INFO spoon.Launcher - Log info
2018-10-13 16:21:07,002 WARN spoon.Launcher - Log warn
2018-10-13 16:21:07,002 ERROR spoon.Launcher - Log error
2018-10-13 16:21:07,002 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-10-13 16:21:07,002 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-10-13 16:21:07,003 WARN spoon.Launcher - Log warn
2018-10-13 16:21:07,003 ERROR spoon.Launcher - Log error
2018-10-13 16:21:07,004 ERROR spoon.Launcher - Log error
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.006 s - in spoon.test.logging.LogTest
[INFO] Running spoon.test.varargs.VarArgsTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.037 s - in spoon.test.varargs.VarArgsTest
[INFO] Running spoon.test.ctBlock.TestCtBlock
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.116 s - in spoon.test.ctBlock.TestCtBlock
[INFO] Running spoon.test.casts.CastTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.199 s - in spoon.test.casts.CastTest
[INFO] Running spoon.test.ctElement.MetadataTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.037 s - in spoon.test.ctElement.MetadataTest
[INFO] Running spoon.test.ctElement.ElementTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.test.ctElement.ElementTest
[INFO] Running spoon.test.methodreference.MethodReferenceTest
[INFO] Tests run: 13, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.424 s - in spoon.test.methodreference.MethodReferenceTest
[INFO] Running spoon.test.signature.SignatureTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.649 s - in spoon.test.signature.SignatureTest
[INFO] Running spoon.test.labels.TestLabels
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.039 s - in spoon.test.labels.TestLabels
[INFO] Running spoon.test.ctCase.SwitchCaseTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.073 s - in spoon.test.ctCase.SwitchCaseTest
[INFO] Running spoon.test.role.TestCtRole
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.003 s - in spoon.test.role.TestCtRole
[INFO] Running spoon.test.snippets.SnippetTest
[INFO] Tests run: 7, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.377 s - in spoon.test.snippets.SnippetTest
[INFO] Running spoon.test.compilationunit.TestCompilationUnit
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.237 s - in spoon.test.compilationunit.TestCompilationUnit
[INFO] Running spoon.test.compilationunit.GetBinaryFilesTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.394 s - in spoon.test.compilationunit.GetBinaryFilesTest
[INFO] Running spoon.reflect.declaration.CtTypeInformationTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.542 s - in spoon.reflect.declaration.CtTypeInformationTest
[INFO] Running spoon.reflect.declaration.UnknownDeclarationTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.reflect.declaration.UnknownDeclarationTest
[INFO] Running spoon.reflect.visitor.CtIteratorTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.134 s - in spoon.reflect.visitor.CtIteratorTest
[INFO] Running spoon.reflect.visitor.CtScannerTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 28.79 s - in spoon.reflect.visitor.CtScannerTest
[INFO] Running spoon.reflect.visitor.CtVisitorTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.925 s - in spoon.reflect.visitor.CtVisitorTest
[INFO] Running spoon.reflect.visitor.CtInheritanceScannerTest
[INFO] Tests run: 82, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.417 s - in spoon.reflect.visitor.CtInheritanceScannerTest
[INFO] Running spoon.reflect.visitor.CtInheritanceScannerMethodsTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.937 s - in spoon.reflect.visitor.CtInheritanceScannerMethodsTest
[INFO] Running spoon.reflect.ast.CloneTest
[ERROR] Tests run: 5, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 5.955 s <<< FAILURE! - in spoon.reflect.ast.CloneTest
[ERROR] testCloneListener(spoon.reflect.ast.CloneTest)  Time elapsed: 1.048 s  <<< FAILURE!
java.lang.AssertionError: 
Source and Target are not equal expected:</**
A visitor for generating Java code from the program compile-time model.
 */
public class DefaultJavaPrettyPrinter implements spoon.reflect.visitor.CtVisitor , spoon.reflect.visitor.PrettyPrinter {
    /**
    Java file extension (.java).
     */
    public static final java.lang.String JAVA_FILE_EXTENSION = ".java";

    /**
    Package declaration file name.
     */
    public static final java.lang.String JAVA_PACKAGE_DECLARATION = "package-info" + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);

    /**
    Module declaration file name.
     */
    public static final java.lang.String JAVA_MODULE_DECLARATION = "module-info" + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);

    /**
    Line separator which is used by the system
     */
    public static final java.lang.String LINE_SEPARATOR = java.lang.System.getProperty("line.separator");

    /**
    The star at the beginning of a block/JavaDoc comment line
     */
    public static final java.lang.String COMMENT_STAR = " * ";

    /**
    The end of a block/JavaDoc comment
     */
    public static final java.lang.String BLOCK_COMMENT_END = " */";

    /**
    The beginning of a JavaDoc comment
     */
    public static final java.lang.String JAVADOC_START = "/**";

    /**
    The beginning of an inline comment
     */
    public static final java.lang.String INLINE_COMMENT_START = "// ";

    /**
    The beginning of a block comment
     */
    public static final java.lang.String BLOCK_COMMENT_START = "/* ";

    /**
    The printing context.

    since Spoon 7.1.0, use {{@link #getContext()}}
     */
    private spoon.reflect.visitor.PrintingContext context = new spoon.reflect.visitor.PrintingContext();

    /**
    get the import scanner of this pretty printer
     */
    public spoon.reflect.visitor.ImportScanner getImportsContext() {
        return importsContext;
    }

    /**
    Handle imports of classes.
     */
    private spoon.reflect.visitor.ImportScanner importsContext;

    /**
    Environment which Spoon is executed.
     */
    protected spoon.compiler.Environment env;

    /**
    Token detector, which delegates tokens to {@link TokenWriter}
     */
    private spoon.reflect.visitor.TokenWriter printer;

    /**
    Element printer helper.
     */
    private spoon.reflect.visitor.ElementPrinterHelper elementPrinterHelper;

    /**
    Compilation unit we are printing.
     */
    protected spoon.reflect.cu.CompilationUnit sourceCompilationUnit;

    /**
    Imports computed
     */
    java.util.Set<spoon.reflect.declaration.CtImport> imports;

    /**
    Creates a new code generator visitor.
     */
    public DefaultJavaPrettyPrinter(spoon.compiler.Environment env) {
        this.env = env;
        this.imports = new java.util.HashSet<>();
        setPrinterTokenWriter(new spoon.reflect.visitor.DefaultTokenWriter(new spoon.reflect.visitor.PrinterHelper(env)));
        if (env.isAutoImports()) {
            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();
        }else {
            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();
        }
    }

    /**

    @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
    defined by System.getProperty("line.separator")
     *
     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
     * defined by System.getProperty("line.separator")
     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
     * defined by System.getProperty("line.separator")
     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
     * defined by System.getProperty("line.separator")
     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
     * defined by System.getProperty("line.separator")
     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
     * defined by System.getProperty("line.separator")
     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
     * defined by System.getProperty("line.separator")
     */
    public java.lang.String getLineSeparator() {
        return getPrinterHelper().getLineSeparator();
    }

    /**

    @param lineSeparator characters which will be printed as End of line.
    By default there is System.getProperty("line.separator")
     *
     * @param lineSeparator * 		characters which will be printed as End of line.
     * 		By default there is System.getProperty("line.separator")
     * @param lineSeparator * 		characters which will be printed as End of line.
     * 		By default there is System.getProperty("line.separator")
     * @param lineSeparator * 		characters which will be printed as End of line.
     * 		By default there is System.getProperty("line.separator")
     * @param lineSeparator * 		characters which will be printed as End of line.
     * 		By default there is System.getProperty("line.separator")
     * @param lineSeparator * 		characters which will be printed as End of line.
     * 		By default there is System.getProperty("line.separator")
     * @param lineSeparator * 		characters which will be printed as End of line.
     * 		By default there is System.getProperty("line.separator")
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter setLineSeparator(java.lang.String lineSeparator) {
        getPrinterHelper().setLineSeparator(lineSeparator);
        return this;
    }

    /**
    Enters an expression.
     */
    protected void enterCtExpression(spoon.reflect.code.CtExpression<?> e) {
        if (!(e instanceof spoon.reflect.code.CtStatement)) {
            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        }
        getPrinterHelper().mapLine(e, sourceCompilationUnit);
        if (shouldSetBracket(e)) {
            context.parenthesedExpression.push(e);
            printer.writeSeparator("(");
        }
        if (!(e.getTypeCasts().isEmpty())) {
            for (spoon.reflect.reference.CtTypeReference<?> r : e.getTypeCasts()) {
                printer.writeSeparator("(");
                scan(r);
                printer.writeSeparator(")").writeSpace();
                printer.writeSeparator("(");
                context.parenthesedExpression.push(e);
            }
        }
    }

    /**
    Enters a statement.
     */
    protected void enterCtStatement(spoon.reflect.code.CtStatement s) {
        elementPrinterHelper.writeComment(s, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        getPrinterHelper().mapLine(s, sourceCompilationUnit);
        if (!(context.isNextForVariable())) {
            // TODO AnnotationLoopTest#testAnnotationDeclaredInForInit expects that annotations of next for variables are not printed
            // but may be correct is that the next variables are not annotated, because they might have different annotation then first param!
            elementPrinterHelper.writeAnnotations(s);
        }
        if ((!(context.isFirstForVariable())) && (!(context.isNextForVariable()))) {
            if ((s.getLabel()) != null) {
                printer.writeIdentifier(s.getLabel()).writeSpace().writeSeparator(":").writeSpace();
            }
        }
    }

    /**
    Exits a statement.
     */
    protected void exitCtStatement(spoon.reflect.code.CtStatement statement) {
        if (!((((((((((statement instanceof spoon.reflect.code.CtBlock) || (statement instanceof spoon.reflect.code.CtIf)) || (statement instanceof spoon.reflect.code.CtFor)) || (statement instanceof spoon.reflect.code.CtForEach)) || (statement instanceof spoon.reflect.code.CtWhile)) || (statement instanceof spoon.reflect.code.CtTry)) || (statement instanceof spoon.reflect.code.CtSwitch)) || (statement instanceof spoon.reflect.code.CtSynchronized)) || (statement instanceof spoon.reflect.declaration.CtClass)) || (statement instanceof spoon.reflect.code.CtComment))) {
            if (((context.isStatement(statement)) && (!(context.isFirstForVariable()))) && (!(context.isNextForVariable()))) {
                printer.writeSeparator(";");
            }
        }
        elementPrinterHelper.writeComment(statement, spoon.reflect.visitor.printer.CommentOffset.AFTER);
    }

    /**
    Exits an expression.
     */
    protected void exitCtExpression(spoon.reflect.code.CtExpression<?> e) {
        while ((!(context.parenthesedExpression.isEmpty())) && (e == (context.parenthesedExpression.peek()))) {
            context.parenthesedExpression.pop();
            printer.writeSeparator(")");
        } 
        if (!(e instanceof spoon.reflect.code.CtStatement)) {
            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);
        }
    }

    /**
    Make the imports for a given type.
     */
    private java.util.Collection<spoon.reflect.declaration.CtImport> computeImports(spoon.reflect.declaration.CtType<?> type) {
        context.currentTopLevel = type;
        importsContext.computeImports(context.currentTopLevel);
        return importsContext.getAllImports();
    }

    /**
    This method is called by {@link #scan(CtElement)} when entering a scanned element.
    To be overridden to implement specific behavior.

    Same KISS design as for {@link CtScanner}.
     */
    protected void enter(spoon.reflect.declaration.CtElement e) {
    }

    /**
    This method is called by {@link #scan(CtElement)} when entering a scanned element.
    To be overridden to implement specific behavior.
     */
    protected void exit(spoon.reflect.declaration.CtElement e) {
    }

    /**
    The generic scan method for an element.
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.declaration.CtElement e) {
        if (e != null) {
            enter(e);
            context.elementStack.push(e);
            if (env.isPreserveLineNumbers()) {
                if (!(e instanceof spoon.reflect.declaration.CtNamedElement)) {
                    getPrinterHelper().adjustStartPosition(e);
                }
            }
            try {
                e.accept(this);
            } catch (spoon.SpoonException ex) {
                throw ex;
            } catch (java.lang.Exception ex) {
                java.lang.String elementInfo = e.getClass().getName();
                elementInfo += (" on path " + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.getPath(e))) + "\n";
                if (e.getPosition().isValidPosition()) {
                    elementInfo += ("at position " + (e.getPosition().toString())) + " ";
                }
                throw new spoon.SpoonException((("Printing of " + elementInfo) + "failed"), ex);
            }
            context.elementStack.pop();
            exit(e);
        }
        return this;
    }

    private static java.lang.String getPath(spoon.reflect.declaration.CtElement ele) {
        java.lang.StringBuilder sb = new java.lang.StringBuilder();
        spoon.reflect.visitor.DefaultJavaPrettyPrinter.addParentPath(sb, ele);
        if (ele instanceof spoon.reflect.code.CtVariableAccess) {
            sb.append(':').append(((spoon.reflect.code.CtVariableAccess) (ele)).getVariable().getSimpleName());
        }
        return sb.toString();
    }

    private static void addParentPath(java.lang.StringBuilder sb, spoon.reflect.declaration.CtElement ele) {
        if ((ele == null) || ((ele instanceof spoon.reflect.declaration.CtPackage) && (((spoon.reflect.declaration.CtPackage) (ele)).isUnnamedPackage()))) {
            return;
        }
        if (ele.isParentInitialized()) {
            spoon.reflect.visitor.DefaultJavaPrettyPrinter.addParentPath(sb, ele.getParent());
        }
        sb.append("\n\t").append(ele.getClass().getSimpleName());
        if (ele instanceof spoon.reflect.declaration.CtNamedElement) {
            sb.append(":").append(((spoon.reflect.declaration.CtNamedElement) (ele)).getSimpleName());
        }else
            if (ele instanceof spoon.reflect.reference.CtReference) {
                sb.append(":").append(((spoon.reflect.reference.CtReference) (ele)).getSimpleName());
            }

    }

    private boolean shouldSetBracket(spoon.reflect.code.CtExpression<?> e) {
        if (!(e.getTypeCasts().isEmpty())) {
            return true;
        }
        try {
            if (((e.getParent()) instanceof spoon.reflect.code.CtBinaryOperator) || ((e.getParent()) instanceof spoon.reflect.code.CtUnaryOperator)) {
                return ((((e instanceof spoon.reflect.code.CtTargetedExpression) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator)) || (e instanceof spoon.reflect.code.CtBinaryOperator);
            }
            if ((e.getParent()) instanceof spoon.reflect.code.CtTargetedExpression) {
                return (((e instanceof spoon.reflect.code.CtBinaryOperator) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator);
            }
        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {
            // nothing we accept not to have a parent
        }
        return false;
    }

    /**
    Gets the currently pretty-printed string.
     */
    @java.lang.Override
    public java.lang.String toString() {
        return printer.getPrinterHelper().toString();
    }

    @java.lang.Override
    public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation<A> annotation) {
        elementPrinterHelper.writeAnnotations(annotation);
        printer.writeSeparator("@");
        scan(annotation.getAnnotationType());
        if (!(annotation.getValues().isEmpty())) {
            elementPrinterHelper.printList(annotation.getValues().entrySet(), null, false, "(", false, false, ",", true, false, ")", ( e) -> {
                if ((((annotation.getValues().size()) == 1) && ("value".equals(e.getKey()))) == false) {
                    // it is not a default value attribute. We must print a attribute name too.
                    printer.writeIdentifier(e.getKey()).writeSpace().writeOperator("=").writeSpace();
                }
                elementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());
            });
        }
    }

    @java.lang.Override
    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {
        visitCtType(annotationType);
        printer.writeSeparator("@").writeKeyword("interface").writeSpace().writeIdentifier(annotationType.getSimpleName()).writeSpace().writeSeparator("{").incTab();
        elementPrinterHelper.writeElementList(annotationType.getTypeMembers());
        printer.decTab().writeSeparator("}");
    }

    @java.lang.Override
    public void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable impl) {
        elementPrinterHelper.writeComment(impl);
        elementPrinterHelper.writeAnnotations(impl);
        elementPrinterHelper.writeModifiers(impl);
        scan(impl.getBody());
    }

    @java.lang.Override
    public <T> void visitCtArrayRead(spoon.reflect.code.CtArrayRead<T> arrayRead) {
        printCtArrayAccess(arrayRead);
    }

    @java.lang.Override
    public <T> void visitCtArrayWrite(spoon.reflect.code.CtArrayWrite<T> arrayWrite) {
        printCtArrayAccess(arrayWrite);
    }

    private <T, E extends spoon.reflect.code.CtExpression<?>> void printCtArrayAccess(spoon.reflect.code.CtArrayAccess<T, E> arrayAccess) {
        enterCtExpression(arrayAccess);
        scan(arrayAccess.getTarget());
        printer.writeSeparator("[");
        scan(arrayAccess.getIndexExpression());
        printer.writeSeparator("]");
        exitCtExpression(arrayAccess);
    }

    @java.lang.Override
    public <T> void visitCtArrayTypeReference(spoon.reflect.reference.CtArrayTypeReference<T> reference) {
        if (reference.isImplicit()) {
            return;
        }
        scan(reference.getComponentType());
        if (!(context.skipArray())) {
            printer.writeSeparator("[").writeSeparator("]");
        }
    }

    @java.lang.Override
    public <T> void visitCtAssert(spoon.reflect.code.CtAssert<T> asserted) {
        enterCtStatement(asserted);
        printer.writeKeyword("assert").writeSpace();
        scan(asserted.getAssertExpression());
        if ((asserted.getExpression()) != null) {
            printer.writeSpace().writeSeparator(":").writeSpace();
            scan(asserted.getExpression());
        }
        exitCtStatement(asserted);
    }

    @java.lang.Override
    public <T, A extends T> void visitCtAssignment(spoon.reflect.code.CtAssignment<T, A> assignement) {
        enterCtStatement(assignement);
        enterCtExpression(assignement);
        scan(assignement.getAssigned());
        printer.writeSpace().writeOperator("=").writeSpace();
        scan(assignement.getAssignment());
        exitCtExpression(assignement);
        exitCtStatement(assignement);
    }

    @java.lang.Override
    public <T> void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator<T> operator) {
        enterCtExpression(operator);
        scan(operator.getLeftHandOperand());
        printer.writeSpace();
        printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(operator.getKind()));
        printer.writeSpace();
        try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {
            if ((operator.getKind()) == (spoon.reflect.code.BinaryOperatorKind.INSTANCEOF)) {
                _context.forceWildcardGenerics(true);
            }
            scan(operator.getRightHandOperand());
        }
        exitCtExpression(operator);
    }

    @java.lang.Override
    public <R> void visitCtBlock(spoon.reflect.code.CtBlock<R> block) {
        enterCtStatement(block);
        if (!(block.isImplicit())) {
            printer.writeSeparator("{");
        }
        printer.incTab();
        for (spoon.reflect.code.CtStatement statement : block.getStatements()) {
            if (!(statement.isImplicit())) {
                printer.writeln();
                elementPrinterHelper.writeStatement(statement);
            }
        }
        printer.decTab();
        getPrinterHelper().adjustEndPosition(block);
        if (env.isPreserveLineNumbers()) {
            if (!(block.isImplicit())) {
                printer.writeSeparator("}");
            }
        }else {
            printer.writeln();
            if (!(block.isImplicit())) {
                printer.writeSeparator("}");
            }
        }
        exitCtStatement(block);
    }

    @java.lang.Override
    public void visitCtBreak(spoon.reflect.code.CtBreak breakStatement) {
        enterCtStatement(breakStatement);
        printer.writeKeyword("break");
        if ((breakStatement.getTargetLabel()) != null) {
            printer.writeSpace().writeKeyword(breakStatement.getTargetLabel());
        }
        exitCtStatement(breakStatement);
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("rawtypes")
    public <E> void visitCtCase(spoon.reflect.code.CtCase<E> caseStatement) {
        enterCtStatement(caseStatement);
        if ((caseStatement.getCaseExpression()) != null) {
            printer.writeKeyword("case").writeSpace();
            // writing enum case expression
            if ((caseStatement.getCaseExpression()) instanceof spoon.reflect.code.CtFieldAccess) {
                final spoon.reflect.reference.CtFieldReference variable = ((spoon.reflect.code.CtFieldAccess) (caseStatement.getCaseExpression())).getVariable();
                // In noclasspath mode, we don't have always the type of the declaring type.
                if ((((variable.getType()) != null) && ((variable.getDeclaringType()) != null)) && (variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName()))) {
                    printer.writeIdentifier(variable.getSimpleName());
                }else {
                    scan(caseStatement.getCaseExpression());
                }
            }else {
                scan(caseStatement.getCaseExpression());
            }
        }else {
            printer.writeKeyword("default");
        }
        printer.writeSpace().writeSeparator(":").incTab();
        for (spoon.reflect.code.CtStatement statement : caseStatement.getStatements()) {
            printer.writeln();
            elementPrinterHelper.writeStatement(statement);
        }
        printer.decTab();
        exitCtStatement(caseStatement);
    }

    @java.lang.Override
    public void visitCtCatch(spoon.reflect.code.CtCatch catchBlock) {
        elementPrinterHelper.writeComment(catchBlock, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        printer.writeSpace().writeKeyword("catch").writeSpace().writeSeparator("(");
        spoon.reflect.code.CtCatchVariable<? extends java.lang.Throwable> parameter = catchBlock.getParameter();
        if ((parameter != null) && ((parameter.getMultiTypes().size()) > 1)) {
            elementPrinterHelper.printList(parameter.getMultiTypes(), null, false, null, false, true, "|", true, false, null, ( type) -> scan(type));
            printer.writeSpace().writeIdentifier(parameter.getSimpleName());
        }else {
            scan(parameter);
        }
        printer.writeSeparator(")").writeSpace();
        scan(catchBlock.getBody());
    }

    @java.lang.Override
    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {
        context.pushCurrentThis(ctClass);
        if ((((ctClass.getSimpleName()) != null) && (!(spoon.reflect.declaration.CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName())))) && (!(ctClass.isAnonymous()))) {
            visitCtType(ctClass);
            if (ctClass.isLocalType()) {
                printer.writeKeyword("class").writeSpace().writeIdentifier(ctClass.getSimpleName().replaceAll("^[0-9]*", ""));
            }else {
                printer.writeKeyword("class").writeSpace().writeIdentifier(ctClass.getSimpleName());
            }
            elementPrinterHelper.writeFormalTypeParameters(ctClass);
            elementPrinterHelper.writeExtendsClause(ctClass);
            elementPrinterHelper.writeImplementsClause(ctClass);
        }
        printer.writeSpace().writeSeparator("{").incTab();
        elementPrinterHelper.writeElementList(ctClass.getTypeMembers());
        getPrinterHelper().adjustEndPosition(ctClass);
        printer.decTab().writeSeparator("}");
        context.popCurrentThis();
    }

    @java.lang.Override
    public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {
        elementPrinterHelper.writeAnnotations(typeParameter);
        printer.writeIdentifier(typeParameter.getSimpleName());
        if (((typeParameter.getSuperclass()) != null) && ((typeParameter.getSuperclass().isImplicit()) == false)) {
            printer.writeSpace().writeKeyword("extends").writeSpace();
            scan(typeParameter.getSuperclass());
        }
    }

    @java.lang.Override
    public <T> void visitCtConditional(spoon.reflect.code.CtConditional<T> conditional) {
        enterCtExpression(conditional);
        spoon.reflect.code.CtExpression<java.lang.Boolean> condition = conditional.getCondition();
        boolean parent;
        try {
            parent = ((conditional.getParent()) instanceof spoon.reflect.code.CtAssignment) || ((conditional.getParent()) instanceof spoon.reflect.declaration.CtVariable);
        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {
            // nothing if we have no parent
            parent = false;
        }
        if (parent) {
            printer.writeSeparator("(");
        }
        scan(condition);
        if (parent) {
            printer.writeSeparator(")");
        }
        printer.writeSpace().writeOperator("?").writeSpace();
        spoon.reflect.code.CtExpression<T> thenExpression = conditional.getThenExpression();
        scan(thenExpression);
        printer.writeSpace().writeOperator(":").writeSpace();
        spoon.reflect.code.CtExpression<T> elseExpression = conditional.getElseExpression();
        boolean isAssign;
        if (isAssign = elseExpression instanceof spoon.reflect.code.CtAssignment) {
            printer.writeSeparator("(");
        }
        scan(elseExpression);
        if (isAssign) {
            printer.writeSeparator(")");
        }
        exitCtExpression(conditional);
    }

    @java.lang.Override
    public <T> void visitCtConstructor(spoon.reflect.declaration.CtConstructor<T> constructor) {
        elementPrinterHelper.writeComment(constructor);
        elementPrinterHelper.visitCtNamedElement(constructor, sourceCompilationUnit);
        elementPrinterHelper.writeModifiers(constructor);
        elementPrinterHelper.writeFormalTypeParameters(constructor);
        if (!(constructor.getFormalCtTypeParameters().isEmpty())) {
            printer.writeSpace();
        }
        if ((constructor.getDeclaringType()) != null) {
            if (constructor.getDeclaringType().isLocalType()) {
                printer.writeIdentifier(constructor.getDeclaringType().getSimpleName().replaceAll("^[0-9]*", ""));
            }else {
                printer.writeIdentifier(constructor.getDeclaringType().getSimpleName());
            }
        }
        elementPrinterHelper.writeExecutableParameters(constructor);
        elementPrinterHelper.writeThrowsClause(constructor);
        printer.writeSpace();
        scan(constructor.getBody());
    }

    @java.lang.Override
    public void visitCtContinue(spoon.reflect.code.CtContinue continueStatement) {
        enterCtStatement(continueStatement);
        printer.writeKeyword("continue");
        if ((continueStatement.getTargetLabel()) != null) {
            printer.writeSpace().writeIdentifier(continueStatement.getTargetLabel());
        }
        exitCtStatement(continueStatement);
    }

    @java.lang.Override
    public void visitCtDo(spoon.reflect.code.CtDo doLoop) {
        enterCtStatement(doLoop);
        printer.writeKeyword("do");
        elementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());
        printer.writeKeyword("while").writeSpace().writeSeparator("(");
        scan(doLoop.getLoopingExpression());
        printer.writeSpace().writeSeparator(")");
        exitCtStatement(doLoop);
    }

    @java.lang.Override
    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {
        visitCtType(ctEnum);
        printer.writeKeyword("enum").writeSpace().writeIdentifier(ctEnum.getSimpleName());
        elementPrinterHelper.writeImplementsClause(ctEnum);
        context.pushCurrentThis(ctEnum);
        printer.writeSpace().writeSeparator("{").incTab().writeln();
        if (ctEnum.getEnumValues().isEmpty()) {
            printer.writeSeparator(";").writeln();
        }else {
            elementPrinterHelper.printList(ctEnum.getEnumValues(), null, false, null, false, false, ",", false, false, ";", ( enumValue) -> {
                printer.writeln();
                scan(enumValue);
            });
        }
        elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());
        printer.decTab().writeSeparator("}");
        context.popCurrentThis();
    }

    @java.lang.Override
    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {
        // it is not called during printing of sources. Use shortcut and print directly to PrinterHelper
        printer.getPrinterHelper().write(reference.getSignature());
    }

    @java.lang.Override
    public <T> void visitCtField(spoon.reflect.declaration.CtField<T> f) {
        elementPrinterHelper.writeComment(f, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        elementPrinterHelper.visitCtNamedElement(f, sourceCompilationUnit);
        elementPrinterHelper.writeModifiers(f);
        scan(f.getType());
        printer.writeSpace();
        printer.writeIdentifier(f.getSimpleName());
        if ((f.getDefaultExpression()) != null) {
            printer.writeSpace().writeOperator("=").writeSpace();
            scan(f.getDefaultExpression());
        }
        printer.writeSeparator(";");
        elementPrinterHelper.writeComment(f, spoon.reflect.visitor.printer.CommentOffset.AFTER);
    }

    @java.lang.Override
    public <T> void visitCtEnumValue(spoon.reflect.declaration.CtEnumValue<T> enumValue) {
        elementPrinterHelper.visitCtNamedElement(enumValue, sourceCompilationUnit);
        elementPrinterHelper.writeComment(enumValue, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        printer.writeIdentifier(enumValue.getSimpleName());
        if ((enumValue.getDefaultExpression()) != null) {
            spoon.reflect.code.CtConstructorCall<?> constructorCall = ((spoon.reflect.code.CtConstructorCall<?>) (enumValue.getDefaultExpression()));
            if (!(constructorCall.isImplicit())) {
                elementPrinterHelper.printList(constructorCall.getArguments(), null, false, "(", false, false, ",", true, false, ")", ( expr) -> scan(expr));
            }
            if (constructorCall instanceof spoon.reflect.code.CtNewClass) {
                scan(((spoon.reflect.code.CtNewClass<?>) (constructorCall)).getAnonymousClass());
            }
        }
    }

    @java.lang.Override
    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {
        printCtFieldAccess(fieldRead);
    }

    @java.lang.Override
    public <T> void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite<T> fieldWrite) {
        printCtFieldAccess(fieldWrite);
    }

    private boolean isImported(spoon.reflect.reference.CtFieldReference fieldReference) {
        spoon.reflect.declaration.CtImport fieldImport = fieldReference.getFactory().createImport(fieldReference);
        if (this.imports.contains(fieldImport)) {
            return true;
        }else {
            if ((fieldReference.getDeclaringType()) == null) {
                return false;
            }
            spoon.reflect.reference.CtTypeReference staticTypeMemberReference = fieldReference.getFactory().Type().createWildcardStaticTypeMemberReference(fieldReference.getDeclaringType());
            spoon.reflect.declaration.CtImport staticClassImport = fieldReference.getFactory().createImport(staticTypeMemberReference);
            return this.imports.contains(staticClassImport);
        }
    }

    private boolean isImported(spoon.reflect.reference.CtExecutableReference executableReference) {
        spoon.reflect.declaration.CtImport executableImport = executableReference.getFactory().createImport(executableReference);
        if (this.imports.contains(executableImport)) {
            return true;
        }else {
            if ((executableReference.getDeclaringType()) == null) {
                return false;
            }
            spoon.reflect.reference.CtTypeReference staticTypeMemberReference = executableReference.getFactory().Type().createWildcardStaticTypeMemberReference(executableReference.getDeclaringType());
            spoon.reflect.declaration.CtImport staticClassImport = executableReference.getFactory().createImport(staticTypeMemberReference);
            return this.imports.contains(staticClassImport);
        }
    }

    private <T> void printCtFieldAccess(spoon.reflect.code.CtFieldAccess<T> f) {
        enterCtExpression(f);
        try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {
            if (((f.getVariable().isStatic()) || ("class".equals(f.getVariable().getSimpleName()))) && ((f.getTarget()) instanceof spoon.reflect.code.CtTypeAccess)) {
                _context.ignoreGenerics(true);
            }
            spoon.reflect.code.CtExpression<?> target = f.getTarget();
            if (target != null) {
                boolean isInitializeStaticFinalField = isInitializeStaticFinalField(f.getTarget());
                boolean isStaticField = f.getVariable().isStatic();
                boolean isImportedField = this.isImported(f.getVariable());
                if ((!isInitializeStaticFinalField) && (!(isStaticField && isImportedField))) {
                    if ((target.isImplicit()) && (!(((f.getVariable().getFieldDeclaration()) == null) && (this.env.getNoClasspath())))) {
                        /* target is implicit, check whether there is no conflict with an local variable, catch variable or parameter
                        in case of conflict make it explicit, otherwise the field access is shadowed by that variable.
                        Search for potential variable declaration until we found a class which declares or inherits this field */
                        final spoon.reflect.declaration.CtField<?> field = f.getVariable().getFieldDeclaration();
                        if (field != null) {
                            final java.lang.String fieldName = field.getSimpleName();
                            spoon.reflect.declaration.CtVariable<?> var = f.getVariable().map(new spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction(fieldName)).first();
                            if (var != field) {
                                // another variable declaration was found which is hiding the field declaration for this field access. Make the field access explicit
                                target.setImplicit(false);
                            }
                        }else {
                            // There is a model inconsistency
                            printer.writeComment(f.getFactory().createComment((("ERROR: Missing field \"" + (f.getVariable().getSimpleName())) + "\", please check your model. The code may not compile."), spoon.reflect.code.CtComment.CommentType.BLOCK)).writeSpace();
                        }
                    }
                    // the implicit drives the separator
                    if (!(target.isImplicit())) {
                        scan(target);
                        printer.writeSeparator(".");
                    }
                }
                _context.ignoreStaticAccess(true);
            }
            scan(f.getVariable());
        }
        exitCtExpression(f);
    }

    /**
    Check if the target expression is a static final field initialized in a static anonymous block.
     */
    private <T> boolean isInitializeStaticFinalField(spoon.reflect.code.CtExpression<T> targetExp) {
        final spoon.reflect.declaration.CtElement parent;
        final spoon.reflect.declaration.CtAnonymousExecutable anonymousParent;
        try {
            parent = targetExp.getParent();
            anonymousParent = targetExp.getParent(spoon.reflect.declaration.CtAnonymousExecutable.class);
        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {
            return false;
        }
        return (((((parent instanceof spoon.reflect.code.CtFieldWrite) && (targetExp.equals(((spoon.reflect.code.CtFieldWrite) (parent)).getTarget()))) && (anonymousParent != null)) && ((((spoon.reflect.code.CtFieldWrite) (parent)).getVariable()) != null)) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.STATIC))) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.FINAL));
    }

    @java.lang.Override
    public <T> void visitCtThisAccess(spoon.reflect.code.CtThisAccess<T> thisAccess) {
        try {
            enterCtExpression(thisAccess);
            // we only write qualified this when this is required
            // this is good both in fully-qualified mode and in readable (with-imports) mode
            // the implicit information is used for analysis (e.g. is visibility caused by implicit bugs?) but
            // not for pretty-printing
            spoon.reflect.code.CtTypeAccess target = ((spoon.reflect.code.CtTypeAccess) (thisAccess.getTarget()));
            spoon.reflect.reference.CtTypeReference targetType = target.getAccessedType();
            // readable mode as close as possible to the original code
            if (thisAccess.isImplicit()) {
                // write nothing, "this" is implicit and we unfortunately cannot always know
                // what the good target is in JDTTreeBuilder
                return;
            }
            // the simplest case: we always print "this" if we're in the top-level class,
            // this is shorter (no qualified this), explicit, and less fragile wrt transformation
            if ((targetType == null) || (((thisAccess.getParent(spoon.reflect.declaration.CtType.class)) != null) && (thisAccess.getParent(spoon.reflect.declaration.CtType.class).isTopLevel()))) {
                printer.writeKeyword("this");
                return;// still go through finally block below

            }
            // we cannot have fully-qualified this in anonymous classes
            // we simply print "this" and it always works
            // this has to come after the implicit test just before
            if (targetType.isAnonymous()) {
                printer.writeKeyword("this");
                return;
            }
            // complex case of qualified this
            if (!(context.currentThis.isEmpty())) {
                spoon.reflect.declaration.CtType lastType = context.currentThis.peekFirst().type;
                java.lang.String lastTypeQualifiedName = lastType.getQualifiedName();
                java.lang.String targetTypeQualifiedName = targetType.getQualifiedName();
                if (!(lastTypeQualifiedName.equals(targetTypeQualifiedName))) {
                    if (!(targetType.isImplicit())) {
                        visitCtTypeReferenceWithoutGenerics(targetType);
                        printer.writeSeparator(".");
                    }
                    printer.writeKeyword("this");
                    return;
                }
            }
            // the default super simple case only comes at the end
            printer.writeKeyword("this");
        } finally {
            exitCtExpression(thisAccess);
        }
    }

    @java.lang.Override
    public <T> void visitCtSuperAccess(spoon.reflect.code.CtSuperAccess<T> f) {
        enterCtExpression(f);
        if ((f.getTarget()) != null) {
            scan(f.getTarget());
            printer.writeSeparator(".");
        }
        printer.writeKeyword("super");
        exitCtExpression(f);
    }

    @java.lang.Override
    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc comment) {
        visitCtComment(comment);
    }

    @java.lang.Override
    public void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag docTag) {
        /* is not called during normal printing of java sources.
        It can be called only when CtJavaDocTag has to be printed directly.
        E.g. from CtJavaDocTag#toString
        Write directly to PrinterHelper, because java doc tag is not a java token. Normally it is part of COMMENT token. */
        spoon.reflect.visitor.CommentHelper.printJavaDocTag(printer.getPrinterHelper(), docTag);
    }

    @java.lang.Override
    public void visitCtImport(spoon.reflect.declaration.CtImport ctImport) {
        if ((ctImport.getImportKind()) != null) {
            printer.writeKeyword("import");
            printer.writeSpace();
            switch (ctImport.getImportKind()) {
                case TYPE :
                    visitCtTypeReference(((spoon.reflect.reference.CtTypeReference) (ctImport.getReference())));
                    break;
                case METHOD :
                    printer.writeKeyword("static");
                    printer.writeSpace();
                    visitCtExecutableReference(((spoon.reflect.reference.CtExecutableReference) (ctImport.getReference())));
                    break;
                case FIELD :
                    printer.writeKeyword("static");
                    printer.writeSpace();
                    visitCtFieldReference(((spoon.reflect.reference.CtFieldReference) (ctImport.getReference())));
                    break;
                case ALL_TYPES :
                    visitCtPackageReference(((spoon.reflect.reference.CtPackageReference) (ctImport.getReference())));
                    printer.writeSeparator(".");
                    printer.writeIdentifier("*");
                    break;
                case ALL_STATIC_MEMBERS :
                    printer.writeKeyword("static");
                    printer.writeSpace();
                    visitCtTypeReference(((spoon.reflect.reference.CtTypeReference) (ctImport.getReference())));
                    break;
            }
            printer.writeSeparator(";");
            printer.writeln();
        }
    }

    @java.lang.Override
    public void visitCtModule(spoon.reflect.declaration.CtModule module) {
        enter(module);
        if (module.isOpenModule()) {
            printer.writeKeyword("open").writeSpace();
        }
        printer.writeKeyword("module").writeSpace().writeIdentifier(module.getSimpleName());
        printer.writeSpace().writeSeparator("{").incTab().writeln();
        for (spoon.reflect.declaration.CtModuleDirective moduleDirective : module.getModuleDirectives()) {
            scan(moduleDirective);
        }
        printer.decTab().writeSeparator("}");
        exit(module);
    }

    @java.lang.Override
    public void visitCtModuleReference(spoon.reflect.reference.CtModuleReference moduleReference) {
        printer.writeIdentifier(moduleReference.getSimpleName());
    }

    @java.lang.Override
    public void visitCtPackageExport(spoon.reflect.declaration.CtPackageExport moduleExport) {
        if (moduleExport.isOpenedPackage()) {
            printer.writeKeyword("opens");
        }else {
            printer.writeKeyword("exports");
        }
        printer.writeSpace();
        visitCtPackageReference(moduleExport.getPackageReference());
        if (!(moduleExport.getTargetExport().isEmpty())) {
            this.elementPrinterHelper.printList(moduleExport.getTargetExport(), null, false, " to", true, false, ",", true, false, null, ( moduleReference) -> scan(moduleReference));
        }
        printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtModuleRequirement(spoon.reflect.declaration.CtModuleRequirement moduleRequirement) {
        printer.writeKeyword("requires").writeSpace();
        if (!(moduleRequirement.getRequiresModifiers().isEmpty())) {
            this.elementPrinterHelper.printList(moduleRequirement.getRequiresModifiers(), null, false, null, false, false, " ", false, false, " ", ( modifier) -> printer.writeKeyword(modifier.name().toLowerCase()));
        }
        scan(moduleRequirement.getModuleReference());
        printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtProvidedService(spoon.reflect.declaration.CtProvidedService moduleProvidedService) {
        printer.writeKeyword("provides").writeSpace();
        scan(moduleProvidedService.getServiceType());
        this.elementPrinterHelper.printList(moduleProvidedService.getImplementationTypes(), null, false, " with", true, false, ",", true, false, null, ( implementations) -> scan(implementations));
        printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtUsedService(spoon.reflect.declaration.CtUsedService usedService) {
        printer.writeKeyword("uses").writeSpace();
        scan(usedService.getServiceType());
        printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtComment(spoon.reflect.code.CtComment comment) {
        if ((!(env.isCommentsEnabled())) && ((context.elementStack.size()) > 1)) {
            return;
        }
        printer.writeComment(comment);
    }

    @java.lang.Override
    public <T> void visitCtAnnotationFieldAccess(spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {
        enterCtExpression(annotationFieldAccess);
        try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {
            if ((annotationFieldAccess.getTarget()) != null) {
                scan(annotationFieldAccess.getTarget());
                printer.writeSeparator(".");
                _context.ignoreStaticAccess(true);
            }
            _context.ignoreGenerics(true);
            scan(annotationFieldAccess.getVariable());
            printer.writeSeparator("(").writeSeparator(")");
        }
        exitCtExpression(annotationFieldAccess);
    }

    @java.lang.Override
    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {
        boolean isStatic = ("class".equals(reference.getSimpleName())) || ((!("super".equals(reference.getSimpleName()))) && (reference.isStatic()));
        boolean printType = true;
        if ((reference.isFinal()) && (reference.isStatic())) {
            spoon.reflect.reference.CtTypeReference<?> declTypeRef = reference.getDeclaringType();
            if (declTypeRef.isAnonymous()) {
                // never print anonymous class ref
                printType = false;
            }else {
                if (context.isInCurrentScope(declTypeRef)) {
                    // do not printType if we are in scope of that type
                    printType = false;
                }
            }
        }
        if ((isStatic && printType) && (!(context.ignoreStaticAccess()))) {
            try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(true)) {
                scan(reference.getDeclaringType());
            }
            printer.writeSeparator(".");
        }
        if ("class".equals(reference.getSimpleName())) {
            printer.writeKeyword("class");
        }else {
            printer.writeIdentifier(reference.getSimpleName());
        }
    }

    @java.lang.Override
    public void visitCtFor(spoon.reflect.code.CtFor forLoop) {
        enterCtStatement(forLoop);
        printer.writeKeyword("for").writeSpace().writeSeparator("(");
        java.util.List<spoon.reflect.code.CtStatement> st = forLoop.getForInit();
        if (!(st.isEmpty())) {
            try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().isFirstForVariable(true)) {
                scan(st.get(0));
            }
        }
        if ((st.size()) > 1) {
            try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().isNextForVariable(true)) {
                for (int i = 1; i < (st.size()); i++) {
                    printer.writeSeparator(",").writeSpace();
                    scan(st.get(i));
                }
            }
        }
        printer.writeSeparator(";").writeSpace();
        scan(forLoop.getExpression());
        printer.writeSeparator(";");
        if (!(forLoop.getForUpdate().isEmpty())) {
            printer.writeSpace();
        }
        elementPrinterHelper.printList(forLoop.getForUpdate(), null, false, null, false, true, ",", true, false, null, ( s) -> scan(s));
        printer.writeSeparator(")");
        elementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());
        exitCtStatement(forLoop);
    }

    @java.lang.Override
    public void visitCtForEach(spoon.reflect.code.CtForEach foreach) {
        enterCtStatement(foreach);
        printer.writeKeyword("for").writeSpace().writeSeparator("(");
        scan(foreach.getVariable());
        printer.writeSpace().writeSeparator(":").writeSpace();
        scan(foreach.getExpression());
        printer.writeSeparator(")");
        elementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());
        exitCtStatement(foreach);
    }

    @java.lang.Override
    public void visitCtIf(spoon.reflect.code.CtIf ifElement) {
        enterCtStatement(ifElement);
        printer.writeKeyword("if").writeSpace().writeSeparator("(");
        scan(ifElement.getCondition());
        printer.writeSeparator(")");
        elementPrinterHelper.writeIfOrLoopBlock(ifElement.getThenStatement());
        if ((ifElement.getElseStatement()) != null) {
            java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(ifElement, spoon.reflect.visitor.printer.CommentOffset.INSIDE);
            for (spoon.reflect.code.CtComment comment : comments) {
                spoon.reflect.cu.SourcePosition thenPosition = (ifElement.getThenStatement().getPosition().isValidPosition()) ? ifElement.getThenStatement().getPosition() : ((spoon.reflect.code.CtBlock) (ifElement.getThenStatement())).getStatement(0).getPosition();
                if ((comment.getPosition().getSourceStart()) > (thenPosition.getSourceEnd())) {
                    elementPrinterHelper.writeComment(comment);
                }
            }
            printer.writeKeyword("else");
            elementPrinterHelper.writeIfOrLoopBlock(ifElement.getElseStatement());
        }
        exitCtStatement(ifElement);
    }

    @java.lang.Override
    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {
        visitCtType(intrface);
        printer.writeKeyword("interface").writeSpace().writeIdentifier(intrface.getSimpleName());
        if ((intrface.getFormalCtTypeParameters()) != null) {
            elementPrinterHelper.writeFormalTypeParameters(intrface);
        }
        if (!(intrface.getSuperInterfaces().isEmpty())) {
            elementPrinterHelper.printList(intrface.getSuperInterfaces(), "extends", false, null, false, true, ",", true, false, null, ( ref) -> scan(ref));
        }
        context.pushCurrentThis(intrface);
        printer.writeSpace().writeSeparator("{").incTab();
        // Content
        elementPrinterHelper.writeElementList(intrface.getTypeMembers());
        printer.decTab().writeSeparator("}");
        context.popCurrentThis();
    }

    @java.lang.Override
    public <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> invocation) {
        enterCtStatement(invocation);
        enterCtExpression(invocation);
        if (invocation.getExecutable().isConstructor()) {
            // It's a constructor (super or this)
            elementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());
            spoon.reflect.declaration.CtType<?> parentType;
            try {
                parentType = invocation.getParent(spoon.reflect.declaration.CtType.class);
            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {
                parentType = null;
            }
            if (((parentType != null) && ((parentType.getQualifiedName()) != null)) && (parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName()))) {
                printer.writeKeyword("this");
            }else {
                if (((invocation.getTarget()) != null) && (!(invocation.getTarget().isImplicit()))) {
                    scan(invocation.getTarget());
                    printer.writeSeparator(".");
                }
                printer.writeKeyword("super");
            }
        }else {
            // It's a method invocation
            boolean isImported = this.isImported(invocation.getExecutable());
            if (!isImported) {
                try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {
                    if ((invocation.getTarget()) instanceof spoon.reflect.code.CtTypeAccess) {
                        _context.ignoreGenerics(true);
                    }
                    if (((invocation.getTarget()) != null) && (!(invocation.getTarget().isImplicit()))) {
                        scan(invocation.getTarget());
                        printer.writeSeparator(".");
                    }
                }
            }
            elementPrinterHelper.writeActualTypeArguments(invocation);
            if (env.isPreserveLineNumbers()) {
                getPrinterHelper().adjustStartPosition(invocation);
            }
            printer.writeIdentifier(invocation.getExecutable().getSimpleName());
        }
        elementPrinterHelper.printList(invocation.getArguments(), null, false, "(", false, false, ",", true, false, ")", ( e) -> scan(e));
        exitCtExpression(invocation);
        exitCtStatement(invocation);
    }

    @java.lang.Override
    public <T> void visitCtLiteral(spoon.reflect.code.CtLiteral<T> literal) {
        enterCtExpression(literal);
        printer.writeLiteral(spoon.reflect.visitor.LiteralHelper.getLiteralToken(literal));
        exitCtExpression(literal);
    }

    @java.lang.Override
    public <T> void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable<T> localVariable) {
        enterCtStatement(localVariable);
        if (env.isPreserveLineNumbers()) {
            getPrinterHelper().adjustStartPosition(localVariable);
        }
        if (!(context.isNextForVariable())) {
            elementPrinterHelper.writeModifiers(localVariable);
            if ((localVariable.isInferred()) && ((this.env.getComplianceLevel()) >= 10)) {
                getPrinterTokenWriter().writeKeyword("var");
            }else {
                scan(localVariable.getType());
            }
            printer.writeSpace();
        }
        printer.writeIdentifier(localVariable.getSimpleName());
        if ((localVariable.getDefaultExpression()) != null) {
            printer.writeSpace().writeOperator("=").writeSpace();
            scan(localVariable.getDefaultExpression());
        }
        exitCtStatement(localVariable);
    }

    @java.lang.Override
    public <T> void visitCtLocalVariableReference(spoon.reflect.reference.CtLocalVariableReference<T> reference) {
        printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {
        if (env.isPreserveLineNumbers()) {
            getPrinterHelper().adjustStartPosition(catchVariable);
        }
        elementPrinterHelper.writeModifiers(catchVariable);
        scan(catchVariable.getType());
        printer.writeSpace();
        printer.writeIdentifier(catchVariable.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtCatchVariableReference(spoon.reflect.reference.CtCatchVariableReference<T> reference) {
        printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtMethod(spoon.reflect.declaration.CtMethod<T> m) {
        elementPrinterHelper.writeComment(m, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        elementPrinterHelper.visitCtNamedElement(m, sourceCompilationUnit);
        elementPrinterHelper.writeModifiers(m);
        elementPrinterHelper.writeFormalTypeParameters(m);
        if (!(m.getFormalCtTypeParameters().isEmpty())) {
            printer.writeSpace();
        }
        try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(false)) {
            scan(m.getType());
        }
        printer.writeSpace();
        printer.writeIdentifier(m.getSimpleName());
        elementPrinterHelper.writeExecutableParameters(m);
        elementPrinterHelper.writeThrowsClause(m);
        if ((m.getBody()) != null) {
            printer.writeSpace();
            scan(m.getBody());
            if (m.getBody().getPosition().isValidPosition()) {
                if ((m.getBody().getPosition().getCompilationUnit()) == (sourceCompilationUnit)) {
                    if ((m.getBody().getStatements().isEmpty()) || (!((m.getBody().getStatements().get(((m.getBody().getStatements().size()) - 1))) instanceof spoon.reflect.code.CtReturn))) {
                        getPrinterHelper().putLineNumberMapping(m.getBody().getPosition().getEndLine());
                    }
                }else {
                    getPrinterHelper().undefineLine();
                }
            }else {
                getPrinterHelper().undefineLine();
            }
        }else {
            printer.writeSeparator(";");
        }
        elementPrinterHelper.writeComment(m, spoon.reflect.visitor.printer.CommentOffset.AFTER);
    }

    @java.lang.Override
    public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {
        elementPrinterHelper.writeComment(annotationMethod);
        elementPrinterHelper.visitCtNamedElement(annotationMethod, sourceCompilationUnit);
        elementPrinterHelper.writeModifiers(annotationMethod);
        scan(annotationMethod.getType());
        printer.writeSpace();
        printer.writeIdentifier(annotationMethod.getSimpleName());
        printer.writeSeparator("(").writeSeparator(")");
        if ((annotationMethod.getDefaultExpression()) != null) {
            printer.writeSpace().writeKeyword("default").writeSpace();
            scan(annotationMethod.getDefaultExpression());
        }
        printer.writeSeparator(";");
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("rawtypes")
    public <T> void visitCtNewArray(spoon.reflect.code.CtNewArray<T> newArray) {
        enterCtExpression(newArray);
        boolean isNotInAnnotation;
        try {
            isNotInAnnotation = ((newArray.getParent(spoon.reflect.declaration.CtAnnotationType.class)) == null) && ((newArray.getParent(spoon.reflect.declaration.CtAnnotation.class)) == null);
        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {
            isNotInAnnotation = true;
        }
        if (isNotInAnnotation) {
            spoon.reflect.reference.CtTypeReference<?> ref = newArray.getType();
            if (ref != null) {
                printer.writeKeyword("new").writeSpace();
            }
            try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().skipArray(true)) {
                scan(ref);
            }
            for (int i = 0; ref instanceof spoon.reflect.reference.CtArrayTypeReference; i++) {
                printer.writeSeparator("[");
                if ((newArray.getDimensionExpressions().size()) > i) {
                    spoon.reflect.code.CtExpression<java.lang.Integer> e = newArray.getDimensionExpressions().get(i);
                    scan(e);
                }
                printer.writeSeparator("]");
                ref = ((spoon.reflect.reference.CtArrayTypeReference) (ref)).getComponentType();
            }
        }
        if (newArray.getDimensionExpressions().isEmpty()) {
            elementPrinterHelper.printList(newArray.getElements(), null, false, "{", true, false, ",", true, true, "}", ( e) -> scan(e));
            elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.INSIDE);
        }
        elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.AFTER);
        exitCtExpression(newArray);
    }

    @java.lang.Override
    public <T> void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {
        enterCtStatement(ctConstructorCall);
        enterCtExpression(ctConstructorCall);
        printConstructorCall(ctConstructorCall);
        exitCtExpression(ctConstructorCall);
        exitCtStatement(ctConstructorCall);
    }

    @java.lang.Override
    public <T> void visitCtNewClass(spoon.reflect.code.CtNewClass<T> newClass) {
        enterCtStatement(newClass);
        enterCtExpression(newClass);
        printConstructorCall(newClass);
        scan(newClass.getAnonymousClass());
        exitCtExpression(newClass);
        exitCtStatement(newClass);
    }

    private <T> void printConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {
        try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {
            if ((ctConstructorCall.getTarget()) != null) {
                scan(ctConstructorCall.getTarget());
                printer.writeSeparator(".");
                _context.ignoreEnclosingClass(true);
            }
            if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {
                _context.ignoreEnclosingClass(true);
            }
            printer.writeKeyword("new").writeSpace();
            if (!(ctConstructorCall.getActualTypeArguments().isEmpty())) {
                elementPrinterHelper.writeActualTypeArguments(ctConstructorCall);
            }
            scan(ctConstructorCall.getType());
        }
        elementPrinterHelper.printList(ctConstructorCall.getArguments(), null, false, "(", false, false, ",", true, false, ")", ( exp) -> scan(exp));
    }

    /**
    JDT doesn't support <code>new Foo<K>.Bar()</code>. To avoid reprinting this kind of type reference,
    we check that the reference has a declaring type with generics.
    See https://bugs.eclipse.org/bugs/show_bug.cgi?id=474593

    @param reference Type reference concerned by the bug.
    @return true if a declaring type has generic types.
     *
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     */
    private <T> boolean hasDeclaringTypeWithGenerics(spoon.reflect.reference.CtTypeReference<T> reference) {
        // We don't have a declaring type, it can't have generics.
        if (reference == null) {
            return false;
        }
        // If the declaring type isn't a type, we don't need this hack.
        if ((reference.getDeclaringType()) == null) {
            return false;
        }
        // If current reference is a class declared in a method, we don't need this hack.
        if (reference.isLocalType()) {
            return false;
        }
        // If declaring type have generics, we return true.
        if (!(reference.getDeclaringType().getActualTypeArguments().isEmpty())) {
            return true;
        }
        // Checks if the declaring type has generic types.
        return hasDeclaringTypeWithGenerics(reference.getDeclaringType());
    }

    @java.lang.Override
    public <T> void visitCtLambda(spoon.reflect.code.CtLambda<T> lambda) {
        enterCtExpression(lambda);
        elementPrinterHelper.printList(lambda.getParameters(), null, false, "(", false, false, ",", false, false, ")", ( parameter) -> scan(parameter));
        printer.writeSpace();
        printer.writeSeparator("->");
        printer.writeSpace();
        if ((lambda.getBody()) != null) {
            scan(lambda.getBody());
        }else {
            scan(lambda.getExpression());
        }
        exitCtExpression(lambda);
    }

    @java.lang.Override
    public <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {
        enterCtExpression(expression);
        try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {
            if (expression.getExecutable().isStatic()) {
                _context.ignoreGenerics(true);
            }
            scan(expression.getTarget());
        }
        printer.writeSeparator("::");
        if (expression.getExecutable().isConstructor()) {
            printer.writeKeyword("new");
        }else {
            printer.writeIdentifier(expression.getExecutable().getSimpleName());
        }
        exitCtExpression(expression);
    }

    @java.lang.Override
    public <T, A extends T> void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {
        enterCtStatement(assignment);
        enterCtExpression(assignment);
        scan(assignment.getAssigned());
        printer.writeSpace();
        // the operators like +=, *= are sent as one operator token
        printer.writeOperator(((spoon.reflect.visitor.OperatorHelper.getOperatorText(assignment.getKind())) + "="));
        printer.writeSpace();
        scan(assignment.getAssignment());
        exitCtExpression(assignment);
        exitCtStatement(assignment);
    }

    @java.lang.Override
    public void visitCtPackage(spoon.reflect.declaration.CtPackage ctPackage) {
        if (!(ctPackage.isUnnamedPackage())) {
            elementPrinterHelper.writePackageLine(ctPackage.getQualifiedName());
        }else {
            printer.writeComment(ctPackage.getFactory().createComment("default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon= unnamed package)", spoon.reflect.code.CtComment.CommentType.INLINE)).writeln();
        }
    }

    @java.lang.Override
    public void visitCtPackageReference(spoon.reflect.reference.CtPackageReference reference) {
        elementPrinterHelper.writeQualifiedName(reference.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtParameter(spoon.reflect.declaration.CtParameter<T> parameter) {
        elementPrinterHelper.writeComment(parameter);
        elementPrinterHelper.writeAnnotations(parameter);
        elementPrinterHelper.writeModifiers(parameter);
        if (parameter.isVarArgs()) {
            scan(((spoon.reflect.reference.CtArrayTypeReference<T>) (parameter.getType())).getComponentType());
            printer.writeSeparator("...");
        }else {
            scan(parameter.getType());
        }
        printer.writeSpace();
        printer.writeIdentifier(parameter.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtParameterReference(spoon.reflect.reference.CtParameterReference<T> reference) {
        printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public <R> void visitCtReturn(spoon.reflect.code.CtReturn<R> returnStatement) {
        enterCtStatement(returnStatement);
        printer.writeKeyword("return");
        // checkstyle wants "return;" and not "return ;"
        if ((returnStatement.getReturnedExpression()) != null) {
            printer.writeSpace();
        }
        scan(returnStatement.getReturnedExpression());
        exitCtStatement(returnStatement);
    }

    private <T> void visitCtType(spoon.reflect.declaration.CtType<T> type) {
        elementPrinterHelper.writeComment(type, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        getPrinterHelper().mapLine(type, sourceCompilationUnit);
        if (type.isTopLevel()) {
            context.currentTopLevel = type;
        }
        elementPrinterHelper.visitCtNamedElement(type, sourceCompilationUnit);
        elementPrinterHelper.writeModifiers(type);
    }

    @java.lang.Override
    public void visitCtStatementList(spoon.reflect.code.CtStatementList statements) {
        for (spoon.reflect.code.CtStatement s : statements.getStatements()) {
            scan(s);
        }
    }

    @java.lang.Override
    public <E> void visitCtSwitch(spoon.reflect.code.CtSwitch<E> switchStatement) {
        enterCtStatement(switchStatement);
        printer.writeKeyword("switch").writeSpace().writeSeparator("(");
        scan(switchStatement.getSelector());
        printer.writeSeparator(")").writeSpace().writeSeparator("{").incTab();
        for (spoon.reflect.code.CtCase<?> c : switchStatement.getCases()) {
            printer.writeln();
            scan(c);
        }
        if (env.isPreserveLineNumbers()) {
            printer.decTab().writeSeparator("}");
        }else {
            printer.decTab().writeln().writeSeparator("}");
        }
        exitCtStatement(switchStatement);
    }

    @java.lang.Override
    public void visitCtSynchronized(spoon.reflect.code.CtSynchronized synchro) {
        enterCtStatement(synchro);
        printer.writeKeyword("synchronized");
        if ((synchro.getExpression()) != null) {
            printer.writeSeparator("(");
            scan(synchro.getExpression());
            printer.writeSeparator(")").writeSpace();
        }
        scan(synchro.getBlock());
        exitCtStatement(synchro);
    }

    @java.lang.Override
    public void visitCtThrow(spoon.reflect.code.CtThrow throwStatement) {
        enterCtStatement(throwStatement);
        printer.writeKeyword("throw").writeSpace();
        scan(throwStatement.getThrownExpression());
        exitCtStatement(throwStatement);
    }

    @java.lang.Override
    public void visitCtTry(spoon.reflect.code.CtTry tryBlock) {
        enterCtStatement(tryBlock);
        printer.writeKeyword("try").writeSpace();
        scan(tryBlock.getBody());
        for (spoon.reflect.code.CtCatch c : tryBlock.getCatchers()) {
            scan(c);
        }
        if ((tryBlock.getFinalizer()) != null) {
            printer.writeSpace().writeKeyword("finally").writeSpace();
            scan(tryBlock.getFinalizer());
        }
        exitCtStatement(tryBlock);
    }

    @java.lang.Override
    public void visitCtTryWithResource(spoon.reflect.code.CtTryWithResource tryWithResource) {
        enterCtStatement(tryWithResource);
        printer.writeKeyword("try").writeSpace();
        if (((tryWithResource.getResources()) != null) && (!(tryWithResource.getResources().isEmpty()))) {
            elementPrinterHelper.printList(tryWithResource.getResources(), null, false, "(", false, false, ";", false, false, ")", ( r) -> scan(r));
        }
        printer.writeSpace();
        scan(tryWithResource.getBody());
        for (spoon.reflect.code.CtCatch c : tryWithResource.getCatchers()) {
            scan(c);
        }
        if ((tryWithResource.getFinalizer()) != null) {
            printer.writeSpace().writeKeyword("finally").writeSpace();
            scan(tryWithResource.getFinalizer());
        }
        exitCtStatement(tryWithResource);
    }

    @java.lang.Override
    public void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {
        if (ref.isImplicit()) {
            return;
        }
        elementPrinterHelper.writeAnnotations(ref);
        if (printQualified(ref)) {
            elementPrinterHelper.writeQualifiedName(ref.getQualifiedName());
        }else {
            printer.writeIdentifier(ref.getSimpleName());
        }
    }

    @java.lang.Override
    public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {
        if (wildcardReference.isImplicit()) {
            return;
        }
        elementPrinterHelper.writeAnnotations(wildcardReference);
        printer.writeSeparator("?");
        // we ignore printing "extends Object" except if it's explicit
        if ((!(wildcardReference.isDefaultBoundingType())) || (!(wildcardReference.getBoundingType().isImplicit()))) {
            if (wildcardReference.isUpper()) {
                printer.writeSpace().writeKeyword("extends").writeSpace();
            }else {
                printer.writeSpace().writeKeyword("super").writeSpace();
            }
            scan(wildcardReference.getBoundingType());
        }
    }

    private boolean printQualified(spoon.reflect.reference.CtTypeReference<?> ref) {
        // or that we are in java.lang
        if ((importsContext.isImported(ref))// If my.pkg.Something is imported
         || (((this.env.isAutoImports()) && ((ref.getPackage()) != null)) && ("java.lang".equals(ref.getPackage().getSimpleName())))) {
            for (spoon.reflect.visitor.CacheBasedConflictFinder typeContext : context.currentThis) {
                // A) we are in the context of a class which is also called "Something",
                if ((typeContext.getSimpleName().equals(ref.getSimpleName())) && (!(java.util.Objects.equals(typeContext.getPackage(), ref.getPackage())))) {
                    return true;
                }
                // B) we are in the context of a class which defines field which is also called "Something",
                // we should still use qualified version my.pkg.Something
                // fix of #2369
                if ((typeContext.hasFieldConflict(ref.getSimpleName())) || (typeContext.hasNestedTypeConflict(ref.getSimpleName()))) {
                    return true;
                }
            }
            return false;
        }else {
            return true;
        }
    }

    @java.lang.Override
    public <T> void visitCtIntersectionTypeReference(spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {
        elementPrinterHelper.printList(reference.getBounds(), null, false, null, false, true, "&", true, false, null, ( bound) -> scan(bound));
    }

    @java.lang.Override
    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> ref) {
        visitCtTypeReference(ref, true);
    }

    @java.lang.Override
    public <T> void visitCtTypeAccess(spoon.reflect.code.CtTypeAccess<T> typeAccess) {
        if (typeAccess.isImplicit()) {
            return;
        }
        enterCtExpression(typeAccess);
        scan(typeAccess.getAccessedType());
        exitCtExpression(typeAccess);
    }

    private void visitCtTypeReferenceWithoutGenerics(spoon.reflect.reference.CtTypeReference<?> ref) {
        visitCtTypeReference(ref, false);
    }

    private void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<?> ref, boolean withGenerics) {
        if (ref.isImplicit()) {
            return;
        }
        if (ref.isPrimitive()) {
            elementPrinterHelper.writeAnnotations(ref);
            printer.writeKeyword(ref.getSimpleName());
            return;
        }
        boolean isInner = (ref.getDeclaringType()) != null;
        if (isInner) {
            if ((!(context.ignoreEnclosingClass())) && (!(ref.isLocalType()))) {
                // compute visible type which can be used to print access path to ref
                spoon.reflect.reference.CtTypeReference<?> accessType = ref.getAccessType();
                if (!(accessType.isAnonymous())) {
                    try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {
                        if (!withGenerics) {
                            _context.ignoreGenerics(true);
                        }
                        scan(accessType);
                    }
                    printer.writeSeparator(".");
                }
            }
            // ?? are these annotations on correct place ??
            elementPrinterHelper.writeAnnotations(ref);
            if (ref.isLocalType()) {
                printer.writeIdentifier(ref.getSimpleName().replaceAll("^[0-9]*", ""));
            }else {
                printer.writeIdentifier(ref.getSimpleName());
            }
        }else {
            if (((ref.getPackage()) != null) && (printQualified(ref))) {
                if (!(ref.getPackage().isUnnamedPackage())) {
                    scan(ref.getPackage());
                    printer.writeSeparator(spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);
                }
            }
            elementPrinterHelper.writeAnnotations(ref);
            printer.writeIdentifier(ref.getSimpleName());
        }
        if (withGenerics && (!(context.ignoreGenerics()))) {
            try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreEnclosingClass(false)) {
                elementPrinterHelper.writeActualTypeArguments(ref);
            }
        }
    }

    @java.lang.Override
    public <T> void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator<T> operator) {
        enterCtStatement(operator);
        enterCtExpression(operator);
        spoon.reflect.code.UnaryOperatorKind op = operator.getKind();
        if (spoon.reflect.visitor.OperatorHelper.isPrefixOperator(op)) {
            printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(op));
        }
        scan(operator.getOperand());
        if (spoon.reflect.visitor.OperatorHelper.isSufixOperator(op)) {
            printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(op));
        }
        exitCtExpression(operator);
        exitCtStatement(operator);
    }

    @java.lang.Override
    public <T> void visitCtVariableRead(spoon.reflect.code.CtVariableRead<T> variableRead) {
        enterCtExpression(variableRead);
        printer.writeIdentifier(variableRead.getVariable().getSimpleName());
        exitCtExpression(variableRead);
    }

    @java.lang.Override
    public <T> void visitCtVariableWrite(spoon.reflect.code.CtVariableWrite<T> variableWrite) {
        enterCtExpression(variableWrite);
        printer.writeIdentifier(variableWrite.getVariable().getSimpleName());
        exitCtExpression(variableWrite);
    }

    @java.lang.Override
    public void visitCtWhile(spoon.reflect.code.CtWhile whileLoop) {
        enterCtStatement(whileLoop);
        printer.writeKeyword("while").writeSpace().writeSeparator("(");
        scan(whileLoop.getLoopingExpression());
        printer.writeSeparator(")");
        elementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());
        exitCtStatement(whileLoop);
    }

    @java.lang.Override
    public <T> void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression<T> expression) {
        elementPrinterHelper.writeComment(expression);
        printer.writeCodeSnippet(expression.getValue());
    }

    @java.lang.Override
    public void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement statement) {
        enterCtStatement(statement);
        printer.writeCodeSnippet(statement.getValue());
        exitCtStatement(statement);
    }

    public spoon.reflect.visitor.ElementPrinterHelper getElementPrinterHelper() {
        return elementPrinterHelper;
    }

    public spoon.reflect.visitor.PrintingContext getContext() {
        return context;
    }

    @java.lang.Override
    public <T> void visitCtUnboundVariableReference(spoon.reflect.reference.CtUnboundVariableReference<T> reference) {
        printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public java.lang.String printPackageInfo(spoon.reflect.declaration.CtPackage pack) {
        reset();
        elementPrinterHelper.writeComment(pack);
        // we need to compute imports only for annotations
        // we don't want to get all imports coming from content of package
        for (spoon.reflect.declaration.CtAnnotation annotation : pack.getAnnotations()) {
            this.importsContext.computeImports(annotation);
        }
        elementPrinterHelper.writeAnnotations(pack);
        if (!(pack.isUnnamedPackage())) {
            elementPrinterHelper.writePackageLine(pack.getQualifiedName());
        }
        elementPrinterHelper.writeImports(this.importsContext.getAllImports());
        return printer.getPrinterHelper().toString();
    }

    @java.lang.Override
    public java.lang.String printModuleInfo(spoon.reflect.declaration.CtModule module) {
        reset();
        scan(module);
        return this.getResult();
    }

    @java.lang.Override
    public java.lang.String getResult() {
        return printer.getPrinterHelper().toString();
    }

    private void reset() {
        printer.reset();
        context = new spoon.reflect.visitor.PrintingContext();
        if (env.isAutoImports()) {
            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();
        }else {
            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();
        }
    }

    /**
    Write the compilation unit header.
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter writeHeader(java.util.List<spoon.reflect.declaration.CtType<?>> types, java.util.Collection<spoon.reflect.declaration.CtImport> imports) {
        elementPrinterHelper.writeHeader(types, imports);
        return this;
    }

    /**
    Write the compilation unit footer.
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter writeFooter(java.util.List<spoon.reflect.declaration.CtType<?>> types) {
        elementPrinterHelper.writeFooter(types);
        return this;
    }

    @java.lang.Override
    public void calculate(spoon.reflect.cu.CompilationUnit sourceCompilationUnit, java.util.List<spoon.reflect.declaration.CtType<?>> types) {
        // reset the importsContext to avoid errors with multiple CU
        reset();
        this.sourceCompilationUnit = sourceCompilationUnit;
        this.imports = new java.util.HashSet<>();
        if (sourceCompilationUnit != null) {
            this.importsContext.initWithImports(sourceCompilationUnit.getImports());
        }
        for (spoon.reflect.declaration.CtType<?> t : types) {
            imports.addAll(computeImports(t));
        }
        this.writeHeader(types, imports);
        printTypes(types);
    }

    protected void printTypes(java.util.List<spoon.reflect.declaration.CtType<?>> types) {
        for (spoon.reflect.declaration.CtType<?> t : types) {
            scan(t);
            if (!(env.isPreserveLineNumbers())) {
                // saving lines and chars
                printer.writeln().writeln();
            }else {
                getPrinterHelper().adjustEndPosition(t);
            }
        }
        this.writeFooter(types);
    }

    @java.lang.Override
    public java.util.Map<java.lang.Integer, java.lang.Integer> getLineNumberMapping() {
        return getPrinterHelper().getLineNumberMapping();
    }

    /**

    @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     *
     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     */
    protected spoon.reflect.visitor.TokenWriter getPrinterTokenWriter() {
        return printer;
    }

    /**
    Set {@link TokenWriter}, which has to be used to print tokens
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter setPrinterTokenWriter(spoon.reflect.visitor.TokenWriter tokenWriter) {
        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(tokenWriter, this, env);
        printer = tokenWriter;
        return this;
    }

    private spoon.reflect.visitor.PrinterHelper getPrinterHelper() {
        return printer.getPrinterHelper();
    }
}> but was:</**
A visitor for generating Java code from the program compile-time model.
 */
public class DefaultJavaPrettyPrinter implements spoon.reflect.visitor.CtVisitor , spoon.reflect.visitor.PrettyPrinter {
    /**
    Java file extension (.java).
     */
    public static final java.lang.String JAVA_FILE_EXTENSION = ".java";

    /**
    Package declaration file name.
     */
    public static final java.lang.String JAVA_PACKAGE_DECLARATION = "package-info" + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);

    /**
    Module declaration file name.
     */
    public static final java.lang.String JAVA_MODULE_DECLARATION = "module-info" + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);

    /**
    Line separator which is used by the system
     */
    public static final java.lang.String LINE_SEPARATOR = java.lang.System.getProperty("line.separator");

    /**
    The star at the beginning of a block/JavaDoc comment line
     */
    public static final java.lang.String COMMENT_STAR = " * ";

    /**
    The end of a block/JavaDoc comment
     */
    public static final java.lang.String BLOCK_COMMENT_END = " */";

    /**
    The beginning of a JavaDoc comment
     */
    public static final java.lang.String JAVADOC_START = "/**";

    /**
    The beginning of an inline comment
     */
    public static final java.lang.String INLINE_COMMENT_START = "// ";

    /**
    The beginning of a block comment
     */
    public static final java.lang.String BLOCK_COMMENT_START = "/* ";

    /**
    The printing context.

    since Spoon 7.1.0, use {{@link #getContext()}}
     */
    private spoon.reflect.visitor.PrintingContext context = new spoon.reflect.visitor.PrintingContext();

    /**
    get the import scanner of this pretty printer
     */
    public spoon.reflect.visitor.ImportScanner getImportsContext() {
        return this.importsContext;
    }

    /**
    Handle imports of classes.
     */
    private spoon.reflect.visitor.ImportScanner importsContext;

    /**
    Environment which Spoon is executed.
     */
    protected spoon.compiler.Environment env;

    /**
    Token detector, which delegates tokens to {@link TokenWriter}
     */
    private spoon.reflect.visitor.TokenWriter printer;

    /**
    Element printer helper.
     */
    private spoon.reflect.visitor.ElementPrinterHelper elementPrinterHelper;

    /**
    Compilation unit we are printing.
     */
    protected spoon.reflect.cu.CompilationUnit sourceCompilationUnit;

    /**
    Imports computed
     */
    java.util.Set<spoon.reflect.declaration.CtImport> imports;

    /**
    Creates a new code generator visitor.
     */
    public DefaultJavaPrettyPrinter(spoon.compiler.Environment env) {
        this.env = env;
        this.imports = new java.util.HashSet<>();
        setPrinterTokenWriter(new spoon.reflect.visitor.DefaultTokenWriter(new spoon.reflect.visitor.PrinterHelper(env)));
        if (env.isAutoImports()) {
            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();
        }else {
            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();
        }
    }

    /**
     *
     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
     * defined by System.getProperty("line.separator")
     */
    public java.lang.String getLineSeparator() {
        return getPrinterHelper().getLineSeparator();
    }

    /**
     *
     * @param lineSeparator * 		characters which will be printed as End of line.
     * 		By default there is System.getProperty("line.separator")
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter setLineSeparator(java.lang.String lineSeparator) {
        getPrinterHelper().setLineSeparator(lineSeparator);
        return this;
    }

    /**
    Enters an expression.
     */
    protected void enterCtExpression(spoon.reflect.code.CtExpression<?> e) {
        if (!(e instanceof spoon.reflect.code.CtStatement)) {
            this.elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        }
        getPrinterHelper().mapLine(e, this.sourceCompilationUnit);
        if (shouldSetBracket(e)) {
            this.context.parenthesedExpression.push(e);
            this.printer.writeSeparator("(");
        }
        if (!(e.getTypeCasts().isEmpty())) {
            for (spoon.reflect.reference.CtTypeReference<?> r : e.getTypeCasts()) {
                this.printer.writeSeparator("(");
                scan(r);
                this.printer.writeSeparator(")").writeSpace();
                this.printer.writeSeparator("(");
                this.context.parenthesedExpression.push(e);
            }
        }
    }

    /**
    Enters a statement.
     */
    protected void enterCtStatement(spoon.reflect.code.CtStatement s) {
        this.elementPrinterHelper.writeComment(s, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        getPrinterHelper().mapLine(s, this.sourceCompilationUnit);
        if (!(this.context.isNextForVariable())) {
            // TODO AnnotationLoopTest#testAnnotationDeclaredInForInit expects that annotations of next for variables are not printed
            // but may be correct is that the next variables are not annotated, because they might have different annotation then first param!
            this.elementPrinterHelper.writeAnnotations(s);
        }
        if ((!(this.context.isFirstForVariable())) && (!(this.context.isNextForVariable()))) {
            if ((s.getLabel()) != null) {
                this.printer.writeIdentifier(s.getLabel()).writeSpace().writeSeparator(":").writeSpace();
            }
        }
    }

    /**
    Exits a statement.
     */
    protected void exitCtStatement(spoon.reflect.code.CtStatement statement) {
        if (!((((((((((statement instanceof spoon.reflect.code.CtBlock) || (statement instanceof spoon.reflect.code.CtIf)) || (statement instanceof spoon.reflect.code.CtFor)) || (statement instanceof spoon.reflect.code.CtForEach)) || (statement instanceof spoon.reflect.code.CtWhile)) || (statement instanceof spoon.reflect.code.CtTry)) || (statement instanceof spoon.reflect.code.CtSwitch)) || (statement instanceof spoon.reflect.code.CtSynchronized)) || (statement instanceof spoon.reflect.declaration.CtClass)) || (statement instanceof spoon.reflect.code.CtComment))) {
            if (((this.context.isStatement(statement)) && (!(this.context.isFirstForVariable()))) && (!(this.context.isNextForVariable()))) {
                this.printer.writeSeparator(";");
            }
        }
        this.elementPrinterHelper.writeComment(statement, spoon.reflect.visitor.printer.CommentOffset.AFTER);
    }

    /**
    Exits an expression.
     */
    protected void exitCtExpression(spoon.reflect.code.CtExpression<?> e) {
        while ((!(this.context.parenthesedExpression.isEmpty())) && (e == (this.context.parenthesedExpression.peek()))) {
            this.context.parenthesedExpression.pop();
            this.printer.writeSeparator(")");
        } 
        if (!(e instanceof spoon.reflect.code.CtStatement)) {
            this.elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);
        }
    }

    /**
    Make the imports for a given type.
     */
    private java.util.Collection<spoon.reflect.declaration.CtImport> computeImports(spoon.reflect.declaration.CtType<?> type) {
        this.context.currentTopLevel = type;
        this.importsContext.computeImports(this.context.currentTopLevel);
        return this.importsContext.getAllImports();
    }

    /**
    This method is called by {@link #scan(CtElement)} when entering a scanned element.
    To be overridden to implement specific behavior.

    Same KISS design as for {@link CtScanner}.
     */
    protected void enter(spoon.reflect.declaration.CtElement e) {
    }

    /**
    This method is called by {@link #scan(CtElement)} when entering a scanned element.
    To be overridden to implement specific behavior.
     */
    protected void exit(spoon.reflect.declaration.CtElement e) {
    }

    /**
    The generic scan method for an element.
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.declaration.CtElement e) {
        if (e != null) {
            enter(e);
            this.context.elementStack.push(e);
            if (this.env.isPreserveLineNumbers()) {
                if (!(e instanceof spoon.reflect.declaration.CtNamedElement)) {
                    getPrinterHelper().adjustStartPosition(e);
                }
            }
            try {
                e.accept(this);
            } catch (spoon.SpoonException ex) {
                throw ex;
            } catch (java.lang.Exception ex) {
                java.lang.String elementInfo = e.getClass().getName();
                elementInfo += (" on path " + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.getPath(e))) + "\n";
                if (e.getPosition().isValidPosition()) {
                    elementInfo += ("at position " + (e.getPosition().toString())) + " ";
                }
                throw new spoon.SpoonException((("Printing of " + elementInfo) + "failed"), ex);
            }
            this.context.elementStack.pop();
            exit(e);
        }
        return this;
    }

    private static java.lang.String getPath(spoon.reflect.declaration.CtElement ele) {
        java.lang.StringBuilder sb = new java.lang.StringBuilder();
        spoon.reflect.visitor.DefaultJavaPrettyPrinter.addParentPath(sb, ele);
        if (ele instanceof spoon.reflect.code.CtVariableAccess) {
            sb.append(':').append(((spoon.reflect.code.CtVariableAccess) (ele)).getVariable().getSimpleName());
        }
        return sb.toString();
    }

    private static void addParentPath(java.lang.StringBuilder sb, spoon.reflect.declaration.CtElement ele) {
        if ((ele == null) || ((ele instanceof spoon.reflect.declaration.CtPackage) && (((spoon.reflect.declaration.CtPackage) (ele)).isUnnamedPackage()))) {
            return;
        }
        if (ele.isParentInitialized()) {
            spoon.reflect.visitor.DefaultJavaPrettyPrinter.addParentPath(sb, ele.getParent());
        }
        sb.append("\n\t").append(ele.getClass().getSimpleName());
        if (ele instanceof spoon.reflect.declaration.CtNamedElement) {
            sb.append(":").append(((spoon.reflect.declaration.CtNamedElement) (ele)).getSimpleName());
        }else
            if (ele instanceof spoon.reflect.reference.CtReference) {
                sb.append(":").append(((spoon.reflect.reference.CtReference) (ele)).getSimpleName());
            }

    }

    private boolean shouldSetBracket(spoon.reflect.code.CtExpression<?> e) {
        if (!(e.getTypeCasts().isEmpty())) {
            return true;
        }
        try {
            if (((e.getParent()) instanceof spoon.reflect.code.CtBinaryOperator) || ((e.getParent()) instanceof spoon.reflect.code.CtUnaryOperator)) {
                return ((((e instanceof spoon.reflect.code.CtTargetedExpression) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator)) || (e instanceof spoon.reflect.code.CtBinaryOperator);
            }
            if ((e.getParent()) instanceof spoon.reflect.code.CtTargetedExpression) {
                return (((e instanceof spoon.reflect.code.CtBinaryOperator) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator);
            }
        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {
            // nothing we accept not to have a parent
        }
        return false;
    }

    /**
    Gets the currently pretty-printed string.
     */
    @java.lang.Override
    public java.lang.String toString() {
        return this.printer.getPrinterHelper().toString();
    }

    @java.lang.Override
    public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation<A> annotation) {
        this.elementPrinterHelper.writeAnnotations(annotation);
        this.printer.writeSeparator("@");
        scan(annotation.getAnnotationType());
        if (!(annotation.getValues().isEmpty())) {
            this.elementPrinterHelper.printList(annotation.getValues().entrySet(), null, false, "(", false, false, ",", true, false, ")", ( e) -> {
                if ((((annotation.getValues().size()) == 1) && ("value".equals(e.getKey()))) == false) {
                    // it is not a default value attribute. We must print a attribute name too.
                    this.printer.writeIdentifier(e.getKey()).writeSpace().writeOperator("=").writeSpace();
                }
                this.elementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());
            });
        }
    }

    @java.lang.Override
    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {
        visitCtType(annotationType);
        this.printer.writeSeparator("@").writeKeyword("interface").writeSpace().writeIdentifier(annotationType.getSimpleName()).writeSpace().writeSeparator("{").incTab();
        this.elementPrinterHelper.writeElementList(annotationType.getTypeMembers());
        this.printer.decTab().writeSeparator("}");
    }

    @java.lang.Override
    public void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable impl) {
        this.elementPrinterHelper.writeComment(impl);
        this.elementPrinterHelper.writeAnnotations(impl);
        this.elementPrinterHelper.writeModifiers(impl);
        scan(impl.getBody());
    }

    @java.lang.Override
    public <T> void visitCtArrayRead(spoon.reflect.code.CtArrayRead<T> arrayRead) {
        printCtArrayAccess(arrayRead);
    }

    @java.lang.Override
    public <T> void visitCtArrayWrite(spoon.reflect.code.CtArrayWrite<T> arrayWrite) {
        printCtArrayAccess(arrayWrite);
    }

    private <T, E extends spoon.reflect.code.CtExpression<?>> void printCtArrayAccess(spoon.reflect.code.CtArrayAccess<T, E> arrayAccess) {
        enterCtExpression(arrayAccess);
        scan(arrayAccess.getTarget());
        this.printer.writeSeparator("[");
        scan(arrayAccess.getIndexExpression());
        this.printer.writeSeparator("]");
        exitCtExpression(arrayAccess);
    }

    @java.lang.Override
    public <T> void visitCtArrayTypeReference(spoon.reflect.reference.CtArrayTypeReference<T> reference) {
        if (reference.isImplicit()) {
            return;
        }
        scan(reference.getComponentType());
        if (!(this.context.skipArray())) {
            this.printer.writeSeparator("[").writeSeparator("]");
        }
    }

    @java.lang.Override
    public <T> void visitCtAssert(spoon.reflect.code.CtAssert<T> asserted) {
        enterCtStatement(asserted);
        this.printer.writeKeyword("assert").writeSpace();
        scan(asserted.getAssertExpression());
        if ((asserted.getExpression()) != null) {
            this.printer.writeSpace().writeSeparator(":").writeSpace();
            scan(asserted.getExpression());
        }
        exitCtStatement(asserted);
    }

    @java.lang.Override
    public <T, A extends T> void visitCtAssignment(spoon.reflect.code.CtAssignment<T, A> assignement) {
        enterCtStatement(assignement);
        enterCtExpression(assignement);
        scan(assignement.getAssigned());
        this.printer.writeSpace().writeOperator("=").writeSpace();
        scan(assignement.getAssignment());
        exitCtExpression(assignement);
        exitCtStatement(assignement);
    }

    @java.lang.Override
    public <T> void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator<T> operator) {
        enterCtExpression(operator);
        scan(operator.getLeftHandOperand());
        this.printer.writeSpace();
        this.printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(operator.getKind()));
        this.printer.writeSpace();
        try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify()) {
            if ((operator.getKind()) == (spoon.reflect.code.BinaryOperatorKind.INSTANCEOF)) {
                _context.forceWildcardGenerics(true);
            }
            scan(operator.getRightHandOperand());
        }
        exitCtExpression(operator);
    }

    @java.lang.Override
    public <R> void visitCtBlock(spoon.reflect.code.CtBlock<R> block) {
        enterCtStatement(block);
        if (!(block.isImplicit())) {
            this.printer.writeSeparator("{");
        }
        this.printer.incTab();
        for (spoon.reflect.code.CtStatement statement : block.getStatements()) {
            if (!(statement.isImplicit())) {
                this.printer.writeln();
                this.elementPrinterHelper.writeStatement(statement);
            }
        }
        this.printer.decTab();
        getPrinterHelper().adjustEndPosition(block);
        if (this.env.isPreserveLineNumbers()) {
            if (!(block.isImplicit())) {
                this.printer.writeSeparator("}");
            }
        }else {
            this.printer.writeln();
            if (!(block.isImplicit())) {
                this.printer.writeSeparator("}");
            }
        }
        exitCtStatement(block);
    }

    @java.lang.Override
    public void visitCtBreak(spoon.reflect.code.CtBreak breakStatement) {
        enterCtStatement(breakStatement);
        this.printer.writeKeyword("break");
        if ((breakStatement.getTargetLabel()) != null) {
            this.printer.writeSpace().writeKeyword(breakStatement.getTargetLabel());
        }
        exitCtStatement(breakStatement);
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("rawtypes")
    public <E> void visitCtCase(spoon.reflect.code.CtCase<E> caseStatement) {
        enterCtStatement(caseStatement);
        if ((caseStatement.getCaseExpression()) != null) {
            this.printer.writeKeyword("case").writeSpace();
            // writing enum case expression
            if ((caseStatement.getCaseExpression()) instanceof spoon.reflect.code.CtFieldAccess) {
                final spoon.reflect.reference.CtFieldReference variable = ((spoon.reflect.code.CtFieldAccess) (caseStatement.getCaseExpression())).getVariable();
                // In noclasspath mode, we don't have always the type of the declaring type.
                if ((((variable.getType()) != null) && ((variable.getDeclaringType()) != null)) && (variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName()))) {
                    this.printer.writeIdentifier(variable.getSimpleName());
                }else {
                    scan(caseStatement.getCaseExpression());
                }
            }else {
                scan(caseStatement.getCaseExpression());
            }
        }else {
            this.printer.writeKeyword("default");
        }
        this.printer.writeSpace().writeSeparator(":").incTab();
        for (spoon.reflect.code.CtStatement statement : caseStatement.getStatements()) {
            this.printer.writeln();
            this.elementPrinterHelper.writeStatement(statement);
        }
        this.printer.decTab();
        exitCtStatement(caseStatement);
    }

    @java.lang.Override
    public void visitCtCatch(spoon.reflect.code.CtCatch catchBlock) {
        this.elementPrinterHelper.writeComment(catchBlock, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        this.printer.writeSpace().writeKeyword("catch").writeSpace().writeSeparator("(");
        spoon.reflect.code.CtCatchVariable<? extends java.lang.Throwable> parameter = catchBlock.getParameter();
        if ((parameter != null) && ((parameter.getMultiTypes().size()) > 1)) {
            this.elementPrinterHelper.printList(parameter.getMultiTypes(), null, false, null, false, true, "|", true, false, null, ( type) -> scan(type));
            this.printer.writeSpace().writeIdentifier(parameter.getSimpleName());
        }else {
            scan(parameter);
        }
        this.printer.writeSeparator(")").writeSpace();
        scan(catchBlock.getBody());
    }

    @java.lang.Override
    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {
        this.context.pushCurrentThis(ctClass);
        if ((((ctClass.getSimpleName()) != null) && (!(spoon.reflect.declaration.CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName())))) && (!(ctClass.isAnonymous()))) {
            visitCtType(ctClass);
            if (ctClass.isLocalType()) {
                this.printer.writeKeyword("class").writeSpace().writeIdentifier(ctClass.getSimpleName().replaceAll("^[0-9]*", ""));
            }else {
                this.printer.writeKeyword("class").writeSpace().writeIdentifier(ctClass.getSimpleName());
            }
            this.elementPrinterHelper.writeFormalTypeParameters(ctClass);
            this.elementPrinterHelper.writeExtendsClause(ctClass);
            this.elementPrinterHelper.writeImplementsClause(ctClass);
        }
        this.printer.writeSpace().writeSeparator("{").incTab();
        this.elementPrinterHelper.writeElementList(ctClass.getTypeMembers());
        getPrinterHelper().adjustEndPosition(ctClass);
        this.printer.decTab().writeSeparator("}");
        this.context.popCurrentThis();
    }

    @java.lang.Override
    public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {
        this.elementPrinterHelper.writeAnnotations(typeParameter);
        this.printer.writeIdentifier(typeParameter.getSimpleName());
        if (((typeParameter.getSuperclass()) != null) && ((typeParameter.getSuperclass().isImplicit()) == false)) {
            this.printer.writeSpace().writeKeyword("extends").writeSpace();
            scan(typeParameter.getSuperclass());
        }
    }

    @java.lang.Override
    public <T> void visitCtConditional(spoon.reflect.code.CtConditional<T> conditional) {
        enterCtExpression(conditional);
        spoon.reflect.code.CtExpression<java.lang.Boolean> condition = conditional.getCondition();
        boolean parent;
        try {
            parent = ((conditional.getParent()) instanceof spoon.reflect.code.CtAssignment) || ((conditional.getParent()) instanceof spoon.reflect.declaration.CtVariable);
        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {
            // nothing if we have no parent
            parent = false;
        }
        if (parent) {
            this.printer.writeSeparator("(");
        }
        scan(condition);
        if (parent) {
            this.printer.writeSeparator(")");
        }
        this.printer.writeSpace().writeOperator("?").writeSpace();
        spoon.reflect.code.CtExpression<T> thenExpression = conditional.getThenExpression();
        scan(thenExpression);
        this.printer.writeSpace().writeOperator(":").writeSpace();
        spoon.reflect.code.CtExpression<T> elseExpression = conditional.getElseExpression();
        boolean isAssign;
        if (isAssign = elseExpression instanceof spoon.reflect.code.CtAssignment) {
            this.printer.writeSeparator("(");
        }
        scan(elseExpression);
        if (isAssign) {
            this.printer.writeSeparator(")");
        }
        exitCtExpression(conditional);
    }

    @java.lang.Override
    public <T> void visitCtConstructor(spoon.reflect.declaration.CtConstructor<T> constructor) {
        this.elementPrinterHelper.writeComment(constructor);
        this.elementPrinterHelper.visitCtNamedElement(constructor, this.sourceCompilationUnit);
        this.elementPrinterHelper.writeModifiers(constructor);
        this.elementPrinterHelper.writeFormalTypeParameters(constructor);
        if (!(constructor.getFormalCtTypeParameters().isEmpty())) {
            this.printer.writeSpace();
        }
        if ((constructor.getDeclaringType()) != null) {
            if (constructor.getDeclaringType().isLocalType()) {
                this.printer.writeIdentifier(constructor.getDeclaringType().getSimpleName().replaceAll("^[0-9]*", ""));
            }else {
                this.printer.writeIdentifier(constructor.getDeclaringType().getSimpleName());
            }
        }
        this.elementPrinterHelper.writeExecutableParameters(constructor);
        this.elementPrinterHelper.writeThrowsClause(constructor);
        this.printer.writeSpace();
        scan(constructor.getBody());
    }

    @java.lang.Override
    public void visitCtContinue(spoon.reflect.code.CtContinue continueStatement) {
        enterCtStatement(continueStatement);
        this.printer.writeKeyword("continue");
        if ((continueStatement.getTargetLabel()) != null) {
            this.printer.writeSpace().writeIdentifier(continueStatement.getTargetLabel());
        }
        exitCtStatement(continueStatement);
    }

    @java.lang.Override
    public void visitCtDo(spoon.reflect.code.CtDo doLoop) {
        enterCtStatement(doLoop);
        this.printer.writeKeyword("do");
        this.elementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());
        this.printer.writeKeyword("while").writeSpace().writeSeparator("(");
        scan(doLoop.getLoopingExpression());
        this.printer.writeSpace().writeSeparator(")");
        exitCtStatement(doLoop);
    }

    @java.lang.Override
    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {
        visitCtType(ctEnum);
        this.printer.writeKeyword("enum").writeSpace().writeIdentifier(ctEnum.getSimpleName());
        this.elementPrinterHelper.writeImplementsClause(ctEnum);
        this.context.pushCurrentThis(ctEnum);
        this.printer.writeSpace().writeSeparator("{").incTab().writeln();
        if (ctEnum.getEnumValues().isEmpty()) {
            this.printer.writeSeparator(";").writeln();
        }else {
            this.elementPrinterHelper.printList(ctEnum.getEnumValues(), null, false, null, false, false, ",", false, false, ";", ( enumValue) -> {
                this.printer.writeln();
                scan(enumValue);
            });
        }
        this.elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());
        this.printer.decTab().writeSeparator("}");
        this.context.popCurrentThis();
    }

    @java.lang.Override
    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {
        // it is not called during printing of sources. Use shortcut and print directly to PrinterHelper
        this.printer.getPrinterHelper().write(reference.getSignature());
    }

    @java.lang.Override
    public <T> void visitCtField(spoon.reflect.declaration.CtField<T> f) {
        this.elementPrinterHelper.writeComment(f, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        this.elementPrinterHelper.visitCtNamedElement(f, this.sourceCompilationUnit);
        this.elementPrinterHelper.writeModifiers(f);
        scan(f.getType());
        this.printer.writeSpace();
        this.printer.writeIdentifier(f.getSimpleName());
        if ((f.getDefaultExpression()) != null) {
            this.printer.writeSpace().writeOperator("=").writeSpace();
            scan(f.getDefaultExpression());
        }
        this.printer.writeSeparator(";");
        this.elementPrinterHelper.writeComment(f, spoon.reflect.visitor.printer.CommentOffset.AFTER);
    }

    @java.lang.Override
    public <T> void visitCtEnumValue(spoon.reflect.declaration.CtEnumValue<T> enumValue) {
        this.elementPrinterHelper.visitCtNamedElement(enumValue, this.sourceCompilationUnit);
        this.elementPrinterHelper.writeComment(enumValue, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        this.printer.writeIdentifier(enumValue.getSimpleName());
        if ((enumValue.getDefaultExpression()) != null) {
            spoon.reflect.code.CtConstructorCall<?> constructorCall = ((spoon.reflect.code.CtConstructorCall<?>) (enumValue.getDefaultExpression()));
            if (!(constructorCall.isImplicit())) {
                this.elementPrinterHelper.printList(constructorCall.getArguments(), null, false, "(", false, false, ",", true, false, ")", ( expr) -> scan(expr));
            }
            if (constructorCall instanceof spoon.reflect.code.CtNewClass) {
                scan(((spoon.reflect.code.CtNewClass<?>) (constructorCall)).getAnonymousClass());
            }
        }
    }

    @java.lang.Override
    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {
        printCtFieldAccess(fieldRead);
    }

    @java.lang.Override
    public <T> void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite<T> fieldWrite) {
        printCtFieldAccess(fieldWrite);
    }

    private boolean isImported(spoon.reflect.reference.CtFieldReference fieldReference) {
        spoon.reflect.declaration.CtImport fieldImport = fieldReference.getFactory().createImport(fieldReference);
        if (this.imports.contains(fieldImport)) {
            return true;
        }else {
            if ((fieldReference.getDeclaringType()) == null) {
                return false;
            }
            spoon.reflect.reference.CtTypeReference staticTypeMemberReference = fieldReference.getFactory().Type().createWildcardStaticTypeMemberReference(fieldReference.getDeclaringType());
            spoon.reflect.declaration.CtImport staticClassImport = fieldReference.getFactory().createImport(staticTypeMemberReference);
            return this.imports.contains(staticClassImport);
        }
    }

    private boolean isImported(spoon.reflect.reference.CtExecutableReference executableReference) {
        spoon.reflect.declaration.CtImport executableImport = executableReference.getFactory().createImport(executableReference);
        if (this.imports.contains(executableImport)) {
            return true;
        }else {
            if ((executableReference.getDeclaringType()) == null) {
                return false;
            }
            spoon.reflect.reference.CtTypeReference staticTypeMemberReference = executableReference.getFactory().Type().createWildcardStaticTypeMemberReference(executableReference.getDeclaringType());
            spoon.reflect.declaration.CtImport staticClassImport = executableReference.getFactory().createImport(staticTypeMemberReference);
            return this.imports.contains(staticClassImport);
        }
    }

    private <T> void printCtFieldAccess(spoon.reflect.code.CtFieldAccess<T> f) {
        enterCtExpression(f);
        try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify()) {
            if (((f.getVariable().isStatic()) || ("class".equals(f.getVariable().getSimpleName()))) && ((f.getTarget()) instanceof spoon.reflect.code.CtTypeAccess)) {
                _context.ignoreGenerics(true);
            }
            spoon.reflect.code.CtExpression<?> target = f.getTarget();
            if (target != null) {
                boolean isInitializeStaticFinalField = isInitializeStaticFinalField(f.getTarget());
                boolean isStaticField = f.getVariable().isStatic();
                boolean isImportedField = this.isImported(f.getVariable());
                if ((!isInitializeStaticFinalField) && (!(isStaticField && isImportedField))) {
                    if ((target.isImplicit()) && (!(((f.getVariable().getFieldDeclaration()) == null) && (this.env.getNoClasspath())))) {
                        /* target is implicit, check whether there is no conflict with an local variable, catch variable or parameter
                        in case of conflict make it explicit, otherwise the field access is shadowed by that variable.
                        Search for potential variable declaration until we found a class which declares or inherits this field */
                        final spoon.reflect.declaration.CtField<?> field = f.getVariable().getFieldDeclaration();
                        if (field != null) {
                            final java.lang.String fieldName = field.getSimpleName();
                            spoon.reflect.declaration.CtVariable<?> var = f.getVariable().map(new spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction(fieldName)).first();
                            if (var != field) {
                                // another variable declaration was found which is hiding the field declaration for this field access. Make the field access explicit
                                target.setImplicit(false);
                            }
                        }else {
                            // There is a model inconsistency
                            this.printer.writeComment(f.getFactory().createComment((("ERROR: Missing field \"" + (f.getVariable().getSimpleName())) + "\", please check your model. The code may not compile."), spoon.reflect.code.CtComment.CommentType.BLOCK)).writeSpace();
                        }
                    }
                    // the implicit drives the separator
                    if (!(target.isImplicit())) {
                        scan(target);
                        this.printer.writeSeparator(".");
                    }
                }
                _context.ignoreStaticAccess(true);
            }
            scan(f.getVariable());
        }
        exitCtExpression(f);
    }

    /**
    Check if the target expression is a static final field initialized in a static anonymous block.
     */
    private <T> boolean isInitializeStaticFinalField(spoon.reflect.code.CtExpression<T> targetExp) {
        final spoon.reflect.declaration.CtElement parent;
        final spoon.reflect.declaration.CtAnonymousExecutable anonymousParent;
        try {
            parent = targetExp.getParent();
            anonymousParent = targetExp.getParent(spoon.reflect.declaration.CtAnonymousExecutable.class);
        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {
            return false;
        }
        return (((((parent instanceof spoon.reflect.code.CtFieldWrite) && (targetExp.equals(((spoon.reflect.code.CtFieldWrite) (parent)).getTarget()))) && (anonymousParent != null)) && ((((spoon.reflect.code.CtFieldWrite) (parent)).getVariable()) != null)) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.STATIC))) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.FINAL));
    }

    @java.lang.Override
    public <T> void visitCtThisAccess(spoon.reflect.code.CtThisAccess<T> thisAccess) {
        try {
            enterCtExpression(thisAccess);
            // we only write qualified this when this is required
            // this is good both in fully-qualified mode and in readable (with-imports) mode
            // the implicit information is used for analysis (e.g. is visibility caused by implicit bugs?) but
            // not for pretty-printing
            spoon.reflect.code.CtTypeAccess target = ((spoon.reflect.code.CtTypeAccess) (thisAccess.getTarget()));
            spoon.reflect.reference.CtTypeReference targetType = target.getAccessedType();
            // readable mode as close as possible to the original code
            if (thisAccess.isImplicit()) {
                // write nothing, "this" is implicit and we unfortunately cannot always know
                // what the good target is in JDTTreeBuilder
                return;
            }
            // the simplest case: we always print "this" if we're in the top-level class,
            // this is shorter (no qualified this), explicit, and less fragile wrt transformation
            if ((targetType == null) || (((thisAccess.getParent(spoon.reflect.declaration.CtType.class)) != null) && (thisAccess.getParent(spoon.reflect.declaration.CtType.class).isTopLevel()))) {
                this.printer.writeKeyword("this");
                return;// still go through finally block below

            }
            // we cannot have fully-qualified this in anonymous classes
            // we simply print "this" and it always works
            // this has to come after the implicit test just before
            if (targetType.isAnonymous()) {
                this.printer.writeKeyword("this");
                return;
            }
            // complex case of qualified this
            if (!(this.context.currentThis.isEmpty())) {
                spoon.reflect.declaration.CtType lastType = this.context.currentThis.peekFirst().type;
                java.lang.String lastTypeQualifiedName = lastType.getQualifiedName();
                java.lang.String targetTypeQualifiedName = targetType.getQualifiedName();
                if (!(lastTypeQualifiedName.equals(targetTypeQualifiedName))) {
                    if (!(targetType.isImplicit())) {
                        visitCtTypeReferenceWithoutGenerics(targetType);
                        this.printer.writeSeparator(".");
                    }
                    this.printer.writeKeyword("this");
                    return;
                }
            }
            // the default super simple case only comes at the end
            this.printer.writeKeyword("this");
        } finally {
            exitCtExpression(thisAccess);
        }
    }

    @java.lang.Override
    public <T> void visitCtSuperAccess(spoon.reflect.code.CtSuperAccess<T> f) {
        enterCtExpression(f);
        if ((f.getTarget()) != null) {
            scan(f.getTarget());
            this.printer.writeSeparator(".");
        }
        this.printer.writeKeyword("super");
        exitCtExpression(f);
    }

    @java.lang.Override
    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc comment) {
        visitCtComment(comment);
    }

    @java.lang.Override
    public void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag docTag) {
        /* is not called during normal printing of java sources.
        It can be called only when CtJavaDocTag has to be printed directly.
        E.g. from CtJavaDocTag#toString
        Write directly to PrinterHelper, because java doc tag is not a java token. Normally it is part of COMMENT token. */
        spoon.reflect.visitor.CommentHelper.printJavaDocTag(this.printer.getPrinterHelper(), docTag);
    }

    @java.lang.Override
    public void visitCtImport(spoon.reflect.declaration.CtImport ctImport) {
        if ((ctImport.getImportKind()) != null) {
            this.printer.writeKeyword("import");
            this.printer.writeSpace();
            switch (ctImport.getImportKind()) {
                case TYPE :
                    visitCtTypeReference(((spoon.reflect.reference.CtTypeReference) (ctImport.getReference())));
                    break;
                case METHOD :
                    this.printer.writeKeyword("static");
                    this.printer.writeSpace();
                    visitCtExecutableReference(((spoon.reflect.reference.CtExecutableReference) (ctImport.getReference())));
                    break;
                case FIELD :
                    this.printer.writeKeyword("static");
                    this.printer.writeSpace();
                    visitCtFieldReference(((spoon.reflect.reference.CtFieldReference) (ctImport.getReference())));
                    break;
                case ALL_TYPES :
                    visitCtPackageReference(((spoon.reflect.reference.CtPackageReference) (ctImport.getReference())));
                    this.printer.writeSeparator(".");
                    this.printer.writeIdentifier("*");
                    break;
                case ALL_STATIC_MEMBERS :
                    this.printer.writeKeyword("static");
                    this.printer.writeSpace();
                    visitCtTypeReference(((spoon.reflect.reference.CtTypeReference) (ctImport.getReference())));
                    break;
            }
            this.printer.writeSeparator(";");
            this.printer.writeln();
        }
    }

    @java.lang.Override
    public void visitCtModule(spoon.reflect.declaration.CtModule module) {
        enter(module);
        if (module.isOpenModule()) {
            this.printer.writeKeyword("open").writeSpace();
        }
        this.printer.writeKeyword("module").writeSpace().writeIdentifier(module.getSimpleName());
        this.printer.writeSpace().writeSeparator("{").incTab().writeln();
        for (spoon.reflect.declaration.CtModuleDirective moduleDirective : module.getModuleDirectives()) {
            scan(moduleDirective);
        }
        this.printer.decTab().writeSeparator("}");
        exit(module);
    }

    @java.lang.Override
    public void visitCtModuleReference(spoon.reflect.reference.CtModuleReference moduleReference) {
        this.printer.writeIdentifier(moduleReference.getSimpleName());
    }

    @java.lang.Override
    public void visitCtPackageExport(spoon.reflect.declaration.CtPackageExport moduleExport) {
        if (moduleExport.isOpenedPackage()) {
            this.printer.writeKeyword("opens");
        }else {
            this.printer.writeKeyword("exports");
        }
        this.printer.writeSpace();
        visitCtPackageReference(moduleExport.getPackageReference());
        if (!(moduleExport.getTargetExport().isEmpty())) {
            this.elementPrinterHelper.printList(moduleExport.getTargetExport(), null, false, " to", true, false, ",", true, false, null, ( moduleReference) -> scan(moduleReference));
        }
        this.printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtModuleRequirement(spoon.reflect.declaration.CtModuleRequirement moduleRequirement) {
        this.printer.writeKeyword("requires").writeSpace();
        if (!(moduleRequirement.getRequiresModifiers().isEmpty())) {
            this.elementPrinterHelper.printList(moduleRequirement.getRequiresModifiers(), null, false, null, false, false, " ", false, false, " ", ( modifier) -> this.printer.writeKeyword(modifier.name().toLowerCase()));
        }
        scan(moduleRequirement.getModuleReference());
        this.printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtProvidedService(spoon.reflect.declaration.CtProvidedService moduleProvidedService) {
        this.printer.writeKeyword("provides").writeSpace();
        scan(moduleProvidedService.getServiceType());
        this.elementPrinterHelper.printList(moduleProvidedService.getImplementationTypes(), null, false, " with", true, false, ",", true, false, null, ( implementations) -> scan(implementations));
        this.printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtUsedService(spoon.reflect.declaration.CtUsedService usedService) {
        this.printer.writeKeyword("uses").writeSpace();
        scan(usedService.getServiceType());
        this.printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtComment(spoon.reflect.code.CtComment comment) {
        if ((!(this.env.isCommentsEnabled())) && ((this.context.elementStack.size()) > 1)) {
            return;
        }
        this.printer.writeComment(comment);
    }

    @java.lang.Override
    public <T> void visitCtAnnotationFieldAccess(spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {
        enterCtExpression(annotationFieldAccess);
        try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify()) {
            if ((annotationFieldAccess.getTarget()) != null) {
                scan(annotationFieldAccess.getTarget());
                this.printer.writeSeparator(".");
                _context.ignoreStaticAccess(true);
            }
            _context.ignoreGenerics(true);
            scan(annotationFieldAccess.getVariable());
            this.printer.writeSeparator("(").writeSeparator(")");
        }
        exitCtExpression(annotationFieldAccess);
    }

    @java.lang.Override
    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {
        boolean isStatic = ("class".equals(reference.getSimpleName())) || ((!("super".equals(reference.getSimpleName()))) && (reference.isStatic()));
        boolean printType = true;
        if ((reference.isFinal()) && (reference.isStatic())) {
            spoon.reflect.reference.CtTypeReference<?> declTypeRef = reference.getDeclaringType();
            if (declTypeRef.isAnonymous()) {
                // never print anonymous class ref
                printType = false;
            }else {
                if (this.context.isInCurrentScope(declTypeRef)) {
                    // do not printType if we are in scope of that type
                    printType = false;
                }
            }
        }
        if ((isStatic && printType) && (!(this.context.ignoreStaticAccess()))) {
            try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify().ignoreGenerics(true)) {
                scan(reference.getDeclaringType());
            }
            this.printer.writeSeparator(".");
        }
        if ("class".equals(reference.getSimpleName())) {
            this.printer.writeKeyword("class");
        }else {
            this.printer.writeIdentifier(reference.getSimpleName());
        }
    }

    @java.lang.Override
    public void visitCtFor(spoon.reflect.code.CtFor forLoop) {
        enterCtStatement(forLoop);
        this.printer.writeKeyword("for").writeSpace().writeSeparator("(");
        java.util.List<spoon.reflect.code.CtStatement> st = forLoop.getForInit();
        if (!(st.isEmpty())) {
            try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify().isFirstForVariable(true)) {
                scan(st.get(0));
            }
        }
        if ((st.size()) > 1) {
            try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify().isNextForVariable(true)) {
                for (int i = 1; i < (st.size()); i++) {
                    this.printer.writeSeparator(",").writeSpace();
                    scan(st.get(i));
                }
            }
        }
        this.printer.writeSeparator(";").writeSpace();
        scan(forLoop.getExpression());
        this.printer.writeSeparator(";");
        if (!(forLoop.getForUpdate().isEmpty())) {
            this.printer.writeSpace();
        }
        this.elementPrinterHelper.printList(forLoop.getForUpdate(), null, false, null, false, true, ",", true, false, null, ( s) -> scan(s));
        this.printer.writeSeparator(")");
        this.elementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());
        exitCtStatement(forLoop);
    }

    @java.lang.Override
    public void visitCtForEach(spoon.reflect.code.CtForEach foreach) {
        enterCtStatement(foreach);
        this.printer.writeKeyword("for").writeSpace().writeSeparator("(");
        scan(foreach.getVariable());
        this.printer.writeSpace().writeSeparator(":").writeSpace();
        scan(foreach.getExpression());
        this.printer.writeSeparator(")");
        this.elementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());
        exitCtStatement(foreach);
    }

    @java.lang.Override
    public void visitCtIf(spoon.reflect.code.CtIf ifElement) {
        enterCtStatement(ifElement);
        this.printer.writeKeyword("if").writeSpace().writeSeparator("(");
        scan(ifElement.getCondition());
        this.printer.writeSeparator(")");
        this.elementPrinterHelper.writeIfOrLoopBlock(ifElement.getThenStatement());
        if ((ifElement.getElseStatement()) != null) {
            java.util.List<spoon.reflect.code.CtComment> comments = this.elementPrinterHelper.getComments(ifElement, spoon.reflect.visitor.printer.CommentOffset.INSIDE);
            for (spoon.reflect.code.CtComment comment : comments) {
                spoon.reflect.cu.SourcePosition thenPosition = (ifElement.getThenStatement().getPosition().isValidPosition()) ? ifElement.getThenStatement().getPosition() : ((spoon.reflect.code.CtBlock) (ifElement.getThenStatement())).getStatement(0).getPosition();
                if ((comment.getPosition().getSourceStart()) > (thenPosition.getSourceEnd())) {
                    this.elementPrinterHelper.writeComment(comment);
                }
            }
            this.printer.writeKeyword("else");
            this.elementPrinterHelper.writeIfOrLoopBlock(ifElement.getElseStatement());
        }
        exitCtStatement(ifElement);
    }

    @java.lang.Override
    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {
        visitCtType(intrface);
        this.printer.writeKeyword("interface").writeSpace().writeIdentifier(intrface.getSimpleName());
        if ((intrface.getFormalCtTypeParameters()) != null) {
            this.elementPrinterHelper.writeFormalTypeParameters(intrface);
        }
        if (!(intrface.getSuperInterfaces().isEmpty())) {
            this.elementPrinterHelper.printList(intrface.getSuperInterfaces(), "extends", false, null, false, true, ",", true, false, null, ( ref) -> scan(ref));
        }
        this.context.pushCurrentThis(intrface);
        this.printer.writeSpace().writeSeparator("{").incTab();
        // Content
        this.elementPrinterHelper.writeElementList(intrface.getTypeMembers());
        this.printer.decTab().writeSeparator("}");
        this.context.popCurrentThis();
    }

    @java.lang.Override
    public <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> invocation) {
        enterCtStatement(invocation);
        enterCtExpression(invocation);
        if (invocation.getExecutable().isConstructor()) {
            // It's a constructor (super or this)
            this.elementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());
            spoon.reflect.declaration.CtType<?> parentType;
            try {
                parentType = invocation.getParent(spoon.reflect.declaration.CtType.class);
            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {
                parentType = null;
            }
            if (((parentType != null) && ((parentType.getQualifiedName()) != null)) && (parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName()))) {
                this.printer.writeKeyword("this");
            }else {
                if (((invocation.getTarget()) != null) && (!(invocation.getTarget().isImplicit()))) {
                    scan(invocation.getTarget());
                    this.printer.writeSeparator(".");
                }
                this.printer.writeKeyword("super");
            }
        }else {
            // It's a method invocation
            boolean isImported = this.isImported(invocation.getExecutable());
            if (!isImported) {
                try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify()) {
                    if ((invocation.getTarget()) instanceof spoon.reflect.code.CtTypeAccess) {
                        _context.ignoreGenerics(true);
                    }
                    if (((invocation.getTarget()) != null) && (!(invocation.getTarget().isImplicit()))) {
                        scan(invocation.getTarget());
                        this.printer.writeSeparator(".");
                    }
                }
            }
            this.elementPrinterHelper.writeActualTypeArguments(invocation);
            if (this.env.isPreserveLineNumbers()) {
                getPrinterHelper().adjustStartPosition(invocation);
            }
            this.printer.writeIdentifier(invocation.getExecutable().getSimpleName());
        }
        this.elementPrinterHelper.printList(invocation.getArguments(), null, false, "(", false, false, ",", true, false, ")", ( e) -> scan(e));
        exitCtExpression(invocation);
        exitCtStatement(invocation);
    }

    @java.lang.Override
    public <T> void visitCtLiteral(spoon.reflect.code.CtLiteral<T> literal) {
        enterCtExpression(literal);
        this.printer.writeLiteral(spoon.reflect.visitor.LiteralHelper.getLiteralToken(literal));
        exitCtExpression(literal);
    }

    @java.lang.Override
    public <T> void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable<T> localVariable) {
        enterCtStatement(localVariable);
        if (this.env.isPreserveLineNumbers()) {
            getPrinterHelper().adjustStartPosition(localVariable);
        }
        if (!(this.context.isNextForVariable())) {
            this.elementPrinterHelper.writeModifiers(localVariable);
            if ((localVariable.isInferred()) && ((this.env.getComplianceLevel()) >= 10)) {
                getPrinterTokenWriter().writeKeyword("var");
            }else {
                scan(localVariable.getType());
            }
            this.printer.writeSpace();
        }
        this.printer.writeIdentifier(localVariable.getSimpleName());
        if ((localVariable.getDefaultExpression()) != null) {
            this.printer.writeSpace().writeOperator("=").writeSpace();
            scan(localVariable.getDefaultExpression());
        }
        exitCtStatement(localVariable);
    }

    @java.lang.Override
    public <T> void visitCtLocalVariableReference(spoon.reflect.reference.CtLocalVariableReference<T> reference) {
        this.printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {
        if (this.env.isPreserveLineNumbers()) {
            getPrinterHelper().adjustStartPosition(catchVariable);
        }
        this.elementPrinterHelper.writeModifiers(catchVariable);
        scan(catchVariable.getType());
        this.printer.writeSpace();
        this.printer.writeIdentifier(catchVariable.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtCatchVariableReference(spoon.reflect.reference.CtCatchVariableReference<T> reference) {
        this.printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtMethod(spoon.reflect.declaration.CtMethod<T> m) {
        this.elementPrinterHelper.writeComment(m, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        this.elementPrinterHelper.visitCtNamedElement(m, this.sourceCompilationUnit);
        this.elementPrinterHelper.writeModifiers(m);
        this.elementPrinterHelper.writeFormalTypeParameters(m);
        if (!(m.getFormalCtTypeParameters().isEmpty())) {
            this.printer.writeSpace();
        }
        try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify().ignoreGenerics(false)) {
            scan(m.getType());
        }
        this.printer.writeSpace();
        this.printer.writeIdentifier(m.getSimpleName());
        this.elementPrinterHelper.writeExecutableParameters(m);
        this.elementPrinterHelper.writeThrowsClause(m);
        if ((m.getBody()) != null) {
            this.printer.writeSpace();
            scan(m.getBody());
            if (m.getBody().getPosition().isValidPosition()) {
                if ((m.getBody().getPosition().getCompilationUnit()) == (this.sourceCompilationUnit)) {
                    if ((m.getBody().getStatements().isEmpty()) || (!((m.getBody().getStatements().get(((m.getBody().getStatements().size()) - 1))) instanceof spoon.reflect.code.CtReturn))) {
                        getPrinterHelper().putLineNumberMapping(m.getBody().getPosition().getEndLine());
                    }
                }else {
                    getPrinterHelper().undefineLine();
                }
            }else {
                getPrinterHelper().undefineLine();
            }
        }else {
            this.printer.writeSeparator(";");
        }
        this.elementPrinterHelper.writeComment(m, spoon.reflect.visitor.printer.CommentOffset.AFTER);
    }

    @java.lang.Override
    public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {
        this.elementPrinterHelper.writeComment(annotationMethod);
        this.elementPrinterHelper.visitCtNamedElement(annotationMethod, this.sourceCompilationUnit);
        this.elementPrinterHelper.writeModifiers(annotationMethod);
        scan(annotationMethod.getType());
        this.printer.writeSpace();
        this.printer.writeIdentifier(annotationMethod.getSimpleName());
        this.printer.writeSeparator("(").writeSeparator(")");
        if ((annotationMethod.getDefaultExpression()) != null) {
            this.printer.writeSpace().writeKeyword("default").writeSpace();
            scan(annotationMethod.getDefaultExpression());
        }
        this.printer.writeSeparator(";");
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("rawtypes")
    public <T> void visitCtNewArray(spoon.reflect.code.CtNewArray<T> newArray) {
        enterCtExpression(newArray);
        boolean isNotInAnnotation;
        try {
            isNotInAnnotation = ((newArray.getParent(spoon.reflect.declaration.CtAnnotationType.class)) == null) && ((newArray.getParent(spoon.reflect.declaration.CtAnnotation.class)) == null);
        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {
            isNotInAnnotation = true;
        }
        if (isNotInAnnotation) {
            spoon.reflect.reference.CtTypeReference<?> ref = newArray.getType();
            if (ref != null) {
                this.printer.writeKeyword("new").writeSpace();
            }
            try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify().skipArray(true)) {
                scan(ref);
            }
            for (int i = 0; ref instanceof spoon.reflect.reference.CtArrayTypeReference; i++) {
                this.printer.writeSeparator("[");
                if ((newArray.getDimensionExpressions().size()) > i) {
                    spoon.reflect.code.CtExpression<java.lang.Integer> e = newArray.getDimensionExpressions().get(i);
                    scan(e);
                }
                this.printer.writeSeparator("]");
                ref = ((spoon.reflect.reference.CtArrayTypeReference) (ref)).getComponentType();
            }
        }
        if (newArray.getDimensionExpressions().isEmpty()) {
            this.elementPrinterHelper.printList(newArray.getElements(), null, false, "{", true, false, ",", true, true, "}", ( e) -> scan(e));
            this.elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.INSIDE);
        }
        this.elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.AFTER);
        exitCtExpression(newArray);
    }

    @java.lang.Override
    public <T> void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {
        enterCtStatement(ctConstructorCall);
        enterCtExpression(ctConstructorCall);
        printConstructorCall(ctConstructorCall);
        exitCtExpression(ctConstructorCall);
        exitCtStatement(ctConstructorCall);
    }

    @java.lang.Override
    public <T> void visitCtNewClass(spoon.reflect.code.CtNewClass<T> newClass) {
        enterCtStatement(newClass);
        enterCtExpression(newClass);
        printConstructorCall(newClass);
        scan(newClass.getAnonymousClass());
        exitCtExpression(newClass);
        exitCtStatement(newClass);
    }

    private <T> void printConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {
        try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify()) {
            if ((ctConstructorCall.getTarget()) != null) {
                scan(ctConstructorCall.getTarget());
                this.printer.writeSeparator(".");
                _context.ignoreEnclosingClass(true);
            }
            if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {
                _context.ignoreEnclosingClass(true);
            }
            this.printer.writeKeyword("new").writeSpace();
            if (!(ctConstructorCall.getActualTypeArguments().isEmpty())) {
                this.elementPrinterHelper.writeActualTypeArguments(ctConstructorCall);
            }
            scan(ctConstructorCall.getType());
        }
        this.elementPrinterHelper.printList(ctConstructorCall.getArguments(), null, false, "(", false, false, ",", true, false, ")", ( exp) -> scan(exp));
    }

    /**
    JDT doesn't support <code>new Foo<K>.Bar()</code>. To avoid reprinting this kind of type reference,
    we check that the reference has a declaring type with generics.
    See https://bugs.eclipse.org/bugs/show_bug.cgi?id=474593

    @param reference Type reference concerned by the bug.
    @return true if a declaring type has generic types.
     *
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     */
    private <T> boolean hasDeclaringTypeWithGenerics(spoon.reflect.reference.CtTypeReference<T> reference) {
        // We don't have a declaring type, it can't have generics.
        if (reference == null) {
            return false;
        }
        // If the declaring type isn't a type, we don't need this hack.
        if ((reference.getDeclaringType()) == null) {
            return false;
        }
        // If current reference is a class declared in a method, we don't need this hack.
        if (reference.isLocalType()) {
            return false;
        }
        // If declaring type have generics, we return true.
        if (!(reference.getDeclaringType().getActualTypeArguments().isEmpty())) {
            return true;
        }
        // Checks if the declaring type has generic types.
        return hasDeclaringTypeWithGenerics(reference.getDeclaringType());
    }

    @java.lang.Override
    public <T> void visitCtLambda(spoon.reflect.code.CtLambda<T> lambda) {
        enterCtExpression(lambda);
        this.elementPrinterHelper.printList(lambda.getParameters(), null, false, "(", false, false, ",", false, false, ")", ( parameter) -> scan(parameter));
        this.printer.writeSpace();
        this.printer.writeSeparator("->");
        this.printer.writeSpace();
        if ((lambda.getBody()) != null) {
            scan(lambda.getBody());
        }else {
            scan(lambda.getExpression());
        }
        exitCtExpression(lambda);
    }

    @java.lang.Override
    public <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {
        enterCtExpression(expression);
        try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify()) {
            if (expression.getExecutable().isStatic()) {
                _context.ignoreGenerics(true);
            }
            scan(expression.getTarget());
        }
        this.printer.writeSeparator("::");
        if (expression.getExecutable().isConstructor()) {
            this.printer.writeKeyword("new");
        }else {
            this.printer.writeIdentifier(expression.getExecutable().getSimpleName());
        }
        exitCtExpression(expression);
    }

    @java.lang.Override
    public <T, A extends T> void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {
        enterCtStatement(assignment);
        enterCtExpression(assignment);
        scan(assignment.getAssigned());
        this.printer.writeSpace();
        // the operators like +=, *= are sent as one operator token
        this.printer.writeOperator(((spoon.reflect.visitor.OperatorHelper.getOperatorText(assignment.getKind())) + "="));
        this.printer.writeSpace();
        scan(assignment.getAssignment());
        exitCtExpression(assignment);
        exitCtStatement(assignment);
    }

    @java.lang.Override
    public void visitCtPackage(spoon.reflect.declaration.CtPackage ctPackage) {
        if (!(ctPackage.isUnnamedPackage())) {
            this.elementPrinterHelper.writePackageLine(ctPackage.getQualifiedName());
        }else {
            this.printer.writeComment(ctPackage.getFactory().createComment("default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon= unnamed package)", spoon.reflect.code.CtComment.CommentType.INLINE)).writeln();
        }
    }

    @java.lang.Override
    public void visitCtPackageReference(spoon.reflect.reference.CtPackageReference reference) {
        this.elementPrinterHelper.writeQualifiedName(reference.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtParameter(spoon.reflect.declaration.CtParameter<T> parameter) {
        this.elementPrinterHelper.writeComment(parameter);
        this.elementPrinterHelper.writeAnnotations(parameter);
        this.elementPrinterHelper.writeModifiers(parameter);
        if (parameter.isVarArgs()) {
            scan(((spoon.reflect.reference.CtArrayTypeReference<T>) (parameter.getType())).getComponentType());
            this.printer.writeSeparator("...");
        }else {
            scan(parameter.getType());
        }
        this.printer.writeSpace();
        this.printer.writeIdentifier(parameter.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtParameterReference(spoon.reflect.reference.CtParameterReference<T> reference) {
        this.printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public <R> void visitCtReturn(spoon.reflect.code.CtReturn<R> returnStatement) {
        enterCtStatement(returnStatement);
        this.printer.writeKeyword("return");
        // checkstyle wants "return;" and not "return ;"
        if ((returnStatement.getReturnedExpression()) != null) {
            this.printer.writeSpace();
        }
        scan(returnStatement.getReturnedExpression());
        exitCtStatement(returnStatement);
    }

    private <T> void visitCtType(spoon.reflect.declaration.CtType<T> type) {
        this.elementPrinterHelper.writeComment(type, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        getPrinterHelper().mapLine(type, this.sourceCompilationUnit);
        if (type.isTopLevel()) {
            this.context.currentTopLevel = type;
        }
        this.elementPrinterHelper.visitCtNamedElement(type, this.sourceCompilationUnit);
        this.elementPrinterHelper.writeModifiers(type);
    }

    @java.lang.Override
    public void visitCtStatementList(spoon.reflect.code.CtStatementList statements) {
        for (spoon.reflect.code.CtStatement s : statements.getStatements()) {
            scan(s);
        }
    }

    @java.lang.Override
    public <E> void visitCtSwitch(spoon.reflect.code.CtSwitch<E> switchStatement) {
        enterCtStatement(switchStatement);
        this.printer.writeKeyword("switch").writeSpace().writeSeparator("(");
        scan(switchStatement.getSelector());
        this.printer.writeSeparator(")").writeSpace().writeSeparator("{").incTab();
        for (spoon.reflect.code.CtCase<?> c : switchStatement.getCases()) {
            this.printer.writeln();
            scan(c);
        }
        if (this.env.isPreserveLineNumbers()) {
            this.printer.decTab().writeSeparator("}");
        }else {
            this.printer.decTab().writeln().writeSeparator("}");
        }
        exitCtStatement(switchStatement);
    }

    @java.lang.Override
    public void visitCtSynchronized(spoon.reflect.code.CtSynchronized synchro) {
        enterCtStatement(synchro);
        this.printer.writeKeyword("synchronized");
        if ((synchro.getExpression()) != null) {
            this.printer.writeSeparator("(");
            scan(synchro.getExpression());
            this.printer.writeSeparator(")").writeSpace();
        }
        scan(synchro.getBlock());
        exitCtStatement(synchro);
    }

    @java.lang.Override
    public void visitCtThrow(spoon.reflect.code.CtThrow throwStatement) {
        enterCtStatement(throwStatement);
        this.printer.writeKeyword("throw").writeSpace();
        scan(throwStatement.getThrownExpression());
        exitCtStatement(throwStatement);
    }

    @java.lang.Override
    public void visitCtTry(spoon.reflect.code.CtTry tryBlock) {
        enterCtStatement(tryBlock);
        this.printer.writeKeyword("try").writeSpace();
        scan(tryBlock.getBody());
        for (spoon.reflect.code.CtCatch c : tryBlock.getCatchers()) {
            scan(c);
        }
        if ((tryBlock.getFinalizer()) != null) {
            this.printer.writeSpace().writeKeyword("finally").writeSpace();
            scan(tryBlock.getFinalizer());
        }
        exitCtStatement(tryBlock);
    }

    @java.lang.Override
    public void visitCtTryWithResource(spoon.reflect.code.CtTryWithResource tryWithResource) {
        enterCtStatement(tryWithResource);
        this.printer.writeKeyword("try").writeSpace();
        if (((tryWithResource.getResources()) != null) && (!(tryWithResource.getResources().isEmpty()))) {
            this.elementPrinterHelper.printList(tryWithResource.getResources(), null, false, "(", false, false, ";", false, false, ")", ( r) -> scan(r));
        }
        this.printer.writeSpace();
        scan(tryWithResource.getBody());
        for (spoon.reflect.code.CtCatch c : tryWithResource.getCatchers()) {
            scan(c);
        }
        if ((tryWithResource.getFinalizer()) != null) {
            this.printer.writeSpace().writeKeyword("finally").writeSpace();
            scan(tryWithResource.getFinalizer());
        }
        exitCtStatement(tryWithResource);
    }

    @java.lang.Override
    public void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {
        if (ref.isImplicit()) {
            return;
        }
        this.elementPrinterHelper.writeAnnotations(ref);
        if (printQualified(ref)) {
            this.elementPrinterHelper.writeQualifiedName(ref.getQualifiedName());
        }else {
            this.printer.writeIdentifier(ref.getSimpleName());
        }
    }

    @java.lang.Override
    public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {
        if (wildcardReference.isImplicit()) {
            return;
        }
        this.elementPrinterHelper.writeAnnotations(wildcardReference);
        this.printer.writeSeparator("?");
        // we ignore printing "extends Object" except if it's explicit
        if ((!(wildcardReference.isDefaultBoundingType())) || (!(wildcardReference.getBoundingType().isImplicit()))) {
            if (wildcardReference.isUpper()) {
                this.printer.writeSpace().writeKeyword("extends").writeSpace();
            }else {
                this.printer.writeSpace().writeKeyword("super").writeSpace();
            }
            scan(wildcardReference.getBoundingType());
        }
    }

    private boolean printQualified(spoon.reflect.reference.CtTypeReference<?> ref) {
        // or that we are in java.lang
        if ((this.importsContext.isImported(ref))// If my.pkg.Something is imported
         || (((this.env.isAutoImports()) && ((ref.getPackage()) != null)) && ("java.lang".equals(ref.getPackage().getSimpleName())))) {
            for (spoon.reflect.visitor.CacheBasedConflictFinder typeContext : this.context.currentThis) {
                // A) we are in the context of a class which is also called "Something",
                if ((typeContext.getSimpleName().equals(ref.getSimpleName())) && (!(java.util.Objects.equals(typeContext.getPackage(), ref.getPackage())))) {
                    return true;
                }
                // B) we are in the context of a class which defines field which is also called "Something",
                // we should still use qualified version my.pkg.Something
                // fix of #2369
                if ((typeContext.hasFieldConflict(ref.getSimpleName())) || (typeContext.hasNestedTypeConflict(ref.getSimpleName()))) {
                    return true;
                }
            }
            return false;
        }else {
            return true;
        }
    }

    @java.lang.Override
    public <T> void visitCtIntersectionTypeReference(spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {
        this.elementPrinterHelper.printList(reference.getBounds(), null, false, null, false, true, "&", true, false, null, ( bound) -> scan(bound));
    }

    @java.lang.Override
    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> ref) {
        visitCtTypeReference(ref, true);
    }

    @java.lang.Override
    public <T> void visitCtTypeAccess(spoon.reflect.code.CtTypeAccess<T> typeAccess) {
        if (typeAccess.isImplicit()) {
            return;
        }
        enterCtExpression(typeAccess);
        scan(typeAccess.getAccessedType());
        exitCtExpression(typeAccess);
    }

    private void visitCtTypeReferenceWithoutGenerics(spoon.reflect.reference.CtTypeReference<?> ref) {
        visitCtTypeReference(ref, false);
    }

    private void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<?> ref, boolean withGenerics) {
        if (ref.isImplicit()) {
            return;
        }
        if (ref.isPrimitive()) {
            this.elementPrinterHelper.writeAnnotations(ref);
            this.printer.writeKeyword(ref.getSimpleName());
            return;
        }
        boolean isInner = (ref.getDeclaringType()) != null;
        if (isInner) {
            if ((!(this.context.ignoreEnclosingClass())) && (!(ref.isLocalType()))) {
                // compute visible type which can be used to print access path to ref
                spoon.reflect.reference.CtTypeReference<?> accessType = ref.getAccessType();
                if (!(accessType.isAnonymous())) {
                    try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify()) {
                        if (!withGenerics) {
                            _context.ignoreGenerics(true);
                        }
                        scan(accessType);
                    }
                    this.printer.writeSeparator(".");
                }
            }
            // ?? are these annotations on correct place ??
            this.elementPrinterHelper.writeAnnotations(ref);
            if (ref.isLocalType()) {
                this.printer.writeIdentifier(ref.getSimpleName().replaceAll("^[0-9]*", ""));
            }else {
                this.printer.writeIdentifier(ref.getSimpleName());
            }
        }else {
            if (((ref.getPackage()) != null) && (printQualified(ref))) {
                if (!(ref.getPackage().isUnnamedPackage())) {
                    scan(ref.getPackage());
                    this.printer.writeSeparator(spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);
                }
            }
            this.elementPrinterHelper.writeAnnotations(ref);
            this.printer.writeIdentifier(ref.getSimpleName());
        }
        if (withGenerics && (!(this.context.ignoreGenerics()))) {
            try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify().ignoreEnclosingClass(false)) {
                this.elementPrinterHelper.writeActualTypeArguments(ref);
            }
        }
    }

    @java.lang.Override
    public <T> void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator<T> operator) {
        enterCtStatement(operator);
        enterCtExpression(operator);
        spoon.reflect.code.UnaryOperatorKind op = operator.getKind();
        if (spoon.reflect.visitor.OperatorHelper.isPrefixOperator(op)) {
            this.printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(op));
        }
        scan(operator.getOperand());
        if (spoon.reflect.visitor.OperatorHelper.isSufixOperator(op)) {
            this.printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(op));
        }
        exitCtExpression(operator);
        exitCtStatement(operator);
    }

    @java.lang.Override
    public <T> void visitCtVariableRead(spoon.reflect.code.CtVariableRead<T> variableRead) {
        enterCtExpression(variableRead);
        this.printer.writeIdentifier(variableRead.getVariable().getSimpleName());
        exitCtExpression(variableRead);
    }

    @java.lang.Override
    public <T> void visitCtVariableWrite(spoon.reflect.code.CtVariableWrite<T> variableWrite) {
        enterCtExpression(variableWrite);
        this.printer.writeIdentifier(variableWrite.getVariable().getSimpleName());
        exitCtExpression(variableWrite);
    }

    @java.lang.Override
    public void visitCtWhile(spoon.reflect.code.CtWhile whileLoop) {
        enterCtStatement(whileLoop);
        this.printer.writeKeyword("while").writeSpace().writeSeparator("(");
        scan(whileLoop.getLoopingExpression());
        this.printer.writeSeparator(")");
        this.elementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());
        exitCtStatement(whileLoop);
    }

    @java.lang.Override
    public <T> void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression<T> expression) {
        this.elementPrinterHelper.writeComment(expression);
        this.printer.writeCodeSnippet(expression.getValue());
    }

    @java.lang.Override
    public void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement statement) {
        enterCtStatement(statement);
        this.printer.writeCodeSnippet(statement.getValue());
        exitCtStatement(statement);
    }

    public spoon.reflect.visitor.ElementPrinterHelper getElementPrinterHelper() {
        return this.elementPrinterHelper;
    }

    public spoon.reflect.visitor.PrintingContext getContext() {
        return this.context;
    }

    @java.lang.Override
    public <T> void visitCtUnboundVariableReference(spoon.reflect.reference.CtUnboundVariableReference<T> reference) {
        this.printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public java.lang.String printPackageInfo(spoon.reflect.declaration.CtPackage pack) {
        reset();
        this.elementPrinterHelper.writeComment(pack);
        // we need to compute imports only for annotations
        // we don't want to get all imports coming from content of package
        for (spoon.reflect.declaration.CtAnnotation annotation : pack.getAnnotations()) {
            this.importsContext.computeImports(annotation);
        }
        this.elementPrinterHelper.writeAnnotations(pack);
        if (!(pack.isUnnamedPackage())) {
            this.elementPrinterHelper.writePackageLine(pack.getQualifiedName());
        }
        this.elementPrinterHelper.writeImports(this.importsContext.getAllImports());
        return this.printer.getPrinterHelper().toString();
    }

    @java.lang.Override
    public java.lang.String printModuleInfo(spoon.reflect.declaration.CtModule module) {
        reset();
        scan(module);
        return this.getResult();
    }

    @java.lang.Override
    public java.lang.String getResult() {
        return this.printer.getPrinterHelper().toString();
    }

    private void reset() {
        this.printer.reset();
        this.context = new spoon.reflect.visitor.PrintingContext();
        if (this.env.isAutoImports()) {
            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();
        }else {
            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();
        }
    }

    /**
    Write the compilation unit header.
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter writeHeader(java.util.List<spoon.reflect.declaration.CtType<?>> types, java.util.Collection<spoon.reflect.declaration.CtImport> imports) {
        this.elementPrinterHelper.writeHeader(types, imports);
        return this;
    }

    /**
    Write the compilation unit footer.
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter writeFooter(java.util.List<spoon.reflect.declaration.CtType<?>> types) {
        this.elementPrinterHelper.writeFooter(types);
        return this;
    }

    @java.lang.Override
    public void calculate(spoon.reflect.cu.CompilationUnit sourceCompilationUnit, java.util.List<spoon.reflect.declaration.CtType<?>> types) {
        // reset the importsContext to avoid errors with multiple CU
        reset();
        this.sourceCompilationUnit = sourceCompilationUnit;
        this.imports = new java.util.HashSet<>();
        if (sourceCompilationUnit != null) {
            this.importsContext.initWithImports(sourceCompilationUnit.getImports());
        }
        for (spoon.reflect.declaration.CtType<?> t : types) {
            this.imports.addAll(computeImports(t));
        }
        this.writeHeader(types, this.imports);
        printTypes(types);
    }

    protected void printTypes(java.util.List<spoon.reflect.declaration.CtType<?>> types) {
        for (spoon.reflect.declaration.CtType<?> t : types) {
            scan(t);
            if (!(this.env.isPreserveLineNumbers())) {
                // saving lines and chars
                this.printer.writeln().writeln();
            }else {
                getPrinterHelper().adjustEndPosition(t);
            }
        }
        this.writeFooter(types);
    }

    @java.lang.Override
    public java.util.Map<java.lang.Integer, java.lang.Integer> getLineNumberMapping() {
        return getPrinterHelper().getLineNumberMapping();
    }

    /**
     *
     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     */
    protected spoon.reflect.visitor.TokenWriter getPrinterTokenWriter() {
        return this.printer;
    }

    /**
    Set {@link TokenWriter}, which has to be used to print tokens
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter setPrinterTokenWriter(spoon.reflect.visitor.TokenWriter tokenWriter) {
        this.elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(tokenWriter, this, this.env);
        this.printer = tokenWriter;
        return this;
    }

    private spoon.reflect.visitor.PrinterHelper getPrinterHelper() {
        return this.printer.getPrinterHelper();
    }
}>
	at spoon.reflect.ast.CloneTest.lambda$testCloneListener$0(CloneTest.java:169)
	at spoon.reflect.ast.CloneTest.testCloneListener(CloneTest.java:165)

[INFO] Running spoon.reflect.ast.AstCheckerTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.575 s - in spoon.reflect.ast.AstCheckerTest
[INFO] Running spoon.testing.FileAssertTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.158 s - in spoon.testing.FileAssertTest
[INFO] Running spoon.testing.CtElementAssertTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.218 s - in spoon.testing.CtElementAssertTest
[INFO] Running spoon.testing.AbstractAssertTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.291 s - in spoon.testing.AbstractAssertTest
[INFO] Running spoon.testing.CtPackageAssertTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.124 s - in spoon.testing.CtPackageAssertTest
[INFO] Running spoon.support.compiler.jdt.ExtendedStringLiteralTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.043 s - in spoon.support.compiler.jdt.ExtendedStringLiteralTest
[INFO] Running spoon.support.compiler.jdt.JDTBuilderTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.support.compiler.jdt.JDTBuilderTest
[INFO] Running spoon.support.compiler.jdt.JDTBatchCompilerTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.079 s - in spoon.support.compiler.jdt.JDTBatchCompilerTest
[INFO] Running spoon.support.compiler.jdt.JDTBasedSpoonCompilerTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.543 s - in spoon.support.compiler.jdt.JDTBasedSpoonCompilerTest
[INFO] Running spoon.support.compiler.classpath.ComputeClasspathTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.support.compiler.classpath.ComputeClasspathTest
[INFO] Running spoon.support.visitor.java.JavaReflectionTreeBuilderTest
[INFO] Tests run: 19, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.964 s - in spoon.support.visitor.java.JavaReflectionTreeBuilderTest
[INFO] Running spoon.JarLauncherTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 13.338 s - in spoon.JarLauncherTest
[INFO] Running spoon.processing.ProcessingTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.115 s - in spoon.processing.ProcessingTest
[INFO] Running spoon.processing.CtGenerationTest
[ERROR] Tests run: 4, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 33.972 s <<< FAILURE! - in spoon.processing.CtGenerationTest
[ERROR] testGenerateCloneVisitor(spoon.processing.CtGenerationTest)  Time elapsed: 20.957 s  <<< ERROR!
spoon.SpoonException: 
Get more than one setter. Please make an more ingenious method to get setter method. 0 /**
parsed version of the javadoc
 */
private transient spoon.support.javadoc.Javadoc javadoc;
	at spoon.processing.CtGenerationTest.testGenerateCloneVisitor(CtGenerationTest.java:151)

[INFO] Running spoon.MavenLauncherTest
[WARNING] Tests run: 8, Failures: 0, Errors: 0, Skipped: 1, Time elapsed: 89.09 s - in spoon.MavenLauncherTest
[INFO] Running spoon.LauncherTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.215 s - in spoon.LauncherTest
[INFO] 
[INFO] Results:
[INFO] 
[ERROR] Failures: 
[ERROR]   CloneTest.testCloneListener:165->lambda$testCloneListener$0:169 Source and Target are not equal expected:</**
A visitor for generating Java code from the program compile-time model.
 */
public class DefaultJavaPrettyPrinter implements spoon.reflect.visitor.CtVisitor , spoon.reflect.visitor.PrettyPrinter {
    /**
    Java file extension (.java).
     */
    public static final java.lang.String JAVA_FILE_EXTENSION = ".java";

    /**
    Package declaration file name.
     */
    public static final java.lang.String JAVA_PACKAGE_DECLARATION = "package-info" + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);

    /**
    Module declaration file name.
     */
    public static final java.lang.String JAVA_MODULE_DECLARATION = "module-info" + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);

    /**
    Line separator which is used by the system
     */
    public static final java.lang.String LINE_SEPARATOR = java.lang.System.getProperty("line.separator");

    /**
    The star at the beginning of a block/JavaDoc comment line
     */
    public static final java.lang.String COMMENT_STAR = " * ";

    /**
    The end of a block/JavaDoc comment
     */
    public static final java.lang.String BLOCK_COMMENT_END = " */";

    /**
    The beginning of a JavaDoc comment
     */
    public static final java.lang.String JAVADOC_START = "/**";

    /**
    The beginning of an inline comment
     */
    public static final java.lang.String INLINE_COMMENT_START = "// ";

    /**
    The beginning of a block comment
     */
    public static final java.lang.String BLOCK_COMMENT_START = "/* ";

    /**
    The printing context.

    since Spoon 7.1.0, use {{@link #getContext()}}
     */
    private spoon.reflect.visitor.PrintingContext context = new spoon.reflect.visitor.PrintingContext();

    /**
    get the import scanner of this pretty printer
     */
    public spoon.reflect.visitor.ImportScanner getImportsContext() {
        return importsContext;
    }

    /**
    Handle imports of classes.
     */
    private spoon.reflect.visitor.ImportScanner importsContext;

    /**
    Environment which Spoon is executed.
     */
    protected spoon.compiler.Environment env;

    /**
    Token detector, which delegates tokens to {@link TokenWriter}
     */
    private spoon.reflect.visitor.TokenWriter printer;

    /**
    Element printer helper.
     */
    private spoon.reflect.visitor.ElementPrinterHelper elementPrinterHelper;

    /**
    Compilation unit we are printing.
     */
    protected spoon.reflect.cu.CompilationUnit sourceCompilationUnit;

    /**
    Imports computed
     */
    java.util.Set<spoon.reflect.declaration.CtImport> imports;

    /**
    Creates a new code generator visitor.
     */
    public DefaultJavaPrettyPrinter(spoon.compiler.Environment env) {
        this.env = env;
        this.imports = new java.util.HashSet<>();
        setPrinterTokenWriter(new spoon.reflect.visitor.DefaultTokenWriter(new spoon.reflect.visitor.PrinterHelper(env)));
        if (env.isAutoImports()) {
            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();
        }else {
            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();
        }
    }

    /**

    @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
    defined by System.getProperty("line.separator")
     *
     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
     * defined by System.getProperty("line.separator")
     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
     * defined by System.getProperty("line.separator")
     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
     * defined by System.getProperty("line.separator")
     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
     * defined by System.getProperty("line.separator")
     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
     * defined by System.getProperty("line.separator")
     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
     * defined by System.getProperty("line.separator")
     */
    public java.lang.String getLineSeparator() {
        return getPrinterHelper().getLineSeparator();
    }

    /**

    @param lineSeparator characters which will be printed as End of line.
    By default there is System.getProperty("line.separator")
     *
     * @param lineSeparator * 		characters which will be printed as End of line.
     * 		By default there is System.getProperty("line.separator")
     * @param lineSeparator * 		characters which will be printed as End of line.
     * 		By default there is System.getProperty("line.separator")
     * @param lineSeparator * 		characters which will be printed as End of line.
     * 		By default there is System.getProperty("line.separator")
     * @param lineSeparator * 		characters which will be printed as End of line.
     * 		By default there is System.getProperty("line.separator")
     * @param lineSeparator * 		characters which will be printed as End of line.
     * 		By default there is System.getProperty("line.separator")
     * @param lineSeparator * 		characters which will be printed as End of line.
     * 		By default there is System.getProperty("line.separator")
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter setLineSeparator(java.lang.String lineSeparator) {
        getPrinterHelper().setLineSeparator(lineSeparator);
        return this;
    }

    /**
    Enters an expression.
     */
    protected void enterCtExpression(spoon.reflect.code.CtExpression<?> e) {
        if (!(e instanceof spoon.reflect.code.CtStatement)) {
            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        }
        getPrinterHelper().mapLine(e, sourceCompilationUnit);
        if (shouldSetBracket(e)) {
            context.parenthesedExpression.push(e);
            printer.writeSeparator("(");
        }
        if (!(e.getTypeCasts().isEmpty())) {
            for (spoon.reflect.reference.CtTypeReference<?> r : e.getTypeCasts()) {
                printer.writeSeparator("(");
                scan(r);
                printer.writeSeparator(")").writeSpace();
                printer.writeSeparator("(");
                context.parenthesedExpression.push(e);
            }
        }
    }

    /**
    Enters a statement.
     */
    protected void enterCtStatement(spoon.reflect.code.CtStatement s) {
        elementPrinterHelper.writeComment(s, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        getPrinterHelper().mapLine(s, sourceCompilationUnit);
        if (!(context.isNextForVariable())) {
            // TODO AnnotationLoopTest#testAnnotationDeclaredInForInit expects that annotations of next for variables are not printed
            // but may be correct is that the next variables are not annotated, because they might have different annotation then first param!
            elementPrinterHelper.writeAnnotations(s);
        }
        if ((!(context.isFirstForVariable())) && (!(context.isNextForVariable()))) {
            if ((s.getLabel()) != null) {
                printer.writeIdentifier(s.getLabel()).writeSpace().writeSeparator(":").writeSpace();
            }
        }
    }

    /**
    Exits a statement.
     */
    protected void exitCtStatement(spoon.reflect.code.CtStatement statement) {
        if (!((((((((((statement instanceof spoon.reflect.code.CtBlock) || (statement instanceof spoon.reflect.code.CtIf)) || (statement instanceof spoon.reflect.code.CtFor)) || (statement instanceof spoon.reflect.code.CtForEach)) || (statement instanceof spoon.reflect.code.CtWhile)) || (statement instanceof spoon.reflect.code.CtTry)) || (statement instanceof spoon.reflect.code.CtSwitch)) || (statement instanceof spoon.reflect.code.CtSynchronized)) || (statement instanceof spoon.reflect.declaration.CtClass)) || (statement instanceof spoon.reflect.code.CtComment))) {
            if (((context.isStatement(statement)) && (!(context.isFirstForVariable()))) && (!(context.isNextForVariable()))) {
                printer.writeSeparator(";");
            }
        }
        elementPrinterHelper.writeComment(statement, spoon.reflect.visitor.printer.CommentOffset.AFTER);
    }

    /**
    Exits an expression.
     */
    protected void exitCtExpression(spoon.reflect.code.CtExpression<?> e) {
        while ((!(context.parenthesedExpression.isEmpty())) && (e == (context.parenthesedExpression.peek()))) {
            context.parenthesedExpression.pop();
            printer.writeSeparator(")");
        } 
        if (!(e instanceof spoon.reflect.code.CtStatement)) {
            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);
        }
    }

    /**
    Make the imports for a given type.
     */
    private java.util.Collection<spoon.reflect.declaration.CtImport> computeImports(spoon.reflect.declaration.CtType<?> type) {
        context.currentTopLevel = type;
        importsContext.computeImports(context.currentTopLevel);
        return importsContext.getAllImports();
    }

    /**
    This method is called by {@link #scan(CtElement)} when entering a scanned element.
    To be overridden to implement specific behavior.

    Same KISS design as for {@link CtScanner}.
     */
    protected void enter(spoon.reflect.declaration.CtElement e) {
    }

    /**
    This method is called by {@link #scan(CtElement)} when entering a scanned element.
    To be overridden to implement specific behavior.
     */
    protected void exit(spoon.reflect.declaration.CtElement e) {
    }

    /**
    The generic scan method for an element.
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.declaration.CtElement e) {
        if (e != null) {
            enter(e);
            context.elementStack.push(e);
            if (env.isPreserveLineNumbers()) {
                if (!(e instanceof spoon.reflect.declaration.CtNamedElement)) {
                    getPrinterHelper().adjustStartPosition(e);
                }
            }
            try {
                e.accept(this);
            } catch (spoon.SpoonException ex) {
                throw ex;
            } catch (java.lang.Exception ex) {
                java.lang.String elementInfo = e.getClass().getName();
                elementInfo += (" on path " + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.getPath(e))) + "\n";
                if (e.getPosition().isValidPosition()) {
                    elementInfo += ("at position " + (e.getPosition().toString())) + " ";
                }
                throw new spoon.SpoonException((("Printing of " + elementInfo) + "failed"), ex);
            }
            context.elementStack.pop();
            exit(e);
        }
        return this;
    }

    private static java.lang.String getPath(spoon.reflect.declaration.CtElement ele) {
        java.lang.StringBuilder sb = new java.lang.StringBuilder();
        spoon.reflect.visitor.DefaultJavaPrettyPrinter.addParentPath(sb, ele);
        if (ele instanceof spoon.reflect.code.CtVariableAccess) {
            sb.append(':').append(((spoon.reflect.code.CtVariableAccess) (ele)).getVariable().getSimpleName());
        }
        return sb.toString();
    }

    private static void addParentPath(java.lang.StringBuilder sb, spoon.reflect.declaration.CtElement ele) {
        if ((ele == null) || ((ele instanceof spoon.reflect.declaration.CtPackage) && (((spoon.reflect.declaration.CtPackage) (ele)).isUnnamedPackage()))) {
            return;
        }
        if (ele.isParentInitialized()) {
            spoon.reflect.visitor.DefaultJavaPrettyPrinter.addParentPath(sb, ele.getParent());
        }
        sb.append("\n\t").append(ele.getClass().getSimpleName());
        if (ele instanceof spoon.reflect.declaration.CtNamedElement) {
            sb.append(":").append(((spoon.reflect.declaration.CtNamedElement) (ele)).getSimpleName());
        }else
            if (ele instanceof spoon.reflect.reference.CtReference) {
                sb.append(":").append(((spoon.reflect.reference.CtReference) (ele)).getSimpleName());
            }

    }

    private boolean shouldSetBracket(spoon.reflect.code.CtExpression<?> e) {
        if (!(e.getTypeCasts().isEmpty())) {
            return true;
        }
        try {
            if (((e.getParent()) instanceof spoon.reflect.code.CtBinaryOperator) || ((e.getParent()) instanceof spoon.reflect.code.CtUnaryOperator)) {
                return ((((e instanceof spoon.reflect.code.CtTargetedExpression) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator)) || (e instanceof spoon.reflect.code.CtBinaryOperator);
            }
            if ((e.getParent()) instanceof spoon.reflect.code.CtTargetedExpression) {
                return (((e instanceof spoon.reflect.code.CtBinaryOperator) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator);
            }
        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {
            // nothing we accept not to have a parent
        }
        return false;
    }

    /**
    Gets the currently pretty-printed string.
     */
    @java.lang.Override
    public java.lang.String toString() {
        return printer.getPrinterHelper().toString();
    }

    @java.lang.Override
    public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation<A> annotation) {
        elementPrinterHelper.writeAnnotations(annotation);
        printer.writeSeparator("@");
        scan(annotation.getAnnotationType());
        if (!(annotation.getValues().isEmpty())) {
            elementPrinterHelper.printList(annotation.getValues().entrySet(), null, false, "(", false, false, ",", true, false, ")", ( e) -> {
                if ((((annotation.getValues().size()) == 1) && ("value".equals(e.getKey()))) == false) {
                    // it is not a default value attribute. We must print a attribute name too.
                    printer.writeIdentifier(e.getKey()).writeSpace().writeOperator("=").writeSpace();
                }
                elementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());
            });
        }
    }

    @java.lang.Override
    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {
        visitCtType(annotationType);
        printer.writeSeparator("@").writeKeyword("interface").writeSpace().writeIdentifier(annotationType.getSimpleName()).writeSpace().writeSeparator("{").incTab();
        elementPrinterHelper.writeElementList(annotationType.getTypeMembers());
        printer.decTab().writeSeparator("}");
    }

    @java.lang.Override
    public void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable impl) {
        elementPrinterHelper.writeComment(impl);
        elementPrinterHelper.writeAnnotations(impl);
        elementPrinterHelper.writeModifiers(impl);
        scan(impl.getBody());
    }

    @java.lang.Override
    public <T> void visitCtArrayRead(spoon.reflect.code.CtArrayRead<T> arrayRead) {
        printCtArrayAccess(arrayRead);
    }

    @java.lang.Override
    public <T> void visitCtArrayWrite(spoon.reflect.code.CtArrayWrite<T> arrayWrite) {
        printCtArrayAccess(arrayWrite);
    }

    private <T, E extends spoon.reflect.code.CtExpression<?>> void printCtArrayAccess(spoon.reflect.code.CtArrayAccess<T, E> arrayAccess) {
        enterCtExpression(arrayAccess);
        scan(arrayAccess.getTarget());
        printer.writeSeparator("[");
        scan(arrayAccess.getIndexExpression());
        printer.writeSeparator("]");
        exitCtExpression(arrayAccess);
    }

    @java.lang.Override
    public <T> void visitCtArrayTypeReference(spoon.reflect.reference.CtArrayTypeReference<T> reference) {
        if (reference.isImplicit()) {
            return;
        }
        scan(reference.getComponentType());
        if (!(context.skipArray())) {
            printer.writeSeparator("[").writeSeparator("]");
        }
    }

    @java.lang.Override
    public <T> void visitCtAssert(spoon.reflect.code.CtAssert<T> asserted) {
        enterCtStatement(asserted);
        printer.writeKeyword("assert").writeSpace();
        scan(asserted.getAssertExpression());
        if ((asserted.getExpression()) != null) {
            printer.writeSpace().writeSeparator(":").writeSpace();
            scan(asserted.getExpression());
        }
        exitCtStatement(asserted);
    }

    @java.lang.Override
    public <T, A extends T> void visitCtAssignment(spoon.reflect.code.CtAssignment<T, A> assignement) {
        enterCtStatement(assignement);
        enterCtExpression(assignement);
        scan(assignement.getAssigned());
        printer.writeSpace().writeOperator("=").writeSpace();
        scan(assignement.getAssignment());
        exitCtExpression(assignement);
        exitCtStatement(assignement);
    }

    @java.lang.Override
    public <T> void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator<T> operator) {
        enterCtExpression(operator);
        scan(operator.getLeftHandOperand());
        printer.writeSpace();
        printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(operator.getKind()));
        printer.writeSpace();
        try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {
            if ((operator.getKind()) == (spoon.reflect.code.BinaryOperatorKind.INSTANCEOF)) {
                _context.forceWildcardGenerics(true);
            }
            scan(operator.getRightHandOperand());
        }
        exitCtExpression(operator);
    }

    @java.lang.Override
    public <R> void visitCtBlock(spoon.reflect.code.CtBlock<R> block) {
        enterCtStatement(block);
        if (!(block.isImplicit())) {
            printer.writeSeparator("{");
        }
        printer.incTab();
        for (spoon.reflect.code.CtStatement statement : block.getStatements()) {
            if (!(statement.isImplicit())) {
                printer.writeln();
                elementPrinterHelper.writeStatement(statement);
            }
        }
        printer.decTab();
        getPrinterHelper().adjustEndPosition(block);
        if (env.isPreserveLineNumbers()) {
            if (!(block.isImplicit())) {
                printer.writeSeparator("}");
            }
        }else {
            printer.writeln();
            if (!(block.isImplicit())) {
                printer.writeSeparator("}");
            }
        }
        exitCtStatement(block);
    }

    @java.lang.Override
    public void visitCtBreak(spoon.reflect.code.CtBreak breakStatement) {
        enterCtStatement(breakStatement);
        printer.writeKeyword("break");
        if ((breakStatement.getTargetLabel()) != null) {
            printer.writeSpace().writeKeyword(breakStatement.getTargetLabel());
        }
        exitCtStatement(breakStatement);
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("rawtypes")
    public <E> void visitCtCase(spoon.reflect.code.CtCase<E> caseStatement) {
        enterCtStatement(caseStatement);
        if ((caseStatement.getCaseExpression()) != null) {
            printer.writeKeyword("case").writeSpace();
            // writing enum case expression
            if ((caseStatement.getCaseExpression()) instanceof spoon.reflect.code.CtFieldAccess) {
                final spoon.reflect.reference.CtFieldReference variable = ((spoon.reflect.code.CtFieldAccess) (caseStatement.getCaseExpression())).getVariable();
                // In noclasspath mode, we don't have always the type of the declaring type.
                if ((((variable.getType()) != null) && ((variable.getDeclaringType()) != null)) && (variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName()))) {
                    printer.writeIdentifier(variable.getSimpleName());
                }else {
                    scan(caseStatement.getCaseExpression());
                }
            }else {
                scan(caseStatement.getCaseExpression());
            }
        }else {
            printer.writeKeyword("default");
        }
        printer.writeSpace().writeSeparator(":").incTab();
        for (spoon.reflect.code.CtStatement statement : caseStatement.getStatements()) {
            printer.writeln();
            elementPrinterHelper.writeStatement(statement);
        }
        printer.decTab();
        exitCtStatement(caseStatement);
    }

    @java.lang.Override
    public void visitCtCatch(spoon.reflect.code.CtCatch catchBlock) {
        elementPrinterHelper.writeComment(catchBlock, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        printer.writeSpace().writeKeyword("catch").writeSpace().writeSeparator("(");
        spoon.reflect.code.CtCatchVariable<? extends java.lang.Throwable> parameter = catchBlock.getParameter();
        if ((parameter != null) && ((parameter.getMultiTypes().size()) > 1)) {
            elementPrinterHelper.printList(parameter.getMultiTypes(), null, false, null, false, true, "|", true, false, null, ( type) -> scan(type));
            printer.writeSpace().writeIdentifier(parameter.getSimpleName());
        }else {
            scan(parameter);
        }
        printer.writeSeparator(")").writeSpace();
        scan(catchBlock.getBody());
    }

    @java.lang.Override
    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {
        context.pushCurrentThis(ctClass);
        if ((((ctClass.getSimpleName()) != null) && (!(spoon.reflect.declaration.CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName())))) && (!(ctClass.isAnonymous()))) {
            visitCtType(ctClass);
            if (ctClass.isLocalType()) {
                printer.writeKeyword("class").writeSpace().writeIdentifier(ctClass.getSimpleName().replaceAll("^[0-9]*", ""));
            }else {
                printer.writeKeyword("class").writeSpace().writeIdentifier(ctClass.getSimpleName());
            }
            elementPrinterHelper.writeFormalTypeParameters(ctClass);
            elementPrinterHelper.writeExtendsClause(ctClass);
            elementPrinterHelper.writeImplementsClause(ctClass);
        }
        printer.writeSpace().writeSeparator("{").incTab();
        elementPrinterHelper.writeElementList(ctClass.getTypeMembers());
        getPrinterHelper().adjustEndPosition(ctClass);
        printer.decTab().writeSeparator("}");
        context.popCurrentThis();
    }

    @java.lang.Override
    public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {
        elementPrinterHelper.writeAnnotations(typeParameter);
        printer.writeIdentifier(typeParameter.getSimpleName());
        if (((typeParameter.getSuperclass()) != null) && ((typeParameter.getSuperclass().isImplicit()) == false)) {
            printer.writeSpace().writeKeyword("extends").writeSpace();
            scan(typeParameter.getSuperclass());
        }
    }

    @java.lang.Override
    public <T> void visitCtConditional(spoon.reflect.code.CtConditional<T> conditional) {
        enterCtExpression(conditional);
        spoon.reflect.code.CtExpression<java.lang.Boolean> condition = conditional.getCondition();
        boolean parent;
        try {
            parent = ((conditional.getParent()) instanceof spoon.reflect.code.CtAssignment) || ((conditional.getParent()) instanceof spoon.reflect.declaration.CtVariable);
        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {
            // nothing if we have no parent
            parent = false;
        }
        if (parent) {
            printer.writeSeparator("(");
        }
        scan(condition);
        if (parent) {
            printer.writeSeparator(")");
        }
        printer.writeSpace().writeOperator("?").writeSpace();
        spoon.reflect.code.CtExpression<T> thenExpression = conditional.getThenExpression();
        scan(thenExpression);
        printer.writeSpace().writeOperator(":").writeSpace();
        spoon.reflect.code.CtExpression<T> elseExpression = conditional.getElseExpression();
        boolean isAssign;
        if (isAssign = elseExpression instanceof spoon.reflect.code.CtAssignment) {
            printer.writeSeparator("(");
        }
        scan(elseExpression);
        if (isAssign) {
            printer.writeSeparator(")");
        }
        exitCtExpression(conditional);
    }

    @java.lang.Override
    public <T> void visitCtConstructor(spoon.reflect.declaration.CtConstructor<T> constructor) {
        elementPrinterHelper.writeComment(constructor);
        elementPrinterHelper.visitCtNamedElement(constructor, sourceCompilationUnit);
        elementPrinterHelper.writeModifiers(constructor);
        elementPrinterHelper.writeFormalTypeParameters(constructor);
        if (!(constructor.getFormalCtTypeParameters().isEmpty())) {
            printer.writeSpace();
        }
        if ((constructor.getDeclaringType()) != null) {
            if (constructor.getDeclaringType().isLocalType()) {
                printer.writeIdentifier(constructor.getDeclaringType().getSimpleName().replaceAll("^[0-9]*", ""));
            }else {
                printer.writeIdentifier(constructor.getDeclaringType().getSimpleName());
            }
        }
        elementPrinterHelper.writeExecutableParameters(constructor);
        elementPrinterHelper.writeThrowsClause(constructor);
        printer.writeSpace();
        scan(constructor.getBody());
    }

    @java.lang.Override
    public void visitCtContinue(spoon.reflect.code.CtContinue continueStatement) {
        enterCtStatement(continueStatement);
        printer.writeKeyword("continue");
        if ((continueStatement.getTargetLabel()) != null) {
            printer.writeSpace().writeIdentifier(continueStatement.getTargetLabel());
        }
        exitCtStatement(continueStatement);
    }

    @java.lang.Override
    public void visitCtDo(spoon.reflect.code.CtDo doLoop) {
        enterCtStatement(doLoop);
        printer.writeKeyword("do");
        elementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());
        printer.writeKeyword("while").writeSpace().writeSeparator("(");
        scan(doLoop.getLoopingExpression());
        printer.writeSpace().writeSeparator(")");
        exitCtStatement(doLoop);
    }

    @java.lang.Override
    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {
        visitCtType(ctEnum);
        printer.writeKeyword("enum").writeSpace().writeIdentifier(ctEnum.getSimpleName());
        elementPrinterHelper.writeImplementsClause(ctEnum);
        context.pushCurrentThis(ctEnum);
        printer.writeSpace().writeSeparator("{").incTab().writeln();
        if (ctEnum.getEnumValues().isEmpty()) {
            printer.writeSeparator(";").writeln();
        }else {
            elementPrinterHelper.printList(ctEnum.getEnumValues(), null, false, null, false, false, ",", false, false, ";", ( enumValue) -> {
                printer.writeln();
                scan(enumValue);
            });
        }
        elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());
        printer.decTab().writeSeparator("}");
        context.popCurrentThis();
    }

    @java.lang.Override
    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {
        // it is not called during printing of sources. Use shortcut and print directly to PrinterHelper
        printer.getPrinterHelper().write(reference.getSignature());
    }

    @java.lang.Override
    public <T> void visitCtField(spoon.reflect.declaration.CtField<T> f) {
        elementPrinterHelper.writeComment(f, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        elementPrinterHelper.visitCtNamedElement(f, sourceCompilationUnit);
        elementPrinterHelper.writeModifiers(f);
        scan(f.getType());
        printer.writeSpace();
        printer.writeIdentifier(f.getSimpleName());
        if ((f.getDefaultExpression()) != null) {
            printer.writeSpace().writeOperator("=").writeSpace();
            scan(f.getDefaultExpression());
        }
        printer.writeSeparator(";");
        elementPrinterHelper.writeComment(f, spoon.reflect.visitor.printer.CommentOffset.AFTER);
    }

    @java.lang.Override
    public <T> void visitCtEnumValue(spoon.reflect.declaration.CtEnumValue<T> enumValue) {
        elementPrinterHelper.visitCtNamedElement(enumValue, sourceCompilationUnit);
        elementPrinterHelper.writeComment(enumValue, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        printer.writeIdentifier(enumValue.getSimpleName());
        if ((enumValue.getDefaultExpression()) != null) {
            spoon.reflect.code.CtConstructorCall<?> constructorCall = ((spoon.reflect.code.CtConstructorCall<?>) (enumValue.getDefaultExpression()));
            if (!(constructorCall.isImplicit())) {
                elementPrinterHelper.printList(constructorCall.getArguments(), null, false, "(", false, false, ",", true, false, ")", ( expr) -> scan(expr));
            }
            if (constructorCall instanceof spoon.reflect.code.CtNewClass) {
                scan(((spoon.reflect.code.CtNewClass<?>) (constructorCall)).getAnonymousClass());
            }
        }
    }

    @java.lang.Override
    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {
        printCtFieldAccess(fieldRead);
    }

    @java.lang.Override
    public <T> void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite<T> fieldWrite) {
        printCtFieldAccess(fieldWrite);
    }

    private boolean isImported(spoon.reflect.reference.CtFieldReference fieldReference) {
        spoon.reflect.declaration.CtImport fieldImport = fieldReference.getFactory().createImport(fieldReference);
        if (this.imports.contains(fieldImport)) {
            return true;
        }else {
            if ((fieldReference.getDeclaringType()) == null) {
                return false;
            }
            spoon.reflect.reference.CtTypeReference staticTypeMemberReference = fieldReference.getFactory().Type().createWildcardStaticTypeMemberReference(fieldReference.getDeclaringType());
            spoon.reflect.declaration.CtImport staticClassImport = fieldReference.getFactory().createImport(staticTypeMemberReference);
            return this.imports.contains(staticClassImport);
        }
    }

    private boolean isImported(spoon.reflect.reference.CtExecutableReference executableReference) {
        spoon.reflect.declaration.CtImport executableImport = executableReference.getFactory().createImport(executableReference);
        if (this.imports.contains(executableImport)) {
            return true;
        }else {
            if ((executableReference.getDeclaringType()) == null) {
                return false;
            }
            spoon.reflect.reference.CtTypeReference staticTypeMemberReference = executableReference.getFactory().Type().createWildcardStaticTypeMemberReference(executableReference.getDeclaringType());
            spoon.reflect.declaration.CtImport staticClassImport = executableReference.getFactory().createImport(staticTypeMemberReference);
            return this.imports.contains(staticClassImport);
        }
    }

    private <T> void printCtFieldAccess(spoon.reflect.code.CtFieldAccess<T> f) {
        enterCtExpression(f);
        try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {
            if (((f.getVariable().isStatic()) || ("class".equals(f.getVariable().getSimpleName()))) && ((f.getTarget()) instanceof spoon.reflect.code.CtTypeAccess)) {
                _context.ignoreGenerics(true);
            }
            spoon.reflect.code.CtExpression<?> target = f.getTarget();
            if (target != null) {
                boolean isInitializeStaticFinalField = isInitializeStaticFinalField(f.getTarget());
                boolean isStaticField = f.getVariable().isStatic();
                boolean isImportedField = this.isImported(f.getVariable());
                if ((!isInitializeStaticFinalField) && (!(isStaticField && isImportedField))) {
                    if ((target.isImplicit()) && (!(((f.getVariable().getFieldDeclaration()) == null) && (this.env.getNoClasspath())))) {
                        /* target is implicit, check whether there is no conflict with an local variable, catch variable or parameter
                        in case of conflict make it explicit, otherwise the field access is shadowed by that variable.
                        Search for potential variable declaration until we found a class which declares or inherits this field */
                        final spoon.reflect.declaration.CtField<?> field = f.getVariable().getFieldDeclaration();
                        if (field != null) {
                            final java.lang.String fieldName = field.getSimpleName();
                            spoon.reflect.declaration.CtVariable<?> var = f.getVariable().map(new spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction(fieldName)).first();
                            if (var != field) {
                                // another variable declaration was found which is hiding the field declaration for this field access. Make the field access explicit
                                target.setImplicit(false);
                            }
                        }else {
                            // There is a model inconsistency
                            printer.writeComment(f.getFactory().createComment((("ERROR: Missing field \"" + (f.getVariable().getSimpleName())) + "\", please check your model. The code may not compile."), spoon.reflect.code.CtComment.CommentType.BLOCK)).writeSpace();
                        }
                    }
                    // the implicit drives the separator
                    if (!(target.isImplicit())) {
                        scan(target);
                        printer.writeSeparator(".");
                    }
                }
                _context.ignoreStaticAccess(true);
            }
            scan(f.getVariable());
        }
        exitCtExpression(f);
    }

    /**
    Check if the target expression is a static final field initialized in a static anonymous block.
     */
    private <T> boolean isInitializeStaticFinalField(spoon.reflect.code.CtExpression<T> targetExp) {
        final spoon.reflect.declaration.CtElement parent;
        final spoon.reflect.declaration.CtAnonymousExecutable anonymousParent;
        try {
            parent = targetExp.getParent();
            anonymousParent = targetExp.getParent(spoon.reflect.declaration.CtAnonymousExecutable.class);
        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {
            return false;
        }
        return (((((parent instanceof spoon.reflect.code.CtFieldWrite) && (targetExp.equals(((spoon.reflect.code.CtFieldWrite) (parent)).getTarget()))) && (anonymousParent != null)) && ((((spoon.reflect.code.CtFieldWrite) (parent)).getVariable()) != null)) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.STATIC))) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.FINAL));
    }

    @java.lang.Override
    public <T> void visitCtThisAccess(spoon.reflect.code.CtThisAccess<T> thisAccess) {
        try {
            enterCtExpression(thisAccess);
            // we only write qualified this when this is required
            // this is good both in fully-qualified mode and in readable (with-imports) mode
            // the implicit information is used for analysis (e.g. is visibility caused by implicit bugs?) but
            // not for pretty-printing
            spoon.reflect.code.CtTypeAccess target = ((spoon.reflect.code.CtTypeAccess) (thisAccess.getTarget()));
            spoon.reflect.reference.CtTypeReference targetType = target.getAccessedType();
            // readable mode as close as possible to the original code
            if (thisAccess.isImplicit()) {
                // write nothing, "this" is implicit and we unfortunately cannot always know
                // what the good target is in JDTTreeBuilder
                return;
            }
            // the simplest case: we always print "this" if we're in the top-level class,
            // this is shorter (no qualified this), explicit, and less fragile wrt transformation
            if ((targetType == null) || (((thisAccess.getParent(spoon.reflect.declaration.CtType.class)) != null) && (thisAccess.getParent(spoon.reflect.declaration.CtType.class).isTopLevel()))) {
                printer.writeKeyword("this");
                return;// still go through finally block below

            }
            // we cannot have fully-qualified this in anonymous classes
            // we simply print "this" and it always works
            // this has to come after the implicit test just before
            if (targetType.isAnonymous()) {
                printer.writeKeyword("this");
                return;
            }
            // complex case of qualified this
            if (!(context.currentThis.isEmpty())) {
                spoon.reflect.declaration.CtType lastType = context.currentThis.peekFirst().type;
                java.lang.String lastTypeQualifiedName = lastType.getQualifiedName();
                java.lang.String targetTypeQualifiedName = targetType.getQualifiedName();
                if (!(lastTypeQualifiedName.equals(targetTypeQualifiedName))) {
                    if (!(targetType.isImplicit())) {
                        visitCtTypeReferenceWithoutGenerics(targetType);
                        printer.writeSeparator(".");
                    }
                    printer.writeKeyword("this");
                    return;
                }
            }
            // the default super simple case only comes at the end
            printer.writeKeyword("this");
        } finally {
            exitCtExpression(thisAccess);
        }
    }

    @java.lang.Override
    public <T> void visitCtSuperAccess(spoon.reflect.code.CtSuperAccess<T> f) {
        enterCtExpression(f);
        if ((f.getTarget()) != null) {
            scan(f.getTarget());
            printer.writeSeparator(".");
        }
        printer.writeKeyword("super");
        exitCtExpression(f);
    }

    @java.lang.Override
    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc comment) {
        visitCtComment(comment);
    }

    @java.lang.Override
    public void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag docTag) {
        /* is not called during normal printing of java sources.
        It can be called only when CtJavaDocTag has to be printed directly.
        E.g. from CtJavaDocTag#toString
        Write directly to PrinterHelper, because java doc tag is not a java token. Normally it is part of COMMENT token. */
        spoon.reflect.visitor.CommentHelper.printJavaDocTag(printer.getPrinterHelper(), docTag);
    }

    @java.lang.Override
    public void visitCtImport(spoon.reflect.declaration.CtImport ctImport) {
        if ((ctImport.getImportKind()) != null) {
            printer.writeKeyword("import");
            printer.writeSpace();
            switch (ctImport.getImportKind()) {
                case TYPE :
                    visitCtTypeReference(((spoon.reflect.reference.CtTypeReference) (ctImport.getReference())));
                    break;
                case METHOD :
                    printer.writeKeyword("static");
                    printer.writeSpace();
                    visitCtExecutableReference(((spoon.reflect.reference.CtExecutableReference) (ctImport.getReference())));
                    break;
                case FIELD :
                    printer.writeKeyword("static");
                    printer.writeSpace();
                    visitCtFieldReference(((spoon.reflect.reference.CtFieldReference) (ctImport.getReference())));
                    break;
                case ALL_TYPES :
                    visitCtPackageReference(((spoon.reflect.reference.CtPackageReference) (ctImport.getReference())));
                    printer.writeSeparator(".");
                    printer.writeIdentifier("*");
                    break;
                case ALL_STATIC_MEMBERS :
                    printer.writeKeyword("static");
                    printer.writeSpace();
                    visitCtTypeReference(((spoon.reflect.reference.CtTypeReference) (ctImport.getReference())));
                    break;
            }
            printer.writeSeparator(";");
            printer.writeln();
        }
    }

    @java.lang.Override
    public void visitCtModule(spoon.reflect.declaration.CtModule module) {
        enter(module);
        if (module.isOpenModule()) {
            printer.writeKeyword("open").writeSpace();
        }
        printer.writeKeyword("module").writeSpace().writeIdentifier(module.getSimpleName());
        printer.writeSpace().writeSeparator("{").incTab().writeln();
        for (spoon.reflect.declaration.CtModuleDirective moduleDirective : module.getModuleDirectives()) {
            scan(moduleDirective);
        }
        printer.decTab().writeSeparator("}");
        exit(module);
    }

    @java.lang.Override
    public void visitCtModuleReference(spoon.reflect.reference.CtModuleReference moduleReference) {
        printer.writeIdentifier(moduleReference.getSimpleName());
    }

    @java.lang.Override
    public void visitCtPackageExport(spoon.reflect.declaration.CtPackageExport moduleExport) {
        if (moduleExport.isOpenedPackage()) {
            printer.writeKeyword("opens");
        }else {
            printer.writeKeyword("exports");
        }
        printer.writeSpace();
        visitCtPackageReference(moduleExport.getPackageReference());
        if (!(moduleExport.getTargetExport().isEmpty())) {
            this.elementPrinterHelper.printList(moduleExport.getTargetExport(), null, false, " to", true, false, ",", true, false, null, ( moduleReference) -> scan(moduleReference));
        }
        printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtModuleRequirement(spoon.reflect.declaration.CtModuleRequirement moduleRequirement) {
        printer.writeKeyword("requires").writeSpace();
        if (!(moduleRequirement.getRequiresModifiers().isEmpty())) {
            this.elementPrinterHelper.printList(moduleRequirement.getRequiresModifiers(), null, false, null, false, false, " ", false, false, " ", ( modifier) -> printer.writeKeyword(modifier.name().toLowerCase()));
        }
        scan(moduleRequirement.getModuleReference());
        printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtProvidedService(spoon.reflect.declaration.CtProvidedService moduleProvidedService) {
        printer.writeKeyword("provides").writeSpace();
        scan(moduleProvidedService.getServiceType());
        this.elementPrinterHelper.printList(moduleProvidedService.getImplementationTypes(), null, false, " with", true, false, ",", true, false, null, ( implementations) -> scan(implementations));
        printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtUsedService(spoon.reflect.declaration.CtUsedService usedService) {
        printer.writeKeyword("uses").writeSpace();
        scan(usedService.getServiceType());
        printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtComment(spoon.reflect.code.CtComment comment) {
        if ((!(env.isCommentsEnabled())) && ((context.elementStack.size()) > 1)) {
            return;
        }
        printer.writeComment(comment);
    }

    @java.lang.Override
    public <T> void visitCtAnnotationFieldAccess(spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {
        enterCtExpression(annotationFieldAccess);
        try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {
            if ((annotationFieldAccess.getTarget()) != null) {
                scan(annotationFieldAccess.getTarget());
                printer.writeSeparator(".");
                _context.ignoreStaticAccess(true);
            }
            _context.ignoreGenerics(true);
            scan(annotationFieldAccess.getVariable());
            printer.writeSeparator("(").writeSeparator(")");
        }
        exitCtExpression(annotationFieldAccess);
    }

    @java.lang.Override
    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {
        boolean isStatic = ("class".equals(reference.getSimpleName())) || ((!("super".equals(reference.getSimpleName()))) && (reference.isStatic()));
        boolean printType = true;
        if ((reference.isFinal()) && (reference.isStatic())) {
            spoon.reflect.reference.CtTypeReference<?> declTypeRef = reference.getDeclaringType();
            if (declTypeRef.isAnonymous()) {
                // never print anonymous class ref
                printType = false;
            }else {
                if (context.isInCurrentScope(declTypeRef)) {
                    // do not printType if we are in scope of that type
                    printType = false;
                }
            }
        }
        if ((isStatic && printType) && (!(context.ignoreStaticAccess()))) {
            try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(true)) {
                scan(reference.getDeclaringType());
            }
            printer.writeSeparator(".");
        }
        if ("class".equals(reference.getSimpleName())) {
            printer.writeKeyword("class");
        }else {
            printer.writeIdentifier(reference.getSimpleName());
        }
    }

    @java.lang.Override
    public void visitCtFor(spoon.reflect.code.CtFor forLoop) {
        enterCtStatement(forLoop);
        printer.writeKeyword("for").writeSpace().writeSeparator("(");
        java.util.List<spoon.reflect.code.CtStatement> st = forLoop.getForInit();
        if (!(st.isEmpty())) {
            try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().isFirstForVariable(true)) {
                scan(st.get(0));
            }
        }
        if ((st.size()) > 1) {
            try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().isNextForVariable(true)) {
                for (int i = 1; i < (st.size()); i++) {
                    printer.writeSeparator(",").writeSpace();
                    scan(st.get(i));
                }
            }
        }
        printer.writeSeparator(";").writeSpace();
        scan(forLoop.getExpression());
        printer.writeSeparator(";");
        if (!(forLoop.getForUpdate().isEmpty())) {
            printer.writeSpace();
        }
        elementPrinterHelper.printList(forLoop.getForUpdate(), null, false, null, false, true, ",", true, false, null, ( s) -> scan(s));
        printer.writeSeparator(")");
        elementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());
        exitCtStatement(forLoop);
    }

    @java.lang.Override
    public void visitCtForEach(spoon.reflect.code.CtForEach foreach) {
        enterCtStatement(foreach);
        printer.writeKeyword("for").writeSpace().writeSeparator("(");
        scan(foreach.getVariable());
        printer.writeSpace().writeSeparator(":").writeSpace();
        scan(foreach.getExpression());
        printer.writeSeparator(")");
        elementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());
        exitCtStatement(foreach);
    }

    @java.lang.Override
    public void visitCtIf(spoon.reflect.code.CtIf ifElement) {
        enterCtStatement(ifElement);
        printer.writeKeyword("if").writeSpace().writeSeparator("(");
        scan(ifElement.getCondition());
        printer.writeSeparator(")");
        elementPrinterHelper.writeIfOrLoopBlock(ifElement.getThenStatement());
        if ((ifElement.getElseStatement()) != null) {
            java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(ifElement, spoon.reflect.visitor.printer.CommentOffset.INSIDE);
            for (spoon.reflect.code.CtComment comment : comments) {
                spoon.reflect.cu.SourcePosition thenPosition = (ifElement.getThenStatement().getPosition().isValidPosition()) ? ifElement.getThenStatement().getPosition() : ((spoon.reflect.code.CtBlock) (ifElement.getThenStatement())).getStatement(0).getPosition();
                if ((comment.getPosition().getSourceStart()) > (thenPosition.getSourceEnd())) {
                    elementPrinterHelper.writeComment(comment);
                }
            }
            printer.writeKeyword("else");
            elementPrinterHelper.writeIfOrLoopBlock(ifElement.getElseStatement());
        }
        exitCtStatement(ifElement);
    }

    @java.lang.Override
    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {
        visitCtType(intrface);
        printer.writeKeyword("interface").writeSpace().writeIdentifier(intrface.getSimpleName());
        if ((intrface.getFormalCtTypeParameters()) != null) {
            elementPrinterHelper.writeFormalTypeParameters(intrface);
        }
        if (!(intrface.getSuperInterfaces().isEmpty())) {
            elementPrinterHelper.printList(intrface.getSuperInterfaces(), "extends", false, null, false, true, ",", true, false, null, ( ref) -> scan(ref));
        }
        context.pushCurrentThis(intrface);
        printer.writeSpace().writeSeparator("{").incTab();
        // Content
        elementPrinterHelper.writeElementList(intrface.getTypeMembers());
        printer.decTab().writeSeparator("}");
        context.popCurrentThis();
    }

    @java.lang.Override
    public <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> invocation) {
        enterCtStatement(invocation);
        enterCtExpression(invocation);
        if (invocation.getExecutable().isConstructor()) {
            // It's a constructor (super or this)
            elementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());
            spoon.reflect.declaration.CtType<?> parentType;
            try {
                parentType = invocation.getParent(spoon.reflect.declaration.CtType.class);
            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {
                parentType = null;
            }
            if (((parentType != null) && ((parentType.getQualifiedName()) != null)) && (parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName()))) {
                printer.writeKeyword("this");
            }else {
                if (((invocation.getTarget()) != null) && (!(invocation.getTarget().isImplicit()))) {
                    scan(invocation.getTarget());
                    printer.writeSeparator(".");
                }
                printer.writeKeyword("super");
            }
        }else {
            // It's a method invocation
            boolean isImported = this.isImported(invocation.getExecutable());
            if (!isImported) {
                try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {
                    if ((invocation.getTarget()) instanceof spoon.reflect.code.CtTypeAccess) {
                        _context.ignoreGenerics(true);
                    }
                    if (((invocation.getTarget()) != null) && (!(invocation.getTarget().isImplicit()))) {
                        scan(invocation.getTarget());
                        printer.writeSeparator(".");
                    }
                }
            }
            elementPrinterHelper.writeActualTypeArguments(invocation);
            if (env.isPreserveLineNumbers()) {
                getPrinterHelper().adjustStartPosition(invocation);
            }
            printer.writeIdentifier(invocation.getExecutable().getSimpleName());
        }
        elementPrinterHelper.printList(invocation.getArguments(), null, false, "(", false, false, ",", true, false, ")", ( e) -> scan(e));
        exitCtExpression(invocation);
        exitCtStatement(invocation);
    }

    @java.lang.Override
    public <T> void visitCtLiteral(spoon.reflect.code.CtLiteral<T> literal) {
        enterCtExpression(literal);
        printer.writeLiteral(spoon.reflect.visitor.LiteralHelper.getLiteralToken(literal));
        exitCtExpression(literal);
    }

    @java.lang.Override
    public <T> void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable<T> localVariable) {
        enterCtStatement(localVariable);
        if (env.isPreserveLineNumbers()) {
            getPrinterHelper().adjustStartPosition(localVariable);
        }
        if (!(context.isNextForVariable())) {
            elementPrinterHelper.writeModifiers(localVariable);
            if ((localVariable.isInferred()) && ((this.env.getComplianceLevel()) >= 10)) {
                getPrinterTokenWriter().writeKeyword("var");
            }else {
                scan(localVariable.getType());
            }
            printer.writeSpace();
        }
        printer.writeIdentifier(localVariable.getSimpleName());
        if ((localVariable.getDefaultExpression()) != null) {
            printer.writeSpace().writeOperator("=").writeSpace();
            scan(localVariable.getDefaultExpression());
        }
        exitCtStatement(localVariable);
    }

    @java.lang.Override
    public <T> void visitCtLocalVariableReference(spoon.reflect.reference.CtLocalVariableReference<T> reference) {
        printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {
        if (env.isPreserveLineNumbers()) {
            getPrinterHelper().adjustStartPosition(catchVariable);
        }
        elementPrinterHelper.writeModifiers(catchVariable);
        scan(catchVariable.getType());
        printer.writeSpace();
        printer.writeIdentifier(catchVariable.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtCatchVariableReference(spoon.reflect.reference.CtCatchVariableReference<T> reference) {
        printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtMethod(spoon.reflect.declaration.CtMethod<T> m) {
        elementPrinterHelper.writeComment(m, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        elementPrinterHelper.visitCtNamedElement(m, sourceCompilationUnit);
        elementPrinterHelper.writeModifiers(m);
        elementPrinterHelper.writeFormalTypeParameters(m);
        if (!(m.getFormalCtTypeParameters().isEmpty())) {
            printer.writeSpace();
        }
        try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(false)) {
            scan(m.getType());
        }
        printer.writeSpace();
        printer.writeIdentifier(m.getSimpleName());
        elementPrinterHelper.writeExecutableParameters(m);
        elementPrinterHelper.writeThrowsClause(m);
        if ((m.getBody()) != null) {
            printer.writeSpace();
            scan(m.getBody());
            if (m.getBody().getPosition().isValidPosition()) {
                if ((m.getBody().getPosition().getCompilationUnit()) == (sourceCompilationUnit)) {
                    if ((m.getBody().getStatements().isEmpty()) || (!((m.getBody().getStatements().get(((m.getBody().getStatements().size()) - 1))) instanceof spoon.reflect.code.CtReturn))) {
                        getPrinterHelper().putLineNumberMapping(m.getBody().getPosition().getEndLine());
                    }
                }else {
                    getPrinterHelper().undefineLine();
                }
            }else {
                getPrinterHelper().undefineLine();
            }
        }else {
            printer.writeSeparator(";");
        }
        elementPrinterHelper.writeComment(m, spoon.reflect.visitor.printer.CommentOffset.AFTER);
    }

    @java.lang.Override
    public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {
        elementPrinterHelper.writeComment(annotationMethod);
        elementPrinterHelper.visitCtNamedElement(annotationMethod, sourceCompilationUnit);
        elementPrinterHelper.writeModifiers(annotationMethod);
        scan(annotationMethod.getType());
        printer.writeSpace();
        printer.writeIdentifier(annotationMethod.getSimpleName());
        printer.writeSeparator("(").writeSeparator(")");
        if ((annotationMethod.getDefaultExpression()) != null) {
            printer.writeSpace().writeKeyword("default").writeSpace();
            scan(annotationMethod.getDefaultExpression());
        }
        printer.writeSeparator(";");
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("rawtypes")
    public <T> void visitCtNewArray(spoon.reflect.code.CtNewArray<T> newArray) {
        enterCtExpression(newArray);
        boolean isNotInAnnotation;
        try {
            isNotInAnnotation = ((newArray.getParent(spoon.reflect.declaration.CtAnnotationType.class)) == null) && ((newArray.getParent(spoon.reflect.declaration.CtAnnotation.class)) == null);
        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {
            isNotInAnnotation = true;
        }
        if (isNotInAnnotation) {
            spoon.reflect.reference.CtTypeReference<?> ref = newArray.getType();
            if (ref != null) {
                printer.writeKeyword("new").writeSpace();
            }
            try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().skipArray(true)) {
                scan(ref);
            }
            for (int i = 0; ref instanceof spoon.reflect.reference.CtArrayTypeReference; i++) {
                printer.writeSeparator("[");
                if ((newArray.getDimensionExpressions().size()) > i) {
                    spoon.reflect.code.CtExpression<java.lang.Integer> e = newArray.getDimensionExpressions().get(i);
                    scan(e);
                }
                printer.writeSeparator("]");
                ref = ((spoon.reflect.reference.CtArrayTypeReference) (ref)).getComponentType();
            }
        }
        if (newArray.getDimensionExpressions().isEmpty()) {
            elementPrinterHelper.printList(newArray.getElements(), null, false, "{", true, false, ",", true, true, "}", ( e) -> scan(e));
            elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.INSIDE);
        }
        elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.AFTER);
        exitCtExpression(newArray);
    }

    @java.lang.Override
    public <T> void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {
        enterCtStatement(ctConstructorCall);
        enterCtExpression(ctConstructorCall);
        printConstructorCall(ctConstructorCall);
        exitCtExpression(ctConstructorCall);
        exitCtStatement(ctConstructorCall);
    }

    @java.lang.Override
    public <T> void visitCtNewClass(spoon.reflect.code.CtNewClass<T> newClass) {
        enterCtStatement(newClass);
        enterCtExpression(newClass);
        printConstructorCall(newClass);
        scan(newClass.getAnonymousClass());
        exitCtExpression(newClass);
        exitCtStatement(newClass);
    }

    private <T> void printConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {
        try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {
            if ((ctConstructorCall.getTarget()) != null) {
                scan(ctConstructorCall.getTarget());
                printer.writeSeparator(".");
                _context.ignoreEnclosingClass(true);
            }
            if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {
                _context.ignoreEnclosingClass(true);
            }
            printer.writeKeyword("new").writeSpace();
            if (!(ctConstructorCall.getActualTypeArguments().isEmpty())) {
                elementPrinterHelper.writeActualTypeArguments(ctConstructorCall);
            }
            scan(ctConstructorCall.getType());
        }
        elementPrinterHelper.printList(ctConstructorCall.getArguments(), null, false, "(", false, false, ",", true, false, ")", ( exp) -> scan(exp));
    }

    /**
    JDT doesn't support <code>new Foo<K>.Bar()</code>. To avoid reprinting this kind of type reference,
    we check that the reference has a declaring type with generics.
    See https://bugs.eclipse.org/bugs/show_bug.cgi?id=474593

    @param reference Type reference concerned by the bug.
    @return true if a declaring type has generic types.
     *
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     */
    private <T> boolean hasDeclaringTypeWithGenerics(spoon.reflect.reference.CtTypeReference<T> reference) {
        // We don't have a declaring type, it can't have generics.
        if (reference == null) {
            return false;
        }
        // If the declaring type isn't a type, we don't need this hack.
        if ((reference.getDeclaringType()) == null) {
            return false;
        }
        // If current reference is a class declared in a method, we don't need this hack.
        if (reference.isLocalType()) {
            return false;
        }
        // If declaring type have generics, we return true.
        if (!(reference.getDeclaringType().getActualTypeArguments().isEmpty())) {
            return true;
        }
        // Checks if the declaring type has generic types.
        return hasDeclaringTypeWithGenerics(reference.getDeclaringType());
    }

    @java.lang.Override
    public <T> void visitCtLambda(spoon.reflect.code.CtLambda<T> lambda) {
        enterCtExpression(lambda);
        elementPrinterHelper.printList(lambda.getParameters(), null, false, "(", false, false, ",", false, false, ")", ( parameter) -> scan(parameter));
        printer.writeSpace();
        printer.writeSeparator("->");
        printer.writeSpace();
        if ((lambda.getBody()) != null) {
            scan(lambda.getBody());
        }else {
            scan(lambda.getExpression());
        }
        exitCtExpression(lambda);
    }

    @java.lang.Override
    public <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {
        enterCtExpression(expression);
        try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {
            if (expression.getExecutable().isStatic()) {
                _context.ignoreGenerics(true);
            }
            scan(expression.getTarget());
        }
        printer.writeSeparator("::");
        if (expression.getExecutable().isConstructor()) {
            printer.writeKeyword("new");
        }else {
            printer.writeIdentifier(expression.getExecutable().getSimpleName());
        }
        exitCtExpression(expression);
    }

    @java.lang.Override
    public <T, A extends T> void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {
        enterCtStatement(assignment);
        enterCtExpression(assignment);
        scan(assignment.getAssigned());
        printer.writeSpace();
        // the operators like +=, *= are sent as one operator token
        printer.writeOperator(((spoon.reflect.visitor.OperatorHelper.getOperatorText(assignment.getKind())) + "="));
        printer.writeSpace();
        scan(assignment.getAssignment());
        exitCtExpression(assignment);
        exitCtStatement(assignment);
    }

    @java.lang.Override
    public void visitCtPackage(spoon.reflect.declaration.CtPackage ctPackage) {
        if (!(ctPackage.isUnnamedPackage())) {
            elementPrinterHelper.writePackageLine(ctPackage.getQualifiedName());
        }else {
            printer.writeComment(ctPackage.getFactory().createComment("default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon= unnamed package)", spoon.reflect.code.CtComment.CommentType.INLINE)).writeln();
        }
    }

    @java.lang.Override
    public void visitCtPackageReference(spoon.reflect.reference.CtPackageReference reference) {
        elementPrinterHelper.writeQualifiedName(reference.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtParameter(spoon.reflect.declaration.CtParameter<T> parameter) {
        elementPrinterHelper.writeComment(parameter);
        elementPrinterHelper.writeAnnotations(parameter);
        elementPrinterHelper.writeModifiers(parameter);
        if (parameter.isVarArgs()) {
            scan(((spoon.reflect.reference.CtArrayTypeReference<T>) (parameter.getType())).getComponentType());
            printer.writeSeparator("...");
        }else {
            scan(parameter.getType());
        }
        printer.writeSpace();
        printer.writeIdentifier(parameter.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtParameterReference(spoon.reflect.reference.CtParameterReference<T> reference) {
        printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public <R> void visitCtReturn(spoon.reflect.code.CtReturn<R> returnStatement) {
        enterCtStatement(returnStatement);
        printer.writeKeyword("return");
        // checkstyle wants "return;" and not "return ;"
        if ((returnStatement.getReturnedExpression()) != null) {
            printer.writeSpace();
        }
        scan(returnStatement.getReturnedExpression());
        exitCtStatement(returnStatement);
    }

    private <T> void visitCtType(spoon.reflect.declaration.CtType<T> type) {
        elementPrinterHelper.writeComment(type, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        getPrinterHelper().mapLine(type, sourceCompilationUnit);
        if (type.isTopLevel()) {
            context.currentTopLevel = type;
        }
        elementPrinterHelper.visitCtNamedElement(type, sourceCompilationUnit);
        elementPrinterHelper.writeModifiers(type);
    }

    @java.lang.Override
    public void visitCtStatementList(spoon.reflect.code.CtStatementList statements) {
        for (spoon.reflect.code.CtStatement s : statements.getStatements()) {
            scan(s);
        }
    }

    @java.lang.Override
    public <E> void visitCtSwitch(spoon.reflect.code.CtSwitch<E> switchStatement) {
        enterCtStatement(switchStatement);
        printer.writeKeyword("switch").writeSpace().writeSeparator("(");
        scan(switchStatement.getSelector());
        printer.writeSeparator(")").writeSpace().writeSeparator("{").incTab();
        for (spoon.reflect.code.CtCase<?> c : switchStatement.getCases()) {
            printer.writeln();
            scan(c);
        }
        if (env.isPreserveLineNumbers()) {
            printer.decTab().writeSeparator("}");
        }else {
            printer.decTab().writeln().writeSeparator("}");
        }
        exitCtStatement(switchStatement);
    }

    @java.lang.Override
    public void visitCtSynchronized(spoon.reflect.code.CtSynchronized synchro) {
        enterCtStatement(synchro);
        printer.writeKeyword("synchronized");
        if ((synchro.getExpression()) != null) {
            printer.writeSeparator("(");
            scan(synchro.getExpression());
            printer.writeSeparator(")").writeSpace();
        }
        scan(synchro.getBlock());
        exitCtStatement(synchro);
    }

    @java.lang.Override
    public void visitCtThrow(spoon.reflect.code.CtThrow throwStatement) {
        enterCtStatement(throwStatement);
        printer.writeKeyword("throw").writeSpace();
        scan(throwStatement.getThrownExpression());
        exitCtStatement(throwStatement);
    }

    @java.lang.Override
    public void visitCtTry(spoon.reflect.code.CtTry tryBlock) {
        enterCtStatement(tryBlock);
        printer.writeKeyword("try").writeSpace();
        scan(tryBlock.getBody());
        for (spoon.reflect.code.CtCatch c : tryBlock.getCatchers()) {
            scan(c);
        }
        if ((tryBlock.getFinalizer()) != null) {
            printer.writeSpace().writeKeyword("finally").writeSpace();
            scan(tryBlock.getFinalizer());
        }
        exitCtStatement(tryBlock);
    }

    @java.lang.Override
    public void visitCtTryWithResource(spoon.reflect.code.CtTryWithResource tryWithResource) {
        enterCtStatement(tryWithResource);
        printer.writeKeyword("try").writeSpace();
        if (((tryWithResource.getResources()) != null) && (!(tryWithResource.getResources().isEmpty()))) {
            elementPrinterHelper.printList(tryWithResource.getResources(), null, false, "(", false, false, ";", false, false, ")", ( r) -> scan(r));
        }
        printer.writeSpace();
        scan(tryWithResource.getBody());
        for (spoon.reflect.code.CtCatch c : tryWithResource.getCatchers()) {
            scan(c);
        }
        if ((tryWithResource.getFinalizer()) != null) {
            printer.writeSpace().writeKeyword("finally").writeSpace();
            scan(tryWithResource.getFinalizer());
        }
        exitCtStatement(tryWithResource);
    }

    @java.lang.Override
    public void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {
        if (ref.isImplicit()) {
            return;
        }
        elementPrinterHelper.writeAnnotations(ref);
        if (printQualified(ref)) {
            elementPrinterHelper.writeQualifiedName(ref.getQualifiedName());
        }else {
            printer.writeIdentifier(ref.getSimpleName());
        }
    }

    @java.lang.Override
    public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {
        if (wildcardReference.isImplicit()) {
            return;
        }
        elementPrinterHelper.writeAnnotations(wildcardReference);
        printer.writeSeparator("?");
        // we ignore printing "extends Object" except if it's explicit
        if ((!(wildcardReference.isDefaultBoundingType())) || (!(wildcardReference.getBoundingType().isImplicit()))) {
            if (wildcardReference.isUpper()) {
                printer.writeSpace().writeKeyword("extends").writeSpace();
            }else {
                printer.writeSpace().writeKeyword("super").writeSpace();
            }
            scan(wildcardReference.getBoundingType());
        }
    }

    private boolean printQualified(spoon.reflect.reference.CtTypeReference<?> ref) {
        // or that we are in java.lang
        if ((importsContext.isImported(ref))// If my.pkg.Something is imported
         || (((this.env.isAutoImports()) && ((ref.getPackage()) != null)) && ("java.lang".equals(ref.getPackage().getSimpleName())))) {
            for (spoon.reflect.visitor.CacheBasedConflictFinder typeContext : context.currentThis) {
                // A) we are in the context of a class which is also called "Something",
                if ((typeContext.getSimpleName().equals(ref.getSimpleName())) && (!(java.util.Objects.equals(typeContext.getPackage(), ref.getPackage())))) {
                    return true;
                }
                // B) we are in the context of a class which defines field which is also called "Something",
                // we should still use qualified version my.pkg.Something
                // fix of #2369
                if ((typeContext.hasFieldConflict(ref.getSimpleName())) || (typeContext.hasNestedTypeConflict(ref.getSimpleName()))) {
                    return true;
                }
            }
            return false;
        }else {
            return true;
        }
    }

    @java.lang.Override
    public <T> void visitCtIntersectionTypeReference(spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {
        elementPrinterHelper.printList(reference.getBounds(), null, false, null, false, true, "&", true, false, null, ( bound) -> scan(bound));
    }

    @java.lang.Override
    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> ref) {
        visitCtTypeReference(ref, true);
    }

    @java.lang.Override
    public <T> void visitCtTypeAccess(spoon.reflect.code.CtTypeAccess<T> typeAccess) {
        if (typeAccess.isImplicit()) {
            return;
        }
        enterCtExpression(typeAccess);
        scan(typeAccess.getAccessedType());
        exitCtExpression(typeAccess);
    }

    private void visitCtTypeReferenceWithoutGenerics(spoon.reflect.reference.CtTypeReference<?> ref) {
        visitCtTypeReference(ref, false);
    }

    private void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<?> ref, boolean withGenerics) {
        if (ref.isImplicit()) {
            return;
        }
        if (ref.isPrimitive()) {
            elementPrinterHelper.writeAnnotations(ref);
            printer.writeKeyword(ref.getSimpleName());
            return;
        }
        boolean isInner = (ref.getDeclaringType()) != null;
        if (isInner) {
            if ((!(context.ignoreEnclosingClass())) && (!(ref.isLocalType()))) {
                // compute visible type which can be used to print access path to ref
                spoon.reflect.reference.CtTypeReference<?> accessType = ref.getAccessType();
                if (!(accessType.isAnonymous())) {
                    try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {
                        if (!withGenerics) {
                            _context.ignoreGenerics(true);
                        }
                        scan(accessType);
                    }
                    printer.writeSeparator(".");
                }
            }
            // ?? are these annotations on correct place ??
            elementPrinterHelper.writeAnnotations(ref);
            if (ref.isLocalType()) {
                printer.writeIdentifier(ref.getSimpleName().replaceAll("^[0-9]*", ""));
            }else {
                printer.writeIdentifier(ref.getSimpleName());
            }
        }else {
            if (((ref.getPackage()) != null) && (printQualified(ref))) {
                if (!(ref.getPackage().isUnnamedPackage())) {
                    scan(ref.getPackage());
                    printer.writeSeparator(spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);
                }
            }
            elementPrinterHelper.writeAnnotations(ref);
            printer.writeIdentifier(ref.getSimpleName());
        }
        if (withGenerics && (!(context.ignoreGenerics()))) {
            try (spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreEnclosingClass(false)) {
                elementPrinterHelper.writeActualTypeArguments(ref);
            }
        }
    }

    @java.lang.Override
    public <T> void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator<T> operator) {
        enterCtStatement(operator);
        enterCtExpression(operator);
        spoon.reflect.code.UnaryOperatorKind op = operator.getKind();
        if (spoon.reflect.visitor.OperatorHelper.isPrefixOperator(op)) {
            printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(op));
        }
        scan(operator.getOperand());
        if (spoon.reflect.visitor.OperatorHelper.isSufixOperator(op)) {
            printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(op));
        }
        exitCtExpression(operator);
        exitCtStatement(operator);
    }

    @java.lang.Override
    public <T> void visitCtVariableRead(spoon.reflect.code.CtVariableRead<T> variableRead) {
        enterCtExpression(variableRead);
        printer.writeIdentifier(variableRead.getVariable().getSimpleName());
        exitCtExpression(variableRead);
    }

    @java.lang.Override
    public <T> void visitCtVariableWrite(spoon.reflect.code.CtVariableWrite<T> variableWrite) {
        enterCtExpression(variableWrite);
        printer.writeIdentifier(variableWrite.getVariable().getSimpleName());
        exitCtExpression(variableWrite);
    }

    @java.lang.Override
    public void visitCtWhile(spoon.reflect.code.CtWhile whileLoop) {
        enterCtStatement(whileLoop);
        printer.writeKeyword("while").writeSpace().writeSeparator("(");
        scan(whileLoop.getLoopingExpression());
        printer.writeSeparator(")");
        elementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());
        exitCtStatement(whileLoop);
    }

    @java.lang.Override
    public <T> void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression<T> expression) {
        elementPrinterHelper.writeComment(expression);
        printer.writeCodeSnippet(expression.getValue());
    }

    @java.lang.Override
    public void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement statement) {
        enterCtStatement(statement);
        printer.writeCodeSnippet(statement.getValue());
        exitCtStatement(statement);
    }

    public spoon.reflect.visitor.ElementPrinterHelper getElementPrinterHelper() {
        return elementPrinterHelper;
    }

    public spoon.reflect.visitor.PrintingContext getContext() {
        return context;
    }

    @java.lang.Override
    public <T> void visitCtUnboundVariableReference(spoon.reflect.reference.CtUnboundVariableReference<T> reference) {
        printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public java.lang.String printPackageInfo(spoon.reflect.declaration.CtPackage pack) {
        reset();
        elementPrinterHelper.writeComment(pack);
        // we need to compute imports only for annotations
        // we don't want to get all imports coming from content of package
        for (spoon.reflect.declaration.CtAnnotation annotation : pack.getAnnotations()) {
            this.importsContext.computeImports(annotation);
        }
        elementPrinterHelper.writeAnnotations(pack);
        if (!(pack.isUnnamedPackage())) {
            elementPrinterHelper.writePackageLine(pack.getQualifiedName());
        }
        elementPrinterHelper.writeImports(this.importsContext.getAllImports());
        return printer.getPrinterHelper().toString();
    }

    @java.lang.Override
    public java.lang.String printModuleInfo(spoon.reflect.declaration.CtModule module) {
        reset();
        scan(module);
        return this.getResult();
    }

    @java.lang.Override
    public java.lang.String getResult() {
        return printer.getPrinterHelper().toString();
    }

    private void reset() {
        printer.reset();
        context = new spoon.reflect.visitor.PrintingContext();
        if (env.isAutoImports()) {
            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();
        }else {
            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();
        }
    }

    /**
    Write the compilation unit header.
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter writeHeader(java.util.List<spoon.reflect.declaration.CtType<?>> types, java.util.Collection<spoon.reflect.declaration.CtImport> imports) {
        elementPrinterHelper.writeHeader(types, imports);
        return this;
    }

    /**
    Write the compilation unit footer.
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter writeFooter(java.util.List<spoon.reflect.declaration.CtType<?>> types) {
        elementPrinterHelper.writeFooter(types);
        return this;
    }

    @java.lang.Override
    public void calculate(spoon.reflect.cu.CompilationUnit sourceCompilationUnit, java.util.List<spoon.reflect.declaration.CtType<?>> types) {
        // reset the importsContext to avoid errors with multiple CU
        reset();
        this.sourceCompilationUnit = sourceCompilationUnit;
        this.imports = new java.util.HashSet<>();
        if (sourceCompilationUnit != null) {
            this.importsContext.initWithImports(sourceCompilationUnit.getImports());
        }
        for (spoon.reflect.declaration.CtType<?> t : types) {
            imports.addAll(computeImports(t));
        }
        this.writeHeader(types, imports);
        printTypes(types);
    }

    protected void printTypes(java.util.List<spoon.reflect.declaration.CtType<?>> types) {
        for (spoon.reflect.declaration.CtType<?> t : types) {
            scan(t);
            if (!(env.isPreserveLineNumbers())) {
                // saving lines and chars
                printer.writeln().writeln();
            }else {
                getPrinterHelper().adjustEndPosition(t);
            }
        }
        this.writeFooter(types);
    }

    @java.lang.Override
    public java.util.Map<java.lang.Integer, java.lang.Integer> getLineNumberMapping() {
        return getPrinterHelper().getLineNumberMapping();
    }

    /**

    @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     *
     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     */
    protected spoon.reflect.visitor.TokenWriter getPrinterTokenWriter() {
        return printer;
    }

    /**
    Set {@link TokenWriter}, which has to be used to print tokens
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter setPrinterTokenWriter(spoon.reflect.visitor.TokenWriter tokenWriter) {
        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(tokenWriter, this, env);
        printer = tokenWriter;
        return this;
    }

    private spoon.reflect.visitor.PrinterHelper getPrinterHelper() {
        return printer.getPrinterHelper();
    }
}> but was:</**
A visitor for generating Java code from the program compile-time model.
 */
public class DefaultJavaPrettyPrinter implements spoon.reflect.visitor.CtVisitor , spoon.reflect.visitor.PrettyPrinter {
    /**
    Java file extension (.java).
     */
    public static final java.lang.String JAVA_FILE_EXTENSION = ".java";

    /**
    Package declaration file name.
     */
    public static final java.lang.String JAVA_PACKAGE_DECLARATION = "package-info" + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);

    /**
    Module declaration file name.
     */
    public static final java.lang.String JAVA_MODULE_DECLARATION = "module-info" + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);

    /**
    Line separator which is used by the system
     */
    public static final java.lang.String LINE_SEPARATOR = java.lang.System.getProperty("line.separator");

    /**
    The star at the beginning of a block/JavaDoc comment line
     */
    public static final java.lang.String COMMENT_STAR = " * ";

    /**
    The end of a block/JavaDoc comment
     */
    public static final java.lang.String BLOCK_COMMENT_END = " */";

    /**
    The beginning of a JavaDoc comment
     */
    public static final java.lang.String JAVADOC_START = "/**";

    /**
    The beginning of an inline comment
     */
    public static final java.lang.String INLINE_COMMENT_START = "// ";

    /**
    The beginning of a block comment
     */
    public static final java.lang.String BLOCK_COMMENT_START = "/* ";

    /**
    The printing context.

    since Spoon 7.1.0, use {{@link #getContext()}}
     */
    private spoon.reflect.visitor.PrintingContext context = new spoon.reflect.visitor.PrintingContext();

    /**
    get the import scanner of this pretty printer
     */
    public spoon.reflect.visitor.ImportScanner getImportsContext() {
        return this.importsContext;
    }

    /**
    Handle imports of classes.
     */
    private spoon.reflect.visitor.ImportScanner importsContext;

    /**
    Environment which Spoon is executed.
     */
    protected spoon.compiler.Environment env;

    /**
    Token detector, which delegates tokens to {@link TokenWriter}
     */
    private spoon.reflect.visitor.TokenWriter printer;

    /**
    Element printer helper.
     */
    private spoon.reflect.visitor.ElementPrinterHelper elementPrinterHelper;

    /**
    Compilation unit we are printing.
     */
    protected spoon.reflect.cu.CompilationUnit sourceCompilationUnit;

    /**
    Imports computed
     */
    java.util.Set<spoon.reflect.declaration.CtImport> imports;

    /**
    Creates a new code generator visitor.
     */
    public DefaultJavaPrettyPrinter(spoon.compiler.Environment env) {
        this.env = env;
        this.imports = new java.util.HashSet<>();
        setPrinterTokenWriter(new spoon.reflect.visitor.DefaultTokenWriter(new spoon.reflect.visitor.PrinterHelper(env)));
        if (env.isAutoImports()) {
            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();
        }else {
            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();
        }
    }

    /**
     *
     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system
     * defined by System.getProperty("line.separator")
     */
    public java.lang.String getLineSeparator() {
        return getPrinterHelper().getLineSeparator();
    }

    /**
     *
     * @param lineSeparator * 		characters which will be printed as End of line.
     * 		By default there is System.getProperty("line.separator")
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter setLineSeparator(java.lang.String lineSeparator) {
        getPrinterHelper().setLineSeparator(lineSeparator);
        return this;
    }

    /**
    Enters an expression.
     */
    protected void enterCtExpression(spoon.reflect.code.CtExpression<?> e) {
        if (!(e instanceof spoon.reflect.code.CtStatement)) {
            this.elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        }
        getPrinterHelper().mapLine(e, this.sourceCompilationUnit);
        if (shouldSetBracket(e)) {
            this.context.parenthesedExpression.push(e);
            this.printer.writeSeparator("(");
        }
        if (!(e.getTypeCasts().isEmpty())) {
            for (spoon.reflect.reference.CtTypeReference<?> r : e.getTypeCasts()) {
                this.printer.writeSeparator("(");
                scan(r);
                this.printer.writeSeparator(")").writeSpace();
                this.printer.writeSeparator("(");
                this.context.parenthesedExpression.push(e);
            }
        }
    }

    /**
    Enters a statement.
     */
    protected void enterCtStatement(spoon.reflect.code.CtStatement s) {
        this.elementPrinterHelper.writeComment(s, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        getPrinterHelper().mapLine(s, this.sourceCompilationUnit);
        if (!(this.context.isNextForVariable())) {
            // TODO AnnotationLoopTest#testAnnotationDeclaredInForInit expects that annotations of next for variables are not printed
            // but may be correct is that the next variables are not annotated, because they might have different annotation then first param!
            this.elementPrinterHelper.writeAnnotations(s);
        }
        if ((!(this.context.isFirstForVariable())) && (!(this.context.isNextForVariable()))) {
            if ((s.getLabel()) != null) {
                this.printer.writeIdentifier(s.getLabel()).writeSpace().writeSeparator(":").writeSpace();
            }
        }
    }

    /**
    Exits a statement.
     */
    protected void exitCtStatement(spoon.reflect.code.CtStatement statement) {
        if (!((((((((((statement instanceof spoon.reflect.code.CtBlock) || (statement instanceof spoon.reflect.code.CtIf)) || (statement instanceof spoon.reflect.code.CtFor)) || (statement instanceof spoon.reflect.code.CtForEach)) || (statement instanceof spoon.reflect.code.CtWhile)) || (statement instanceof spoon.reflect.code.CtTry)) || (statement instanceof spoon.reflect.code.CtSwitch)) || (statement instanceof spoon.reflect.code.CtSynchronized)) || (statement instanceof spoon.reflect.declaration.CtClass)) || (statement instanceof spoon.reflect.code.CtComment))) {
            if (((this.context.isStatement(statement)) && (!(this.context.isFirstForVariable()))) && (!(this.context.isNextForVariable()))) {
                this.printer.writeSeparator(";");
            }
        }
        this.elementPrinterHelper.writeComment(statement, spoon.reflect.visitor.printer.CommentOffset.AFTER);
    }

    /**
    Exits an expression.
     */
    protected void exitCtExpression(spoon.reflect.code.CtExpression<?> e) {
        while ((!(this.context.parenthesedExpression.isEmpty())) && (e == (this.context.parenthesedExpression.peek()))) {
            this.context.parenthesedExpression.pop();
            this.printer.writeSeparator(")");
        } 
        if (!(e instanceof spoon.reflect.code.CtStatement)) {
            this.elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);
        }
    }

    /**
    Make the imports for a given type.
     */
    private java.util.Collection<spoon.reflect.declaration.CtImport> computeImports(spoon.reflect.declaration.CtType<?> type) {
        this.context.currentTopLevel = type;
        this.importsContext.computeImports(this.context.currentTopLevel);
        return this.importsContext.getAllImports();
    }

    /**
    This method is called by {@link #scan(CtElement)} when entering a scanned element.
    To be overridden to implement specific behavior.

    Same KISS design as for {@link CtScanner}.
     */
    protected void enter(spoon.reflect.declaration.CtElement e) {
    }

    /**
    This method is called by {@link #scan(CtElement)} when entering a scanned element.
    To be overridden to implement specific behavior.
     */
    protected void exit(spoon.reflect.declaration.CtElement e) {
    }

    /**
    The generic scan method for an element.
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.declaration.CtElement e) {
        if (e != null) {
            enter(e);
            this.context.elementStack.push(e);
            if (this.env.isPreserveLineNumbers()) {
                if (!(e instanceof spoon.reflect.declaration.CtNamedElement)) {
                    getPrinterHelper().adjustStartPosition(e);
                }
            }
            try {
                e.accept(this);
            } catch (spoon.SpoonException ex) {
                throw ex;
            } catch (java.lang.Exception ex) {
                java.lang.String elementInfo = e.getClass().getName();
                elementInfo += (" on path " + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.getPath(e))) + "\n";
                if (e.getPosition().isValidPosition()) {
                    elementInfo += ("at position " + (e.getPosition().toString())) + " ";
                }
                throw new spoon.SpoonException((("Printing of " + elementInfo) + "failed"), ex);
            }
            this.context.elementStack.pop();
            exit(e);
        }
        return this;
    }

    private static java.lang.String getPath(spoon.reflect.declaration.CtElement ele) {
        java.lang.StringBuilder sb = new java.lang.StringBuilder();
        spoon.reflect.visitor.DefaultJavaPrettyPrinter.addParentPath(sb, ele);
        if (ele instanceof spoon.reflect.code.CtVariableAccess) {
            sb.append(':').append(((spoon.reflect.code.CtVariableAccess) (ele)).getVariable().getSimpleName());
        }
        return sb.toString();
    }

    private static void addParentPath(java.lang.StringBuilder sb, spoon.reflect.declaration.CtElement ele) {
        if ((ele == null) || ((ele instanceof spoon.reflect.declaration.CtPackage) && (((spoon.reflect.declaration.CtPackage) (ele)).isUnnamedPackage()))) {
            return;
        }
        if (ele.isParentInitialized()) {
            spoon.reflect.visitor.DefaultJavaPrettyPrinter.addParentPath(sb, ele.getParent());
        }
        sb.append("\n\t").append(ele.getClass().getSimpleName());
        if (ele instanceof spoon.reflect.declaration.CtNamedElement) {
            sb.append(":").append(((spoon.reflect.declaration.CtNamedElement) (ele)).getSimpleName());
        }else
            if (ele instanceof spoon.reflect.reference.CtReference) {
                sb.append(":").append(((spoon.reflect.reference.CtReference) (ele)).getSimpleName());
            }

    }

    private boolean shouldSetBracket(spoon.reflect.code.CtExpression<?> e) {
        if (!(e.getTypeCasts().isEmpty())) {
            return true;
        }
        try {
            if (((e.getParent()) instanceof spoon.reflect.code.CtBinaryOperator) || ((e.getParent()) instanceof spoon.reflect.code.CtUnaryOperator)) {
                return ((((e instanceof spoon.reflect.code.CtTargetedExpression) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator)) || (e instanceof spoon.reflect.code.CtBinaryOperator);
            }
            if ((e.getParent()) instanceof spoon.reflect.code.CtTargetedExpression) {
                return (((e instanceof spoon.reflect.code.CtBinaryOperator) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator);
            }
        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {
            // nothing we accept not to have a parent
        }
        return false;
    }

    /**
    Gets the currently pretty-printed string.
     */
    @java.lang.Override
    public java.lang.String toString() {
        return this.printer.getPrinterHelper().toString();
    }

    @java.lang.Override
    public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation<A> annotation) {
        this.elementPrinterHelper.writeAnnotations(annotation);
        this.printer.writeSeparator("@");
        scan(annotation.getAnnotationType());
        if (!(annotation.getValues().isEmpty())) {
            this.elementPrinterHelper.printList(annotation.getValues().entrySet(), null, false, "(", false, false, ",", true, false, ")", ( e) -> {
                if ((((annotation.getValues().size()) == 1) && ("value".equals(e.getKey()))) == false) {
                    // it is not a default value attribute. We must print a attribute name too.
                    this.printer.writeIdentifier(e.getKey()).writeSpace().writeOperator("=").writeSpace();
                }
                this.elementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());
            });
        }
    }

    @java.lang.Override
    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {
        visitCtType(annotationType);
        this.printer.writeSeparator("@").writeKeyword("interface").writeSpace().writeIdentifier(annotationType.getSimpleName()).writeSpace().writeSeparator("{").incTab();
        this.elementPrinterHelper.writeElementList(annotationType.getTypeMembers());
        this.printer.decTab().writeSeparator("}");
    }

    @java.lang.Override
    public void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable impl) {
        this.elementPrinterHelper.writeComment(impl);
        this.elementPrinterHelper.writeAnnotations(impl);
        this.elementPrinterHelper.writeModifiers(impl);
        scan(impl.getBody());
    }

    @java.lang.Override
    public <T> void visitCtArrayRead(spoon.reflect.code.CtArrayRead<T> arrayRead) {
        printCtArrayAccess(arrayRead);
    }

    @java.lang.Override
    public <T> void visitCtArrayWrite(spoon.reflect.code.CtArrayWrite<T> arrayWrite) {
        printCtArrayAccess(arrayWrite);
    }

    private <T, E extends spoon.reflect.code.CtExpression<?>> void printCtArrayAccess(spoon.reflect.code.CtArrayAccess<T, E> arrayAccess) {
        enterCtExpression(arrayAccess);
        scan(arrayAccess.getTarget());
        this.printer.writeSeparator("[");
        scan(arrayAccess.getIndexExpression());
        this.printer.writeSeparator("]");
        exitCtExpression(arrayAccess);
    }

    @java.lang.Override
    public <T> void visitCtArrayTypeReference(spoon.reflect.reference.CtArrayTypeReference<T> reference) {
        if (reference.isImplicit()) {
            return;
        }
        scan(reference.getComponentType());
        if (!(this.context.skipArray())) {
            this.printer.writeSeparator("[").writeSeparator("]");
        }
    }

    @java.lang.Override
    public <T> void visitCtAssert(spoon.reflect.code.CtAssert<T> asserted) {
        enterCtStatement(asserted);
        this.printer.writeKeyword("assert").writeSpace();
        scan(asserted.getAssertExpression());
        if ((asserted.getExpression()) != null) {
            this.printer.writeSpace().writeSeparator(":").writeSpace();
            scan(asserted.getExpression());
        }
        exitCtStatement(asserted);
    }

    @java.lang.Override
    public <T, A extends T> void visitCtAssignment(spoon.reflect.code.CtAssignment<T, A> assignement) {
        enterCtStatement(assignement);
        enterCtExpression(assignement);
        scan(assignement.getAssigned());
        this.printer.writeSpace().writeOperator("=").writeSpace();
        scan(assignement.getAssignment());
        exitCtExpression(assignement);
        exitCtStatement(assignement);
    }

    @java.lang.Override
    public <T> void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator<T> operator) {
        enterCtExpression(operator);
        scan(operator.getLeftHandOperand());
        this.printer.writeSpace();
        this.printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(operator.getKind()));
        this.printer.writeSpace();
        try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify()) {
            if ((operator.getKind()) == (spoon.reflect.code.BinaryOperatorKind.INSTANCEOF)) {
                _context.forceWildcardGenerics(true);
            }
            scan(operator.getRightHandOperand());
        }
        exitCtExpression(operator);
    }

    @java.lang.Override
    public <R> void visitCtBlock(spoon.reflect.code.CtBlock<R> block) {
        enterCtStatement(block);
        if (!(block.isImplicit())) {
            this.printer.writeSeparator("{");
        }
        this.printer.incTab();
        for (spoon.reflect.code.CtStatement statement : block.getStatements()) {
            if (!(statement.isImplicit())) {
                this.printer.writeln();
                this.elementPrinterHelper.writeStatement(statement);
            }
        }
        this.printer.decTab();
        getPrinterHelper().adjustEndPosition(block);
        if (this.env.isPreserveLineNumbers()) {
            if (!(block.isImplicit())) {
                this.printer.writeSeparator("}");
            }
        }else {
            this.printer.writeln();
            if (!(block.isImplicit())) {
                this.printer.writeSeparator("}");
            }
        }
        exitCtStatement(block);
    }

    @java.lang.Override
    public void visitCtBreak(spoon.reflect.code.CtBreak breakStatement) {
        enterCtStatement(breakStatement);
        this.printer.writeKeyword("break");
        if ((breakStatement.getTargetLabel()) != null) {
            this.printer.writeSpace().writeKeyword(breakStatement.getTargetLabel());
        }
        exitCtStatement(breakStatement);
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("rawtypes")
    public <E> void visitCtCase(spoon.reflect.code.CtCase<E> caseStatement) {
        enterCtStatement(caseStatement);
        if ((caseStatement.getCaseExpression()) != null) {
            this.printer.writeKeyword("case").writeSpace();
            // writing enum case expression
            if ((caseStatement.getCaseExpression()) instanceof spoon.reflect.code.CtFieldAccess) {
                final spoon.reflect.reference.CtFieldReference variable = ((spoon.reflect.code.CtFieldAccess) (caseStatement.getCaseExpression())).getVariable();
                // In noclasspath mode, we don't have always the type of the declaring type.
                if ((((variable.getType()) != null) && ((variable.getDeclaringType()) != null)) && (variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName()))) {
                    this.printer.writeIdentifier(variable.getSimpleName());
                }else {
                    scan(caseStatement.getCaseExpression());
                }
            }else {
                scan(caseStatement.getCaseExpression());
            }
        }else {
            this.printer.writeKeyword("default");
        }
        this.printer.writeSpace().writeSeparator(":").incTab();
        for (spoon.reflect.code.CtStatement statement : caseStatement.getStatements()) {
            this.printer.writeln();
            this.elementPrinterHelper.writeStatement(statement);
        }
        this.printer.decTab();
        exitCtStatement(caseStatement);
    }

    @java.lang.Override
    public void visitCtCatch(spoon.reflect.code.CtCatch catchBlock) {
        this.elementPrinterHelper.writeComment(catchBlock, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        this.printer.writeSpace().writeKeyword("catch").writeSpace().writeSeparator("(");
        spoon.reflect.code.CtCatchVariable<? extends java.lang.Throwable> parameter = catchBlock.getParameter();
        if ((parameter != null) && ((parameter.getMultiTypes().size()) > 1)) {
            this.elementPrinterHelper.printList(parameter.getMultiTypes(), null, false, null, false, true, "|", true, false, null, ( type) -> scan(type));
            this.printer.writeSpace().writeIdentifier(parameter.getSimpleName());
        }else {
            scan(parameter);
        }
        this.printer.writeSeparator(")").writeSpace();
        scan(catchBlock.getBody());
    }

    @java.lang.Override
    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {
        this.context.pushCurrentThis(ctClass);
        if ((((ctClass.getSimpleName()) != null) && (!(spoon.reflect.declaration.CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName())))) && (!(ctClass.isAnonymous()))) {
            visitCtType(ctClass);
            if (ctClass.isLocalType()) {
                this.printer.writeKeyword("class").writeSpace().writeIdentifier(ctClass.getSimpleName().replaceAll("^[0-9]*", ""));
            }else {
                this.printer.writeKeyword("class").writeSpace().writeIdentifier(ctClass.getSimpleName());
            }
            this.elementPrinterHelper.writeFormalTypeParameters(ctClass);
            this.elementPrinterHelper.writeExtendsClause(ctClass);
            this.elementPrinterHelper.writeImplementsClause(ctClass);
        }
        this.printer.writeSpace().writeSeparator("{").incTab();
        this.elementPrinterHelper.writeElementList(ctClass.getTypeMembers());
        getPrinterHelper().adjustEndPosition(ctClass);
        this.printer.decTab().writeSeparator("}");
        this.context.popCurrentThis();
    }

    @java.lang.Override
    public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {
        this.elementPrinterHelper.writeAnnotations(typeParameter);
        this.printer.writeIdentifier(typeParameter.getSimpleName());
        if (((typeParameter.getSuperclass()) != null) && ((typeParameter.getSuperclass().isImplicit()) == false)) {
            this.printer.writeSpace().writeKeyword("extends").writeSpace();
            scan(typeParameter.getSuperclass());
        }
    }

    @java.lang.Override
    public <T> void visitCtConditional(spoon.reflect.code.CtConditional<T> conditional) {
        enterCtExpression(conditional);
        spoon.reflect.code.CtExpression<java.lang.Boolean> condition = conditional.getCondition();
        boolean parent;
        try {
            parent = ((conditional.getParent()) instanceof spoon.reflect.code.CtAssignment) || ((conditional.getParent()) instanceof spoon.reflect.declaration.CtVariable);
        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {
            // nothing if we have no parent
            parent = false;
        }
        if (parent) {
            this.printer.writeSeparator("(");
        }
        scan(condition);
        if (parent) {
            this.printer.writeSeparator(")");
        }
        this.printer.writeSpace().writeOperator("?").writeSpace();
        spoon.reflect.code.CtExpression<T> thenExpression = conditional.getThenExpression();
        scan(thenExpression);
        this.printer.writeSpace().writeOperator(":").writeSpace();
        spoon.reflect.code.CtExpression<T> elseExpression = conditional.getElseExpression();
        boolean isAssign;
        if (isAssign = elseExpression instanceof spoon.reflect.code.CtAssignment) {
            this.printer.writeSeparator("(");
        }
        scan(elseExpression);
        if (isAssign) {
            this.printer.writeSeparator(")");
        }
        exitCtExpression(conditional);
    }

    @java.lang.Override
    public <T> void visitCtConstructor(spoon.reflect.declaration.CtConstructor<T> constructor) {
        this.elementPrinterHelper.writeComment(constructor);
        this.elementPrinterHelper.visitCtNamedElement(constructor, this.sourceCompilationUnit);
        this.elementPrinterHelper.writeModifiers(constructor);
        this.elementPrinterHelper.writeFormalTypeParameters(constructor);
        if (!(constructor.getFormalCtTypeParameters().isEmpty())) {
            this.printer.writeSpace();
        }
        if ((constructor.getDeclaringType()) != null) {
            if (constructor.getDeclaringType().isLocalType()) {
                this.printer.writeIdentifier(constructor.getDeclaringType().getSimpleName().replaceAll("^[0-9]*", ""));
            }else {
                this.printer.writeIdentifier(constructor.getDeclaringType().getSimpleName());
            }
        }
        this.elementPrinterHelper.writeExecutableParameters(constructor);
        this.elementPrinterHelper.writeThrowsClause(constructor);
        this.printer.writeSpace();
        scan(constructor.getBody());
    }

    @java.lang.Override
    public void visitCtContinue(spoon.reflect.code.CtContinue continueStatement) {
        enterCtStatement(continueStatement);
        this.printer.writeKeyword("continue");
        if ((continueStatement.getTargetLabel()) != null) {
            this.printer.writeSpace().writeIdentifier(continueStatement.getTargetLabel());
        }
        exitCtStatement(continueStatement);
    }

    @java.lang.Override
    public void visitCtDo(spoon.reflect.code.CtDo doLoop) {
        enterCtStatement(doLoop);
        this.printer.writeKeyword("do");
        this.elementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());
        this.printer.writeKeyword("while").writeSpace().writeSeparator("(");
        scan(doLoop.getLoopingExpression());
        this.printer.writeSpace().writeSeparator(")");
        exitCtStatement(doLoop);
    }

    @java.lang.Override
    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {
        visitCtType(ctEnum);
        this.printer.writeKeyword("enum").writeSpace().writeIdentifier(ctEnum.getSimpleName());
        this.elementPrinterHelper.writeImplementsClause(ctEnum);
        this.context.pushCurrentThis(ctEnum);
        this.printer.writeSpace().writeSeparator("{").incTab().writeln();
        if (ctEnum.getEnumValues().isEmpty()) {
            this.printer.writeSeparator(";").writeln();
        }else {
            this.elementPrinterHelper.printList(ctEnum.getEnumValues(), null, false, null, false, false, ",", false, false, ";", ( enumValue) -> {
                this.printer.writeln();
                scan(enumValue);
            });
        }
        this.elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());
        this.printer.decTab().writeSeparator("}");
        this.context.popCurrentThis();
    }

    @java.lang.Override
    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {
        // it is not called during printing of sources. Use shortcut and print directly to PrinterHelper
        this.printer.getPrinterHelper().write(reference.getSignature());
    }

    @java.lang.Override
    public <T> void visitCtField(spoon.reflect.declaration.CtField<T> f) {
        this.elementPrinterHelper.writeComment(f, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        this.elementPrinterHelper.visitCtNamedElement(f, this.sourceCompilationUnit);
        this.elementPrinterHelper.writeModifiers(f);
        scan(f.getType());
        this.printer.writeSpace();
        this.printer.writeIdentifier(f.getSimpleName());
        if ((f.getDefaultExpression()) != null) {
            this.printer.writeSpace().writeOperator("=").writeSpace();
            scan(f.getDefaultExpression());
        }
        this.printer.writeSeparator(";");
        this.elementPrinterHelper.writeComment(f, spoon.reflect.visitor.printer.CommentOffset.AFTER);
    }

    @java.lang.Override
    public <T> void visitCtEnumValue(spoon.reflect.declaration.CtEnumValue<T> enumValue) {
        this.elementPrinterHelper.visitCtNamedElement(enumValue, this.sourceCompilationUnit);
        this.elementPrinterHelper.writeComment(enumValue, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        this.printer.writeIdentifier(enumValue.getSimpleName());
        if ((enumValue.getDefaultExpression()) != null) {
            spoon.reflect.code.CtConstructorCall<?> constructorCall = ((spoon.reflect.code.CtConstructorCall<?>) (enumValue.getDefaultExpression()));
            if (!(constructorCall.isImplicit())) {
                this.elementPrinterHelper.printList(constructorCall.getArguments(), null, false, "(", false, false, ",", true, false, ")", ( expr) -> scan(expr));
            }
            if (constructorCall instanceof spoon.reflect.code.CtNewClass) {
                scan(((spoon.reflect.code.CtNewClass<?>) (constructorCall)).getAnonymousClass());
            }
        }
    }

    @java.lang.Override
    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {
        printCtFieldAccess(fieldRead);
    }

    @java.lang.Override
    public <T> void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite<T> fieldWrite) {
        printCtFieldAccess(fieldWrite);
    }

    private boolean isImported(spoon.reflect.reference.CtFieldReference fieldReference) {
        spoon.reflect.declaration.CtImport fieldImport = fieldReference.getFactory().createImport(fieldReference);
        if (this.imports.contains(fieldImport)) {
            return true;
        }else {
            if ((fieldReference.getDeclaringType()) == null) {
                return false;
            }
            spoon.reflect.reference.CtTypeReference staticTypeMemberReference = fieldReference.getFactory().Type().createWildcardStaticTypeMemberReference(fieldReference.getDeclaringType());
            spoon.reflect.declaration.CtImport staticClassImport = fieldReference.getFactory().createImport(staticTypeMemberReference);
            return this.imports.contains(staticClassImport);
        }
    }

    private boolean isImported(spoon.reflect.reference.CtExecutableReference executableReference) {
        spoon.reflect.declaration.CtImport executableImport = executableReference.getFactory().createImport(executableReference);
        if (this.imports.contains(executableImport)) {
            return true;
        }else {
            if ((executableReference.getDeclaringType()) == null) {
                return false;
            }
            spoon.reflect.reference.CtTypeReference staticTypeMemberReference = executableReference.getFactory().Type().createWildcardStaticTypeMemberReference(executableReference.getDeclaringType());
            spoon.reflect.declaration.CtImport staticClassImport = executableReference.getFactory().createImport(staticTypeMemberReference);
            return this.imports.contains(staticClassImport);
        }
    }

    private <T> void printCtFieldAccess(spoon.reflect.code.CtFieldAccess<T> f) {
        enterCtExpression(f);
        try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify()) {
            if (((f.getVariable().isStatic()) || ("class".equals(f.getVariable().getSimpleName()))) && ((f.getTarget()) instanceof spoon.reflect.code.CtTypeAccess)) {
                _context.ignoreGenerics(true);
            }
            spoon.reflect.code.CtExpression<?> target = f.getTarget();
            if (target != null) {
                boolean isInitializeStaticFinalField = isInitializeStaticFinalField(f.getTarget());
                boolean isStaticField = f.getVariable().isStatic();
                boolean isImportedField = this.isImported(f.getVariable());
                if ((!isInitializeStaticFinalField) && (!(isStaticField && isImportedField))) {
                    if ((target.isImplicit()) && (!(((f.getVariable().getFieldDeclaration()) == null) && (this.env.getNoClasspath())))) {
                        /* target is implicit, check whether there is no conflict with an local variable, catch variable or parameter
                        in case of conflict make it explicit, otherwise the field access is shadowed by that variable.
                        Search for potential variable declaration until we found a class which declares or inherits this field */
                        final spoon.reflect.declaration.CtField<?> field = f.getVariable().getFieldDeclaration();
                        if (field != null) {
                            final java.lang.String fieldName = field.getSimpleName();
                            spoon.reflect.declaration.CtVariable<?> var = f.getVariable().map(new spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction(fieldName)).first();
                            if (var != field) {
                                // another variable declaration was found which is hiding the field declaration for this field access. Make the field access explicit
                                target.setImplicit(false);
                            }
                        }else {
                            // There is a model inconsistency
                            this.printer.writeComment(f.getFactory().createComment((("ERROR: Missing field \"" + (f.getVariable().getSimpleName())) + "\", please check your model. The code may not compile."), spoon.reflect.code.CtComment.CommentType.BLOCK)).writeSpace();
                        }
                    }
                    // the implicit drives the separator
                    if (!(target.isImplicit())) {
                        scan(target);
                        this.printer.writeSeparator(".");
                    }
                }
                _context.ignoreStaticAccess(true);
            }
            scan(f.getVariable());
        }
        exitCtExpression(f);
    }

    /**
    Check if the target expression is a static final field initialized in a static anonymous block.
     */
    private <T> boolean isInitializeStaticFinalField(spoon.reflect.code.CtExpression<T> targetExp) {
        final spoon.reflect.declaration.CtElement parent;
        final spoon.reflect.declaration.CtAnonymousExecutable anonymousParent;
        try {
            parent = targetExp.getParent();
            anonymousParent = targetExp.getParent(spoon.reflect.declaration.CtAnonymousExecutable.class);
        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {
            return false;
        }
        return (((((parent instanceof spoon.reflect.code.CtFieldWrite) && (targetExp.equals(((spoon.reflect.code.CtFieldWrite) (parent)).getTarget()))) && (anonymousParent != null)) && ((((spoon.reflect.code.CtFieldWrite) (parent)).getVariable()) != null)) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.STATIC))) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.FINAL));
    }

    @java.lang.Override
    public <T> void visitCtThisAccess(spoon.reflect.code.CtThisAccess<T> thisAccess) {
        try {
            enterCtExpression(thisAccess);
            // we only write qualified this when this is required
            // this is good both in fully-qualified mode and in readable (with-imports) mode
            // the implicit information is used for analysis (e.g. is visibility caused by implicit bugs?) but
            // not for pretty-printing
            spoon.reflect.code.CtTypeAccess target = ((spoon.reflect.code.CtTypeAccess) (thisAccess.getTarget()));
            spoon.reflect.reference.CtTypeReference targetType = target.getAccessedType();
            // readable mode as close as possible to the original code
            if (thisAccess.isImplicit()) {
                // write nothing, "this" is implicit and we unfortunately cannot always know
                // what the good target is in JDTTreeBuilder
                return;
            }
            // the simplest case: we always print "this" if we're in the top-level class,
            // this is shorter (no qualified this), explicit, and less fragile wrt transformation
            if ((targetType == null) || (((thisAccess.getParent(spoon.reflect.declaration.CtType.class)) != null) && (thisAccess.getParent(spoon.reflect.declaration.CtType.class).isTopLevel()))) {
                this.printer.writeKeyword("this");
                return;// still go through finally block below

            }
            // we cannot have fully-qualified this in anonymous classes
            // we simply print "this" and it always works
            // this has to come after the implicit test just before
            if (targetType.isAnonymous()) {
                this.printer.writeKeyword("this");
                return;
            }
            // complex case of qualified this
            if (!(this.context.currentThis.isEmpty())) {
                spoon.reflect.declaration.CtType lastType = this.context.currentThis.peekFirst().type;
                java.lang.String lastTypeQualifiedName = lastType.getQualifiedName();
                java.lang.String targetTypeQualifiedName = targetType.getQualifiedName();
                if (!(lastTypeQualifiedName.equals(targetTypeQualifiedName))) {
                    if (!(targetType.isImplicit())) {
                        visitCtTypeReferenceWithoutGenerics(targetType);
                        this.printer.writeSeparator(".");
                    }
                    this.printer.writeKeyword("this");
                    return;
                }
            }
            // the default super simple case only comes at the end
            this.printer.writeKeyword("this");
        } finally {
            exitCtExpression(thisAccess);
        }
    }

    @java.lang.Override
    public <T> void visitCtSuperAccess(spoon.reflect.code.CtSuperAccess<T> f) {
        enterCtExpression(f);
        if ((f.getTarget()) != null) {
            scan(f.getTarget());
            this.printer.writeSeparator(".");
        }
        this.printer.writeKeyword("super");
        exitCtExpression(f);
    }

    @java.lang.Override
    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc comment) {
        visitCtComment(comment);
    }

    @java.lang.Override
    public void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag docTag) {
        /* is not called during normal printing of java sources.
        It can be called only when CtJavaDocTag has to be printed directly.
        E.g. from CtJavaDocTag#toString
        Write directly to PrinterHelper, because java doc tag is not a java token. Normally it is part of COMMENT token. */
        spoon.reflect.visitor.CommentHelper.printJavaDocTag(this.printer.getPrinterHelper(), docTag);
    }

    @java.lang.Override
    public void visitCtImport(spoon.reflect.declaration.CtImport ctImport) {
        if ((ctImport.getImportKind()) != null) {
            this.printer.writeKeyword("import");
            this.printer.writeSpace();
            switch (ctImport.getImportKind()) {
                case TYPE :
                    visitCtTypeReference(((spoon.reflect.reference.CtTypeReference) (ctImport.getReference())));
                    break;
                case METHOD :
                    this.printer.writeKeyword("static");
                    this.printer.writeSpace();
                    visitCtExecutableReference(((spoon.reflect.reference.CtExecutableReference) (ctImport.getReference())));
                    break;
                case FIELD :
                    this.printer.writeKeyword("static");
                    this.printer.writeSpace();
                    visitCtFieldReference(((spoon.reflect.reference.CtFieldReference) (ctImport.getReference())));
                    break;
                case ALL_TYPES :
                    visitCtPackageReference(((spoon.reflect.reference.CtPackageReference) (ctImport.getReference())));
                    this.printer.writeSeparator(".");
                    this.printer.writeIdentifier("*");
                    break;
                case ALL_STATIC_MEMBERS :
                    this.printer.writeKeyword("static");
                    this.printer.writeSpace();
                    visitCtTypeReference(((spoon.reflect.reference.CtTypeReference) (ctImport.getReference())));
                    break;
            }
            this.printer.writeSeparator(";");
            this.printer.writeln();
        }
    }

    @java.lang.Override
    public void visitCtModule(spoon.reflect.declaration.CtModule module) {
        enter(module);
        if (module.isOpenModule()) {
            this.printer.writeKeyword("open").writeSpace();
        }
        this.printer.writeKeyword("module").writeSpace().writeIdentifier(module.getSimpleName());
        this.printer.writeSpace().writeSeparator("{").incTab().writeln();
        for (spoon.reflect.declaration.CtModuleDirective moduleDirective : module.getModuleDirectives()) {
            scan(moduleDirective);
        }
        this.printer.decTab().writeSeparator("}");
        exit(module);
    }

    @java.lang.Override
    public void visitCtModuleReference(spoon.reflect.reference.CtModuleReference moduleReference) {
        this.printer.writeIdentifier(moduleReference.getSimpleName());
    }

    @java.lang.Override
    public void visitCtPackageExport(spoon.reflect.declaration.CtPackageExport moduleExport) {
        if (moduleExport.isOpenedPackage()) {
            this.printer.writeKeyword("opens");
        }else {
            this.printer.writeKeyword("exports");
        }
        this.printer.writeSpace();
        visitCtPackageReference(moduleExport.getPackageReference());
        if (!(moduleExport.getTargetExport().isEmpty())) {
            this.elementPrinterHelper.printList(moduleExport.getTargetExport(), null, false, " to", true, false, ",", true, false, null, ( moduleReference) -> scan(moduleReference));
        }
        this.printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtModuleRequirement(spoon.reflect.declaration.CtModuleRequirement moduleRequirement) {
        this.printer.writeKeyword("requires").writeSpace();
        if (!(moduleRequirement.getRequiresModifiers().isEmpty())) {
            this.elementPrinterHelper.printList(moduleRequirement.getRequiresModifiers(), null, false, null, false, false, " ", false, false, " ", ( modifier) -> this.printer.writeKeyword(modifier.name().toLowerCase()));
        }
        scan(moduleRequirement.getModuleReference());
        this.printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtProvidedService(spoon.reflect.declaration.CtProvidedService moduleProvidedService) {
        this.printer.writeKeyword("provides").writeSpace();
        scan(moduleProvidedService.getServiceType());
        this.elementPrinterHelper.printList(moduleProvidedService.getImplementationTypes(), null, false, " with", true, false, ",", true, false, null, ( implementations) -> scan(implementations));
        this.printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtUsedService(spoon.reflect.declaration.CtUsedService usedService) {
        this.printer.writeKeyword("uses").writeSpace();
        scan(usedService.getServiceType());
        this.printer.writeSeparator(";").writeln();
    }

    @java.lang.Override
    public void visitCtComment(spoon.reflect.code.CtComment comment) {
        if ((!(this.env.isCommentsEnabled())) && ((this.context.elementStack.size()) > 1)) {
            return;
        }
        this.printer.writeComment(comment);
    }

    @java.lang.Override
    public <T> void visitCtAnnotationFieldAccess(spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {
        enterCtExpression(annotationFieldAccess);
        try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify()) {
            if ((annotationFieldAccess.getTarget()) != null) {
                scan(annotationFieldAccess.getTarget());
                this.printer.writeSeparator(".");
                _context.ignoreStaticAccess(true);
            }
            _context.ignoreGenerics(true);
            scan(annotationFieldAccess.getVariable());
            this.printer.writeSeparator("(").writeSeparator(")");
        }
        exitCtExpression(annotationFieldAccess);
    }

    @java.lang.Override
    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {
        boolean isStatic = ("class".equals(reference.getSimpleName())) || ((!("super".equals(reference.getSimpleName()))) && (reference.isStatic()));
        boolean printType = true;
        if ((reference.isFinal()) && (reference.isStatic())) {
            spoon.reflect.reference.CtTypeReference<?> declTypeRef = reference.getDeclaringType();
            if (declTypeRef.isAnonymous()) {
                // never print anonymous class ref
                printType = false;
            }else {
                if (this.context.isInCurrentScope(declTypeRef)) {
                    // do not printType if we are in scope of that type
                    printType = false;
                }
            }
        }
        if ((isStatic && printType) && (!(this.context.ignoreStaticAccess()))) {
            try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify().ignoreGenerics(true)) {
                scan(reference.getDeclaringType());
            }
            this.printer.writeSeparator(".");
        }
        if ("class".equals(reference.getSimpleName())) {
            this.printer.writeKeyword("class");
        }else {
            this.printer.writeIdentifier(reference.getSimpleName());
        }
    }

    @java.lang.Override
    public void visitCtFor(spoon.reflect.code.CtFor forLoop) {
        enterCtStatement(forLoop);
        this.printer.writeKeyword("for").writeSpace().writeSeparator("(");
        java.util.List<spoon.reflect.code.CtStatement> st = forLoop.getForInit();
        if (!(st.isEmpty())) {
            try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify().isFirstForVariable(true)) {
                scan(st.get(0));
            }
        }
        if ((st.size()) > 1) {
            try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify().isNextForVariable(true)) {
                for (int i = 1; i < (st.size()); i++) {
                    this.printer.writeSeparator(",").writeSpace();
                    scan(st.get(i));
                }
            }
        }
        this.printer.writeSeparator(";").writeSpace();
        scan(forLoop.getExpression());
        this.printer.writeSeparator(";");
        if (!(forLoop.getForUpdate().isEmpty())) {
            this.printer.writeSpace();
        }
        this.elementPrinterHelper.printList(forLoop.getForUpdate(), null, false, null, false, true, ",", true, false, null, ( s) -> scan(s));
        this.printer.writeSeparator(")");
        this.elementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());
        exitCtStatement(forLoop);
    }

    @java.lang.Override
    public void visitCtForEach(spoon.reflect.code.CtForEach foreach) {
        enterCtStatement(foreach);
        this.printer.writeKeyword("for").writeSpace().writeSeparator("(");
        scan(foreach.getVariable());
        this.printer.writeSpace().writeSeparator(":").writeSpace();
        scan(foreach.getExpression());
        this.printer.writeSeparator(")");
        this.elementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());
        exitCtStatement(foreach);
    }

    @java.lang.Override
    public void visitCtIf(spoon.reflect.code.CtIf ifElement) {
        enterCtStatement(ifElement);
        this.printer.writeKeyword("if").writeSpace().writeSeparator("(");
        scan(ifElement.getCondition());
        this.printer.writeSeparator(")");
        this.elementPrinterHelper.writeIfOrLoopBlock(ifElement.getThenStatement());
        if ((ifElement.getElseStatement()) != null) {
            java.util.List<spoon.reflect.code.CtComment> comments = this.elementPrinterHelper.getComments(ifElement, spoon.reflect.visitor.printer.CommentOffset.INSIDE);
            for (spoon.reflect.code.CtComment comment : comments) {
                spoon.reflect.cu.SourcePosition thenPosition = (ifElement.getThenStatement().getPosition().isValidPosition()) ? ifElement.getThenStatement().getPosition() : ((spoon.reflect.code.CtBlock) (ifElement.getThenStatement())).getStatement(0).getPosition();
                if ((comment.getPosition().getSourceStart()) > (thenPosition.getSourceEnd())) {
                    this.elementPrinterHelper.writeComment(comment);
                }
            }
            this.printer.writeKeyword("else");
            this.elementPrinterHelper.writeIfOrLoopBlock(ifElement.getElseStatement());
        }
        exitCtStatement(ifElement);
    }

    @java.lang.Override
    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {
        visitCtType(intrface);
        this.printer.writeKeyword("interface").writeSpace().writeIdentifier(intrface.getSimpleName());
        if ((intrface.getFormalCtTypeParameters()) != null) {
            this.elementPrinterHelper.writeFormalTypeParameters(intrface);
        }
        if (!(intrface.getSuperInterfaces().isEmpty())) {
            this.elementPrinterHelper.printList(intrface.getSuperInterfaces(), "extends", false, null, false, true, ",", true, false, null, ( ref) -> scan(ref));
        }
        this.context.pushCurrentThis(intrface);
        this.printer.writeSpace().writeSeparator("{").incTab();
        // Content
        this.elementPrinterHelper.writeElementList(intrface.getTypeMembers());
        this.printer.decTab().writeSeparator("}");
        this.context.popCurrentThis();
    }

    @java.lang.Override
    public <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> invocation) {
        enterCtStatement(invocation);
        enterCtExpression(invocation);
        if (invocation.getExecutable().isConstructor()) {
            // It's a constructor (super or this)
            this.elementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());
            spoon.reflect.declaration.CtType<?> parentType;
            try {
                parentType = invocation.getParent(spoon.reflect.declaration.CtType.class);
            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {
                parentType = null;
            }
            if (((parentType != null) && ((parentType.getQualifiedName()) != null)) && (parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName()))) {
                this.printer.writeKeyword("this");
            }else {
                if (((invocation.getTarget()) != null) && (!(invocation.getTarget().isImplicit()))) {
                    scan(invocation.getTarget());
                    this.printer.writeSeparator(".");
                }
                this.printer.writeKeyword("super");
            }
        }else {
            // It's a method invocation
            boolean isImported = this.isImported(invocation.getExecutable());
            if (!isImported) {
                try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify()) {
                    if ((invocation.getTarget()) instanceof spoon.reflect.code.CtTypeAccess) {
                        _context.ignoreGenerics(true);
                    }
                    if (((invocation.getTarget()) != null) && (!(invocation.getTarget().isImplicit()))) {
                        scan(invocation.getTarget());
                        this.printer.writeSeparator(".");
                    }
                }
            }
            this.elementPrinterHelper.writeActualTypeArguments(invocation);
            if (this.env.isPreserveLineNumbers()) {
                getPrinterHelper().adjustStartPosition(invocation);
            }
            this.printer.writeIdentifier(invocation.getExecutable().getSimpleName());
        }
        this.elementPrinterHelper.printList(invocation.getArguments(), null, false, "(", false, false, ",", true, false, ")", ( e) -> scan(e));
        exitCtExpression(invocation);
        exitCtStatement(invocation);
    }

    @java.lang.Override
    public <T> void visitCtLiteral(spoon.reflect.code.CtLiteral<T> literal) {
        enterCtExpression(literal);
        this.printer.writeLiteral(spoon.reflect.visitor.LiteralHelper.getLiteralToken(literal));
        exitCtExpression(literal);
    }

    @java.lang.Override
    public <T> void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable<T> localVariable) {
        enterCtStatement(localVariable);
        if (this.env.isPreserveLineNumbers()) {
            getPrinterHelper().adjustStartPosition(localVariable);
        }
        if (!(this.context.isNextForVariable())) {
            this.elementPrinterHelper.writeModifiers(localVariable);
            if ((localVariable.isInferred()) && ((this.env.getComplianceLevel()) >= 10)) {
                getPrinterTokenWriter().writeKeyword("var");
            }else {
                scan(localVariable.getType());
            }
            this.printer.writeSpace();
        }
        this.printer.writeIdentifier(localVariable.getSimpleName());
        if ((localVariable.getDefaultExpression()) != null) {
            this.printer.writeSpace().writeOperator("=").writeSpace();
            scan(localVariable.getDefaultExpression());
        }
        exitCtStatement(localVariable);
    }

    @java.lang.Override
    public <T> void visitCtLocalVariableReference(spoon.reflect.reference.CtLocalVariableReference<T> reference) {
        this.printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {
        if (this.env.isPreserveLineNumbers()) {
            getPrinterHelper().adjustStartPosition(catchVariable);
        }
        this.elementPrinterHelper.writeModifiers(catchVariable);
        scan(catchVariable.getType());
        this.printer.writeSpace();
        this.printer.writeIdentifier(catchVariable.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtCatchVariableReference(spoon.reflect.reference.CtCatchVariableReference<T> reference) {
        this.printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtMethod(spoon.reflect.declaration.CtMethod<T> m) {
        this.elementPrinterHelper.writeComment(m, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        this.elementPrinterHelper.visitCtNamedElement(m, this.sourceCompilationUnit);
        this.elementPrinterHelper.writeModifiers(m);
        this.elementPrinterHelper.writeFormalTypeParameters(m);
        if (!(m.getFormalCtTypeParameters().isEmpty())) {
            this.printer.writeSpace();
        }
        try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify().ignoreGenerics(false)) {
            scan(m.getType());
        }
        this.printer.writeSpace();
        this.printer.writeIdentifier(m.getSimpleName());
        this.elementPrinterHelper.writeExecutableParameters(m);
        this.elementPrinterHelper.writeThrowsClause(m);
        if ((m.getBody()) != null) {
            this.printer.writeSpace();
            scan(m.getBody());
            if (m.getBody().getPosition().isValidPosition()) {
                if ((m.getBody().getPosition().getCompilationUnit()) == (this.sourceCompilationUnit)) {
                    if ((m.getBody().getStatements().isEmpty()) || (!((m.getBody().getStatements().get(((m.getBody().getStatements().size()) - 1))) instanceof spoon.reflect.code.CtReturn))) {
                        getPrinterHelper().putLineNumberMapping(m.getBody().getPosition().getEndLine());
                    }
                }else {
                    getPrinterHelper().undefineLine();
                }
            }else {
                getPrinterHelper().undefineLine();
            }
        }else {
            this.printer.writeSeparator(";");
        }
        this.elementPrinterHelper.writeComment(m, spoon.reflect.visitor.printer.CommentOffset.AFTER);
    }

    @java.lang.Override
    public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {
        this.elementPrinterHelper.writeComment(annotationMethod);
        this.elementPrinterHelper.visitCtNamedElement(annotationMethod, this.sourceCompilationUnit);
        this.elementPrinterHelper.writeModifiers(annotationMethod);
        scan(annotationMethod.getType());
        this.printer.writeSpace();
        this.printer.writeIdentifier(annotationMethod.getSimpleName());
        this.printer.writeSeparator("(").writeSeparator(")");
        if ((annotationMethod.getDefaultExpression()) != null) {
            this.printer.writeSpace().writeKeyword("default").writeSpace();
            scan(annotationMethod.getDefaultExpression());
        }
        this.printer.writeSeparator(";");
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("rawtypes")
    public <T> void visitCtNewArray(spoon.reflect.code.CtNewArray<T> newArray) {
        enterCtExpression(newArray);
        boolean isNotInAnnotation;
        try {
            isNotInAnnotation = ((newArray.getParent(spoon.reflect.declaration.CtAnnotationType.class)) == null) && ((newArray.getParent(spoon.reflect.declaration.CtAnnotation.class)) == null);
        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {
            isNotInAnnotation = true;
        }
        if (isNotInAnnotation) {
            spoon.reflect.reference.CtTypeReference<?> ref = newArray.getType();
            if (ref != null) {
                this.printer.writeKeyword("new").writeSpace();
            }
            try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify().skipArray(true)) {
                scan(ref);
            }
            for (int i = 0; ref instanceof spoon.reflect.reference.CtArrayTypeReference; i++) {
                this.printer.writeSeparator("[");
                if ((newArray.getDimensionExpressions().size()) > i) {
                    spoon.reflect.code.CtExpression<java.lang.Integer> e = newArray.getDimensionExpressions().get(i);
                    scan(e);
                }
                this.printer.writeSeparator("]");
                ref = ((spoon.reflect.reference.CtArrayTypeReference) (ref)).getComponentType();
            }
        }
        if (newArray.getDimensionExpressions().isEmpty()) {
            this.elementPrinterHelper.printList(newArray.getElements(), null, false, "{", true, false, ",", true, true, "}", ( e) -> scan(e));
            this.elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.INSIDE);
        }
        this.elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.AFTER);
        exitCtExpression(newArray);
    }

    @java.lang.Override
    public <T> void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {
        enterCtStatement(ctConstructorCall);
        enterCtExpression(ctConstructorCall);
        printConstructorCall(ctConstructorCall);
        exitCtExpression(ctConstructorCall);
        exitCtStatement(ctConstructorCall);
    }

    @java.lang.Override
    public <T> void visitCtNewClass(spoon.reflect.code.CtNewClass<T> newClass) {
        enterCtStatement(newClass);
        enterCtExpression(newClass);
        printConstructorCall(newClass);
        scan(newClass.getAnonymousClass());
        exitCtExpression(newClass);
        exitCtStatement(newClass);
    }

    private <T> void printConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {
        try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify()) {
            if ((ctConstructorCall.getTarget()) != null) {
                scan(ctConstructorCall.getTarget());
                this.printer.writeSeparator(".");
                _context.ignoreEnclosingClass(true);
            }
            if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {
                _context.ignoreEnclosingClass(true);
            }
            this.printer.writeKeyword("new").writeSpace();
            if (!(ctConstructorCall.getActualTypeArguments().isEmpty())) {
                this.elementPrinterHelper.writeActualTypeArguments(ctConstructorCall);
            }
            scan(ctConstructorCall.getType());
        }
        this.elementPrinterHelper.printList(ctConstructorCall.getArguments(), null, false, "(", false, false, ",", true, false, ")", ( exp) -> scan(exp));
    }

    /**
    JDT doesn't support <code>new Foo<K>.Bar()</code>. To avoid reprinting this kind of type reference,
    we check that the reference has a declaring type with generics.
    See https://bugs.eclipse.org/bugs/show_bug.cgi?id=474593

    @param reference Type reference concerned by the bug.
    @return true if a declaring type has generic types.
     *
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     * @param reference * 		Type reference concerned by the bug.
     * @return true if a declaring type has generic types.
     */
    private <T> boolean hasDeclaringTypeWithGenerics(spoon.reflect.reference.CtTypeReference<T> reference) {
        // We don't have a declaring type, it can't have generics.
        if (reference == null) {
            return false;
        }
        // If the declaring type isn't a type, we don't need this hack.
        if ((reference.getDeclaringType()) == null) {
            return false;
        }
        // If current reference is a class declared in a method, we don't need this hack.
        if (reference.isLocalType()) {
            return false;
        }
        // If declaring type have generics, we return true.
        if (!(reference.getDeclaringType().getActualTypeArguments().isEmpty())) {
            return true;
        }
        // Checks if the declaring type has generic types.
        return hasDeclaringTypeWithGenerics(reference.getDeclaringType());
    }

    @java.lang.Override
    public <T> void visitCtLambda(spoon.reflect.code.CtLambda<T> lambda) {
        enterCtExpression(lambda);
        this.elementPrinterHelper.printList(lambda.getParameters(), null, false, "(", false, false, ",", false, false, ")", ( parameter) -> scan(parameter));
        this.printer.writeSpace();
        this.printer.writeSeparator("->");
        this.printer.writeSpace();
        if ((lambda.getBody()) != null) {
            scan(lambda.getBody());
        }else {
            scan(lambda.getExpression());
        }
        exitCtExpression(lambda);
    }

    @java.lang.Override
    public <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {
        enterCtExpression(expression);
        try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify()) {
            if (expression.getExecutable().isStatic()) {
                _context.ignoreGenerics(true);
            }
            scan(expression.getTarget());
        }
        this.printer.writeSeparator("::");
        if (expression.getExecutable().isConstructor()) {
            this.printer.writeKeyword("new");
        }else {
            this.printer.writeIdentifier(expression.getExecutable().getSimpleName());
        }
        exitCtExpression(expression);
    }

    @java.lang.Override
    public <T, A extends T> void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {
        enterCtStatement(assignment);
        enterCtExpression(assignment);
        scan(assignment.getAssigned());
        this.printer.writeSpace();
        // the operators like +=, *= are sent as one operator token
        this.printer.writeOperator(((spoon.reflect.visitor.OperatorHelper.getOperatorText(assignment.getKind())) + "="));
        this.printer.writeSpace();
        scan(assignment.getAssignment());
        exitCtExpression(assignment);
        exitCtStatement(assignment);
    }

    @java.lang.Override
    public void visitCtPackage(spoon.reflect.declaration.CtPackage ctPackage) {
        if (!(ctPackage.isUnnamedPackage())) {
            this.elementPrinterHelper.writePackageLine(ctPackage.getQualifiedName());
        }else {
            this.printer.writeComment(ctPackage.getFactory().createComment("default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon= unnamed package)", spoon.reflect.code.CtComment.CommentType.INLINE)).writeln();
        }
    }

    @java.lang.Override
    public void visitCtPackageReference(spoon.reflect.reference.CtPackageReference reference) {
        this.elementPrinterHelper.writeQualifiedName(reference.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtParameter(spoon.reflect.declaration.CtParameter<T> parameter) {
        this.elementPrinterHelper.writeComment(parameter);
        this.elementPrinterHelper.writeAnnotations(parameter);
        this.elementPrinterHelper.writeModifiers(parameter);
        if (parameter.isVarArgs()) {
            scan(((spoon.reflect.reference.CtArrayTypeReference<T>) (parameter.getType())).getComponentType());
            this.printer.writeSeparator("...");
        }else {
            scan(parameter.getType());
        }
        this.printer.writeSpace();
        this.printer.writeIdentifier(parameter.getSimpleName());
    }

    @java.lang.Override
    public <T> void visitCtParameterReference(spoon.reflect.reference.CtParameterReference<T> reference) {
        this.printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public <R> void visitCtReturn(spoon.reflect.code.CtReturn<R> returnStatement) {
        enterCtStatement(returnStatement);
        this.printer.writeKeyword("return");
        // checkstyle wants "return;" and not "return ;"
        if ((returnStatement.getReturnedExpression()) != null) {
            this.printer.writeSpace();
        }
        scan(returnStatement.getReturnedExpression());
        exitCtStatement(returnStatement);
    }

    private <T> void visitCtType(spoon.reflect.declaration.CtType<T> type) {
        this.elementPrinterHelper.writeComment(type, spoon.reflect.visitor.printer.CommentOffset.BEFORE);
        getPrinterHelper().mapLine(type, this.sourceCompilationUnit);
        if (type.isTopLevel()) {
            this.context.currentTopLevel = type;
        }
        this.elementPrinterHelper.visitCtNamedElement(type, this.sourceCompilationUnit);
        this.elementPrinterHelper.writeModifiers(type);
    }

    @java.lang.Override
    public void visitCtStatementList(spoon.reflect.code.CtStatementList statements) {
        for (spoon.reflect.code.CtStatement s : statements.getStatements()) {
            scan(s);
        }
    }

    @java.lang.Override
    public <E> void visitCtSwitch(spoon.reflect.code.CtSwitch<E> switchStatement) {
        enterCtStatement(switchStatement);
        this.printer.writeKeyword("switch").writeSpace().writeSeparator("(");
        scan(switchStatement.getSelector());
        this.printer.writeSeparator(")").writeSpace().writeSeparator("{").incTab();
        for (spoon.reflect.code.CtCase<?> c : switchStatement.getCases()) {
            this.printer.writeln();
            scan(c);
        }
        if (this.env.isPreserveLineNumbers()) {
            this.printer.decTab().writeSeparator("}");
        }else {
            this.printer.decTab().writeln().writeSeparator("}");
        }
        exitCtStatement(switchStatement);
    }

    @java.lang.Override
    public void visitCtSynchronized(spoon.reflect.code.CtSynchronized synchro) {
        enterCtStatement(synchro);
        this.printer.writeKeyword("synchronized");
        if ((synchro.getExpression()) != null) {
            this.printer.writeSeparator("(");
            scan(synchro.getExpression());
            this.printer.writeSeparator(")").writeSpace();
        }
        scan(synchro.getBlock());
        exitCtStatement(synchro);
    }

    @java.lang.Override
    public void visitCtThrow(spoon.reflect.code.CtThrow throwStatement) {
        enterCtStatement(throwStatement);
        this.printer.writeKeyword("throw").writeSpace();
        scan(throwStatement.getThrownExpression());
        exitCtStatement(throwStatement);
    }

    @java.lang.Override
    public void visitCtTry(spoon.reflect.code.CtTry tryBlock) {
        enterCtStatement(tryBlock);
        this.printer.writeKeyword("try").writeSpace();
        scan(tryBlock.getBody());
        for (spoon.reflect.code.CtCatch c : tryBlock.getCatchers()) {
            scan(c);
        }
        if ((tryBlock.getFinalizer()) != null) {
            this.printer.writeSpace().writeKeyword("finally").writeSpace();
            scan(tryBlock.getFinalizer());
        }
        exitCtStatement(tryBlock);
    }

    @java.lang.Override
    public void visitCtTryWithResource(spoon.reflect.code.CtTryWithResource tryWithResource) {
        enterCtStatement(tryWithResource);
        this.printer.writeKeyword("try").writeSpace();
        if (((tryWithResource.getResources()) != null) && (!(tryWithResource.getResources().isEmpty()))) {
            this.elementPrinterHelper.printList(tryWithResource.getResources(), null, false, "(", false, false, ";", false, false, ")", ( r) -> scan(r));
        }
        this.printer.writeSpace();
        scan(tryWithResource.getBody());
        for (spoon.reflect.code.CtCatch c : tryWithResource.getCatchers()) {
            scan(c);
        }
        if ((tryWithResource.getFinalizer()) != null) {
            this.printer.writeSpace().writeKeyword("finally").writeSpace();
            scan(tryWithResource.getFinalizer());
        }
        exitCtStatement(tryWithResource);
    }

    @java.lang.Override
    public void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {
        if (ref.isImplicit()) {
            return;
        }
        this.elementPrinterHelper.writeAnnotations(ref);
        if (printQualified(ref)) {
            this.elementPrinterHelper.writeQualifiedName(ref.getQualifiedName());
        }else {
            this.printer.writeIdentifier(ref.getSimpleName());
        }
    }

    @java.lang.Override
    public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {
        if (wildcardReference.isImplicit()) {
            return;
        }
        this.elementPrinterHelper.writeAnnotations(wildcardReference);
        this.printer.writeSeparator("?");
        // we ignore printing "extends Object" except if it's explicit
        if ((!(wildcardReference.isDefaultBoundingType())) || (!(wildcardReference.getBoundingType().isImplicit()))) {
            if (wildcardReference.isUpper()) {
                this.printer.writeSpace().writeKeyword("extends").writeSpace();
            }else {
                this.printer.writeSpace().writeKeyword("super").writeSpace();
            }
            scan(wildcardReference.getBoundingType());
        }
    }

    private boolean printQualified(spoon.reflect.reference.CtTypeReference<?> ref) {
        // or that we are in java.lang
        if ((this.importsContext.isImported(ref))// If my.pkg.Something is imported
         || (((this.env.isAutoImports()) && ((ref.getPackage()) != null)) && ("java.lang".equals(ref.getPackage().getSimpleName())))) {
            for (spoon.reflect.visitor.CacheBasedConflictFinder typeContext : this.context.currentThis) {
                // A) we are in the context of a class which is also called "Something",
                if ((typeContext.getSimpleName().equals(ref.getSimpleName())) && (!(java.util.Objects.equals(typeContext.getPackage(), ref.getPackage())))) {
                    return true;
                }
                // B) we are in the context of a class which defines field which is also called "Something",
                // we should still use qualified version my.pkg.Something
                // fix of #2369
                if ((typeContext.hasFieldConflict(ref.getSimpleName())) || (typeContext.hasNestedTypeConflict(ref.getSimpleName()))) {
                    return true;
                }
            }
            return false;
        }else {
            return true;
        }
    }

    @java.lang.Override
    public <T> void visitCtIntersectionTypeReference(spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {
        this.elementPrinterHelper.printList(reference.getBounds(), null, false, null, false, true, "&", true, false, null, ( bound) -> scan(bound));
    }

    @java.lang.Override
    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> ref) {
        visitCtTypeReference(ref, true);
    }

    @java.lang.Override
    public <T> void visitCtTypeAccess(spoon.reflect.code.CtTypeAccess<T> typeAccess) {
        if (typeAccess.isImplicit()) {
            return;
        }
        enterCtExpression(typeAccess);
        scan(typeAccess.getAccessedType());
        exitCtExpression(typeAccess);
    }

    private void visitCtTypeReferenceWithoutGenerics(spoon.reflect.reference.CtTypeReference<?> ref) {
        visitCtTypeReference(ref, false);
    }

    private void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<?> ref, boolean withGenerics) {
        if (ref.isImplicit()) {
            return;
        }
        if (ref.isPrimitive()) {
            this.elementPrinterHelper.writeAnnotations(ref);
            this.printer.writeKeyword(ref.getSimpleName());
            return;
        }
        boolean isInner = (ref.getDeclaringType()) != null;
        if (isInner) {
            if ((!(this.context.ignoreEnclosingClass())) && (!(ref.isLocalType()))) {
                // compute visible type which can be used to print access path to ref
                spoon.reflect.reference.CtTypeReference<?> accessType = ref.getAccessType();
                if (!(accessType.isAnonymous())) {
                    try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify()) {
                        if (!withGenerics) {
                            _context.ignoreGenerics(true);
                        }
                        scan(accessType);
                    }
                    this.printer.writeSeparator(".");
                }
            }
            // ?? are these annotations on correct place ??
            this.elementPrinterHelper.writeAnnotations(ref);
            if (ref.isLocalType()) {
                this.printer.writeIdentifier(ref.getSimpleName().replaceAll("^[0-9]*", ""));
            }else {
                this.printer.writeIdentifier(ref.getSimpleName());
            }
        }else {
            if (((ref.getPackage()) != null) && (printQualified(ref))) {
                if (!(ref.getPackage().isUnnamedPackage())) {
                    scan(ref.getPackage());
                    this.printer.writeSeparator(spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);
                }
            }
            this.elementPrinterHelper.writeAnnotations(ref);
            this.printer.writeIdentifier(ref.getSimpleName());
        }
        if (withGenerics && (!(this.context.ignoreGenerics()))) {
            try (final spoon.reflect.visitor.PrintingContext.Writable _context = this.context.modify().ignoreEnclosingClass(false)) {
                this.elementPrinterHelper.writeActualTypeArguments(ref);
            }
        }
    }

    @java.lang.Override
    public <T> void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator<T> operator) {
        enterCtStatement(operator);
        enterCtExpression(operator);
        spoon.reflect.code.UnaryOperatorKind op = operator.getKind();
        if (spoon.reflect.visitor.OperatorHelper.isPrefixOperator(op)) {
            this.printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(op));
        }
        scan(operator.getOperand());
        if (spoon.reflect.visitor.OperatorHelper.isSufixOperator(op)) {
            this.printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(op));
        }
        exitCtExpression(operator);
        exitCtStatement(operator);
    }

    @java.lang.Override
    public <T> void visitCtVariableRead(spoon.reflect.code.CtVariableRead<T> variableRead) {
        enterCtExpression(variableRead);
        this.printer.writeIdentifier(variableRead.getVariable().getSimpleName());
        exitCtExpression(variableRead);
    }

    @java.lang.Override
    public <T> void visitCtVariableWrite(spoon.reflect.code.CtVariableWrite<T> variableWrite) {
        enterCtExpression(variableWrite);
        this.printer.writeIdentifier(variableWrite.getVariable().getSimpleName());
        exitCtExpression(variableWrite);
    }

    @java.lang.Override
    public void visitCtWhile(spoon.reflect.code.CtWhile whileLoop) {
        enterCtStatement(whileLoop);
        this.printer.writeKeyword("while").writeSpace().writeSeparator("(");
        scan(whileLoop.getLoopingExpression());
        this.printer.writeSeparator(")");
        this.elementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());
        exitCtStatement(whileLoop);
    }

    @java.lang.Override
    public <T> void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression<T> expression) {
        this.elementPrinterHelper.writeComment(expression);
        this.printer.writeCodeSnippet(expression.getValue());
    }

    @java.lang.Override
    public void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement statement) {
        enterCtStatement(statement);
        this.printer.writeCodeSnippet(statement.getValue());
        exitCtStatement(statement);
    }

    public spoon.reflect.visitor.ElementPrinterHelper getElementPrinterHelper() {
        return this.elementPrinterHelper;
    }

    public spoon.reflect.visitor.PrintingContext getContext() {
        return this.context;
    }

    @java.lang.Override
    public <T> void visitCtUnboundVariableReference(spoon.reflect.reference.CtUnboundVariableReference<T> reference) {
        this.printer.writeIdentifier(reference.getSimpleName());
    }

    @java.lang.Override
    public java.lang.String printPackageInfo(spoon.reflect.declaration.CtPackage pack) {
        reset();
        this.elementPrinterHelper.writeComment(pack);
        // we need to compute imports only for annotations
        // we don't want to get all imports coming from content of package
        for (spoon.reflect.declaration.CtAnnotation annotation : pack.getAnnotations()) {
            this.importsContext.computeImports(annotation);
        }
        this.elementPrinterHelper.writeAnnotations(pack);
        if (!(pack.isUnnamedPackage())) {
            this.elementPrinterHelper.writePackageLine(pack.getQualifiedName());
        }
        this.elementPrinterHelper.writeImports(this.importsContext.getAllImports());
        return this.printer.getPrinterHelper().toString();
    }

    @java.lang.Override
    public java.lang.String printModuleInfo(spoon.reflect.declaration.CtModule module) {
        reset();
        scan(module);
        return this.getResult();
    }

    @java.lang.Override
    public java.lang.String getResult() {
        return this.printer.getPrinterHelper().toString();
    }

    private void reset() {
        this.printer.reset();
        this.context = new spoon.reflect.visitor.PrintingContext();
        if (this.env.isAutoImports()) {
            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();
        }else {
            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();
        }
    }

    /**
    Write the compilation unit header.
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter writeHeader(java.util.List<spoon.reflect.declaration.CtType<?>> types, java.util.Collection<spoon.reflect.declaration.CtImport> imports) {
        this.elementPrinterHelper.writeHeader(types, imports);
        return this;
    }

    /**
    Write the compilation unit footer.
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter writeFooter(java.util.List<spoon.reflect.declaration.CtType<?>> types) {
        this.elementPrinterHelper.writeFooter(types);
        return this;
    }

    @java.lang.Override
    public void calculate(spoon.reflect.cu.CompilationUnit sourceCompilationUnit, java.util.List<spoon.reflect.declaration.CtType<?>> types) {
        // reset the importsContext to avoid errors with multiple CU
        reset();
        this.sourceCompilationUnit = sourceCompilationUnit;
        this.imports = new java.util.HashSet<>();
        if (sourceCompilationUnit != null) {
            this.importsContext.initWithImports(sourceCompilationUnit.getImports());
        }
        for (spoon.reflect.declaration.CtType<?> t : types) {
            this.imports.addAll(computeImports(t));
        }
        this.writeHeader(types, this.imports);
        printTypes(types);
    }

    protected void printTypes(java.util.List<spoon.reflect.declaration.CtType<?>> types) {
        for (spoon.reflect.declaration.CtType<?> t : types) {
            scan(t);
            if (!(this.env.isPreserveLineNumbers())) {
                // saving lines and chars
                this.printer.writeln().writeln();
            }else {
                getPrinterHelper().adjustEndPosition(t);
            }
        }
        this.writeFooter(types);
    }

    @java.lang.Override
    public java.util.Map<java.lang.Integer, java.lang.Integer> getLineNumberMapping() {
        return getPrinterHelper().getLineNumberMapping();
    }

    /**
     *
     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too
     */
    protected spoon.reflect.visitor.TokenWriter getPrinterTokenWriter() {
        return this.printer;
    }

    /**
    Set {@link TokenWriter}, which has to be used to print tokens
     */
    public spoon.reflect.visitor.DefaultJavaPrettyPrinter setPrinterTokenWriter(spoon.reflect.visitor.TokenWriter tokenWriter) {
        this.elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(tokenWriter, this, this.env);
        this.printer = tokenWriter;
        return this;
    }

    private spoon.reflect.visitor.PrinterHelper getPrinterHelper() {
        return this.printer.getPrinterHelper();
    }
}>
[ERROR]   SpoonArchitectureEnforcerTest.testSpecPackage:428->assertSetEquals:437 you have created a new package or removed an existing one, please declare it explicitly in SpoonArchitectureEnforcerTest#testSpecPackage

Details: Package spoon.support.javadoc presents in computed but not expected set.
[ERROR]   SpoonArchitectureEnforcerTest.testSrcMainJava:191 6 public methods should be documented with proper API documentation: 
spoon.reflect.visitor.CommentHelper#printComment(spoon.reflect.visitor.PrinterHelper,spoon.reflect.code.CtComment)
spoon.support.javadoc.Javadoc#parse(java.lang.String)
spoon.support.javadoc.JavadocBlockTag#toText()
spoon.support.javadoc.JavadocDescription#parseText(java.lang.String)
spoon.support.javadoc.JavadocDescriptionElement#toText()
spoon.support.javadoc.JavadocInlineTag#fromText(java.lang.String)
[ERROR]   CommentTest.testCombinedPackageInfoComment:128 expected:<...omment2
/**
Comment3[] */
@java.lang.Depre...> but was:<...omment2
/**
Comment3[
] */
@java.lang.Depre...>
[ERROR]   CommentTest.testCommentsInResourcesWithWindowsEOL:900 expected:<...ed well
in this case[]> but was:<...ed well
in this case[

@author pvojtechovsky
]>
[ERROR]   CommentTest.testDocumentationContract:850 doc outdated, please commit doc/code_elements.md expected:<...va

/**
Description
[@see 
		]a tag in the javadoc...> but was:<...va

/**
Description
[
@see ]a tag in the javadoc...>
[ERROR]   CommentTest.testEnumValueComment:943 expected:<...ing the other modes.[]> but was:<...ing the other modes.[
]>
[ERROR]   CommentTest.testJavaDocCommentOnMac:178->testJavaDocComment:185 expected:<...s.

Long description[]> but was:<...s.

Long description[

@deprecated
@since 1.3
@author Thomas Durieux
@version 1.0
]>
[ERROR]   CommentTest.testJavaDocCommentOnUnix:153->testJavaDocComment:185 expected:<...s.

Long description[]> but was:<...s.

Long description[

@deprecated
@since 1.3
@author Thomas Durieux
@version 1.0
]>
[ERROR]   CommentTest.testJavaDocEmptyCommentAndTag:243 expected:<[]> but was:<[
@author there is tag, but there is no comment
]>
[ERROR]   CommentTest.testSnippedWithComments:724 expected:<...thod javadoc comment[]> but was:<...thod javadoc comment[
]>
[ERROR]   CommentTest.testWildComments:919 (/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/comment/testclasses/WildComments.java:85) expected:<*[]> but was:<*[
]>
[ERROR]   EnumsTest.testPrintEnumValues:157
[ERROR]   ImportScannerTest.testImportOnSpoon:178 Import scanner missed 11 imports expected:<0> but was:<11>
[ERROR]   JavaDocTest.testJavaDocReprint:48 expected:<...s Bar {
    /**
    [ * Creates an annotation type.
     *
     * @param owner
     * 		the package of the annotation type
     * @param simpleName
    ] * 		the name of ann...> but was:<...s Bar {
    /**
    [Creates an annotation type.

    @param owner the package of the annotation type
    @param simpleName the name of annotation
     *
     * @param owner * 		the package of the annotation type
     * @param simpleName * 		the name of annotation
     * @param owner * 		the package of the annotation type
     * @param simpleName * 		the name of annotation
     * @param owner * 		the package of the annotation type
     * @param simpleName * 		the name of annotation
     * @param owner * 		the package of the annotation type
     * @param simpleName * 		the name of annotation
     * @param owner * 		the package of the annotation type
     * @param simpleName] * 		the name of ann...>
[ERROR]   TestModule.testModuleInfoWithComments:219 expected:<...e of the application[]> but was:<...e of the application[
]>
[ERROR]   PackageTest.testPackage:87 expected:<...his is test
JavaDoc.[]> but was:<...his is test
JavaDoc.[
]>
[ERROR]   TestSniperPrinter.testPrintAfterAddOfLastTypeMember:141->testSniper:192->lambda$testPrintAfterAddOfLastTypeMember$17:148->assertIsPrintedWithExpectedChanges:245 expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again ]
 */
public
@Depreca...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again]
 */
public
@Depreca...>
[ERROR]   TestSniperPrinter.testPrintAfterRemoveOfFirstParameter:92->testSniper:192->lambda$testPrintAfterRemoveOfFirstParameter$9:96->assertIsPrintedWithExpectedChanges:245 expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again ]
 */
public
@Depreca...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again]
 */
public
@Depreca...>
[ERROR]   TestSniperPrinter.testPrintAfterRemoveOfFormalTypeParamsAndChangeOfReturnType:155->testSniper:192->lambda$testPrintAfterRemoveOfFormalTypeParamsAndChangeOfReturnType$19:162->assertIsPrintedWithExpectedChanges:245 expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again ]
 */
public
@Depreca...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again]
 */
public
@Depreca...>
[ERROR]   TestSniperPrinter.testPrintAfterRemoveOfLastParameter:114->testSniper:192->lambda$testPrintAfterRemoveOfLastParameter$13:118->assertIsPrintedWithExpectedChanges:245 expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again ]
 */
public
@Depreca...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again]
 */
public
@Depreca...>
[ERROR]   TestSniperPrinter.testPrintAfterRemoveOfLastTypeMember:125->testSniper:192->lambda$testPrintAfterRemoveOfLastTypeMember$15:129->assertIsPrintedWithExpectedChanges:245 expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again ]
 */
public
@Depreca...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again]
 */
public
@Depreca...>
[ERROR]   TestSniperPrinter.testPrintAfterRemoveOfMiddleParameter:103->testSniper:192->lambda$testPrintAfterRemoveOfMiddleParameter$11:107->assertIsPrintedWithExpectedChanges:245 expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again ]
 */
public
@Depreca...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again]
 */
public
@Depreca...>
[ERROR]   TestSniperPrinter.testPrintAfterRenameOfField:61->testSniper:192->lambda$testPrintAfterRenameOfField$3:66->assertIsPrintedWithExpectedChanges:245 expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again ]
 */
public
@Depreca...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again]
 */
public
@Depreca...>
[ERROR]   TestSniperPrinter.testPrintUnchaged:51->testSniper:192->lambda$testPrintUnchaged$1:54->assertIsPrintedWithExpectedChanges:245 expected:</**
[ * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again 
 */
public
@Deprecated
abstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged<T, K> /*before extends*/ 
	extends ArrayList<T /* let's confuse > it */ > implements List<T>,
	Cloneable
{
	
	
	/**/
	final
	//
	private String string = "a"
			+ "b" + "c"+"d";
	
	//and spaces here are wanted too
	
	
	public <T, K> void andSomeOtherMethod(
			int param1,
			String param2         , List<?>[][] ... twoDArrayOfLists)
	{/**/
		System.out.println("aaa"
				+ "xyz");
	/*x*/}
	List<?>[][] twoDArrayOfLists = new List<?>[7][];
}

]//and what about thi...> but was:</**
[The content of this file 


		should not be changed
Because DJPP should print only modified content again
 */
public
@Deprecated
abstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged<T, K> /*before extends*/ 
	extends ArrayList<T /* let's confuse > it */ > implements List<T>,
	Cloneable
{
	
	
	/**/
	final
	//
	private String string = "a"
			+ "b" + "c"+"d";
	
	//and spaces here are wanted too
	
	
	public <T, K> void andSomeOtherMethod(
			int param1,
			String param2         , List<?>[][] ... twoDArrayOfLists)
	{/**/
		System.out.println("aaa"
				+ "xyz");
	/*x*/}
	List<?>[][] twoDArrayOfLists = new List<?>[7][];
}

	]//and what about thi...>
[ERROR]   ModelStreamerTest.testDefaultCompressionType:61->compareFactoryModels:90 Model before & after serialization must have the same number of elements
[ERROR]   ModelStreamerTest.testGZipCompressionType:69->compareFactoryModels:90 Model before & after serialization must have the same number of elements
[ERROR]   ModelStreamerTest.testNoneCompressionType:77->compareFactoryModels:90 Model before & after serialization must have the same number of elements
[ERROR] Errors: 
[ERROR]   CtGenerationTest.testGenerateCloneVisitor:151  Spoon Get more than one setter...
[ERROR]   CtClassTest.testDefaultConstructorAreOk:219  ModelBuilding Syntax error on to...
[INFO] 
[ERROR] Tests run: 1574, Failures: 28, Errors: 2, Skipped: 6
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 06:47 min
[INFO] Finished at: 2018-10-13T16:24:16+02:00
[INFO] Final Memory: 23M/511M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.21.0:test (default-test) on project spoon-core: There are test failures.
[ERROR] 
[ERROR] Please refer to /root/workspace/INRIA/spoon/441002125/target/surefire-reports for the individual test results.
[ERROR] Please refer to dump files (if any exist) [date]-jvmRun[N].dump, [date].dumpstream and [date]-jvmRun[N].dumpstream.
[ERROR] -> [Help 1]
[ERROR] 
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
