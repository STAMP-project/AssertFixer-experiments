import { Injectable, NgModule } from '@angular/core';
import { Actions, Effect, EffectsModule, ofType } from '@ngrx/effects';
import { tap } from 'rxjs/operators';
import { CommonModule, Location } from '@angular/common';
import { Observable as Observable$1 } from 'rxjs/Observable';
import { Router } from '@angular/router';
import { RouterStateSerializer } from '@ngrx/router-store';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {string} */
const LocationActions = {
    go: '[Location] go',
    forward: '[Location] forward',
    back: '[Location] back',
};
class LocationGoAction {
    /**
     * @param {?} path
     * @param {?=} query
     */
    constructor(path, query) {
        this.path = path;
        this.query = query;
        this.type = LocationActions.go;
    }
}
class LocationForwardAction {
    constructor() {
        this.type = LocationActions.forward;
    }
}
class LocationBackAction {
    constructor() {
        this.type = LocationActions.back;
    }
}

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LocationEffects {
    /**
     * @param {?} actions$
     * @param {?} location
     */
    constructor(actions$, location) {
        this.actions$ = actions$;
        this.location = location;
        this.go$ = this.actions$
            .pipe(ofType(LocationActions.go), tap(({ path, query }) => this.location.go(path, query)));
        this.forward$ = this.actions$
            .pipe(ofType(LocationActions.forward), tap(() => this.location.forward()));
        this.back$ = this.actions$
            .pipe(ofType(LocationActions.back), tap(() => this.location.back()));
    }
}
LocationEffects.decorators = [
    { type: Injectable },
];
/** @nocollapse */
LocationEffects.ctorParameters = () => [
    { type: Actions, },
    { type: Location, },
];
__decorate([
    Effect({ dispatch: false }),
    __metadata("design:type", Observable$1)
], LocationEffects.prototype, "go$", void 0);
__decorate([
    Effect({ dispatch: false }),
    __metadata("design:type", Observable$1)
], LocationEffects.prototype, "forward$", void 0);
__decorate([
    Effect({ dispatch: false }),
    __metadata("design:type", Observable$1)
], LocationEffects.prototype, "back$", void 0);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LocationStoreHelperModule {
}
LocationStoreHelperModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    EffectsModule.forFeature([LocationEffects])
                ],
                exports: [EffectsModule]
            },] },
];
/** @nocollapse */
LocationStoreHelperModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

class SimpleRouterStateSerializer {
    /**
     * @param {?} routerState
     * @return {?}
     */
    serialize(routerState) {
        let /** @type {?} */ route = routerState.root;
        while (route.firstChild) {
            route = route.firstChild;
        }
        const { url, root: { queryParams } } = routerState;
        const { params } = route;
        return { url, params, queryParams };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {string} */
const RouterActions = {
    navigate: '[Router] navigate',
    navigateByUrl: '[Router] navigateByUrl',
};
class RouterNavigateAction {
    /**
     * @param {?} commands
     * @param {?=} extras
     */
    constructor(commands, extras) {
        this.commands = commands;
        this.extras = extras;
        this.type = RouterActions.navigate;
    }
}
class RouterNavigateByUrlAction {
    /**
     * @param {?} url
     * @param {?=} extras
     */
    constructor(url, extras) {
        this.url = url;
        this.extras = extras;
        this.type = RouterActions.navigateByUrl;
    }
}

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class RouterEffects {
    /**
     * @param {?} actions$
     * @param {?} router
     */
    constructor(actions$, router$$1) {
        this.actions$ = actions$;
        this.router = router$$1;
        this.navigate$ = this.actions$
            .pipe(ofType(RouterActions.navigate), tap(({ commands, extras }) => this.router.navigate(commands, extras)));
        this.navigateByUrl$ = this.actions$
            .pipe(ofType(RouterActions.navigateByUrl), tap(({ url, extras }) => this.router.navigateByUrl(url, extras)));
    }
}
RouterEffects.decorators = [
    { type: Injectable },
];
/** @nocollapse */
RouterEffects.ctorParameters = () => [
    { type: Actions, },
    { type: Router, },
];
__decorate$1([
    Effect({ dispatch: false }),
    __metadata$1("design:type", Observable$1)
], RouterEffects.prototype, "navigate$", void 0);
__decorate$1([
    Effect({ dispatch: false }),
    __metadata$1("design:type", Observable$1)
], RouterEffects.prototype, "navigateByUrl$", void 0);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class RouterStoreHelperModule {
}
RouterStoreHelperModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    EffectsModule.forFeature([RouterEffects])
                ],
                providers: [
                    { provide: RouterStateSerializer, useClass: SimpleRouterStateSerializer }
                ],
                exports: [EffectsModule]
            },] },
];
/** @nocollapse */
RouterStoreHelperModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { LocationActions, LocationGoAction, LocationForwardAction, LocationBackAction, LocationEffects, LocationStoreHelperModule, SimpleRouterStateSerializer, RouterActions, RouterNavigateAction, RouterNavigateByUrlAction, RouterEffects, RouterStoreHelperModule };
