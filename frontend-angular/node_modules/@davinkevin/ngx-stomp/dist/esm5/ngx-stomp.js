import { Inject, Injectable, InjectionToken, NgModule } from '@angular/core';
import { Observable as Observable$1 } from 'rxjs/Observable';
import { concatMap, map, publishReplay } from 'rxjs/operators';
import { DOCUMENT } from '@angular/common';
import * as StompJS from 'stompjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var STOMP_CONFIGURATION = new InjectionToken('STOMP_CONFIGURATION');
/**
 * @record
 */

var STOMP_JS = new InjectionToken('STOMP_JS');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

var StompService = (function () {
    function StompService(conf, stomp, document) {
        this.conf = conf;
        this.stomp = stomp;
        this.cl = initClient(stomp, this.conf.over, this.conf.url, document.location);
        this.cl.debug = initDebug(this.conf.debug);
        this.connection$ = initConnection(this.cl, this.conf);
    }
    /**
     * @template T
     * @param {?} topic
     * @return {?}
     */
    StompService.prototype.on = /**
     * @template T
     * @param {?} topic
     * @return {?}
     */
    function (topic) {
        return this.connection$.pipe(onTopic(topic), toJSON());
    };
    StompService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    StompService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [STOMP_CONFIGURATION,] },] },
        { type: undefined, decorators: [{ type: Inject, args: [STOMP_JS,] },] },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
    ]; };
    return StompService;
}());
/**
 * @param {?} topic
 * @return {?}
 */
function onTopic(topic) {
    return concatMap(function (c) {
        return Observable$1.create(function (observer) {
            var /** @type {?} */ subscription = c.subscribe(topic, function (v) { return observer.next(v); }, {});
            return function () {
                subscription.unsubscribe();
            };
        });
    });
}
/**
 * @template T
 * @return {?}
 */
function toJSON() {
    return map(function (m) { return JSON.parse(m.body); });
}
/**
 * @param {?} stomp
 * @param {?} c
 * @param {?} url
 * @param {?} loc
 * @return {?}
 */
function initClient(stomp, c, url, loc) {
    if (c) {
        return stomp.over(c);
    }
    var /** @type {?} */ urlNormalized = normalizeUrl(url, loc);
    console.log(urlNormalized);
    return stomp.client(urlNormalized);
}
/**
 * @param {?} isActivated
 * @return {?}
 */
function initDebug(isActivated) {
    return isActivated ? console.log : function () { };
}
/**
 * @param {?} client
 * @param {?} config
 * @return {?}
 */
function initConnection(client, config) {
    var /** @type {?} */ c$ = Observable$1.create(function (obs) {
        client.connect(config.login, config.password, function () { return obs.next(client); }, function (e) { return obs.error(e); }, config.vhost);
    })
        .pipe(publishReplay(1));
    c$.connect();
    return c$;
}
/**
 * @param {?} url
 * @param {?} loc
 * @return {?}
 */
function normalizeUrl(url, loc) {
    if (url == null) {
        throw new Error('No url found for web-socket');
    }
    if (url.startsWith('/')) {
        return toWsProtocol(loc.protocol) + '//' + loc.hostname + ':' + loc.port + url;
    }
    try {
        return new URL(url).toString();
    }
    catch (/** @type {?} */ e) {
        console.error(e);
        throw new Error("Url with format " + url + " not handle for now. Should be complete or start with /");
    }
}
/**
 * @param {?} protocol
 * @return {?}
 */
function toWsProtocol(protocol) {
    return 'http:' === protocol ? 'ws:' : 'wss:';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @return {?}
 */
function stompJsFactory() {
    return StompJS;
}
var NgxStompModule = (function () {
    function NgxStompModule() {
    }
    /**
     * @param {?} config
     * @return {?}
     */
    NgxStompModule.withConfig = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        return {
            ngModule: NgxStompModule,
            providers: [
                { provide: STOMP_CONFIGURATION, useValue: config },
                { provide: STOMP_JS, useFactory: stompJsFactory },
                StompService
            ]
        };
    };
    NgxStompModule.decorators = [
        { type: NgModule, args: [{},] },
    ];
    /** @nocollapse */
    NgxStompModule.ctorParameters = function () { return []; };
    return NgxStompModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { stompJsFactory, NgxStompModule, StompService, STOMP_CONFIGURATION, STOMP_JS };
