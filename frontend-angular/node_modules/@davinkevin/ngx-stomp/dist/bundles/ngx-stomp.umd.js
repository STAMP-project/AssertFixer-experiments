(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/Observable'), require('rxjs/operators'), require('@angular/common'), require('stompjs')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/Observable', 'rxjs/operators', '@angular/common', 'stompjs'], factory) :
	(factory((global['ngx-stomp'] = {}),global.ng.core,global.Rx,global.Rx.operators,global.ng.common,global.stompjs));
}(this, (function (exports,core,Observable,operators,common,StompJS) { 'use strict';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var STOMP_CONFIGURATION = new core.InjectionToken('STOMP_CONFIGURATION');
/**
 * @record
 */

var STOMP_JS = new core.InjectionToken('STOMP_JS');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

var StompService = (function () {
    function StompService(conf, stomp, document) {
        this.conf = conf;
        this.stomp = stomp;
        this.cl = initClient(stomp, this.conf.over, this.conf.url, document.location);
        this.cl.debug = initDebug(this.conf.debug);
        this.connection$ = initConnection(this.cl, this.conf);
    }
    /**
     * @template T
     * @param {?} topic
     * @return {?}
     */
    StompService.prototype.on = /**
     * @template T
     * @param {?} topic
     * @return {?}
     */
    function (topic) {
        return this.connection$.pipe(onTopic(topic), toJSON());
    };
    StompService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    StompService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [STOMP_CONFIGURATION,] },] },
        { type: undefined, decorators: [{ type: core.Inject, args: [STOMP_JS,] },] },
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
    ]; };
    return StompService;
}());
/**
 * @param {?} topic
 * @return {?}
 */
function onTopic(topic) {
    return operators.concatMap(function (c) {
        return Observable.Observable.create(function (observer) {
            var /** @type {?} */ subscription = c.subscribe(topic, function (v) { return observer.next(v); }, {});
            return function () {
                subscription.unsubscribe();
            };
        });
    });
}
/**
 * @template T
 * @return {?}
 */
function toJSON() {
    return operators.map(function (m) { return JSON.parse(m.body); });
}
/**
 * @param {?} stomp
 * @param {?} c
 * @param {?} url
 * @param {?} loc
 * @return {?}
 */
function initClient(stomp, c, url, loc) {
    if (c) {
        return stomp.over(c);
    }
    var /** @type {?} */ urlNormalized = normalizeUrl(url, loc);
    console.log(urlNormalized);
    return stomp.client(urlNormalized);
}
/**
 * @param {?} isActivated
 * @return {?}
 */
function initDebug(isActivated) {
    return isActivated ? console.log : function () { };
}
/**
 * @param {?} client
 * @param {?} config
 * @return {?}
 */
function initConnection(client, config) {
    var /** @type {?} */ c$ = Observable.Observable.create(function (obs) {
        client.connect(config.login, config.password, function () { return obs.next(client); }, function (e) { return obs.error(e); }, config.vhost);
    })
        .pipe(operators.publishReplay(1));
    c$.connect();
    return c$;
}
/**
 * @param {?} url
 * @param {?} loc
 * @return {?}
 */
function normalizeUrl(url, loc) {
    if (url == null) {
        throw new Error('No url found for web-socket');
    }
    if (url.startsWith('/')) {
        return toWsProtocol(loc.protocol) + '//' + loc.hostname + ':' + loc.port + url;
    }
    try {
        return new URL(url).toString();
    }
    catch (/** @type {?} */ e) {
        console.error(e);
        throw new Error("Url with format " + url + " not handle for now. Should be complete or start with /");
    }
}
/**
 * @param {?} protocol
 * @return {?}
 */
function toWsProtocol(protocol) {
    return 'http:' === protocol ? 'ws:' : 'wss:';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @return {?}
 */
function stompJsFactory() {
    return StompJS;
}
var NgxStompModule = (function () {
    function NgxStompModule() {
    }
    /**
     * @param {?} config
     * @return {?}
     */
    NgxStompModule.withConfig = /**
     * @param {?} config
     * @return {?}
     */
    function (config) {
        return {
            ngModule: NgxStompModule,
            providers: [
                { provide: STOMP_CONFIGURATION, useValue: config },
                { provide: STOMP_JS, useFactory: stompJsFactory },
                StompService
            ]
        };
    };
    NgxStompModule.decorators = [
        { type: core.NgModule, args: [{},] },
    ];
    /** @nocollapse */
    NgxStompModule.ctorParameters = function () { return []; };
    return NgxStompModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

exports.stompJsFactory = stompJsFactory;
exports.NgxStompModule = NgxStompModule;
exports.StompService = StompService;
exports.STOMP_CONFIGURATION = STOMP_CONFIGURATION;
exports.STOMP_JS = STOMP_JS;

Object.defineProperty(exports, '__esModule', { value: true });

})));
