{
  "bugType": "only_fail",
  "hostname": "cyclone1",
  "repo": "INRIA/spoon",
  "metrics": {
    "FailureNames": [
      "spoon.SpoonException",
      "java.lang.AssertionError",
      "org.junit.ComparisonFailure",
      "spoon.compiler.ModelBuildingException"
    ],
    "StepsDurationsInSeconds": {
      "CheckoutBuggyBuild": 5,
      "ComputeClasspath": 7,
      "ComputeTestDir": 0,
      "BuildProject": 75,
      "InitRepoToPush": 5,
      "ComputeSourceDir": 0,
      "ComputeModules": 0,
      "CloneRepository": 9,
      "CheckoutPatchedBuild": 0,
      "TestProject": 410,
      "AssertFixer": 27,
      "GatherTestInformation": 0,
      "CommitPatch": 3
    },
    "NbFailingTests": 28,
    "NbErroringTests": 2,
    "NbSkippingTests": 6,
    "NbRunningTests": 1568,
    "BugCommitUrl": "http://github.com/INRIA/spoon/commit/7042f76fac6edf0d6281713bdffa6ecbc5dc5a45",
    "ReproductionDate": "Oct 13, 2018 4:15:57 PM",
    "BuggyBuildId": 441002125,
    "PatchedBuilId": 0,
    "BuggyBuildURL": "http://travis-ci.org/INRIA/spoon/builds/441002125",
    "BuggyBuildDate": "Oct 13, 2018 4:16:28 PM",
    "BugCommit": "7042f76fac6edf0d6281713bdffa6ecbc5dc5a45",
    "PatchChangedFiles": 0,
    "PatchAddedLines": 0,
    "PatchDeletedLines": 0,
    "NbLibraries": 34,
    "NbFileApp": 652,
    "NbFileTests": 708,
    "NbCPU": 8,
    "FreeMemory": 324540504,
    "TotalMemory": 779091968,
    "AngelicValuesByTest": {},
    "FreeMemoryByStep": {
      "CheckoutBuggyBuild": 47581008,
      "ComputeClasspath": 45166376,
      "ComputeTestDir": 38078864,
      "BuildProject": 97286608,
      "InitRepoToPush": 46502944,
      "ComputeSourceDir": 322422736,
      "ComputeModules": 322422736,
      "CloneRepository": 98170352,
      "CheckoutPatchedBuild": 324540504,
      "TestProject": 80980936,
      "AssertFixer": 282448664,
      "GatherTestInformation": 54152256,
      "CommitPatch": 324540504
    },
    "NbSucceedingTests": 1538
  },
  "failing-test-cases": [
    {
      "className": "spoon.test.architecture.SpoonArchitectureEnforcerTest",
      "failingMethods": [
        "testSrcMainJava",
        "testSpecPackage"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "6 public methods should be documented with proper API documentation: \nspoon.reflect.visitor.CommentHelper#printComment(spoon.reflect.visitor.PrinterHelper,spoon.reflect.code.CtComment)\nspoon.support.javadoc.Javadoc#parse(java.lang.String)\nspoon.support.javadoc.JavadocBlockTag#toText()\nspoon.support.javadoc.JavadocDescription#parseText(java.lang.String)\nspoon.support.javadoc.JavadocDescriptionElement#toText()\nspoon.support.javadoc.JavadocInlineTag#fromText(java.lang.String)",
          "isError": false
        },
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "you have created a new package or removed an existing one, please declare it explicitly in SpoonArchitectureEnforcerTest#testSpecPackage\n\nDetails: Package spoon.support.javadoc presents in computed but not expected set.",
          "isError": false
        }
      ],
      "nbFailures": 2,
      "nbErrors": 0
    },
    {
      "className": "spoon.processing.CtGenerationTest",
      "failingMethods": [],
      "erroringMethods": [
        "testGenerateCloneVisitor"
      ],
      "failures": [
        {
          "failureName": "spoon.SpoonException",
          "failureDetail": "Get more than one setter. Please make an more ingenious method to get setter method. 0 /**\nparsed version of the javadoc\n */\nprivate transient spoon.support.javadoc.Javadoc javadoc;",
          "isError": true
        }
      ],
      "nbFailures": 0,
      "nbErrors": 1
    },
    {
      "className": "spoon.test.ctClass.CtClassTest",
      "failingMethods": [],
      "erroringMethods": [
        "testDefaultConstructorAreOk"
      ],
      "failures": [
        {
          "failureName": "spoon.compiler.ModelBuildingException",
          "failureDetail": "Syntax error on token(s), misplaced construct(s) at /root/workspace/INRIA/spoon/441002125/BooleanArrays.java:47",
          "isError": true
        }
      ],
      "nbFailures": 0,
      "nbErrors": 1
    },
    {
      "className": "spoon.test.comment.CommentTest",
      "failingMethods": [
        "testJavaDocCommentOnUnix",
        "testCommentsInResourcesWithWindowsEOL",
        "testJavaDocCommentOnMac",
        "testJavaDocEmptyCommentAndTag",
        "testSnippedWithComments",
        "testEnumValueComment",
        "testCombinedPackageInfoComment",
        "testWildComments",
        "testDocumentationContract"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...ing the other modes.[]\u003e but was:\u003c...ing the other modes.[\n]\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...s.\n\nLong description[]\u003e but was:\u003c...s.\n\nLong description[\n\n@deprecated\n@since 1.3\n@author Thomas Durieux\n@version 1.0\n]\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c[]\u003e but was:\u003c[\n@author there is tag, but there is no comment\n]\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "(/root/workspace/INRIA/spoon/441002125/src/test/java/spoon/test/comment/testclasses/WildComments.java:85) expected:\u003c*[]\u003e but was:\u003c*[\n]\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...ed well\nin this case[]\u003e but was:\u003c...ed well\nin this case[\n\n@author pvojtechovsky\n]\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...omment2\n/**\nComment3[] */\n@java.lang.Depre...\u003e but was:\u003c...omment2\n/**\nComment3[\n] */\n@java.lang.Depre...\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...s.\n\nLong description[]\u003e but was:\u003c...s.\n\nLong description[\n\n@deprecated\n@since 1.3\n@author Thomas Durieux\n@version 1.0\n]\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...thod javadoc comment[]\u003e but was:\u003c...thod javadoc comment[\n]\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "doc outdated, please commit doc/code_elements.md expected:\u003c...va\n\n/**\nDescription\n[@see \n  ]a tag in the javadoc...\u003e but was:\u003c...va\n\n/**\nDescription\n[\n@see ]a tag in the javadoc...\u003e",
          "isError": false
        }
      ],
      "nbFailures": 9,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.serializable.ModelStreamerTest",
      "failingMethods": [
        "testGZipCompressionType",
        "testDefaultCompressionType",
        "testNoneCompressionType"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "Model before \u0026 after serialization must have the same number of elements",
          "isError": false
        },
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "Model before \u0026 after serialization must have the same number of elements",
          "isError": false
        },
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "Model before \u0026 after serialization must have the same number of elements",
          "isError": false
        }
      ],
      "nbFailures": 3,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.imports.ImportScannerTest",
      "failingMethods": [
        "testImportOnSpoon"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "Import scanner missed 11 imports expected:\u003c0\u003e but was:\u003c11\u003e",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.prettyprinter.TestSniperPrinter",
      "failingMethods": [
        "testPrintAfterRemoveOfLastParameter",
        "testPrintAfterRemoveOfLastTypeMember",
        "testPrintAfterRenameOfField",
        "testPrintAfterRemoveOfFormalTypeParamsAndChangeOfReturnType",
        "testPrintUnchaged",
        "testPrintAfterRemoveOfMiddleParameter",
        "testPrintAfterAddOfLastTypeMember",
        "testPrintAfterRemoveOfFirstParameter"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c/**\n[ * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again ]\n */\npublic\n@Depreca...\u003e but was:\u003c/**\n[The content of this file \n\n\n  should not be changed\nBecause DJPP should print only modified content again]\n */\npublic\n@Depreca...\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c/**\n[ * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again ]\n */\npublic\n@Depreca...\u003e but was:\u003c/**\n[The content of this file \n\n\n  should not be changed\nBecause DJPP should print only modified content again]\n */\npublic\n@Depreca...\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c/**\n[ * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again ]\n */\npublic\n@Depreca...\u003e but was:\u003c/**\n[The content of this file \n\n\n  should not be changed\nBecause DJPP should print only modified content again]\n */\npublic\n@Depreca...\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c/**\n[ * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again ]\n */\npublic\n@Depreca...\u003e but was:\u003c/**\n[The content of this file \n\n\n  should not be changed\nBecause DJPP should print only modified content again]\n */\npublic\n@Depreca...\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c/**\n[ * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again ]\n */\npublic\n@Depreca...\u003e but was:\u003c/**\n[The content of this file \n\n\n  should not be changed\nBecause DJPP should print only modified content again]\n */\npublic\n@Depreca...\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c/**\n[ * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again ]\n */\npublic\n@Depreca...\u003e but was:\u003c/**\n[The content of this file \n\n\n  should not be changed\nBecause DJPP should print only modified content again]\n */\npublic\n@Depreca...\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c/**\n[ * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again ]\n */\npublic\n@Depreca...\u003e but was:\u003c/**\n[The content of this file \n\n\n  should not be changed\nBecause DJPP should print only modified content again]\n */\npublic\n@Depreca...\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c/**\n[ * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again \n */\npublic\n@Deprecated\nabstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged\u003cT, K\u003e /*before extends*/ \n extends ArrayList\u003cT /* let\u0027s confuse \u003e it */ \u003e implements List\u003cT\u003e,\n Cloneable\n{\n \n \n /**/\n final\n //\n private String string \u003d \"a\"\n   + \"b\" + \"c\"+\"d\";\n \n //and spaces here are wanted too\n \n \n public \u003cT, K\u003e void andSomeOtherMethod(\n   int param1,\n   String param2         , List\u003c?\u003e[][] ... twoDArrayOfLists)\n {/**/\n  System.out.println(\"aaa\"\n    + \"xyz\");\n /*x*/}\n List\u003c?\u003e[][] twoDArrayOfLists \u003d new List\u003c?\u003e[7][];\n}\n\n]//and what about thi...\u003e but was:\u003c/**\n[The content of this file \n\n\n  should not be changed\nBecause DJPP should print only modified content again\n */\npublic\n@Deprecated\nabstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged\u003cT, K\u003e /*before extends*/ \n extends ArrayList\u003cT /* let\u0027s confuse \u003e it */ \u003e implements List\u003cT\u003e,\n Cloneable\n{\n \n \n /**/\n final\n //\n private String string \u003d \"a\"\n   + \"b\" + \"c\"+\"d\";\n \n //and spaces here are wanted too\n \n \n public \u003cT, K\u003e void andSomeOtherMethod(\n   int param1,\n   String param2         , List\u003c?\u003e[][] ... twoDArrayOfLists)\n {/**/\n  System.out.println(\"aaa\"\n    + \"xyz\");\n /*x*/}\n List\u003c?\u003e[][] twoDArrayOfLists \u003d new List\u003c?\u003e[7][];\n}\n\n ]//and what about thi...\u003e",
          "isError": false
        }
      ],
      "nbFailures": 8,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.enums.EnumsTest",
      "failingMethods": [
        "testPrintEnumValues"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.module.TestModule",
      "failingMethods": [
        "testModuleInfoWithComments"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...e of the application[]\u003e but was:\u003c...e of the application[\n]\u003e",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.pkg.PackageTest",
      "failingMethods": [
        "testPackage"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...his is test\nJavaDoc.[]\u003e but was:\u003c...his is test\nJavaDoc.[\n]\u003e",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.javadoc.JavaDocTest",
      "failingMethods": [
        "testJavaDocReprint"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...s Bar {\n    /**\n    [ * Creates an annotation type.\n     *\n     * @param owner\n     *   the package of the annotation type\n     * @param simpleName\n    ] *   the name of ann...\u003e but was:\u003c...s Bar {\n    /**\n    [Creates an annotation type.\n\n    @param owner the package of the annotation type\n    @param simpleName the name of annotation\n     *\n     * @param owner *   the package of the annotation type\n     * @param simpleName *   the name of annotation\n     * @param owner *   the package of the annotation type\n     * @param simpleName *   the name of annotation\n     * @param owner *   the package of the annotation type\n     * @param simpleName *   the name of annotation\n     * @param owner *   the package of the annotation type\n     * @param simpleName *   the name of annotation\n     * @param owner *   the package of the annotation type\n     * @param simpleName] *   the name of ann...\u003e",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    },
    {
      "className": "spoon.reflect.ast.CloneTest",
      "failingMethods": [
        "testCloneListener"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "Source and Target are not equal expected:\u003c/**\nA visitor for generating Java code from the program compile-time model.\n */\npublic class DefaultJavaPrettyPrinter implements spoon.reflect.visitor.CtVisitor , spoon.reflect.visitor.PrettyPrinter {\n    /**\n    Java file extension (.java).\n     */\n    public static final java.lang.String JAVA_FILE_EXTENSION \u003d \".java\";\n\n    /**\n    Package declaration file name.\n     */\n    public static final java.lang.String JAVA_PACKAGE_DECLARATION \u003d \"package-info\" + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);\n\n    /**\n    Module declaration file name.\n     */\n    public static final java.lang.String JAVA_MODULE_DECLARATION \u003d \"module-info\" + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);\n\n    /**\n    Line separator which is used by the system\n     */\n    public static final java.lang.String LINE_SEPARATOR \u003d java.lang.System.getProperty(\"line.separator\");\n\n    /**\n    The star at the beginning of a block/JavaDoc comment line\n     */\n    public static final java.lang.String COMMENT_STAR \u003d \" * \";\n\n    /**\n    The end of a block/JavaDoc comment\n     */\n    public static final java.lang.String BLOCK_COMMENT_END \u003d \" */\";\n\n    /**\n    The beginning of a JavaDoc comment\n     */\n    public static final java.lang.String JAVADOC_START \u003d \"/**\";\n\n    /**\n    The beginning of an inline comment\n     */\n    public static final java.lang.String INLINE_COMMENT_START \u003d \"// \";\n\n    /**\n    The beginning of a block comment\n     */\n    public static final java.lang.String BLOCK_COMMENT_START \u003d \"/* \";\n\n    /**\n    The printing context.\n\n    since Spoon 7.1.0, use {{@link #getContext()}}\n     */\n    private spoon.reflect.visitor.PrintingContext context \u003d new spoon.reflect.visitor.PrintingContext();\n\n    /**\n    get the import scanner of this pretty printer\n     */\n    public spoon.reflect.visitor.ImportScanner getImportsContext() {\n        return importsContext;\n    }\n\n    /**\n    Handle imports of classes.\n     */\n    private spoon.reflect.visitor.ImportScanner importsContext;\n\n    /**\n    Environment which Spoon is executed.\n     */\n    protected spoon.compiler.Environment env;\n\n    /**\n    Token detector, which delegates tokens to {@link TokenWriter}\n     */\n    private spoon.reflect.visitor.TokenWriter printer;\n\n    /**\n    Element printer helper.\n     */\n    private spoon.reflect.visitor.ElementPrinterHelper elementPrinterHelper;\n\n    /**\n    Compilation unit we are printing.\n     */\n    protected spoon.reflect.cu.CompilationUnit sourceCompilationUnit;\n\n    /**\n    Imports computed\n     */\n    java.util.Set\u003cspoon.reflect.declaration.CtImport\u003e imports;\n\n    /**\n    Creates a new code generator visitor.\n     */\n    public DefaultJavaPrettyPrinter(spoon.compiler.Environment env) {\n        this.env \u003d env;\n        this.imports \u003d new java.util.HashSet\u003c\u003e();\n        setPrinterTokenWriter(new spoon.reflect.visitor.DefaultTokenWriter(new spoon.reflect.visitor.PrinterHelper(env)));\n        if (env.isAutoImports()) {\n            this.importsContext \u003d new spoon.reflect.visitor.ImportScannerImpl();\n        }else {\n            this.importsContext \u003d new spoon.reflect.visitor.MinimalImportScanner();\n        }\n    }\n\n    /**\n\n    @return current line separator. By default there is CR LF, LF or CR depending on the Operation system\n    defined by System.getProperty(\"line.separator\")\n     *\n     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system\n     * defined by System.getProperty(\"line.separator\")\n     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system\n     * defined by System.getProperty(\"line.separator\")\n     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system\n     * defined by System.getProperty(\"line.separator\")\n     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system\n     * defined by System.getProperty(\"line.separator\")\n     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system\n     * defined by System.getProperty(\"line.separator\")\n     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system\n     * defined by System.getProperty(\"line.separator\")\n     */\n    public java.lang.String getLineSeparator() {\n        return getPrinterHelper().getLineSeparator();\n    }\n\n    /**\n\n    @param lineSeparator characters which will be printed as End of line.\n    By default there is System.getProperty(\"line.separator\")\n     *\n     * @param lineSeparator *   characters which will be printed as End of line.\n     *   By default there is System.getProperty(\"line.separator\")\n     * @param lineSeparator *   characters which will be printed as End of line.\n     *   By default there is System.getProperty(\"line.separator\")\n     * @param lineSeparator *   characters which will be printed as End of line.\n     *   By default there is System.getProperty(\"line.separator\")\n     * @param lineSeparator *   characters which will be printed as End of line.\n     *   By default there is System.getProperty(\"line.separator\")\n     * @param lineSeparator *   characters which will be printed as End of line.\n     *   By default there is System.getProperty(\"line.separator\")\n     * @param lineSeparator *   characters which will be printed as End of line.\n     *   By default there is System.getProperty(\"line.separator\")\n     */\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter setLineSeparator(java.lang.String lineSeparator) {\n        getPrinterHelper().setLineSeparator(lineSeparator);\n        return this;\n    }\n\n    /**\n    Enters an expression.\n     */\n    protected void enterCtExpression(spoon.reflect.code.CtExpression\u003c?\u003e e) {\n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        }\n        getPrinterHelper().mapLine(e, sourceCompilationUnit);\n        if (shouldSetBracket(e)) {\n            context.parenthesedExpression.push(e);\n            printer.writeSeparator(\"(\");\n        }\n        if (!(e.getTypeCasts().isEmpty())) {\n            for (spoon.reflect.reference.CtTypeReference\u003c?\u003e r : e.getTypeCasts()) {\n                printer.writeSeparator(\"(\");\n                scan(r);\n                printer.writeSeparator(\")\").writeSpace();\n                printer.writeSeparator(\"(\");\n                context.parenthesedExpression.push(e);\n            }\n        }\n    }\n\n    /**\n    Enters a statement.\n     */\n    protected void enterCtStatement(spoon.reflect.code.CtStatement s) {\n        elementPrinterHelper.writeComment(s, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        getPrinterHelper().mapLine(s, sourceCompilationUnit);\n        if (!(context.isNextForVariable())) {\n            // TODO AnnotationLoopTest#testAnnotationDeclaredInForInit expects that annotations of next for variables are not printed\n            // but may be correct is that the next variables are not annotated, because they might have different annotation then first param!\n            elementPrinterHelper.writeAnnotations(s);\n        }\n        if ((!(context.isFirstForVariable())) \u0026\u0026 (!(context.isNextForVariable()))) {\n            if ((s.getLabel()) !\u003d null) {\n                printer.writeIdentifier(s.getLabel()).writeSpace().writeSeparator(\":\").writeSpace();\n            }\n        }\n    }\n\n    /**\n    Exits a statement.\n     */\n    protected void exitCtStatement(spoon.reflect.code.CtStatement statement) {\n        if (!((((((((((statement instanceof spoon.reflect.code.CtBlock) || (statement instanceof spoon.reflect.code.CtIf)) || (statement instanceof spoon.reflect.code.CtFor)) || (statement instanceof spoon.reflect.code.CtForEach)) || (statement instanceof spoon.reflect.code.CtWhile)) || (statement instanceof spoon.reflect.code.CtTry)) || (statement instanceof spoon.reflect.code.CtSwitch)) || (statement instanceof spoon.reflect.code.CtSynchronized)) || (statement instanceof spoon.reflect.declaration.CtClass)) || (statement instanceof spoon.reflect.code.CtComment))) {\n            if (((context.isStatement(statement)) \u0026\u0026 (!(context.isFirstForVariable()))) \u0026\u0026 (!(context.isNextForVariable()))) {\n                printer.writeSeparator(\";\");\n            }\n        }\n        elementPrinterHelper.writeComment(statement, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n    }\n\n    /**\n    Exits an expression.\n     */\n    protected void exitCtExpression(spoon.reflect.code.CtExpression\u003c?\u003e e) {\n        while ((!(context.parenthesedExpression.isEmpty())) \u0026\u0026 (e \u003d\u003d (context.parenthesedExpression.peek()))) {\n            context.parenthesedExpression.pop();\n            printer.writeSeparator(\")\");\n        } \n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        }\n    }\n\n    /**\n    Make the imports for a given type.\n     */\n    private java.util.Collection\u003cspoon.reflect.declaration.CtImport\u003e computeImports(spoon.reflect.declaration.CtType\u003c?\u003e type) {\n        context.currentTopLevel \u003d type;\n        importsContext.computeImports(context.currentTopLevel);\n        return importsContext.getAllImports();\n    }\n\n    /**\n    This method is called by {@link #scan(CtElement)} when entering a scanned element.\n    To be overridden to implement specific behavior.\n\n    Same KISS design as for {@link CtScanner}.\n     */\n    protected void enter(spoon.reflect.declaration.CtElement e) {\n    }\n\n    /**\n    This method is called by {@link #scan(CtElement)} when entering a scanned element.\n    To be overridden to implement specific behavior.\n     */\n    protected void exit(spoon.reflect.declaration.CtElement e) {\n    }\n\n    /**\n    The generic scan method for an element.\n     */\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.declaration.CtElement e) {\n        if (e !\u003d null) {\n            enter(e);\n            context.elementStack.push(e);\n            if (env.isPreserveLineNumbers()) {\n                if (!(e instanceof spoon.reflect.declaration.CtNamedElement)) {\n                    getPrinterHelper().adjustStartPosition(e);\n                }\n            }\n            try {\n                e.accept(this);\n            } catch (spoon.SpoonException ex) {\n                throw ex;\n            } catch (java.lang.Exception ex) {\n                java.lang.String elementInfo \u003d e.getClass().getName();\n                elementInfo +\u003d (\" on path \" + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.getPath(e))) + \"\\n\";\n                if (e.getPosition().isValidPosition()) {\n                    elementInfo +\u003d (\"at position \" + (e.getPosition().toString())) + \" \";\n                }\n                throw new spoon.SpoonException(((\"Printing of \" + elementInfo) + \"failed\"), ex);\n            }\n            context.elementStack.pop();\n            exit(e);\n        }\n        return this;\n    }\n\n    private static java.lang.String getPath(spoon.reflect.declaration.CtElement ele) {\n        java.lang.StringBuilder sb \u003d new java.lang.StringBuilder();\n        spoon.reflect.visitor.DefaultJavaPrettyPrinter.addParentPath(sb, ele);\n        if (ele instanceof spoon.reflect.code.CtVariableAccess) {\n            sb.append(\u0027:\u0027).append(((spoon.reflect.code.CtVariableAccess) (ele)).getVariable().getSimpleName());\n        }\n        return sb.toString();\n    }\n\n    private static void addParentPath(java.lang.StringBuilder sb, spoon.reflect.declaration.CtElement ele) {\n        if ((ele \u003d\u003d null) || ((ele instanceof spoon.reflect.declaration.CtPackage) \u0026\u0026 (((spoon.reflect.declaration.CtPackage) (ele)).isUnnamedPackage()))) {\n            return;\n        }\n        if (ele.isParentInitialized()) {\n            spoon.reflect.visitor.DefaultJavaPrettyPrinter.addParentPath(sb, ele.getParent());\n        }\n        sb.append(\"\\n\\t\").append(ele.getClass().getSimpleName());\n        if (ele instanceof spoon.reflect.declaration.CtNamedElement) {\n            sb.append(\":\").append(((spoon.reflect.declaration.CtNamedElement) (ele)).getSimpleName());\n        }else\n            if (ele instanceof spoon.reflect.reference.CtReference) {\n                sb.append(\":\").append(((spoon.reflect.reference.CtReference) (ele)).getSimpleName());\n            }\n\n    }\n\n    private boolean shouldSetBracket(spoon.reflect.code.CtExpression\u003c?\u003e e) {\n        if (!(e.getTypeCasts().isEmpty())) {\n            return true;\n        }\n        try {\n            if (((e.getParent()) instanceof spoon.reflect.code.CtBinaryOperator) || ((e.getParent()) instanceof spoon.reflect.code.CtUnaryOperator)) {\n                return ((((e instanceof spoon.reflect.code.CtTargetedExpression) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator)) || (e instanceof spoon.reflect.code.CtBinaryOperator);\n            }\n            if ((e.getParent()) instanceof spoon.reflect.code.CtTargetedExpression) {\n                return (((e instanceof spoon.reflect.code.CtBinaryOperator) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator);\n            }\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n            // nothing we accept not to have a parent\n        }\n        return false;\n    }\n\n    /**\n    Gets the currently pretty-printed string.\n     */\n    @java.lang.Override\n    public java.lang.String toString() {\n        return printer.getPrinterHelper().toString();\n    }\n\n    @java.lang.Override\n    public \u003cA extends java.lang.annotation.Annotation\u003e void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation\u003cA\u003e annotation) {\n        elementPrinterHelper.writeAnnotations(annotation);\n        printer.writeSeparator(\"@\");\n        scan(annotation.getAnnotationType());\n        if (!(annotation.getValues().isEmpty())) {\n            elementPrinterHelper.printList(annotation.getValues().entrySet(), null, false, \"(\", false, false, \",\", true, false, \")\", ( e) -\u003e {\n                if ((((annotation.getValues().size()) \u003d\u003d 1) \u0026\u0026 (\"value\".equals(e.getKey()))) \u003d\u003d false) {\n                    // it is not a default value attribute. We must print a attribute name too.\n                    printer.writeIdentifier(e.getKey()).writeSpace().writeOperator(\"\u003d\").writeSpace();\n                }\n                elementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());\n            });\n        }\n    }\n\n    @java.lang.Override\n    public \u003cA extends java.lang.annotation.Annotation\u003e void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType\u003cA\u003e annotationType) {\n        visitCtType(annotationType);\n        printer.writeSeparator(\"@\").writeKeyword(\"interface\").writeSpace().writeIdentifier(annotationType.getSimpleName()).writeSpace().writeSeparator(\"{\").incTab();\n        elementPrinterHelper.writeElementList(annotationType.getTypeMembers());\n        printer.decTab().writeSeparator(\"}\");\n    }\n\n    @java.lang.Override\n    public void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable impl) {\n        elementPrinterHelper.writeComment(impl);\n        elementPrinterHelper.writeAnnotations(impl);\n        elementPrinterHelper.writeModifiers(impl);\n        scan(impl.getBody());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtArrayRead(spoon.reflect.code.CtArrayRead\u003cT\u003e arrayRead) {\n        printCtArrayAccess(arrayRead);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtArrayWrite(spoon.reflect.code.CtArrayWrite\u003cT\u003e arrayWrite) {\n        printCtArrayAccess(arrayWrite);\n    }\n\n    private \u003cT, E extends spoon.reflect.code.CtExpression\u003c?\u003e\u003e void printCtArrayAccess(spoon.reflect.code.CtArrayAccess\u003cT, E\u003e arrayAccess) {\n        enterCtExpression(arrayAccess);\n        scan(arrayAccess.getTarget());\n        printer.writeSeparator(\"[\");\n        scan(arrayAccess.getIndexExpression());\n        printer.writeSeparator(\"]\");\n        exitCtExpression(arrayAccess);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtArrayTypeReference(spoon.reflect.reference.CtArrayTypeReference\u003cT\u003e reference) {\n        if (reference.isImplicit()) {\n            return;\n        }\n        scan(reference.getComponentType());\n        if (!(context.skipArray())) {\n            printer.writeSeparator(\"[\").writeSeparator(\"]\");\n        }\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtAssert(spoon.reflect.code.CtAssert\u003cT\u003e asserted) {\n        enterCtStatement(asserted);\n        printer.writeKeyword(\"assert\").writeSpace();\n        scan(asserted.getAssertExpression());\n        if ((asserted.getExpression()) !\u003d null) {\n            printer.writeSpace().writeSeparator(\":\").writeSpace();\n            scan(asserted.getExpression());\n        }\n        exitCtStatement(asserted);\n    }\n\n    @java.lang.Override\n    public \u003cT, A extends T\u003e void visitCtAssignment(spoon.reflect.code.CtAssignment\u003cT, A\u003e assignement) {\n        enterCtStatement(assignement);\n        enterCtExpression(assignement);\n        scan(assignement.getAssigned());\n        printer.writeSpace().writeOperator(\"\u003d\").writeSpace();\n        scan(assignement.getAssignment());\n        exitCtExpression(assignement);\n        exitCtStatement(assignement);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator\u003cT\u003e operator) {\n        enterCtExpression(operator);\n        scan(operator.getLeftHandOperand());\n        printer.writeSpace();\n        printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(operator.getKind()));\n        printer.writeSpace();\n        try (spoon.reflect.visitor.PrintingContext.Writable _context \u003d context.modify()) {\n            if ((operator.getKind()) \u003d\u003d (spoon.reflect.code.BinaryOperatorKind.INSTANCEOF)) {\n                _context.forceWildcardGenerics(true);\n            }\n            scan(operator.getRightHandOperand());\n        }\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public \u003cR\u003e void visitCtBlock(spoon.reflect.code.CtBlock\u003cR\u003e block) {\n        enterCtStatement(block);\n        if (!(block.isImplicit())) {\n            printer.writeSeparator(\"{\");\n        }\n        printer.incTab();\n        for (spoon.reflect.code.CtStatement statement : block.getStatements()) {\n            if (!(statement.isImplicit())) {\n                printer.writeln();\n                elementPrinterHelper.writeStatement(statement);\n            }\n        }\n        printer.decTab();\n        getPrinterHelper().adjustEndPosition(block);\n        if (env.isPreserveLineNumbers()) {\n            if (!(block.isImplicit())) {\n                printer.writeSeparator(\"}\");\n            }\n        }else {\n            printer.writeln();\n            if (!(block.isImplicit())) {\n                printer.writeSeparator(\"}\");\n            }\n        }\n        exitCtStatement(block);\n    }\n\n    @java.lang.Override\n    public void visitCtBreak(spoon.reflect.code.CtBreak breakStatement) {\n        enterCtStatement(breakStatement);\n        printer.writeKeyword(\"break\");\n        if ((breakStatement.getTargetLabel()) !\u003d null) {\n            printer.writeSpace().writeKeyword(breakStatement.getTargetLabel());\n        }\n        exitCtStatement(breakStatement);\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public \u003cE\u003e void visitCtCase(spoon.reflect.code.CtCase\u003cE\u003e caseStatement) {\n        enterCtStatement(caseStatement);\n        if ((caseStatement.getCaseExpression()) !\u003d null) {\n            printer.writeKeyword(\"case\").writeSpace();\n            // writing enum case expression\n            if ((caseStatement.getCaseExpression()) instanceof spoon.reflect.code.CtFieldAccess) {\n                final spoon.reflect.reference.CtFieldReference variable \u003d ((spoon.reflect.code.CtFieldAccess) (caseStatement.getCaseExpression())).getVariable();\n                // In noclasspath mode, we don\u0027t have always the type of the declaring type.\n                if ((((variable.getType()) !\u003d null) \u0026\u0026 ((variable.getDeclaringType()) !\u003d null)) \u0026\u0026 (variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName()))) {\n                    printer.writeIdentifier(variable.getSimpleName());\n                }else {\n                    scan(caseStatement.getCaseExpression());\n                }\n            }else {\n                scan(caseStatement.getCaseExpression());\n            }\n        }else {\n            printer.writeKeyword(\"default\");\n        }\n        printer.writeSpace().writeSeparator(\":\").incTab();\n        for (spoon.reflect.code.CtStatement statement : caseStatement.getStatements()) {\n            printer.writeln();\n            elementPrinterHelper.writeStatement(statement);\n        }\n        printer.decTab();\n        exitCtStatement(caseStatement);\n    }\n\n    @java.lang.Override\n    public void visitCtCatch(spoon.reflect.code.CtCatch catchBlock) {\n        elementPrinterHelper.writeComment(catchBlock, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.writeSpace().writeKeyword(\"catch\").writeSpace().writeSeparator(\"(\");\n        spoon.reflect.code.CtCatchVariable\u003c? extends java.lang.Throwable\u003e parameter \u003d catchBlock.getParameter();\n        if ((parameter !\u003d null) \u0026\u0026 ((parameter.getMultiTypes().size()) \u003e 1)) {\n            elementPrinterHelper.printList(parameter.getMultiTypes(), null, false, null, false, true, \"|\", true, false, null, ( type) -\u003e scan(type));\n            printer.writeSpace().writeIdentifier(parameter.getSimpleName());\n        }else {\n            scan(parameter);\n        }\n        printer.writeSeparator(\")\").writeSpace();\n        scan(catchBlock.getBody());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtClass(spoon.reflect.declaration.CtClass\u003cT\u003e ctClass) {\n        context.pushCurrentThis(ctClass);\n        if ((((ctClass.getSimpleName()) !\u003d null) \u0026\u0026 (!(spoon.reflect.declaration.CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName())))) \u0026\u0026 (!(ctClass.isAnonymous()))) {\n            visitCtType(ctClass);\n            if (ctClass.isLocalType()) {\n                printer.writeKeyword(\"class\").writeSpace().writeIdentifier(ctClass.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            }else {\n                printer.writeKeyword(\"class\").writeSpace().writeIdentifier(ctClass.getSimpleName());\n            }\n            elementPrinterHelper.writeFormalTypeParameters(ctClass);\n            elementPrinterHelper.writeExtendsClause(ctClass);\n            elementPrinterHelper.writeImplementsClause(ctClass);\n        }\n        printer.writeSpace().writeSeparator(\"{\").incTab();\n        elementPrinterHelper.writeElementList(ctClass.getTypeMembers());\n        getPrinterHelper().adjustEndPosition(ctClass);\n        printer.decTab().writeSeparator(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n        elementPrinterHelper.writeAnnotations(typeParameter);\n        printer.writeIdentifier(typeParameter.getSimpleName());\n        if (((typeParameter.getSuperclass()) !\u003d null) \u0026\u0026 ((typeParameter.getSuperclass().isImplicit()) \u003d\u003d false)) {\n            printer.writeSpace().writeKeyword(\"extends\").writeSpace();\n            scan(typeParameter.getSuperclass());\n        }\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtConditional(spoon.reflect.code.CtConditional\u003cT\u003e conditional) {\n        enterCtExpression(conditional);\n        spoon.reflect.code.CtExpression\u003cjava.lang.Boolean\u003e condition \u003d conditional.getCondition();\n        boolean parent;\n        try {\n            parent \u003d ((conditional.getParent()) instanceof spoon.reflect.code.CtAssignment) || ((conditional.getParent()) instanceof spoon.reflect.declaration.CtVariable);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n            // nothing if we have no parent\n            parent \u003d false;\n        }\n        if (parent) {\n            printer.writeSeparator(\"(\");\n        }\n        scan(condition);\n        if (parent) {\n            printer.writeSeparator(\")\");\n        }\n        printer.writeSpace().writeOperator(\"?\").writeSpace();\n        spoon.reflect.code.CtExpression\u003cT\u003e thenExpression \u003d conditional.getThenExpression();\n        scan(thenExpression);\n        printer.writeSpace().writeOperator(\":\").writeSpace();\n        spoon.reflect.code.CtExpression\u003cT\u003e elseExpression \u003d conditional.getElseExpression();\n        boolean isAssign;\n        if (isAssign \u003d elseExpression instanceof spoon.reflect.code.CtAssignment) {\n            printer.writeSeparator(\"(\");\n        }\n        scan(elseExpression);\n        if (isAssign) {\n            printer.writeSeparator(\")\");\n        }\n        exitCtExpression(conditional);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtConstructor(spoon.reflect.declaration.CtConstructor\u003cT\u003e constructor) {\n        elementPrinterHelper.writeComment(constructor);\n        elementPrinterHelper.visitCtNamedElement(constructor, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(constructor);\n        elementPrinterHelper.writeFormalTypeParameters(constructor);\n        if (!(constructor.getFormalCtTypeParameters().isEmpty())) {\n            printer.writeSpace();\n        }\n        if ((constructor.getDeclaringType()) !\u003d null) {\n            if (constructor.getDeclaringType().isLocalType()) {\n                printer.writeIdentifier(constructor.getDeclaringType().getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            }else {\n                printer.writeIdentifier(constructor.getDeclaringType().getSimpleName());\n            }\n        }\n        elementPrinterHelper.writeExecutableParameters(constructor);\n        elementPrinterHelper.writeThrowsClause(constructor);\n        printer.writeSpace();\n        scan(constructor.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtContinue(spoon.reflect.code.CtContinue continueStatement) {\n        enterCtStatement(continueStatement);\n        printer.writeKeyword(\"continue\");\n        if ((continueStatement.getTargetLabel()) !\u003d null) {\n            printer.writeSpace().writeIdentifier(continueStatement.getTargetLabel());\n        }\n        exitCtStatement(continueStatement);\n    }\n\n    @java.lang.Override\n    public void visitCtDo(spoon.reflect.code.CtDo doLoop) {\n        enterCtStatement(doLoop);\n        printer.writeKeyword(\"do\");\n        elementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());\n        printer.writeKeyword(\"while\").writeSpace().writeSeparator(\"(\");\n        scan(doLoop.getLoopingExpression());\n        printer.writeSpace().writeSeparator(\")\");\n        exitCtStatement(doLoop);\n    }\n\n    @java.lang.Override\n    public \u003cT extends java.lang.Enum\u003c?\u003e\u003e void visitCtEnum(spoon.reflect.declaration.CtEnum\u003cT\u003e ctEnum) {\n        visitCtType(ctEnum);\n        printer.writeKeyword(\"enum\").writeSpace().writeIdentifier(ctEnum.getSimpleName());\n        elementPrinterHelper.writeImplementsClause(ctEnum);\n        context.pushCurrentThis(ctEnum);\n        printer.writeSpace().writeSeparator(\"{\").incTab().writeln();\n        if (ctEnum.getEnumValues().isEmpty()) {\n            printer.writeSeparator(\";\").writeln();\n        }else {\n            elementPrinterHelper.printList(ctEnum.getEnumValues(), null, false, null, false, false, \",\", false, false, \";\", ( enumValue) -\u003e {\n                printer.writeln();\n                scan(enumValue);\n            });\n        }\n        elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());\n        printer.decTab().writeSeparator(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference\u003cT\u003e reference) {\n        // it is not called during printing of sources. Use shortcut and print directly to PrinterHelper\n        printer.getPrinterHelper().write(reference.getSignature());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtField(spoon.reflect.declaration.CtField\u003cT\u003e f) {\n        elementPrinterHelper.writeComment(f, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        elementPrinterHelper.visitCtNamedElement(f, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(f);\n        scan(f.getType());\n        printer.writeSpace();\n        printer.writeIdentifier(f.getSimpleName());\n        if ((f.getDefaultExpression()) !\u003d null) {\n            printer.writeSpace().writeOperator(\"\u003d\").writeSpace();\n            scan(f.getDefaultExpression());\n        }\n        printer.writeSeparator(\";\");\n        elementPrinterHelper.writeComment(f, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtEnumValue(spoon.reflect.declaration.CtEnumValue\u003cT\u003e enumValue) {\n        elementPrinterHelper.visitCtNamedElement(enumValue, sourceCompilationUnit);\n        elementPrinterHelper.writeComment(enumValue, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.writeIdentifier(enumValue.getSimpleName());\n        if ((enumValue.getDefaultExpression()) !\u003d null) {\n            spoon.reflect.code.CtConstructorCall\u003c?\u003e constructorCall \u003d ((spoon.reflect.code.CtConstructorCall\u003c?\u003e) (enumValue.getDefaultExpression()));\n            if (!(constructorCall.isImplicit())) {\n                elementPrinterHelper.printList(constructorCall.getArguments(), null, false, \"(\", false, false, \",\", true, false, \")\", ( expr) -\u003e scan(expr));\n            }\n            if (constructorCall instanceof spoon.reflect.code.CtNewClass) {\n                scan(((spoon.reflect.code.CtNewClass\u003c?\u003e) (constructorCall)).getAnonymousClass());\n            }\n        }\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtFieldRead(spoon.reflect.code.CtFieldRead\u003cT\u003e fieldRead) {\n        printCtFieldAccess(fieldRead);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite\u003cT\u003e fieldWrite) {\n        printCtFieldAccess(fieldWrite);\n    }\n\n    private boolean isImported(spoon.reflect.reference.CtFieldReference fieldReference) {\n        spoon.reflect.declaration.CtImport fieldImport \u003d fieldReference.getFactory().createImport(fieldReference);\n        if (this.imports.contains(fieldImport)) {\n            return true;\n        }else {\n            if ((fieldReference.getDeclaringType()) \u003d\u003d null) {\n                return false;\n            }\n            spoon.reflect.reference.CtTypeReference staticTypeMemberReference \u003d fieldReference.getFactory().Type().createWildcardStaticTypeMemberReference(fieldReference.getDeclaringType());\n            spoon.reflect.declaration.CtImport staticClassImport \u003d fieldReference.getFactory().createImport(staticTypeMemberReference);\n            return this.imports.contains(staticClassImport);\n        }\n    }\n\n    private boolean isImported(spoon.reflect.reference.CtExecutableReference executableReference) {\n        spoon.reflect.declaration.CtImport executableImport \u003d executableReference.getFactory().createImport(executableReference);\n        if (this.imports.contains(executableImport)) {\n            return true;\n        }else {\n            if ((executableReference.getDeclaringType()) \u003d\u003d null) {\n                return false;\n            }\n            spoon.reflect.reference.CtTypeReference staticTypeMemberReference \u003d executableReference.getFactory().Type().createWildcardStaticTypeMemberReference(executableReference.getDeclaringType());\n            spoon.reflect.declaration.CtImport staticClassImport \u003d executableReference.getFactory().createImport(staticTypeMemberReference);\n            return this.imports.contains(staticClassImport);\n        }\n    }\n\n    private \u003cT\u003e void printCtFieldAccess(spoon.reflect.code.CtFieldAccess\u003cT\u003e f) {\n        enterCtExpression(f);\n        try (spoon.reflect.visitor.PrintingContext.Writable _context \u003d context.modify()) {\n            if (((f.getVariable().isStatic()) || (\"class\".equals(f.getVariable().getSimpleName()))) \u0026\u0026 ((f.getTarget()) instanceof spoon.reflect.code.CtTypeAccess)) {\n                _context.ignoreGenerics(true);\n            }\n            spoon.reflect.code.CtExpression\u003c?\u003e target \u003d f.getTarget();\n            if (target !\u003d null) {\n                boolean isInitializeStaticFinalField \u003d isInitializeStaticFinalField(f.getTarget());\n                boolean isStaticField \u003d f.getVariable().isStatic();\n                boolean isImportedField \u003d this.isImported(f.getVariable());\n                if ((!isInitializeStaticFinalField) \u0026\u0026 (!(isStaticField \u0026\u0026 isImportedField))) {\n                    if ((target.isImplicit()) \u0026\u0026 (!(((f.getVariable().getFieldDeclaration()) \u003d\u003d null) \u0026\u0026 (this.env.getNoClasspath())))) {\n                        /* target is implicit, check whether there is no conflict with an local variable, catch variable or parameter\n                        in case of conflict make it explicit, otherwise the field access is shadowed by that variable.\n                        Search for potential variable declaration until we found a class which declares or inherits this field */\n                        final spoon.reflect.declaration.CtField\u003c?\u003e field \u003d f.getVariable().getFieldDeclaration();\n                        if (field !\u003d null) {\n                            final java.lang.String fieldName \u003d field.getSimpleName();\n                            spoon.reflect.declaration.CtVariable\u003c?\u003e var \u003d f.getVariable().map(new spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction(fieldName)).first();\n                            if (var !\u003d field) {\n                                // another variable declaration was found which is hiding the field declaration for this field access. Make the field access explicit\n                                target.setImplicit(false);\n                            }\n                        }else {\n                            // There is a model inconsistency\n                            printer.writeComment(f.getFactory().createComment(((\"ERROR: Missing field \\\"\" + (f.getVariable().getSimpleName())) + \"\\\", please check your model. The code may not compile.\"), spoon.reflect.code.CtComment.CommentType.BLOCK)).writeSpace();\n                        }\n                    }\n                    // the implicit drives the separator\n                    if (!(target.isImplicit())) {\n                        scan(target);\n                        printer.writeSeparator(\".\");\n                    }\n                }\n                _context.ignoreStaticAccess(true);\n            }\n            scan(f.getVariable());\n        }\n        exitCtExpression(f);\n    }\n\n    /**\n    Check if the target expression is a static final field initialized in a static anonymous block.\n     */\n    private \u003cT\u003e boolean isInitializeStaticFinalField(spoon.reflect.code.CtExpression\u003cT\u003e targetExp) {\n        final spoon.reflect.declaration.CtElement parent;\n        final spoon.reflect.declaration.CtAnonymousExecutable anonymousParent;\n        try {\n            parent \u003d targetExp.getParent();\n            anonymousParent \u003d targetExp.getParent(spoon.reflect.declaration.CtAnonymousExecutable.class);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        return (((((parent instanceof spoon.reflect.code.CtFieldWrite) \u0026\u0026 (targetExp.equals(((spoon.reflect.code.CtFieldWrite) (parent)).getTarget()))) \u0026\u0026 (anonymousParent !\u003d null)) \u0026\u0026 ((((spoon.reflect.code.CtFieldWrite) (parent)).getVariable()) !\u003d null)) \u0026\u0026 (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.STATIC))) \u0026\u0026 (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.FINAL));\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtThisAccess(spoon.reflect.code.CtThisAccess\u003cT\u003e thisAccess) {\n        try {\n            enterCtExpression(thisAccess);\n            // we only write qualified this when this is required\n            // this is good both in fully-qualified mode and in readable (with-imports) mode\n            // the implicit information is used for analysis (e.g. is visibility caused by implicit bugs?) but\n            // not for pretty-printing\n            spoon.reflect.code.CtTypeAccess target \u003d ((spoon.reflect.code.CtTypeAccess) (thisAccess.getTarget()));\n            spoon.reflect.reference.CtTypeReference targetType \u003d target.getAccessedType();\n            // readable mode as close as possible to the original code\n            if (thisAccess.isImplicit()) {\n                // write nothing, \"this\" is implicit and we unfortunately cannot always know\n                // what the good target is in JDTTreeBuilder\n                return;\n            }\n            // the simplest case: we always print \"this\" if we\u0027re in the top-level class,\n            // this is shorter (no qualified this), explicit, and less fragile wrt transformation\n            if ((targetType \u003d\u003d null) || (((thisAccess.getParent(spoon.reflect.declaration.CtType.class)) !\u003d null) \u0026\u0026 (thisAccess.getParent(spoon.reflect.declaration.CtType.class).isTopLevel()))) {\n                printer.writeKeyword(\"this\");\n                return;// still go through finally block below\n\n            }\n            // we cannot have fully-qualified this in anonymous classes\n            // we simply print \"this\" and it always works\n            // this has to come after the implicit test just before\n            if (targetType.isAnonymous()) {\n                printer.writeKeyword(\"this\");\n                return;\n            }\n            // complex case of qualified this\n            if (!(context.currentThis.isEmpty())) {\n                spoon.reflect.declaration.CtType lastType \u003d context.currentThis.peekFirst().type;\n                java.lang.String lastTypeQualifiedName \u003d lastType.getQualifiedName();\n                java.lang.String targetTypeQualifiedName \u003d targetType.getQualifiedName();\n                if (!(lastTypeQualifiedName.equals(targetTypeQualifiedName))) {\n                    if (!(targetType.isImplicit())) {\n                        visitCtTypeReferenceWithoutGenerics(targetType);\n                        printer.writeSeparator(\".\");\n                    }\n                    printer.writeKeyword(\"this\");\n                    return;\n                }\n            }\n            // the default super simple case only comes at the end\n            printer.writeKeyword(\"this\");\n        } finally {\n            exitCtExpression(thisAccess);\n        }\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtSuperAccess(spoon.reflect.code.CtSuperAccess\u003cT\u003e f) {\n        enterCtExpression(f);\n        if ((f.getTarget()) !\u003d null) {\n            scan(f.getTarget());\n            printer.writeSeparator(\".\");\n        }\n        printer.writeKeyword(\"super\");\n        exitCtExpression(f);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc comment) {\n        visitCtComment(comment);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag docTag) {\n        /* is not called during normal printing of java sources.\n        It can be called only when CtJavaDocTag has to be printed directly.\n        E.g. from CtJavaDocTag#toString\n        Write directly to PrinterHelper, because java doc tag is not a java token. Normally it is part of COMMENT token. */\n        spoon.reflect.visitor.CommentHelper.printJavaDocTag(printer.getPrinterHelper(), docTag);\n    }\n\n    @java.lang.Override\n    public void visitCtImport(spoon.reflect.declaration.CtImport ctImport) {\n        if ((ctImport.getImportKind()) !\u003d null) {\n            printer.writeKeyword(\"import\");\n            printer.writeSpace();\n            switch (ctImport.getImportKind()) {\n                case TYPE :\n                    visitCtTypeReference(((spoon.reflect.reference.CtTypeReference) (ctImport.getReference())));\n                    break;\n                case METHOD :\n                    printer.writeKeyword(\"static\");\n                    printer.writeSpace();\n                    visitCtExecutableReference(((spoon.reflect.reference.CtExecutableReference) (ctImport.getReference())));\n                    break;\n                case FIELD :\n                    printer.writeKeyword(\"static\");\n                    printer.writeSpace();\n                    visitCtFieldReference(((spoon.reflect.reference.CtFieldReference) (ctImport.getReference())));\n                    break;\n                case ALL_TYPES :\n                    visitCtPackageReference(((spoon.reflect.reference.CtPackageReference) (ctImport.getReference())));\n                    printer.writeSeparator(\".\");\n                    printer.writeIdentifier(\"*\");\n                    break;\n                case ALL_STATIC_MEMBERS :\n                    printer.writeKeyword(\"static\");\n                    printer.writeSpace();\n                    visitCtTypeReference(((spoon.reflect.reference.CtTypeReference) (ctImport.getReference())));\n                    break;\n            }\n            printer.writeSeparator(\";\");\n            printer.writeln();\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtModule(spoon.reflect.declaration.CtModule module) {\n        enter(module);\n        if (module.isOpenModule()) {\n            printer.writeKeyword(\"open\").writeSpace();\n        }\n        printer.writeKeyword(\"module\").writeSpace().writeIdentifier(module.getSimpleName());\n        printer.writeSpace().writeSeparator(\"{\").incTab().writeln();\n        for (spoon.reflect.declaration.CtModuleDirective moduleDirective : module.getModuleDirectives()) {\n            scan(moduleDirective);\n        }\n        printer.decTab().writeSeparator(\"}\");\n        exit(module);\n    }\n\n    @java.lang.Override\n    public void visitCtModuleReference(spoon.reflect.reference.CtModuleReference moduleReference) {\n        printer.writeIdentifier(moduleReference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public void visitCtPackageExport(spoon.reflect.declaration.CtPackageExport moduleExport) {\n        if (moduleExport.isOpenedPackage()) {\n            printer.writeKeyword(\"opens\");\n        }else {\n            printer.writeKeyword(\"exports\");\n        }\n        printer.writeSpace();\n        visitCtPackageReference(moduleExport.getPackageReference());\n        if (!(moduleExport.getTargetExport().isEmpty())) {\n            this.elementPrinterHelper.printList(moduleExport.getTargetExport(), null, false, \" to\", true, false, \",\", true, false, null, ( moduleReference) -\u003e scan(moduleReference));\n        }\n        printer.writeSeparator(\";\").writeln();\n    }\n\n    @java.lang.Override\n    public void visitCtModuleRequirement(spoon.reflect.declaration.CtModuleRequirement moduleRequirement) {\n        printer.writeKeyword(\"requires\").writeSpace();\n        if (!(moduleRequirement.getRequiresModifiers().isEmpty())) {\n            this.elementPrinterHelper.printList(moduleRequirement.getRequiresModifiers(), null, false, null, false, false, \" \", false, false, \" \", ( modifier) -\u003e printer.writeKeyword(modifier.name().toLowerCase()));\n        }\n        scan(moduleRequirement.getModuleReference());\n        printer.writeSeparator(\";\").writeln();\n    }\n\n    @java.lang.Override\n    public void visitCtProvidedService(spoon.reflect.declaration.CtProvidedService moduleProvidedService) {\n        printer.writeKeyword(\"provides\").writeSpace();\n        scan(moduleProvidedService.getServiceType());\n        this.elementPrinterHelper.printList(moduleProvidedService.getImplementationTypes(), null, false, \" with\", true, false, \",\", true, false, null, ( implementations) -\u003e scan(implementations));\n        printer.writeSeparator(\";\").writeln();\n    }\n\n    @java.lang.Override\n    public void visitCtUsedService(spoon.reflect.declaration.CtUsedService usedService) {\n        printer.writeKeyword(\"uses\").writeSpace();\n        scan(usedService.getServiceType());\n        printer.writeSeparator(\";\").writeln();\n    }\n\n    @java.lang.Override\n    public void visitCtComment(spoon.reflect.code.CtComment comment) {\n        if ((!(env.isCommentsEnabled())) \u0026\u0026 ((context.elementStack.size()) \u003e 1)) {\n            return;\n        }\n        printer.writeComment(comment);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtAnnotationFieldAccess(spoon.reflect.code.CtAnnotationFieldAccess\u003cT\u003e annotationFieldAccess) {\n        enterCtExpression(annotationFieldAccess);\n        try (spoon.reflect.visitor.PrintingContext.Writable _context \u003d context.modify()) {\n            if ((annotationFieldAccess.getTarget()) !\u003d null) {\n                scan(annotationFieldAccess.getTarget());\n                printer.writeSeparator(\".\");\n                _context.ignoreStaticAccess(true);\n            }\n            _context.ignoreGenerics(true);\n            scan(annotationFieldAccess.getVariable());\n            printer.writeSeparator(\"(\").writeSeparator(\")\");\n        }\n        exitCtExpression(annotationFieldAccess);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtFieldReference(spoon.reflect.reference.CtFieldReference\u003cT\u003e reference) {\n        boolean isStatic \u003d (\"class\".equals(reference.getSimpleName())) || ((!(\"super\".equals(reference.getSimpleName()))) \u0026\u0026 (reference.isStatic()));\n        boolean printType \u003d true;\n        if ((reference.isFinal()) \u0026\u0026 (reference.isStatic())) {\n            spoon.reflect.reference.CtTypeReference\u003c?\u003e declTypeRef \u003d reference.getDeclaringType();\n            if (declTypeRef.isAnonymous()) {\n                // never print anonymous class ref\n                printType \u003d false;\n            }else {\n                if (context.isInCurrentScope(declTypeRef)) {\n                    // do not printType if we are in scope of that type\n                    printType \u003d false;\n                }\n            }\n        }\n        if ((isStatic \u0026\u0026 printType) \u0026\u0026 (!(context.ignoreStaticAccess()))) {\n            try (spoon.reflect.visitor.PrintingContext.Writable _context \u003d context.modify().ignoreGenerics(true)) {\n                scan(reference.getDeclaringType());\n            }\n            printer.writeSeparator(\".\");\n        }\n        if (\"class\".equals(reference.getSimpleName())) {\n            printer.writeKeyword(\"class\");\n        }else {\n            printer.writeIdentifier(reference.getSimpleName());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtFor(spoon.reflect.code.CtFor forLoop) {\n        enterCtStatement(forLoop);\n        printer.writeKeyword(\"for\").writeSpace().writeSeparator(\"(\");\n        java.util.List\u003cspoon.reflect.code.CtStatement\u003e st \u003d forLoop.getForInit();\n        if (!(st.isEmpty())) {\n            try (spoon.reflect.visitor.PrintingContext.Writable _context \u003d context.modify().isFirstForVariable(true)) {\n                scan(st.get(0));\n            }\n        }\n        if ((st.size()) \u003e 1) {\n            try (spoon.reflect.visitor.PrintingContext.Writable _context \u003d context.modify().isNextForVariable(true)) {\n                for (int i \u003d 1; i \u003c (st.size()); i++) {\n                    printer.writeSeparator(\",\").writeSpace();\n                    scan(st.get(i));\n                }\n            }\n        }\n        printer.writeSeparator(\";\").writeSpace();\n        scan(forLoop.getExpression());\n        printer.writeSeparator(\";\");\n        if (!(forLoop.getForUpdate().isEmpty())) {\n            printer.writeSpace();\n        }\n        elementPrinterHelper.printList(forLoop.getForUpdate(), null, false, null, false, true, \",\", true, false, null, ( s) -\u003e scan(s));\n        printer.writeSeparator(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());\n        exitCtStatement(forLoop);\n    }\n\n    @java.lang.Override\n    public void visitCtForEach(spoon.reflect.code.CtForEach foreach) {\n        enterCtStatement(foreach);\n        printer.writeKeyword(\"for\").writeSpace().writeSeparator(\"(\");\n        scan(foreach.getVariable());\n        printer.writeSpace().writeSeparator(\":\").writeSpace();\n        scan(foreach.getExpression());\n        printer.writeSeparator(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());\n        exitCtStatement(foreach);\n    }\n\n    @java.lang.Override\n    public void visitCtIf(spoon.reflect.code.CtIf ifElement) {\n        enterCtStatement(ifElement);\n        printer.writeKeyword(\"if\").writeSpace().writeSeparator(\"(\");\n        scan(ifElement.getCondition());\n        printer.writeSeparator(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(ifElement.getThenStatement());\n        if ((ifElement.getElseStatement()) !\u003d null) {\n            java.util.List\u003cspoon.reflect.code.CtComment\u003e comments \u003d elementPrinterHelper.getComments(ifElement, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            for (spoon.reflect.code.CtComment comment : comments) {\n                spoon.reflect.cu.SourcePosition thenPosition \u003d (ifElement.getThenStatement().getPosition().isValidPosition()) ? ifElement.getThenStatement().getPosition() : ((spoon.reflect.code.CtBlock) (ifElement.getThenStatement())).getStatement(0).getPosition();\n                if ((comment.getPosition().getSourceStart()) \u003e (thenPosition.getSourceEnd())) {\n                    elementPrinterHelper.writeComment(comment);\n                }\n            }\n            printer.writeKeyword(\"else\");\n            elementPrinterHelper.writeIfOrLoopBlock(ifElement.getElseStatement());\n        }\n        exitCtStatement(ifElement);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtInterface(spoon.reflect.declaration.CtInterface\u003cT\u003e intrface) {\n        visitCtType(intrface);\n        printer.writeKeyword(\"interface\").writeSpace().writeIdentifier(intrface.getSimpleName());\n        if ((intrface.getFormalCtTypeParameters()) !\u003d null) {\n            elementPrinterHelper.writeFormalTypeParameters(intrface);\n        }\n        if (!(intrface.getSuperInterfaces().isEmpty())) {\n            elementPrinterHelper.printList(intrface.getSuperInterfaces(), \"extends\", false, null, false, true, \",\", true, false, null, ( ref) -\u003e scan(ref));\n        }\n        context.pushCurrentThis(intrface);\n        printer.writeSpace().writeSeparator(\"{\").incTab();\n        // Content\n        elementPrinterHelper.writeElementList(intrface.getTypeMembers());\n        printer.decTab().writeSeparator(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtInvocation(spoon.reflect.code.CtInvocation\u003cT\u003e invocation) {\n        enterCtStatement(invocation);\n        enterCtExpression(invocation);\n        if (invocation.getExecutable().isConstructor()) {\n            // It\u0027s a constructor (super or this)\n            elementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());\n            spoon.reflect.declaration.CtType\u003c?\u003e parentType;\n            try {\n                parentType \u003d invocation.getParent(spoon.reflect.declaration.CtType.class);\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n                parentType \u003d null;\n            }\n            if (((parentType !\u003d null) \u0026\u0026 ((parentType.getQualifiedName()) !\u003d null)) \u0026\u0026 (parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName()))) {\n                printer.writeKeyword(\"this\");\n            }else {\n                if (((invocation.getTarget()) !\u003d null) \u0026\u0026 (!(invocation.getTarget().isImplicit()))) {\n                    scan(invocation.getTarget());\n                    printer.writeSeparator(\".\");\n                }\n                printer.writeKeyword(\"super\");\n            }\n        }else {\n            // It\u0027s a method invocation\n            boolean isImported \u003d this.isImported(invocation.getExecutable());\n            if (!isImported) {\n                try (spoon.reflect.visitor.PrintingContext.Writable _context \u003d context.modify()) {\n                    if ((invocation.getTarget()) instanceof spoon.reflect.code.CtTypeAccess) {\n                        _context.ignoreGenerics(true);\n                    }\n                    if (((invocation.getTarget()) !\u003d null) \u0026\u0026 (!(invocation.getTarget().isImplicit()))) {\n                        scan(invocation.getTarget());\n                        printer.writeSeparator(\".\");\n                    }\n                }\n            }\n            elementPrinterHelper.writeActualTypeArguments(invocation);\n            if (env.isPreserveLineNumbers()) {\n                getPrinterHelper().adjustStartPosition(invocation);\n            }\n            printer.writeIdentifier(invocation.getExecutable().getSimpleName());\n        }\n        elementPrinterHelper.printList(invocation.getArguments(), null, false, \"(\", false, false, \",\", true, false, \")\", ( e) -\u003e scan(e));\n        exitCtExpression(invocation);\n        exitCtStatement(invocation);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtLiteral(spoon.reflect.code.CtLiteral\u003cT\u003e literal) {\n        enterCtExpression(literal);\n        printer.writeLiteral(spoon.reflect.visitor.LiteralHelper.getLiteralToken(literal));\n        exitCtExpression(literal);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable\u003cT\u003e localVariable) {\n        enterCtStatement(localVariable);\n        if (env.isPreserveLineNumbers()) {\n            getPrinterHelper().adjustStartPosition(localVariable);\n        }\n        if (!(context.isNextForVariable())) {\n            elementPrinterHelper.writeModifiers(localVariable);\n            if ((localVariable.isInferred()) \u0026\u0026 ((this.env.getComplianceLevel()) \u003e\u003d 10)) {\n                getPrinterTokenWriter().writeKeyword(\"var\");\n            }else {\n                scan(localVariable.getType());\n            }\n            printer.writeSpace();\n        }\n        printer.writeIdentifier(localVariable.getSimpleName());\n        if ((localVariable.getDefaultExpression()) !\u003d null) {\n            printer.writeSpace().writeOperator(\"\u003d\").writeSpace();\n            scan(localVariable.getDefaultExpression());\n        }\n        exitCtStatement(localVariable);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtLocalVariableReference(spoon.reflect.reference.CtLocalVariableReference\u003cT\u003e reference) {\n        printer.writeIdentifier(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable\u003cT\u003e catchVariable) {\n        if (env.isPreserveLineNumbers()) {\n            getPrinterHelper().adjustStartPosition(catchVariable);\n        }\n        elementPrinterHelper.writeModifiers(catchVariable);\n        scan(catchVariable.getType());\n        printer.writeSpace();\n        printer.writeIdentifier(catchVariable.getSimpleName());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtCatchVariableReference(spoon.reflect.reference.CtCatchVariableReference\u003cT\u003e reference) {\n        printer.writeIdentifier(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtMethod(spoon.reflect.declaration.CtMethod\u003cT\u003e m) {\n        elementPrinterHelper.writeComment(m, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        elementPrinterHelper.visitCtNamedElement(m, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(m);\n        elementPrinterHelper.writeFormalTypeParameters(m);\n        if (!(m.getFormalCtTypeParameters().isEmpty())) {\n            printer.writeSpace();\n        }\n        try (spoon.reflect.visitor.PrintingContext.Writable _context \u003d context.modify().ignoreGenerics(false)) {\n            scan(m.getType());\n        }\n        printer.writeSpace();\n        printer.writeIdentifier(m.getSimpleName());\n        elementPrinterHelper.writeExecutableParameters(m);\n        elementPrinterHelper.writeThrowsClause(m);\n        if ((m.getBody()) !\u003d null) {\n            printer.writeSpace();\n            scan(m.getBody());\n            if (m.getBody().getPosition().isValidPosition()) {\n                if ((m.getBody().getPosition().getCompilationUnit()) \u003d\u003d (sourceCompilationUnit)) {\n                    if ((m.getBody().getStatements().isEmpty()) || (!((m.getBody().getStatements().get(((m.getBody().getStatements().size()) - 1))) instanceof spoon.reflect.code.CtReturn))) {\n                        getPrinterHelper().putLineNumberMapping(m.getBody().getPosition().getEndLine());\n                    }\n                }else {\n                    getPrinterHelper().undefineLine();\n                }\n            }else {\n                getPrinterHelper().undefineLine();\n            }\n        }else {\n            printer.writeSeparator(\";\");\n        }\n        elementPrinterHelper.writeComment(m, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod\u003cT\u003e annotationMethod) {\n        elementPrinterHelper.writeComment(annotationMethod);\n        elementPrinterHelper.visitCtNamedElement(annotationMethod, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(annotationMethod);\n        scan(annotationMethod.getType());\n        printer.writeSpace();\n        printer.writeIdentifier(annotationMethod.getSimpleName());\n        printer.writeSeparator(\"(\").writeSeparator(\")\");\n        if ((annotationMethod.getDefaultExpression()) !\u003d null) {\n            printer.writeSpace().writeKeyword(\"default\").writeSpace();\n            scan(annotationMethod.getDefaultExpression());\n        }\n        printer.writeSeparator(\";\");\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public \u003cT\u003e void visitCtNewArray(spoon.reflect.code.CtNewArray\u003cT\u003e newArray) {\n        enterCtExpression(newArray);\n        boolean isNotInAnnotation;\n        try {\n            isNotInAnnotation \u003d ((newArray.getParent(spoon.reflect.declaration.CtAnnotationType.class)) \u003d\u003d null) \u0026\u0026 ((newArray.getParent(spoon.reflect.declaration.CtAnnotation.class)) \u003d\u003d null);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            isNotInAnnotation \u003d true;\n        }\n        if (isNotInAnnotation) {\n            spoon.reflect.reference.CtTypeReference\u003c?\u003e ref \u003d newArray.getType();\n            if (ref !\u003d null) {\n                printer.writeKeyword(\"new\").writeSpace();\n            }\n            try (spoon.reflect.visitor.PrintingContext.Writable _context \u003d context.modify().skipArray(true)) {\n                scan(ref);\n            }\n            for (int i \u003d 0; ref instanceof spoon.reflect.reference.CtArrayTypeReference; i++) {\n                printer.writeSeparator(\"[\");\n                if ((newArray.getDimensionExpressions().size()) \u003e i) {\n                    spoon.reflect.code.CtExpression\u003cjava.lang.Integer\u003e e \u003d newArray.getDimensionExpressions().get(i);\n                    scan(e);\n                }\n                printer.writeSeparator(\"]\");\n                ref \u003d ((spoon.reflect.reference.CtArrayTypeReference) (ref)).getComponentType();\n            }\n        }\n        if (newArray.getDimensionExpressions().isEmpty()) {\n            elementPrinterHelper.printList(newArray.getElements(), null, false, \"{\", true, false, \",\", true, true, \"}\", ( e) -\u003e scan(e));\n            elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n        }\n        elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        exitCtExpression(newArray);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall\u003cT\u003e ctConstructorCall) {\n        enterCtStatement(ctConstructorCall);\n        enterCtExpression(ctConstructorCall);\n        printConstructorCall(ctConstructorCall);\n        exitCtExpression(ctConstructorCall);\n        exitCtStatement(ctConstructorCall);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtNewClass(spoon.reflect.code.CtNewClass\u003cT\u003e newClass) {\n        enterCtStatement(newClass);\n        enterCtExpression(newClass);\n        printConstructorCall(newClass);\n        scan(newClass.getAnonymousClass());\n        exitCtExpression(newClass);\n        exitCtStatement(newClass);\n    }\n\n    private \u003cT\u003e void printConstructorCall(spoon.reflect.code.CtConstructorCall\u003cT\u003e ctConstructorCall) {\n        try (spoon.reflect.visitor.PrintingContext.Writable _context \u003d context.modify()) {\n            if ((ctConstructorCall.getTarget()) !\u003d null) {\n                scan(ctConstructorCall.getTarget());\n                printer.writeSeparator(\".\");\n                _context.ignoreEnclosingClass(true);\n            }\n            if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {\n                _context.ignoreEnclosingClass(true);\n            }\n            printer.writeKeyword(\"new\").writeSpace();\n            if (!(ctConstructorCall.getActualTypeArguments().isEmpty())) {\n                elementPrinterHelper.writeActualTypeArguments(ctConstructorCall);\n            }\n            scan(ctConstructorCall.getType());\n        }\n        elementPrinterHelper.printList(ctConstructorCall.getArguments(), null, false, \"(\", false, false, \",\", true, false, \")\", ( exp) -\u003e scan(exp));\n    }\n\n    /**\n    JDT doesn\u0027t support \u003ccode\u003enew Foo\u003cK\u003e.Bar()\u003c/code\u003e. To avoid reprinting this kind of type reference,\n    we check that the reference has a declaring type with generics.\n    See https://bugs.eclipse.org/bugs/show_bug.cgi?id\u003d474593\n\n    @param reference Type reference concerned by the bug.\n    @return true if a declaring type has generic types.\n     *\n     * @param reference *   Type reference concerned by the bug.\n     * @return true if a declaring type has generic types.\n     * @param reference *   Type reference concerned by the bug.\n     * @return true if a declaring type has generic types.\n     * @param reference *   Type reference concerned by the bug.\n     * @return true if a declaring type has generic types.\n     * @param reference *   Type reference concerned by the bug.\n     * @return true if a declaring type has generic types.\n     * @param reference *   Type reference concerned by the bug.\n     * @return true if a declaring type has generic types.\n     * @param reference *   Type reference concerned by the bug.\n     * @return true if a declaring type has generic types.\n     */\n    private \u003cT\u003e boolean hasDeclaringTypeWithGenerics(spoon.reflect.reference.CtTypeReference\u003cT\u003e reference) {\n        // We don\u0027t have a declaring type, it can\u0027t have generics.\n        if (reference \u003d\u003d null) {\n            return false;\n        }\n        // If the declaring type isn\u0027t a type, we don\u0027t need this hack.\n        if ((reference.getDeclaringType()) \u003d\u003d null) {\n            return false;\n        }\n        // If current reference is a class declared in a method, we don\u0027t need this hack.\n        if (reference.isLocalType()) {\n            return false;\n        }\n        // If declaring type have generics, we return true.\n        if (!(reference.getDeclaringType().getActualTypeArguments().isEmpty())) {\n            return true;\n        }\n        // Checks if the declaring type has generic types.\n        return hasDeclaringTypeWithGenerics(reference.getDeclaringType());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtLambda(spoon.reflect.code.CtLambda\u003cT\u003e lambda) {\n        enterCtExpression(lambda);\n        elementPrinterHelper.printList(lambda.getParameters(), null, false, \"(\", false, false, \",\", false, false, \")\", ( parameter) -\u003e scan(parameter));\n        printer.writeSpace();\n        printer.writeSeparator(\"-\u003e\");\n        printer.writeSpace();\n        if ((lambda.getBody()) !\u003d null) {\n            scan(lambda.getBody());\n        }else {\n            scan(lambda.getExpression());\n        }\n        exitCtExpression(lambda);\n    }\n\n    @java.lang.Override\n    public \u003cT, E extends spoon.reflect.code.CtExpression\u003c?\u003e\u003e void visitCtExecutableReferenceExpression(spoon.reflect.code.CtExecutableReferenceExpression\u003cT, E\u003e expression) {\n        enterCtExpression(expression);\n        try (spoon.reflect.visitor.PrintingContext.Writable _context \u003d context.modify()) {\n            if (expression.getExecutable().isStatic()) {\n                _context.ignoreGenerics(true);\n            }\n            scan(expression.getTarget());\n        }\n        printer.writeSeparator(\"::\");\n        if (expression.getExecutable().isConstructor()) {\n            printer.writeKeyword(\"new\");\n        }else {\n            printer.writeIdentifier(expression.getExecutable().getSimpleName());\n        }\n        exitCtExpression(expression);\n    }\n\n    @java.lang.Override\n    public \u003cT, A extends T\u003e void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment\u003cT, A\u003e assignment) {\n        enterCtStatement(assignment);\n        enterCtExpression(assignment);\n        scan(assignment.getAssigned());\n        printer.writeSpace();\n        // the operators like +\u003d, *\u003d are sent as one operator token\n        printer.writeOperator(((spoon.reflect.visitor.OperatorHelper.getOperatorText(assignment.getKind())) + \"\u003d\"));\n        printer.writeSpace();\n        scan(assignment.getAssignment());\n        exitCtExpression(assignment);\n        exitCtStatement(assignment);\n    }\n\n    @java.lang.Override\n    public void visitCtPackage(spoon.reflect.declaration.CtPackage ctPackage) {\n        if (!(ctPackage.isUnnamedPackage())) {\n            elementPrinterHelper.writePackageLine(ctPackage.getQualifiedName());\n        }else {\n            printer.writeComment(ctPackage.getFactory().createComment(\"default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon\u003d unnamed package)\", spoon.reflect.code.CtComment.CommentType.INLINE)).writeln();\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtPackageReference(spoon.reflect.reference.CtPackageReference reference) {\n        elementPrinterHelper.writeQualifiedName(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtParameter(spoon.reflect.declaration.CtParameter\u003cT\u003e parameter) {\n        elementPrinterHelper.writeComment(parameter);\n        elementPrinterHelper.writeAnnotations(parameter);\n        elementPrinterHelper.writeModifiers(parameter);\n        if (parameter.isVarArgs()) {\n            scan(((spoon.reflect.reference.CtArrayTypeReference\u003cT\u003e) (parameter.getType())).getComponentType());\n            printer.writeSeparator(\"...\");\n        }else {\n            scan(parameter.getType());\n        }\n        printer.writeSpace();\n        printer.writeIdentifier(parameter.getSimpleName());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtParameterReference(spoon.reflect.reference.CtParameterReference\u003cT\u003e reference) {\n        printer.writeIdentifier(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public \u003cR\u003e void visitCtReturn(spoon.reflect.code.CtReturn\u003cR\u003e returnStatement) {\n        enterCtStatement(returnStatement);\n        printer.writeKeyword(\"return\");\n        // checkstyle wants \"return;\" and not \"return ;\"\n        if ((returnStatement.getReturnedExpression()) !\u003d null) {\n            printer.writeSpace();\n        }\n        scan(returnStatement.getReturnedExpression());\n        exitCtStatement(returnStatement);\n    }\n\n    private \u003cT\u003e void visitCtType(spoon.reflect.declaration.CtType\u003cT\u003e type) {\n        elementPrinterHelper.writeComment(type, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        getPrinterHelper().mapLine(type, sourceCompilationUnit);\n        if (type.isTopLevel()) {\n            context.currentTopLevel \u003d type;\n        }\n        elementPrinterHelper.visitCtNamedElement(type, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(type);\n    }\n\n    @java.lang.Override\n    public void visitCtStatementList(spoon.reflect.code.CtStatementList statements) {\n        for (spoon.reflect.code.CtStatement s : statements.getStatements()) {\n            scan(s);\n        }\n    }\n\n    @java.lang.Override\n    public \u003cE\u003e void visitCtSwitch(spoon.reflect.code.CtSwitch\u003cE\u003e switchStatement) {\n        enterCtStatement(switchStatement);\n        printer.writeKeyword(\"switch\").writeSpace().writeSeparator(\"(\");\n        scan(switchStatement.getSelector());\n        printer.writeSeparator(\")\").writeSpace().writeSeparator(\"{\").incTab();\n        for (spoon.reflect.code.CtCase\u003c?\u003e c : switchStatement.getCases()) {\n            printer.writeln();\n            scan(c);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.decTab().writeSeparator(\"}\");\n        }else {\n            printer.decTab().writeln().writeSeparator(\"}\");\n        }\n        exitCtStatement(switchStatement);\n    }\n\n    @java.lang.Override\n    public void visitCtSynchronized(spoon.reflect.code.CtSynchronized synchro) {\n        enterCtStatement(synchro);\n        printer.writeKeyword(\"synchronized\");\n        if ((synchro.getExpression()) !\u003d null) {\n            printer.writeSeparator(\"(\");\n            scan(synchro.getExpression());\n            printer.writeSeparator(\")\").writeSpace();\n        }\n        scan(synchro.getBlock());\n        exitCtStatement(synchro);\n    }\n\n    @java.lang.Override\n    public void visitCtThrow(spoon.reflect.code.CtThrow throwStatement) {\n        enterCtStatement(throwStatement);\n        printer.writeKeyword(\"throw\").writeSpace();\n        scan(throwStatement.getThrownExpression());\n        exitCtStatement(throwStatement);\n    }\n\n    @java.lang.Override\n    public void visitCtTry(spoon.reflect.code.CtTry tryBlock) {\n        enterCtStatement(tryBlock);\n        printer.writeKeyword(\"try\").writeSpace();\n        scan(tryBlock.getBody());\n        for (spoon.reflect.code.CtCatch c : tryBlock.getCatchers()) {\n            scan(c);\n        }\n        if ((tryBlock.getFinalizer()) !\u003d null) {\n            printer.writeSpace().writeKeyword(\"finally\").writeSpace();\n            scan(tryBlock.getFinalizer());\n        }\n        exitCtStatement(tryBlock);\n    }\n\n    @java.lang.Override\n    public void visitCtTryWithResource(spoon.reflect.code.CtTryWithResource tryWithResource) {\n        enterCtStatement(tryWithResource);\n        printer.writeKeyword(\"try\").writeSpace();\n        if (((tryWithResource.getResources()) !\u003d null) \u0026\u0026 (!(tryWithResource.getResources().isEmpty()))) {\n            elementPrinterHelper.printList(tryWithResource.getResources(), null, false, \"(\", false, false, \";\", false, false, \")\", ( r) -\u003e scan(r));\n        }\n        printer.writeSpace();\n        scan(tryWithResource.getBody());\n        for (spoon.reflect.code.CtCatch c : tryWithResource.getCatchers()) {\n            scan(c);\n        }\n        if ((tryWithResource.getFinalizer()) !\u003d null) {\n            printer.writeSpace().writeKeyword(\"finally\").writeSpace();\n            scan(tryWithResource.getFinalizer());\n        }\n        exitCtStatement(tryWithResource);\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(ref);\n        if (printQualified(ref)) {\n            elementPrinterHelper.writeQualifiedName(ref.getQualifiedName());\n        }else {\n            printer.writeIdentifier(ref.getSimpleName());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {\n        if (wildcardReference.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(wildcardReference);\n        printer.writeSeparator(\"?\");\n        // we ignore printing \"extends Object\" except if it\u0027s explicit\n        if ((!(wildcardReference.isDefaultBoundingType())) || (!(wildcardReference.getBoundingType().isImplicit()))) {\n            if (wildcardReference.isUpper()) {\n                printer.writeSpace().writeKeyword(\"extends\").writeSpace();\n            }else {\n                printer.writeSpace().writeKeyword(\"super\").writeSpace();\n            }\n            scan(wildcardReference.getBoundingType());\n        }\n    }\n\n    private boolean printQualified(spoon.reflect.reference.CtTypeReference\u003c?\u003e ref) {\n        // or that we are in java.lang\n        if ((importsContext.isImported(ref))// If my.pkg.Something is imported\n         || (((this.env.isAutoImports()) \u0026\u0026 ((ref.getPackage()) !\u003d null)) \u0026\u0026 (\"java.lang\".equals(ref.getPackage().getSimpleName())))) {\n            for (spoon.reflect.visitor.CacheBasedConflictFinder typeContext : context.currentThis) {\n                // A) we are in the context of a class which is also called \"Something\",\n                if ((typeContext.getSimpleName().equals(ref.getSimpleName())) \u0026\u0026 (!(java.util.Objects.equals(typeContext.getPackage(), ref.getPackage())))) {\n                    return true;\n                }\n                // B) we are in the context of a class which defines field which is also called \"Something\",\n                // we should still use qualified version my.pkg.Something\n                // fix of #2369\n                if ((typeContext.hasFieldConflict(ref.getSimpleName())) || (typeContext.hasNestedTypeConflict(ref.getSimpleName()))) {\n                    return true;\n                }\n            }\n            return false;\n        }else {\n            return true;\n        }\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtIntersectionTypeReference(spoon.reflect.reference.CtIntersectionTypeReference\u003cT\u003e reference) {\n        elementPrinterHelper.printList(reference.getBounds(), null, false, null, false, true, \"\u0026\", true, false, null, ( bound) -\u003e scan(bound));\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtTypeReference(spoon.reflect.reference.CtTypeReference\u003cT\u003e ref) {\n        visitCtTypeReference(ref, true);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtTypeAccess(spoon.reflect.code.CtTypeAccess\u003cT\u003e typeAccess) {\n        if (typeAccess.isImplicit()) {\n            return;\n        }\n        enterCtExpression(typeAccess);\n        scan(typeAccess.getAccessedType());\n        exitCtExpression(typeAccess);\n    }\n\n    private void visitCtTypeReferenceWithoutGenerics(spoon.reflect.reference.CtTypeReference\u003c?\u003e ref) {\n        visitCtTypeReference(ref, false);\n    }\n\n    private void visitCtTypeReference(spoon.reflect.reference.CtTypeReference\u003c?\u003e ref, boolean withGenerics) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        if (ref.isPrimitive()) {\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.writeKeyword(ref.getSimpleName());\n            return;\n        }\n        boolean isInner \u003d (ref.getDeclaringType()) !\u003d null;\n        if (isInner) {\n            if ((!(context.ignoreEnclosingClass())) \u0026\u0026 (!(ref.isLocalType()))) {\n                // compute visible type which can be used to print access path to ref\n                spoon.reflect.reference.CtTypeReference\u003c?\u003e accessType \u003d ref.getAccessType();\n                if (!(accessType.isAnonymous())) {\n                    try (spoon.reflect.visitor.PrintingContext.Writable _context \u003d context.modify()) {\n                        if (!withGenerics) {\n                            _context.ignoreGenerics(true);\n                        }\n                        scan(accessType);\n                    }\n                    printer.writeSeparator(\".\");\n                }\n            }\n            // ?? are these annotations on correct place ??\n            elementPrinterHelper.writeAnnotations(ref);\n            if (ref.isLocalType()) {\n                printer.writeIdentifier(ref.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            }else {\n                printer.writeIdentifier(ref.getSimpleName());\n            }\n        }else {\n            if (((ref.getPackage()) !\u003d null) \u0026\u0026 (printQualified(ref))) {\n                if (!(ref.getPackage().isUnnamedPackage())) {\n                    scan(ref.getPackage());\n                    printer.writeSeparator(spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.writeIdentifier(ref.getSimpleName());\n        }\n        if (withGenerics \u0026\u0026 (!(context.ignoreGenerics()))) {\n            try (spoon.reflect.visitor.PrintingContext.Writable _context \u003d context.modify().ignoreEnclosingClass(false)) {\n                elementPrinterHelper.writeActualTypeArguments(ref);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator\u003cT\u003e operator) {\n        enterCtStatement(operator);\n        enterCtExpression(operator);\n        spoon.reflect.code.UnaryOperatorKind op \u003d operator.getKind();\n        if (spoon.reflect.visitor.OperatorHelper.isPrefixOperator(op)) {\n            printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(op));\n        }\n        scan(operator.getOperand());\n        if (spoon.reflect.visitor.OperatorHelper.isSufixOperator(op)) {\n            printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(op));\n        }\n        exitCtExpression(operator);\n        exitCtStatement(operator);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtVariableRead(spoon.reflect.code.CtVariableRead\u003cT\u003e variableRead) {\n        enterCtExpression(variableRead);\n        printer.writeIdentifier(variableRead.getVariable().getSimpleName());\n        exitCtExpression(variableRead);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtVariableWrite(spoon.reflect.code.CtVariableWrite\u003cT\u003e variableWrite) {\n        enterCtExpression(variableWrite);\n        printer.writeIdentifier(variableWrite.getVariable().getSimpleName());\n        exitCtExpression(variableWrite);\n    }\n\n    @java.lang.Override\n    public void visitCtWhile(spoon.reflect.code.CtWhile whileLoop) {\n        enterCtStatement(whileLoop);\n        printer.writeKeyword(\"while\").writeSpace().writeSeparator(\"(\");\n        scan(whileLoop.getLoopingExpression());\n        printer.writeSeparator(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());\n        exitCtStatement(whileLoop);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression\u003cT\u003e expression) {\n        elementPrinterHelper.writeComment(expression);\n        printer.writeCodeSnippet(expression.getValue());\n    }\n\n    @java.lang.Override\n    public void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement statement) {\n        enterCtStatement(statement);\n        printer.writeCodeSnippet(statement.getValue());\n        exitCtStatement(statement);\n    }\n\n    public spoon.reflect.visitor.ElementPrinterHelper getElementPrinterHelper() {\n        return elementPrinterHelper;\n    }\n\n    public spoon.reflect.visitor.PrintingContext getContext() {\n        return context;\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtUnboundVariableReference(spoon.reflect.reference.CtUnboundVariableReference\u003cT\u003e reference) {\n        printer.writeIdentifier(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public java.lang.String printPackageInfo(spoon.reflect.declaration.CtPackage pack) {\n        reset();\n        elementPrinterHelper.writeComment(pack);\n        // we need to compute imports only for annotations\n        // we don\u0027t want to get all imports coming from content of package\n        for (spoon.reflect.declaration.CtAnnotation annotation : pack.getAnnotations()) {\n            this.importsContext.computeImports(annotation);\n        }\n        elementPrinterHelper.writeAnnotations(pack);\n        if (!(pack.isUnnamedPackage())) {\n            elementPrinterHelper.writePackageLine(pack.getQualifiedName());\n        }\n        elementPrinterHelper.writeImports(this.importsContext.getAllImports());\n        return printer.getPrinterHelper().toString();\n    }\n\n    @java.lang.Override\n    public java.lang.String printModuleInfo(spoon.reflect.declaration.CtModule module) {\n        reset();\n        scan(module);\n        return this.getResult();\n    }\n\n    @java.lang.Override\n    public java.lang.String getResult() {\n        return printer.getPrinterHelper().toString();\n    }\n\n    private void reset() {\n        printer.reset();\n        context \u003d new spoon.reflect.visitor.PrintingContext();\n        if (env.isAutoImports()) {\n            this.importsContext \u003d new spoon.reflect.visitor.ImportScannerImpl();\n        }else {\n            this.importsContext \u003d new spoon.reflect.visitor.MinimalImportScanner();\n        }\n    }\n\n    /**\n    Write the compilation unit header.\n     */\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter writeHeader(java.util.List\u003cspoon.reflect.declaration.CtType\u003c?\u003e\u003e types, java.util.Collection\u003cspoon.reflect.declaration.CtImport\u003e imports) {\n        elementPrinterHelper.writeHeader(types, imports);\n        return this;\n    }\n\n    /**\n    Write the compilation unit footer.\n     */\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter writeFooter(java.util.List\u003cspoon.reflect.declaration.CtType\u003c?\u003e\u003e types) {\n        elementPrinterHelper.writeFooter(types);\n        return this;\n    }\n\n    @java.lang.Override\n    public void calculate(spoon.reflect.cu.CompilationUnit sourceCompilationUnit, java.util.List\u003cspoon.reflect.declaration.CtType\u003c?\u003e\u003e types) {\n        // reset the importsContext to avoid errors with multiple CU\n        reset();\n        this.sourceCompilationUnit \u003d sourceCompilationUnit;\n        this.imports \u003d new java.util.HashSet\u003c\u003e();\n        if (sourceCompilationUnit !\u003d null) {\n            this.importsContext.initWithImports(sourceCompilationUnit.getImports());\n        }\n        for (spoon.reflect.declaration.CtType\u003c?\u003e t : types) {\n            imports.addAll(computeImports(t));\n        }\n        this.writeHeader(types, imports);\n        printTypes(types);\n    }\n\n    protected void printTypes(java.util.List\u003cspoon.reflect.declaration.CtType\u003c?\u003e\u003e types) {\n        for (spoon.reflect.declaration.CtType\u003c?\u003e t : types) {\n            scan(t);\n            if (!(env.isPreserveLineNumbers())) {\n                // saving lines and chars\n                printer.writeln().writeln();\n            }else {\n                getPrinterHelper().adjustEndPosition(t);\n            }\n        }\n        this.writeFooter(types);\n    }\n\n    @java.lang.Override\n    public java.util.Map\u003cjava.lang.Integer, java.lang.Integer\u003e getLineNumberMapping() {\n        return getPrinterHelper().getLineNumberMapping();\n    }\n\n    /**\n\n    @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too\n     *\n     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too\n     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too\n     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too\n     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too\n     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too\n     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too\n     */\n    protected spoon.reflect.visitor.TokenWriter getPrinterTokenWriter() {\n        return printer;\n    }\n\n    /**\n    Set {@link TokenWriter}, which has to be used to print tokens\n     */\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter setPrinterTokenWriter(spoon.reflect.visitor.TokenWriter tokenWriter) {\n        elementPrinterHelper \u003d new spoon.reflect.visitor.ElementPrinterHelper(tokenWriter, this, env);\n        printer \u003d tokenWriter;\n        return this;\n    }\n\n    private spoon.reflect.visitor.PrinterHelper getPrinterHelper() {\n        return printer.getPrinterHelper();\n    }\n}\u003e but was:\u003c/**\nA visitor for generating Java code from the program compile-time model.\n */\npublic class DefaultJavaPrettyPrinter implements spoon.reflect.visitor.CtVisitor , spoon.reflect.visitor.PrettyPrinter {\n    /**\n    Java file extension (.java).\n     */\n    public static final java.lang.String JAVA_FILE_EXTENSION \u003d \".java\";\n\n    /**\n    Package declaration file name.\n     */\n    public static final java.lang.String JAVA_PACKAGE_DECLARATION \u003d \"package-info\" + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);\n\n    /**\n    Module declaration file name.\n     */\n    public static final java.lang.String JAVA_MODULE_DECLARATION \u003d \"module-info\" + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);\n\n    /**\n    Line separator which is used by the system\n     */\n    public static final java.lang.String LINE_SEPARATOR \u003d java.lang.System.getProperty(\"line.separator\");\n\n    /**\n    The star at the beginning of a block/JavaDoc comment line\n     */\n    public static final java.lang.String COMMENT_STAR \u003d \" * \";\n\n    /**\n    The end of a block/JavaDoc comment\n     */\n    public static final java.lang.String BLOCK_COMMENT_END \u003d \" */\";\n\n    /**\n    The beginning of a JavaDoc comment\n     */\n    public static final java.lang.String JAVADOC_START \u003d \"/**\";\n\n    /**\n    The beginning of an inline comment\n     */\n    public static final java.lang.String INLINE_COMMENT_START \u003d \"// \";\n\n    /**\n    The beginning of a block comment\n     */\n    public static final java.lang.String BLOCK_COMMENT_START \u003d \"/* \";\n\n    /**\n    The printing context.\n\n    since Spoon 7.1.0, use {{@link #getContext()}}\n     */\n    private spoon.reflect.visitor.PrintingContext context \u003d new spoon.reflect.visitor.PrintingContext();\n\n    /**\n    get the import scanner of this pretty printer\n     */\n    public spoon.reflect.visitor.ImportScanner getImportsContext() {\n        return this.importsContext;\n    }\n\n    /**\n    Handle imports of classes.\n     */\n    private spoon.reflect.visitor.ImportScanner importsContext;\n\n    /**\n    Environment which Spoon is executed.\n     */\n    protected spoon.compiler.Environment env;\n\n    /**\n    Token detector, which delegates tokens to {@link TokenWriter}\n     */\n    private spoon.reflect.visitor.TokenWriter printer;\n\n    /**\n    Element printer helper.\n     */\n    private spoon.reflect.visitor.ElementPrinterHelper elementPrinterHelper;\n\n    /**\n    Compilation unit we are printing.\n     */\n    protected spoon.reflect.cu.CompilationUnit sourceCompilationUnit;\n\n    /**\n    Imports computed\n     */\n    java.util.Set\u003cspoon.reflect.declaration.CtImport\u003e imports;\n\n    /**\n    Creates a new code generator visitor.\n     */\n    public DefaultJavaPrettyPrinter(spoon.compiler.Environment env) {\n        this.env \u003d env;\n        this.imports \u003d new java.util.HashSet\u003c\u003e();\n        setPrinterTokenWriter(new spoon.reflect.visitor.DefaultTokenWriter(new spoon.reflect.visitor.PrinterHelper(env)));\n        if (env.isAutoImports()) {\n            this.importsContext \u003d new spoon.reflect.visitor.ImportScannerImpl();\n        }else {\n            this.importsContext \u003d new spoon.reflect.visitor.MinimalImportScanner();\n        }\n    }\n\n    /**\n     *\n     * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system\n     * defined by System.getProperty(\"line.separator\")\n     */\n    public java.lang.String getLineSeparator() {\n        return getPrinterHelper().getLineSeparator();\n    }\n\n    /**\n     *\n     * @param lineSeparator *   characters which will be printed as End of line.\n     *   By default there is System.getProperty(\"line.separator\")\n     */\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter setLineSeparator(java.lang.String lineSeparator) {\n        getPrinterHelper().setLineSeparator(lineSeparator);\n        return this;\n    }\n\n    /**\n    Enters an expression.\n     */\n    protected void enterCtExpression(spoon.reflect.code.CtExpression\u003c?\u003e e) {\n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            this.elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        }\n        getPrinterHelper().mapLine(e, this.sourceCompilationUnit);\n        if (shouldSetBracket(e)) {\n            this.context.parenthesedExpression.push(e);\n            this.printer.writeSeparator(\"(\");\n        }\n        if (!(e.getTypeCasts().isEmpty())) {\n            for (spoon.reflect.reference.CtTypeReference\u003c?\u003e r : e.getTypeCasts()) {\n                this.printer.writeSeparator(\"(\");\n                scan(r);\n                this.printer.writeSeparator(\")\").writeSpace();\n                this.printer.writeSeparator(\"(\");\n                this.context.parenthesedExpression.push(e);\n            }\n        }\n    }\n\n    /**\n    Enters a statement.\n     */\n    protected void enterCtStatement(spoon.reflect.code.CtStatement s) {\n        this.elementPrinterHelper.writeComment(s, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        getPrinterHelper().mapLine(s, this.sourceCompilationUnit);\n        if (!(this.context.isNextForVariable())) {\n            // TODO AnnotationLoopTest#testAnnotationDeclaredInForInit expects that annotations of next for variables are not printed\n            // but may be correct is that the next variables are not annotated, because they might have different annotation then first param!\n            this.elementPrinterHelper.writeAnnotations(s);\n        }\n        if ((!(this.context.isFirstForVariable())) \u0026\u0026 (!(this.context.isNextForVariable()))) {\n            if ((s.getLabel()) !\u003d null) {\n                this.printer.writeIdentifier(s.getLabel()).writeSpace().writeSeparator(\":\").writeSpace();\n            }\n        }\n    }\n\n    /**\n    Exits a statement.\n     */\n    protected void exitCtStatement(spoon.reflect.code.CtStatement statement) {\n        if (!((((((((((statement instanceof spoon.reflect.code.CtBlock) || (statement instanceof spoon.reflect.code.CtIf)) || (statement instanceof spoon.reflect.code.CtFor)) || (statement instanceof spoon.reflect.code.CtForEach)) || (statement instanceof spoon.reflect.code.CtWhile)) || (statement instanceof spoon.reflect.code.CtTry)) || (statement instanceof spoon.reflect.code.CtSwitch)) || (statement instanceof spoon.reflect.code.CtSynchronized)) || (statement instanceof spoon.reflect.declaration.CtClass)) || (statement instanceof spoon.reflect.code.CtComment))) {\n            if (((this.context.isStatement(statement)) \u0026\u0026 (!(this.context.isFirstForVariable()))) \u0026\u0026 (!(this.context.isNextForVariable()))) {\n                this.printer.writeSeparator(\";\");\n            }\n        }\n        this.elementPrinterHelper.writeComment(statement, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n    }\n\n    /**\n    Exits an expression.\n     */\n    protected void exitCtExpression(spoon.reflect.code.CtExpression\u003c?\u003e e) {\n        while ((!(this.context.parenthesedExpression.isEmpty())) \u0026\u0026 (e \u003d\u003d (this.context.parenthesedExpression.peek()))) {\n            this.context.parenthesedExpression.pop();\n            this.printer.writeSeparator(\")\");\n        } \n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            this.elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        }\n    }\n\n    /**\n    Make the imports for a given type.\n     */\n    private java.util.Collection\u003cspoon.reflect.declaration.CtImport\u003e computeImports(spoon.reflect.declaration.CtType\u003c?\u003e type) {\n        this.context.currentTopLevel \u003d type;\n        this.importsContext.computeImports(this.context.currentTopLevel);\n        return this.importsContext.getAllImports();\n    }\n\n    /**\n    This method is called by {@link #scan(CtElement)} when entering a scanned element.\n    To be overridden to implement specific behavior.\n\n    Same KISS design as for {@link CtScanner}.\n     */\n    protected void enter(spoon.reflect.declaration.CtElement e) {\n    }\n\n    /**\n    This method is called by {@link #scan(CtElement)} when entering a scanned element.\n    To be overridden to implement specific behavior.\n     */\n    protected void exit(spoon.reflect.declaration.CtElement e) {\n    }\n\n    /**\n    The generic scan method for an element.\n     */\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.declaration.CtElement e) {\n        if (e !\u003d null) {\n            enter(e);\n            this.context.elementStack.push(e);\n            if (this.env.isPreserveLineNumbers()) {\n                if (!(e instanceof spoon.reflect.declaration.CtNamedElement)) {\n                    getPrinterHelper().adjustStartPosition(e);\n                }\n            }\n            try {\n                e.accept(this);\n            } catch (spoon.SpoonException ex) {\n                throw ex;\n            } catch (java.lang.Exception ex) {\n                java.lang.String elementInfo \u003d e.getClass().getName();\n                elementInfo +\u003d (\" on path \" + (spoon.reflect.visitor.DefaultJavaPrettyPrinter.getPath(e))) + \"\\n\";\n                if (e.getPosition().isValidPosition()) {\n                    elementInfo +\u003d (\"at position \" + (e.getPosition().toString())) + \" \";\n                }\n                throw new spoon.SpoonException(((\"Printing of \" + elementInfo) + \"failed\"), ex);\n            }\n            this.context.elementStack.pop();\n            exit(e);\n        }\n        return this;\n    }\n\n    private static java.lang.String getPath(spoon.reflect.declaration.CtElement ele) {\n        java.lang.StringBuilder sb \u003d new java.lang.StringBuilder();\n        spoon.reflect.visitor.DefaultJavaPrettyPrinter.addParentPath(sb, ele);\n        if (ele instanceof spoon.reflect.code.CtVariableAccess) {\n            sb.append(\u0027:\u0027).append(((spoon.reflect.code.CtVariableAccess) (ele)).getVariable().getSimpleName());\n        }\n        return sb.toString();\n    }\n\n    private static void addParentPath(java.lang.StringBuilder sb, spoon.reflect.declaration.CtElement ele) {\n        if ((ele \u003d\u003d null) || ((ele instanceof spoon.reflect.declaration.CtPackage) \u0026\u0026 (((spoon.reflect.declaration.CtPackage) (ele)).isUnnamedPackage()))) {\n            return;\n        }\n        if (ele.isParentInitialized()) {\n            spoon.reflect.visitor.DefaultJavaPrettyPrinter.addParentPath(sb, ele.getParent());\n        }\n        sb.append(\"\\n\\t\").append(ele.getClass().getSimpleName());\n        if (ele instanceof spoon.reflect.declaration.CtNamedElement) {\n            sb.append(\":\").append(((spoon.reflect.declaration.CtNamedElement) (ele)).getSimpleName());\n        }else\n            if (ele instanceof spoon.reflect.reference.CtReference) {\n                sb.append(\":\").append(((spoon.reflect.reference.CtReference) (ele)).getSimpleName());\n            }\n\n    }\n\n    private boolean shouldSetBracket(spoon.reflect.code.CtExpression\u003c?\u003e e) {\n        if (!(e.getTypeCasts().isEmpty())) {\n            return true;\n        }\n        try {\n            if (((e.getParent()) instanceof spoon.reflect.code.CtBinaryOperator) || ((e.getParent()) instanceof spoon.reflect.code.CtUnaryOperator)) {\n                return ((((e instanceof spoon.reflect.code.CtTargetedExpression) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator)) || (e instanceof spoon.reflect.code.CtBinaryOperator);\n            }\n            if ((e.getParent()) instanceof spoon.reflect.code.CtTargetedExpression) {\n                return (((e instanceof spoon.reflect.code.CtBinaryOperator) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator);\n            }\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n            // nothing we accept not to have a parent\n        }\n        return false;\n    }\n\n    /**\n    Gets the currently pretty-printed string.\n     */\n    @java.lang.Override\n    public java.lang.String toString() {\n        return this.printer.getPrinterHelper().toString();\n    }\n\n    @java.lang.Override\n    public \u003cA extends java.lang.annotation.Annotation\u003e void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation\u003cA\u003e annotation) {\n        this.elementPrinterHelper.writeAnnotations(annotation);\n        this.printer.writeSeparator(\"@\");\n        scan(annotation.getAnnotationType());\n        if (!(annotation.getValues().isEmpty())) {\n            this.elementPrinterHelper.printList(annotation.getValues().entrySet(), null, false, \"(\", false, false, \",\", true, false, \")\", ( e) -\u003e {\n                if ((((annotation.getValues().size()) \u003d\u003d 1) \u0026\u0026 (\"value\".equals(e.getKey()))) \u003d\u003d false) {\n                    // it is not a default value attribute. We must print a attribute name too.\n                    this.printer.writeIdentifier(e.getKey()).writeSpace().writeOperator(\"\u003d\").writeSpace();\n                }\n                this.elementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());\n            });\n        }\n    }\n\n    @java.lang.Override\n    public \u003cA extends java.lang.annotation.Annotation\u003e void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType\u003cA\u003e annotationType) {\n        visitCtType(annotationType);\n        this.printer.writeSeparator(\"@\").writeKeyword(\"interface\").writeSpace().writeIdentifier(annotationType.getSimpleName()).writeSpace().writeSeparator(\"{\").incTab();\n        this.elementPrinterHelper.writeElementList(annotationType.getTypeMembers());\n        this.printer.decTab().writeSeparator(\"}\");\n    }\n\n    @java.lang.Override\n    public void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable impl) {\n        this.elementPrinterHelper.writeComment(impl);\n        this.elementPrinterHelper.writeAnnotations(impl);\n        this.elementPrinterHelper.writeModifiers(impl);\n        scan(impl.getBody());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtArrayRead(spoon.reflect.code.CtArrayRead\u003cT\u003e arrayRead) {\n        printCtArrayAccess(arrayRead);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtArrayWrite(spoon.reflect.code.CtArrayWrite\u003cT\u003e arrayWrite) {\n        printCtArrayAccess(arrayWrite);\n    }\n\n    private \u003cT, E extends spoon.reflect.code.CtExpression\u003c?\u003e\u003e void printCtArrayAccess(spoon.reflect.code.CtArrayAccess\u003cT, E\u003e arrayAccess) {\n        enterCtExpression(arrayAccess);\n        scan(arrayAccess.getTarget());\n        this.printer.writeSeparator(\"[\");\n        scan(arrayAccess.getIndexExpression());\n        this.printer.writeSeparator(\"]\");\n        exitCtExpression(arrayAccess);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtArrayTypeReference(spoon.reflect.reference.CtArrayTypeReference\u003cT\u003e reference) {\n        if (reference.isImplicit()) {\n            return;\n        }\n        scan(reference.getComponentType());\n        if (!(this.context.skipArray())) {\n            this.printer.writeSeparator(\"[\").writeSeparator(\"]\");\n        }\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtAssert(spoon.reflect.code.CtAssert\u003cT\u003e asserted) {\n        enterCtStatement(asserted);\n        this.printer.writeKeyword(\"assert\").writeSpace();\n        scan(asserted.getAssertExpression());\n        if ((asserted.getExpression()) !\u003d null) {\n            this.printer.writeSpace().writeSeparator(\":\").writeSpace();\n            scan(asserted.getExpression());\n        }\n        exitCtStatement(asserted);\n    }\n\n    @java.lang.Override\n    public \u003cT, A extends T\u003e void visitCtAssignment(spoon.reflect.code.CtAssignment\u003cT, A\u003e assignement) {\n        enterCtStatement(assignement);\n        enterCtExpression(assignement);\n        scan(assignement.getAssigned());\n        this.printer.writeSpace().writeOperator(\"\u003d\").writeSpace();\n        scan(assignement.getAssignment());\n        exitCtExpression(assignement);\n        exitCtStatement(assignement);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator\u003cT\u003e operator) {\n        enterCtExpression(operator);\n        scan(operator.getLeftHandOperand());\n        this.printer.writeSpace();\n        this.printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(operator.getKind()));\n        this.printer.writeSpace();\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context \u003d this.context.modify()) {\n            if ((operator.getKind()) \u003d\u003d (spoon.reflect.code.BinaryOperatorKind.INSTANCEOF)) {\n                _context.forceWildcardGenerics(true);\n            }\n            scan(operator.getRightHandOperand());\n        }\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public \u003cR\u003e void visitCtBlock(spoon.reflect.code.CtBlock\u003cR\u003e block) {\n        enterCtStatement(block);\n        if (!(block.isImplicit())) {\n            this.printer.writeSeparator(\"{\");\n        }\n        this.printer.incTab();\n        for (spoon.reflect.code.CtStatement statement : block.getStatements()) {\n            if (!(statement.isImplicit())) {\n                this.printer.writeln();\n                this.elementPrinterHelper.writeStatement(statement);\n            }\n        }\n        this.printer.decTab();\n        getPrinterHelper().adjustEndPosition(block);\n        if (this.env.isPreserveLineNumbers()) {\n            if (!(block.isImplicit())) {\n                this.printer.writeSeparator(\"}\");\n            }\n        }else {\n            this.printer.writeln();\n            if (!(block.isImplicit())) {\n                this.printer.writeSeparator(\"}\");\n            }\n        }\n        exitCtStatement(block);\n    }\n\n    @java.lang.Override\n    public void visitCtBreak(spoon.reflect.code.CtBreak breakStatement) {\n        enterCtStatement(breakStatement);\n        this.printer.writeKeyword(\"break\");\n        if ((breakStatement.getTargetLabel()) !\u003d null) {\n            this.printer.writeSpace().writeKeyword(breakStatement.getTargetLabel());\n        }\n        exitCtStatement(breakStatement);\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public \u003cE\u003e void visitCtCase(spoon.reflect.code.CtCase\u003cE\u003e caseStatement) {\n        enterCtStatement(caseStatement);\n        if ((caseStatement.getCaseExpression()) !\u003d null) {\n            this.printer.writeKeyword(\"case\").writeSpace();\n            // writing enum case expression\n            if ((caseStatement.getCaseExpression()) instanceof spoon.reflect.code.CtFieldAccess) {\n                final spoon.reflect.reference.CtFieldReference variable \u003d ((spoon.reflect.code.CtFieldAccess) (caseStatement.getCaseExpression())).getVariable();\n                // In noclasspath mode, we don\u0027t have always the type of the declaring type.\n                if ((((variable.getType()) !\u003d null) \u0026\u0026 ((variable.getDeclaringType()) !\u003d null)) \u0026\u0026 (variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName()))) {\n                    this.printer.writeIdentifier(variable.getSimpleName());\n                }else {\n                    scan(caseStatement.getCaseExpression());\n                }\n            }else {\n                scan(caseStatement.getCaseExpression());\n            }\n        }else {\n            this.printer.writeKeyword(\"default\");\n        }\n        this.printer.writeSpace().writeSeparator(\":\").incTab();\n        for (spoon.reflect.code.CtStatement statement : caseStatement.getStatements()) {\n            this.printer.writeln();\n            this.elementPrinterHelper.writeStatement(statement);\n        }\n        this.printer.decTab();\n        exitCtStatement(caseStatement);\n    }\n\n    @java.lang.Override\n    public void visitCtCatch(spoon.reflect.code.CtCatch catchBlock) {\n        this.elementPrinterHelper.writeComment(catchBlock, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        this.printer.writeSpace().writeKeyword(\"catch\").writeSpace().writeSeparator(\"(\");\n        spoon.reflect.code.CtCatchVariable\u003c? extends java.lang.Throwable\u003e parameter \u003d catchBlock.getParameter();\n        if ((parameter !\u003d null) \u0026\u0026 ((parameter.getMultiTypes().size()) \u003e 1)) {\n            this.elementPrinterHelper.printList(parameter.getMultiTypes(), null, false, null, false, true, \"|\", true, false, null, ( type) -\u003e scan(type));\n            this.printer.writeSpace().writeIdentifier(parameter.getSimpleName());\n        }else {\n            scan(parameter);\n        }\n        this.printer.writeSeparator(\")\").writeSpace();\n        scan(catchBlock.getBody());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtClass(spoon.reflect.declaration.CtClass\u003cT\u003e ctClass) {\n        this.context.pushCurrentThis(ctClass);\n        if ((((ctClass.getSimpleName()) !\u003d null) \u0026\u0026 (!(spoon.reflect.declaration.CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName())))) \u0026\u0026 (!(ctClass.isAnonymous()))) {\n            visitCtType(ctClass);\n            if (ctClass.isLocalType()) {\n                this.printer.writeKeyword(\"class\").writeSpace().writeIdentifier(ctClass.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            }else {\n                this.printer.writeKeyword(\"class\").writeSpace().writeIdentifier(ctClass.getSimpleName());\n            }\n            this.elementPrinterHelper.writeFormalTypeParameters(ctClass);\n            this.elementPrinterHelper.writeExtendsClause(ctClass);\n            this.elementPrinterHelper.writeImplementsClause(ctClass);\n        }\n        this.printer.writeSpace().writeSeparator(\"{\").incTab();\n        this.elementPrinterHelper.writeElementList(ctClass.getTypeMembers());\n        getPrinterHelper().adjustEndPosition(ctClass);\n        this.printer.decTab().writeSeparator(\"}\");\n        this.context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n        this.elementPrinterHelper.writeAnnotations(typeParameter);\n        this.printer.writeIdentifier(typeParameter.getSimpleName());\n        if (((typeParameter.getSuperclass()) !\u003d null) \u0026\u0026 ((typeParameter.getSuperclass().isImplicit()) \u003d\u003d false)) {\n            this.printer.writeSpace().writeKeyword(\"extends\").writeSpace();\n            scan(typeParameter.getSuperclass());\n        }\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtConditional(spoon.reflect.code.CtConditional\u003cT\u003e conditional) {\n        enterCtExpression(conditional);\n        spoon.reflect.code.CtExpression\u003cjava.lang.Boolean\u003e condition \u003d conditional.getCondition();\n        boolean parent;\n        try {\n            parent \u003d ((conditional.getParent()) instanceof spoon.reflect.code.CtAssignment) || ((conditional.getParent()) instanceof spoon.reflect.declaration.CtVariable);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n            // nothing if we have no parent\n            parent \u003d false;\n        }\n        if (parent) {\n            this.printer.writeSeparator(\"(\");\n        }\n        scan(condition);\n        if (parent) {\n            this.printer.writeSeparator(\")\");\n        }\n        this.printer.writeSpace().writeOperator(\"?\").writeSpace();\n        spoon.reflect.code.CtExpression\u003cT\u003e thenExpression \u003d conditional.getThenExpression();\n        scan(thenExpression);\n        this.printer.writeSpace().writeOperator(\":\").writeSpace();\n        spoon.reflect.code.CtExpression\u003cT\u003e elseExpression \u003d conditional.getElseExpression();\n        boolean isAssign;\n        if (isAssign \u003d elseExpression instanceof spoon.reflect.code.CtAssignment) {\n            this.printer.writeSeparator(\"(\");\n        }\n        scan(elseExpression);\n        if (isAssign) {\n            this.printer.writeSeparator(\")\");\n        }\n        exitCtExpression(conditional);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtConstructor(spoon.reflect.declaration.CtConstructor\u003cT\u003e constructor) {\n        this.elementPrinterHelper.writeComment(constructor);\n        this.elementPrinterHelper.visitCtNamedElement(constructor, this.sourceCompilationUnit);\n        this.elementPrinterHelper.writeModifiers(constructor);\n        this.elementPrinterHelper.writeFormalTypeParameters(constructor);\n        if (!(constructor.getFormalCtTypeParameters().isEmpty())) {\n            this.printer.writeSpace();\n        }\n        if ((constructor.getDeclaringType()) !\u003d null) {\n            if (constructor.getDeclaringType().isLocalType()) {\n                this.printer.writeIdentifier(constructor.getDeclaringType().getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            }else {\n                this.printer.writeIdentifier(constructor.getDeclaringType().getSimpleName());\n            }\n        }\n        this.elementPrinterHelper.writeExecutableParameters(constructor);\n        this.elementPrinterHelper.writeThrowsClause(constructor);\n        this.printer.writeSpace();\n        scan(constructor.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtContinue(spoon.reflect.code.CtContinue continueStatement) {\n        enterCtStatement(continueStatement);\n        this.printer.writeKeyword(\"continue\");\n        if ((continueStatement.getTargetLabel()) !\u003d null) {\n            this.printer.writeSpace().writeIdentifier(continueStatement.getTargetLabel());\n        }\n        exitCtStatement(continueStatement);\n    }\n\n    @java.lang.Override\n    public void visitCtDo(spoon.reflect.code.CtDo doLoop) {\n        enterCtStatement(doLoop);\n        this.printer.writeKeyword(\"do\");\n        this.elementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());\n        this.printer.writeKeyword(\"while\").writeSpace().writeSeparator(\"(\");\n        scan(doLoop.getLoopingExpression());\n        this.printer.writeSpace().writeSeparator(\")\");\n        exitCtStatement(doLoop);\n    }\n\n    @java.lang.Override\n    public \u003cT extends java.lang.Enum\u003c?\u003e\u003e void visitCtEnum(spoon.reflect.declaration.CtEnum\u003cT\u003e ctEnum) {\n        visitCtType(ctEnum);\n        this.printer.writeKeyword(\"enum\").writeSpace().writeIdentifier(ctEnum.getSimpleName());\n        this.elementPrinterHelper.writeImplementsClause(ctEnum);\n        this.context.pushCurrentThis(ctEnum);\n        this.printer.writeSpace().writeSeparator(\"{\").incTab().writeln();\n        if (ctEnum.getEnumValues().isEmpty()) {\n            this.printer.writeSeparator(\";\").writeln();\n        }else {\n            this.elementPrinterHelper.printList(ctEnum.getEnumValues(), null, false, null, false, false, \",\", false, false, \";\", ( enumValue) -\u003e {\n                this.printer.writeln();\n                scan(enumValue);\n            });\n        }\n        this.elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());\n        this.printer.decTab().writeSeparator(\"}\");\n        this.context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference\u003cT\u003e reference) {\n        // it is not called during printing of sources. Use shortcut and print directly to PrinterHelper\n        this.printer.getPrinterHelper().write(reference.getSignature());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtField(spoon.reflect.declaration.CtField\u003cT\u003e f) {\n        this.elementPrinterHelper.writeComment(f, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        this.elementPrinterHelper.visitCtNamedElement(f, this.sourceCompilationUnit);\n        this.elementPrinterHelper.writeModifiers(f);\n        scan(f.getType());\n        this.printer.writeSpace();\n        this.printer.writeIdentifier(f.getSimpleName());\n        if ((f.getDefaultExpression()) !\u003d null) {\n            this.printer.writeSpace().writeOperator(\"\u003d\").writeSpace();\n            scan(f.getDefaultExpression());\n        }\n        this.printer.writeSeparator(\";\");\n        this.elementPrinterHelper.writeComment(f, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtEnumValue(spoon.reflect.declaration.CtEnumValue\u003cT\u003e enumValue) {\n        this.elementPrinterHelper.visitCtNamedElement(enumValue, this.sourceCompilationUnit);\n        this.elementPrinterHelper.writeComment(enumValue, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        this.printer.writeIdentifier(enumValue.getSimpleName());\n        if ((enumValue.getDefaultExpression()) !\u003d null) {\n            spoon.reflect.code.CtConstructorCall\u003c?\u003e constructorCall \u003d ((spoon.reflect.code.CtConstructorCall\u003c?\u003e) (enumValue.getDefaultExpression()));\n            if (!(constructorCall.isImplicit())) {\n                this.elementPrinterHelper.printList(constructorCall.getArguments(), null, false, \"(\", false, false, \",\", true, false, \")\", ( expr) -\u003e scan(expr));\n            }\n            if (constructorCall instanceof spoon.reflect.code.CtNewClass) {\n                scan(((spoon.reflect.code.CtNewClass\u003c?\u003e) (constructorCall)).getAnonymousClass());\n            }\n        }\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtFieldRead(spoon.reflect.code.CtFieldRead\u003cT\u003e fieldRead) {\n        printCtFieldAccess(fieldRead);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite\u003cT\u003e fieldWrite) {\n        printCtFieldAccess(fieldWrite);\n    }\n\n    private boolean isImported(spoon.reflect.reference.CtFieldReference fieldReference) {\n        spoon.reflect.declaration.CtImport fieldImport \u003d fieldReference.getFactory().createImport(fieldReference);\n        if (this.imports.contains(fieldImport)) {\n            return true;\n        }else {\n            if ((fieldReference.getDeclaringType()) \u003d\u003d null) {\n                return false;\n            }\n            spoon.reflect.reference.CtTypeReference staticTypeMemberReference \u003d fieldReference.getFactory().Type().createWildcardStaticTypeMemberReference(fieldReference.getDeclaringType());\n            spoon.reflect.declaration.CtImport staticClassImport \u003d fieldReference.getFactory().createImport(staticTypeMemberReference);\n            return this.imports.contains(staticClassImport);\n        }\n    }\n\n    private boolean isImported(spoon.reflect.reference.CtExecutableReference executableReference) {\n        spoon.reflect.declaration.CtImport executableImport \u003d executableReference.getFactory().createImport(executableReference);\n        if (this.imports.contains(executableImport)) {\n            return true;\n        }else {\n            if ((executableReference.getDeclaringType()) \u003d\u003d null) {\n                return false;\n            }\n            spoon.reflect.reference.CtTypeReference staticTypeMemberReference \u003d executableReference.getFactory().Type().createWildcardStaticTypeMemberReference(executableReference.getDeclaringType());\n            spoon.reflect.declaration.CtImport staticClassImport \u003d executableReference.getFactory().createImport(staticTypeMemberReference);\n            return this.imports.contains(staticClassImport);\n        }\n    }\n\n    private \u003cT\u003e void printCtFieldAccess(spoon.reflect.code.CtFieldAccess\u003cT\u003e f) {\n        enterCtExpression(f);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context \u003d this.context.modify()) {\n            if (((f.getVariable().isStatic()) || (\"class\".equals(f.getVariable().getSimpleName()))) \u0026\u0026 ((f.getTarget()) instanceof spoon.reflect.code.CtTypeAccess)) {\n                _context.ignoreGenerics(true);\n            }\n            spoon.reflect.code.CtExpression\u003c?\u003e target \u003d f.getTarget();\n            if (target !\u003d null) {\n                boolean isInitializeStaticFinalField \u003d isInitializeStaticFinalField(f.getTarget());\n                boolean isStaticField \u003d f.getVariable().isStatic();\n                boolean isImportedField \u003d this.isImported(f.getVariable());\n                if ((!isInitializeStaticFinalField) \u0026\u0026 (!(isStaticField \u0026\u0026 isImportedField))) {\n                    if ((target.isImplicit()) \u0026\u0026 (!(((f.getVariable().getFieldDeclaration()) \u003d\u003d null) \u0026\u0026 (this.env.getNoClasspath())))) {\n                        /* target is implicit, check whether there is no conflict with an local variable, catch variable or parameter\n                        in case of conflict make it explicit, otherwise the field access is shadowed by that variable.\n                        Search for potential variable declaration until we found a class which declares or inherits this field */\n                        final spoon.reflect.declaration.CtField\u003c?\u003e field \u003d f.getVariable().getFieldDeclaration();\n                        if (field !\u003d null) {\n                            final java.lang.String fieldName \u003d field.getSimpleName();\n                            spoon.reflect.declaration.CtVariable\u003c?\u003e var \u003d f.getVariable().map(new spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction(fieldName)).first();\n                            if (var !\u003d field) {\n                                // another variable declaration was found which is hiding the field declaration for this field access. Make the field access explicit\n                                target.setImplicit(false);\n                            }\n                        }else {\n                            // There is a model inconsistency\n                            this.printer.writeComment(f.getFactory().createComment(((\"ERROR: Missing field \\\"\" + (f.getVariable().getSimpleName())) + \"\\\", please check your model. The code may not compile.\"), spoon.reflect.code.CtComment.CommentType.BLOCK)).writeSpace();\n                        }\n                    }\n                    // the implicit drives the separator\n                    if (!(target.isImplicit())) {\n                        scan(target);\n                        this.printer.writeSeparator(\".\");\n                    }\n                }\n                _context.ignoreStaticAccess(true);\n            }\n            scan(f.getVariable());\n        }\n        exitCtExpression(f);\n    }\n\n    /**\n    Check if the target expression is a static final field initialized in a static anonymous block.\n     */\n    private \u003cT\u003e boolean isInitializeStaticFinalField(spoon.reflect.code.CtExpression\u003cT\u003e targetExp) {\n        final spoon.reflect.declaration.CtElement parent;\n        final spoon.reflect.declaration.CtAnonymousExecutable anonymousParent;\n        try {\n            parent \u003d targetExp.getParent();\n            anonymousParent \u003d targetExp.getParent(spoon.reflect.declaration.CtAnonymousExecutable.class);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        return (((((parent instanceof spoon.reflect.code.CtFieldWrite) \u0026\u0026 (targetExp.equals(((spoon.reflect.code.CtFieldWrite) (parent)).getTarget()))) \u0026\u0026 (anonymousParent !\u003d null)) \u0026\u0026 ((((spoon.reflect.code.CtFieldWrite) (parent)).getVariable()) !\u003d null)) \u0026\u0026 (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.STATIC))) \u0026\u0026 (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.FINAL));\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtThisAccess(spoon.reflect.code.CtThisAccess\u003cT\u003e thisAccess) {\n        try {\n            enterCtExpression(thisAccess);\n            // we only write qualified this when this is required\n            // this is good both in fully-qualified mode and in readable (with-imports) mode\n            // the implicit information is used for analysis (e.g. is visibility caused by implicit bugs?) but\n            // not for pretty-printing\n            spoon.reflect.code.CtTypeAccess target \u003d ((spoon.reflect.code.CtTypeAccess) (thisAccess.getTarget()));\n            spoon.reflect.reference.CtTypeReference targetType \u003d target.getAccessedType();\n            // readable mode as close as possible to the original code\n            if (thisAccess.isImplicit()) {\n                // write nothing, \"this\" is implicit and we unfortunately cannot always know\n                // what the good target is in JDTTreeBuilder\n                return;\n            }\n            // the simplest case: we always print \"this\" if we\u0027re in the top-level class,\n            // this is shorter (no qualified this), explicit, and less fragile wrt transformation\n            if ((targetType \u003d\u003d null) || (((thisAccess.getParent(spoon.reflect.declaration.CtType.class)) !\u003d null) \u0026\u0026 (thisAccess.getParent(spoon.reflect.declaration.CtType.class).isTopLevel()))) {\n                this.printer.writeKeyword(\"this\");\n                return;// still go through finally block below\n\n            }\n            // we cannot have fully-qualified this in anonymous classes\n            // we simply print \"this\" and it always works\n            // this has to come after the implicit test just before\n            if (targetType.isAnonymous()) {\n                this.printer.writeKeyword(\"this\");\n                return;\n            }\n            // complex case of qualified this\n            if (!(this.context.currentThis.isEmpty())) {\n                spoon.reflect.declaration.CtType lastType \u003d this.context.currentThis.peekFirst().type;\n                java.lang.String lastTypeQualifiedName \u003d lastType.getQualifiedName();\n                java.lang.String targetTypeQualifiedName \u003d targetType.getQualifiedName();\n                if (!(lastTypeQualifiedName.equals(targetTypeQualifiedName))) {\n                    if (!(targetType.isImplicit())) {\n                        visitCtTypeReferenceWithoutGenerics(targetType);\n                        this.printer.writeSeparator(\".\");\n                    }\n                    this.printer.writeKeyword(\"this\");\n                    return;\n                }\n            }\n            // the default super simple case only comes at the end\n            this.printer.writeKeyword(\"this\");\n        } finally {\n            exitCtExpression(thisAccess);\n        }\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtSuperAccess(spoon.reflect.code.CtSuperAccess\u003cT\u003e f) {\n        enterCtExpression(f);\n        if ((f.getTarget()) !\u003d null) {\n            scan(f.getTarget());\n            this.printer.writeSeparator(\".\");\n        }\n        this.printer.writeKeyword(\"super\");\n        exitCtExpression(f);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc comment) {\n        visitCtComment(comment);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag docTag) {\n        /* is not called during normal printing of java sources.\n        It can be called only when CtJavaDocTag has to be printed directly.\n        E.g. from CtJavaDocTag#toString\n        Write directly to PrinterHelper, because java doc tag is not a java token. Normally it is part of COMMENT token. */\n        spoon.reflect.visitor.CommentHelper.printJavaDocTag(this.printer.getPrinterHelper(), docTag);\n    }\n\n    @java.lang.Override\n    public void visitCtImport(spoon.reflect.declaration.CtImport ctImport) {\n        if ((ctImport.getImportKind()) !\u003d null) {\n            this.printer.writeKeyword(\"import\");\n            this.printer.writeSpace();\n            switch (ctImport.getImportKind()) {\n                case TYPE :\n                    visitCtTypeReference(((spoon.reflect.reference.CtTypeReference) (ctImport.getReference())));\n                    break;\n                case METHOD :\n                    this.printer.writeKeyword(\"static\");\n                    this.printer.writeSpace();\n                    visitCtExecutableReference(((spoon.reflect.reference.CtExecutableReference) (ctImport.getReference())));\n                    break;\n                case FIELD :\n                    this.printer.writeKeyword(\"static\");\n                    this.printer.writeSpace();\n                    visitCtFieldReference(((spoon.reflect.reference.CtFieldReference) (ctImport.getReference())));\n                    break;\n                case ALL_TYPES :\n                    visitCtPackageReference(((spoon.reflect.reference.CtPackageReference) (ctImport.getReference())));\n                    this.printer.writeSeparator(\".\");\n                    this.printer.writeIdentifier(\"*\");\n                    break;\n                case ALL_STATIC_MEMBERS :\n                    this.printer.writeKeyword(\"static\");\n                    this.printer.writeSpace();\n                    visitCtTypeReference(((spoon.reflect.reference.CtTypeReference) (ctImport.getReference())));\n                    break;\n            }\n            this.printer.writeSeparator(\";\");\n            this.printer.writeln();\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtModule(spoon.reflect.declaration.CtModule module) {\n        enter(module);\n        if (module.isOpenModule()) {\n            this.printer.writeKeyword(\"open\").writeSpace();\n        }\n        this.printer.writeKeyword(\"module\").writeSpace().writeIdentifier(module.getSimpleName());\n        this.printer.writeSpace().writeSeparator(\"{\").incTab().writeln();\n        for (spoon.reflect.declaration.CtModuleDirective moduleDirective : module.getModuleDirectives()) {\n            scan(moduleDirective);\n        }\n        this.printer.decTab().writeSeparator(\"}\");\n        exit(module);\n    }\n\n    @java.lang.Override\n    public void visitCtModuleReference(spoon.reflect.reference.CtModuleReference moduleReference) {\n        this.printer.writeIdentifier(moduleReference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public void visitCtPackageExport(spoon.reflect.declaration.CtPackageExport moduleExport) {\n        if (moduleExport.isOpenedPackage()) {\n            this.printer.writeKeyword(\"opens\");\n        }else {\n            this.printer.writeKeyword(\"exports\");\n        }\n        this.printer.writeSpace();\n        visitCtPackageReference(moduleExport.getPackageReference());\n        if (!(moduleExport.getTargetExport().isEmpty())) {\n            this.elementPrinterHelper.printList(moduleExport.getTargetExport(), null, false, \" to\", true, false, \",\", true, false, null, ( moduleReference) -\u003e scan(moduleReference));\n        }\n        this.printer.writeSeparator(\";\").writeln();\n    }\n\n    @java.lang.Override\n    public void visitCtModuleRequirement(spoon.reflect.declaration.CtModuleRequirement moduleRequirement) {\n        this.printer.writeKeyword(\"requires\").writeSpace();\n        if (!(moduleRequirement.getRequiresModifiers().isEmpty())) {\n            this.elementPrinterHelper.printList(moduleRequirement.getRequiresModifiers(), null, false, null, false, false, \" \", false, false, \" \", ( modifier) -\u003e this.printer.writeKeyword(modifier.name().toLowerCase()));\n        }\n        scan(moduleRequirement.getModuleReference());\n        this.printer.writeSeparator(\";\").writeln();\n    }\n\n    @java.lang.Override\n    public void visitCtProvidedService(spoon.reflect.declaration.CtProvidedService moduleProvidedService) {\n        this.printer.writeKeyword(\"provides\").writeSpace();\n        scan(moduleProvidedService.getServiceType());\n        this.elementPrinterHelper.printList(moduleProvidedService.getImplementationTypes(), null, false, \" with\", true, false, \",\", true, false, null, ( implementations) -\u003e scan(implementations));\n        this.printer.writeSeparator(\";\").writeln();\n    }\n\n    @java.lang.Override\n    public void visitCtUsedService(spoon.reflect.declaration.CtUsedService usedService) {\n        this.printer.writeKeyword(\"uses\").writeSpace();\n        scan(usedService.getServiceType());\n        this.printer.writeSeparator(\";\").writeln();\n    }\n\n    @java.lang.Override\n    public void visitCtComment(spoon.reflect.code.CtComment comment) {\n        if ((!(this.env.isCommentsEnabled())) \u0026\u0026 ((this.context.elementStack.size()) \u003e 1)) {\n            return;\n        }\n        this.printer.writeComment(comment);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtAnnotationFieldAccess(spoon.reflect.code.CtAnnotationFieldAccess\u003cT\u003e annotationFieldAccess) {\n        enterCtExpression(annotationFieldAccess);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context \u003d this.context.modify()) {\n            if ((annotationFieldAccess.getTarget()) !\u003d null) {\n                scan(annotationFieldAccess.getTarget());\n                this.printer.writeSeparator(\".\");\n                _context.ignoreStaticAccess(true);\n            }\n            _context.ignoreGenerics(true);\n            scan(annotationFieldAccess.getVariable());\n            this.printer.writeSeparator(\"(\").writeSeparator(\")\");\n        }\n        exitCtExpression(annotationFieldAccess);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtFieldReference(spoon.reflect.reference.CtFieldReference\u003cT\u003e reference) {\n        boolean isStatic \u003d (\"class\".equals(reference.getSimpleName())) || ((!(\"super\".equals(reference.getSimpleName()))) \u0026\u0026 (reference.isStatic()));\n        boolean printType \u003d true;\n        if ((reference.isFinal()) \u0026\u0026 (reference.isStatic())) {\n            spoon.reflect.reference.CtTypeReference\u003c?\u003e declTypeRef \u003d reference.getDeclaringType();\n            if (declTypeRef.isAnonymous()) {\n                // never print anonymous class ref\n                printType \u003d false;\n            }else {\n                if (this.context.isInCurrentScope(declTypeRef)) {\n                    // do not printType if we are in scope of that type\n                    printType \u003d false;\n                }\n            }\n        }\n        if ((isStatic \u0026\u0026 printType) \u0026\u0026 (!(this.context.ignoreStaticAccess()))) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context \u003d this.context.modify().ignoreGenerics(true)) {\n                scan(reference.getDeclaringType());\n            }\n            this.printer.writeSeparator(\".\");\n        }\n        if (\"class\".equals(reference.getSimpleName())) {\n            this.printer.writeKeyword(\"class\");\n        }else {\n            this.printer.writeIdentifier(reference.getSimpleName());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtFor(spoon.reflect.code.CtFor forLoop) {\n        enterCtStatement(forLoop);\n        this.printer.writeKeyword(\"for\").writeSpace().writeSeparator(\"(\");\n        java.util.List\u003cspoon.reflect.code.CtStatement\u003e st \u003d forLoop.getForInit();\n        if (!(st.isEmpty())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context \u003d this.context.modify().isFirstForVariable(true)) {\n                scan(st.get(0));\n            }\n        }\n        if ((st.size()) \u003e 1) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context \u003d this.context.modify().isNextForVariable(true)) {\n                for (int i \u003d 1; i \u003c (st.size()); i++) {\n                    this.printer.writeSeparator(\",\").writeSpace();\n                    scan(st.get(i));\n                }\n            }\n        }\n        this.printer.writeSeparator(\";\").writeSpace();\n        scan(forLoop.getExpression());\n        this.printer.writeSeparator(\";\");\n        if (!(forLoop.getForUpdate().isEmpty())) {\n            this.printer.writeSpace();\n        }\n        this.elementPrinterHelper.printList(forLoop.getForUpdate(), null, false, null, false, true, \",\", true, false, null, ( s) -\u003e scan(s));\n        this.printer.writeSeparator(\")\");\n        this.elementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());\n        exitCtStatement(forLoop);\n    }\n\n    @java.lang.Override\n    public void visitCtForEach(spoon.reflect.code.CtForEach foreach) {\n        enterCtStatement(foreach);\n        this.printer.writeKeyword(\"for\").writeSpace().writeSeparator(\"(\");\n        scan(foreach.getVariable());\n        this.printer.writeSpace().writeSeparator(\":\").writeSpace();\n        scan(foreach.getExpression());\n        this.printer.writeSeparator(\")\");\n        this.elementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());\n        exitCtStatement(foreach);\n    }\n\n    @java.lang.Override\n    public void visitCtIf(spoon.reflect.code.CtIf ifElement) {\n        enterCtStatement(ifElement);\n        this.printer.writeKeyword(\"if\").writeSpace().writeSeparator(\"(\");\n        scan(ifElement.getCondition());\n        this.printer.writeSeparator(\")\");\n        this.elementPrinterHelper.writeIfOrLoopBlock(ifElement.getThenStatement());\n        if ((ifElement.getElseStatement()) !\u003d null) {\n            java.util.List\u003cspoon.reflect.code.CtComment\u003e comments \u003d this.elementPrinterHelper.getComments(ifElement, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            for (spoon.reflect.code.CtComment comment : comments) {\n                spoon.reflect.cu.SourcePosition thenPosition \u003d (ifElement.getThenStatement().getPosition().isValidPosition()) ? ifElement.getThenStatement().getPosition() : ((spoon.reflect.code.CtBlock) (ifElement.getThenStatement())).getStatement(0).getPosition();\n                if ((comment.getPosition().getSourceStart()) \u003e (thenPosition.getSourceEnd())) {\n                    this.elementPrinterHelper.writeComment(comment);\n                }\n            }\n            this.printer.writeKeyword(\"else\");\n            this.elementPrinterHelper.writeIfOrLoopBlock(ifElement.getElseStatement());\n        }\n        exitCtStatement(ifElement);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtInterface(spoon.reflect.declaration.CtInterface\u003cT\u003e intrface) {\n        visitCtType(intrface);\n        this.printer.writeKeyword(\"interface\").writeSpace().writeIdentifier(intrface.getSimpleName());\n        if ((intrface.getFormalCtTypeParameters()) !\u003d null) {\n            this.elementPrinterHelper.writeFormalTypeParameters(intrface);\n        }\n        if (!(intrface.getSuperInterfaces().isEmpty())) {\n            this.elementPrinterHelper.printList(intrface.getSuperInterfaces(), \"extends\", false, null, false, true, \",\", true, false, null, ( ref) -\u003e scan(ref));\n        }\n        this.context.pushCurrentThis(intrface);\n        this.printer.writeSpace().writeSeparator(\"{\").incTab();\n        // Content\n        this.elementPrinterHelper.writeElementList(intrface.getTypeMembers());\n        this.printer.decTab().writeSeparator(\"}\");\n        this.context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtInvocation(spoon.reflect.code.CtInvocation\u003cT\u003e invocation) {\n        enterCtStatement(invocation);\n        enterCtExpression(invocation);\n        if (invocation.getExecutable().isConstructor()) {\n            // It\u0027s a constructor (super or this)\n            this.elementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());\n            spoon.reflect.declaration.CtType\u003c?\u003e parentType;\n            try {\n                parentType \u003d invocation.getParent(spoon.reflect.declaration.CtType.class);\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n                parentType \u003d null;\n            }\n            if (((parentType !\u003d null) \u0026\u0026 ((parentType.getQualifiedName()) !\u003d null)) \u0026\u0026 (parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName()))) {\n                this.printer.writeKeyword(\"this\");\n            }else {\n                if (((invocation.getTarget()) !\u003d null) \u0026\u0026 (!(invocation.getTarget().isImplicit()))) {\n                    scan(invocation.getTarget());\n                    this.printer.writeSeparator(\".\");\n                }\n                this.printer.writeKeyword(\"super\");\n            }\n        }else {\n            // It\u0027s a method invocation\n            boolean isImported \u003d this.isImported(invocation.getExecutable());\n            if (!isImported) {\n                try (final spoon.reflect.visitor.PrintingContext.Writable _context \u003d this.context.modify()) {\n                    if ((invocation.getTarget()) instanceof spoon.reflect.code.CtTypeAccess) {\n                        _context.ignoreGenerics(true);\n                    }\n                    if (((invocation.getTarget()) !\u003d null) \u0026\u0026 (!(invocation.getTarget().isImplicit()))) {\n                        scan(invocation.getTarget());\n                        this.printer.writeSeparator(\".\");\n                    }\n                }\n            }\n            this.elementPrinterHelper.writeActualTypeArguments(invocation);\n            if (this.env.isPreserveLineNumbers()) {\n                getPrinterHelper().adjustStartPosition(invocation);\n            }\n            this.printer.writeIdentifier(invocation.getExecutable().getSimpleName());\n        }\n        this.elementPrinterHelper.printList(invocation.getArguments(), null, false, \"(\", false, false, \",\", true, false, \")\", ( e) -\u003e scan(e));\n        exitCtExpression(invocation);\n        exitCtStatement(invocation);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtLiteral(spoon.reflect.code.CtLiteral\u003cT\u003e literal) {\n        enterCtExpression(literal);\n        this.printer.writeLiteral(spoon.reflect.visitor.LiteralHelper.getLiteralToken(literal));\n        exitCtExpression(literal);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable\u003cT\u003e localVariable) {\n        enterCtStatement(localVariable);\n        if (this.env.isPreserveLineNumbers()) {\n            getPrinterHelper().adjustStartPosition(localVariable);\n        }\n        if (!(this.context.isNextForVariable())) {\n            this.elementPrinterHelper.writeModifiers(localVariable);\n            if ((localVariable.isInferred()) \u0026\u0026 ((this.env.getComplianceLevel()) \u003e\u003d 10)) {\n                getPrinterTokenWriter().writeKeyword(\"var\");\n            }else {\n                scan(localVariable.getType());\n            }\n            this.printer.writeSpace();\n        }\n        this.printer.writeIdentifier(localVariable.getSimpleName());\n        if ((localVariable.getDefaultExpression()) !\u003d null) {\n            this.printer.writeSpace().writeOperator(\"\u003d\").writeSpace();\n            scan(localVariable.getDefaultExpression());\n        }\n        exitCtStatement(localVariable);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtLocalVariableReference(spoon.reflect.reference.CtLocalVariableReference\u003cT\u003e reference) {\n        this.printer.writeIdentifier(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable\u003cT\u003e catchVariable) {\n        if (this.env.isPreserveLineNumbers()) {\n            getPrinterHelper().adjustStartPosition(catchVariable);\n        }\n        this.elementPrinterHelper.writeModifiers(catchVariable);\n        scan(catchVariable.getType());\n        this.printer.writeSpace();\n        this.printer.writeIdentifier(catchVariable.getSimpleName());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtCatchVariableReference(spoon.reflect.reference.CtCatchVariableReference\u003cT\u003e reference) {\n        this.printer.writeIdentifier(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtMethod(spoon.reflect.declaration.CtMethod\u003cT\u003e m) {\n        this.elementPrinterHelper.writeComment(m, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        this.elementPrinterHelper.visitCtNamedElement(m, this.sourceCompilationUnit);\n        this.elementPrinterHelper.writeModifiers(m);\n        this.elementPrinterHelper.writeFormalTypeParameters(m);\n        if (!(m.getFormalCtTypeParameters().isEmpty())) {\n            this.printer.writeSpace();\n        }\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context \u003d this.context.modify().ignoreGenerics(false)) {\n            scan(m.getType());\n        }\n        this.printer.writeSpace();\n        this.printer.writeIdentifier(m.getSimpleName());\n        this.elementPrinterHelper.writeExecutableParameters(m);\n        this.elementPrinterHelper.writeThrowsClause(m);\n        if ((m.getBody()) !\u003d null) {\n            this.printer.writeSpace();\n            scan(m.getBody());\n            if (m.getBody().getPosition().isValidPosition()) {\n                if ((m.getBody().getPosition().getCompilationUnit()) \u003d\u003d (this.sourceCompilationUnit)) {\n                    if ((m.getBody().getStatements().isEmpty()) || (!((m.getBody().getStatements().get(((m.getBody().getStatements().size()) - 1))) instanceof spoon.reflect.code.CtReturn))) {\n                        getPrinterHelper().putLineNumberMapping(m.getBody().getPosition().getEndLine());\n                    }\n                }else {\n                    getPrinterHelper().undefineLine();\n                }\n            }else {\n                getPrinterHelper().undefineLine();\n            }\n        }else {\n            this.printer.writeSeparator(\";\");\n        }\n        this.elementPrinterHelper.writeComment(m, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod\u003cT\u003e annotationMethod) {\n        this.elementPrinterHelper.writeComment(annotationMethod);\n        this.elementPrinterHelper.visitCtNamedElement(annotationMethod, this.sourceCompilationUnit);\n        this.elementPrinterHelper.writeModifiers(annotationMethod);\n        scan(annotationMethod.getType());\n        this.printer.writeSpace();\n        this.printer.writeIdentifier(annotationMethod.getSimpleName());\n        this.printer.writeSeparator(\"(\").writeSeparator(\")\");\n        if ((annotationMethod.getDefaultExpression()) !\u003d null) {\n            this.printer.writeSpace().writeKeyword(\"default\").writeSpace();\n            scan(annotationMethod.getDefaultExpression());\n        }\n        this.printer.writeSeparator(\";\");\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public \u003cT\u003e void visitCtNewArray(spoon.reflect.code.CtNewArray\u003cT\u003e newArray) {\n        enterCtExpression(newArray);\n        boolean isNotInAnnotation;\n        try {\n            isNotInAnnotation \u003d ((newArray.getParent(spoon.reflect.declaration.CtAnnotationType.class)) \u003d\u003d null) \u0026\u0026 ((newArray.getParent(spoon.reflect.declaration.CtAnnotation.class)) \u003d\u003d null);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            isNotInAnnotation \u003d true;\n        }\n        if (isNotInAnnotation) {\n            spoon.reflect.reference.CtTypeReference\u003c?\u003e ref \u003d newArray.getType();\n            if (ref !\u003d null) {\n                this.printer.writeKeyword(\"new\").writeSpace();\n            }\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context \u003d this.context.modify().skipArray(true)) {\n                scan(ref);\n            }\n            for (int i \u003d 0; ref instanceof spoon.reflect.reference.CtArrayTypeReference; i++) {\n                this.printer.writeSeparator(\"[\");\n                if ((newArray.getDimensionExpressions().size()) \u003e i) {\n                    spoon.reflect.code.CtExpression\u003cjava.lang.Integer\u003e e \u003d newArray.getDimensionExpressions().get(i);\n                    scan(e);\n                }\n                this.printer.writeSeparator(\"]\");\n                ref \u003d ((spoon.reflect.reference.CtArrayTypeReference) (ref)).getComponentType();\n            }\n        }\n        if (newArray.getDimensionExpressions().isEmpty()) {\n            this.elementPrinterHelper.printList(newArray.getElements(), null, false, \"{\", true, false, \",\", true, true, \"}\", ( e) -\u003e scan(e));\n            this.elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n        }\n        this.elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        exitCtExpression(newArray);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall\u003cT\u003e ctConstructorCall) {\n        enterCtStatement(ctConstructorCall);\n        enterCtExpression(ctConstructorCall);\n        printConstructorCall(ctConstructorCall);\n        exitCtExpression(ctConstructorCall);\n        exitCtStatement(ctConstructorCall);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtNewClass(spoon.reflect.code.CtNewClass\u003cT\u003e newClass) {\n        enterCtStatement(newClass);\n        enterCtExpression(newClass);\n        printConstructorCall(newClass);\n        scan(newClass.getAnonymousClass());\n        exitCtExpression(newClass);\n        exitCtStatement(newClass);\n    }\n\n    private \u003cT\u003e void printConstructorCall(spoon.reflect.code.CtConstructorCall\u003cT\u003e ctConstructorCall) {\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context \u003d this.context.modify()) {\n            if ((ctConstructorCall.getTarget()) !\u003d null) {\n                scan(ctConstructorCall.getTarget());\n                this.printer.writeSeparator(\".\");\n                _context.ignoreEnclosingClass(true);\n            }\n            if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {\n                _context.ignoreEnclosingClass(true);\n            }\n            this.printer.writeKeyword(\"new\").writeSpace();\n            if (!(ctConstructorCall.getActualTypeArguments().isEmpty())) {\n                this.elementPrinterHelper.writeActualTypeArguments(ctConstructorCall);\n            }\n            scan(ctConstructorCall.getType());\n        }\n        this.elementPrinterHelper.printList(ctConstructorCall.getArguments(), null, false, \"(\", false, false, \",\", true, false, \")\", ( exp) -\u003e scan(exp));\n    }\n\n    /**\n    JDT doesn\u0027t support \u003ccode\u003enew Foo\u003cK\u003e.Bar()\u003c/code\u003e. To avoid reprinting this kind of type reference,\n    we check that the reference has a declaring type with generics.\n    See https://bugs.eclipse.org/bugs/show_bug.cgi?id\u003d474593\n\n    @param reference Type reference concerned by the bug.\n    @return true if a declaring type has generic types.\n     *\n     * @param reference *   Type reference concerned by the bug.\n     * @return true if a declaring type has generic types.\n     * @param reference *   Type reference concerned by the bug.\n     * @return true if a declaring type has generic types.\n     * @param reference *   Type reference concerned by the bug.\n     * @return true if a declaring type has generic types.\n     * @param reference *   Type reference concerned by the bug.\n     * @return true if a declaring type has generic types.\n     */\n    private \u003cT\u003e boolean hasDeclaringTypeWithGenerics(spoon.reflect.reference.CtTypeReference\u003cT\u003e reference) {\n        // We don\u0027t have a declaring type, it can\u0027t have generics.\n        if (reference \u003d\u003d null) {\n            return false;\n        }\n        // If the declaring type isn\u0027t a type, we don\u0027t need this hack.\n        if ((reference.getDeclaringType()) \u003d\u003d null) {\n            return false;\n        }\n        // If current reference is a class declared in a method, we don\u0027t need this hack.\n        if (reference.isLocalType()) {\n            return false;\n        }\n        // If declaring type have generics, we return true.\n        if (!(reference.getDeclaringType().getActualTypeArguments().isEmpty())) {\n            return true;\n        }\n        // Checks if the declaring type has generic types.\n        return hasDeclaringTypeWithGenerics(reference.getDeclaringType());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtLambda(spoon.reflect.code.CtLambda\u003cT\u003e lambda) {\n        enterCtExpression(lambda);\n        this.elementPrinterHelper.printList(lambda.getParameters(), null, false, \"(\", false, false, \",\", false, false, \")\", ( parameter) -\u003e scan(parameter));\n        this.printer.writeSpace();\n        this.printer.writeSeparator(\"-\u003e\");\n        this.printer.writeSpace();\n        if ((lambda.getBody()) !\u003d null) {\n            scan(lambda.getBody());\n        }else {\n            scan(lambda.getExpression());\n        }\n        exitCtExpression(lambda);\n    }\n\n    @java.lang.Override\n    public \u003cT, E extends spoon.reflect.code.CtExpression\u003c?\u003e\u003e void visitCtExecutableReferenceExpression(spoon.reflect.code.CtExecutableReferenceExpression\u003cT, E\u003e expression) {\n        enterCtExpression(expression);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context \u003d this.context.modify()) {\n            if (expression.getExecutable().isStatic()) {\n                _context.ignoreGenerics(true);\n            }\n            scan(expression.getTarget());\n        }\n        this.printer.writeSeparator(\"::\");\n        if (expression.getExecutable().isConstructor()) {\n            this.printer.writeKeyword(\"new\");\n        }else {\n            this.printer.writeIdentifier(expression.getExecutable().getSimpleName());\n        }\n        exitCtExpression(expression);\n    }\n\n    @java.lang.Override\n    public \u003cT, A extends T\u003e void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment\u003cT, A\u003e assignment) {\n        enterCtStatement(assignment);\n        enterCtExpression(assignment);\n        scan(assignment.getAssigned());\n        this.printer.writeSpace();\n        // the operators like +\u003d, *\u003d are sent as one operator token\n        this.printer.writeOperator(((spoon.reflect.visitor.OperatorHelper.getOperatorText(assignment.getKind())) + \"\u003d\"));\n        this.printer.writeSpace();\n        scan(assignment.getAssignment());\n        exitCtExpression(assignment);\n        exitCtStatement(assignment);\n    }\n\n    @java.lang.Override\n    public void visitCtPackage(spoon.reflect.declaration.CtPackage ctPackage) {\n        if (!(ctPackage.isUnnamedPackage())) {\n            this.elementPrinterHelper.writePackageLine(ctPackage.getQualifiedName());\n        }else {\n            this.printer.writeComment(ctPackage.getFactory().createComment(\"default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon\u003d unnamed package)\", spoon.reflect.code.CtComment.CommentType.INLINE)).writeln();\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtPackageReference(spoon.reflect.reference.CtPackageReference reference) {\n        this.elementPrinterHelper.writeQualifiedName(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtParameter(spoon.reflect.declaration.CtParameter\u003cT\u003e parameter) {\n        this.elementPrinterHelper.writeComment(parameter);\n        this.elementPrinterHelper.writeAnnotations(parameter);\n        this.elementPrinterHelper.writeModifiers(parameter);\n        if (parameter.isVarArgs()) {\n            scan(((spoon.reflect.reference.CtArrayTypeReference\u003cT\u003e) (parameter.getType())).getComponentType());\n            this.printer.writeSeparator(\"...\");\n        }else {\n            scan(parameter.getType());\n        }\n        this.printer.writeSpace();\n        this.printer.writeIdentifier(parameter.getSimpleName());\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtParameterReference(spoon.reflect.reference.CtParameterReference\u003cT\u003e reference) {\n        this.printer.writeIdentifier(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public \u003cR\u003e void visitCtReturn(spoon.reflect.code.CtReturn\u003cR\u003e returnStatement) {\n        enterCtStatement(returnStatement);\n        this.printer.writeKeyword(\"return\");\n        // checkstyle wants \"return;\" and not \"return ;\"\n        if ((returnStatement.getReturnedExpression()) !\u003d null) {\n            this.printer.writeSpace();\n        }\n        scan(returnStatement.getReturnedExpression());\n        exitCtStatement(returnStatement);\n    }\n\n    private \u003cT\u003e void visitCtType(spoon.reflect.declaration.CtType\u003cT\u003e type) {\n        this.elementPrinterHelper.writeComment(type, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        getPrinterHelper().mapLine(type, this.sourceCompilationUnit);\n        if (type.isTopLevel()) {\n            this.context.currentTopLevel \u003d type;\n        }\n        this.elementPrinterHelper.visitCtNamedElement(type, this.sourceCompilationUnit);\n        this.elementPrinterHelper.writeModifiers(type);\n    }\n\n    @java.lang.Override\n    public void visitCtStatementList(spoon.reflect.code.CtStatementList statements) {\n        for (spoon.reflect.code.CtStatement s : statements.getStatements()) {\n            scan(s);\n        }\n    }\n\n    @java.lang.Override\n    public \u003cE\u003e void visitCtSwitch(spoon.reflect.code.CtSwitch\u003cE\u003e switchStatement) {\n        enterCtStatement(switchStatement);\n        this.printer.writeKeyword(\"switch\").writeSpace().writeSeparator(\"(\");\n        scan(switchStatement.getSelector());\n        this.printer.writeSeparator(\")\").writeSpace().writeSeparator(\"{\").incTab();\n        for (spoon.reflect.code.CtCase\u003c?\u003e c : switchStatement.getCases()) {\n            this.printer.writeln();\n            scan(c);\n        }\n        if (this.env.isPreserveLineNumbers()) {\n            this.printer.decTab().writeSeparator(\"}\");\n        }else {\n            this.printer.decTab().writeln().writeSeparator(\"}\");\n        }\n        exitCtStatement(switchStatement);\n    }\n\n    @java.lang.Override\n    public void visitCtSynchronized(spoon.reflect.code.CtSynchronized synchro) {\n        enterCtStatement(synchro);\n        this.printer.writeKeyword(\"synchronized\");\n        if ((synchro.getExpression()) !\u003d null) {\n            this.printer.writeSeparator(\"(\");\n            scan(synchro.getExpression());\n            this.printer.writeSeparator(\")\").writeSpace();\n        }\n        scan(synchro.getBlock());\n        exitCtStatement(synchro);\n    }\n\n    @java.lang.Override\n    public void visitCtThrow(spoon.reflect.code.CtThrow throwStatement) {\n        enterCtStatement(throwStatement);\n        this.printer.writeKeyword(\"throw\").writeSpace();\n        scan(throwStatement.getThrownExpression());\n        exitCtStatement(throwStatement);\n    }\n\n    @java.lang.Override\n    public void visitCtTry(spoon.reflect.code.CtTry tryBlock) {\n        enterCtStatement(tryBlock);\n        this.printer.writeKeyword(\"try\").writeSpace();\n        scan(tryBlock.getBody());\n        for (spoon.reflect.code.CtCatch c : tryBlock.getCatchers()) {\n            scan(c);\n        }\n        if ((tryBlock.getFinalizer()) !\u003d null) {\n            this.printer.writeSpace().writeKeyword(\"finally\").writeSpace();\n            scan(tryBlock.getFinalizer());\n        }\n        exitCtStatement(tryBlock);\n    }\n\n    @java.lang.Override\n    public void visitCtTryWithResource(spoon.reflect.code.CtTryWithResource tryWithResource) {\n        enterCtStatement(tryWithResource);\n        this.printer.writeKeyword(\"try\").writeSpace();\n        if (((tryWithResource.getResources()) !\u003d null) \u0026\u0026 (!(tryWithResource.getResources().isEmpty()))) {\n            this.elementPrinterHelper.printList(tryWithResource.getResources(), null, false, \"(\", false, false, \";\", false, false, \")\", ( r) -\u003e scan(r));\n        }\n        this.printer.writeSpace();\n        scan(tryWithResource.getBody());\n        for (spoon.reflect.code.CtCatch c : tryWithResource.getCatchers()) {\n            scan(c);\n        }\n        if ((tryWithResource.getFinalizer()) !\u003d null) {\n            this.printer.writeSpace().writeKeyword(\"finally\").writeSpace();\n            scan(tryWithResource.getFinalizer());\n        }\n        exitCtStatement(tryWithResource);\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        this.elementPrinterHelper.writeAnnotations(ref);\n        if (printQualified(ref)) {\n            this.elementPrinterHelper.writeQualifiedName(ref.getQualifiedName());\n        }else {\n            this.printer.writeIdentifier(ref.getSimpleName());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {\n        if (wildcardReference.isImplicit()) {\n            return;\n        }\n        this.elementPrinterHelper.writeAnnotations(wildcardReference);\n        this.printer.writeSeparator(\"?\");\n        // we ignore printing \"extends Object\" except if it\u0027s explicit\n        if ((!(wildcardReference.isDefaultBoundingType())) || (!(wildcardReference.getBoundingType().isImplicit()))) {\n            if (wildcardReference.isUpper()) {\n                this.printer.writeSpace().writeKeyword(\"extends\").writeSpace();\n            }else {\n                this.printer.writeSpace().writeKeyword(\"super\").writeSpace();\n            }\n            scan(wildcardReference.getBoundingType());\n        }\n    }\n\n    private boolean printQualified(spoon.reflect.reference.CtTypeReference\u003c?\u003e ref) {\n        // or that we are in java.lang\n        if ((this.importsContext.isImported(ref))// If my.pkg.Something is imported\n         || (((this.env.isAutoImports()) \u0026\u0026 ((ref.getPackage()) !\u003d null)) \u0026\u0026 (\"java.lang\".equals(ref.getPackage().getSimpleName())))) {\n            for (spoon.reflect.visitor.CacheBasedConflictFinder typeContext : this.context.currentThis) {\n                // A) we are in the context of a class which is also called \"Something\",\n                if ((typeContext.getSimpleName().equals(ref.getSimpleName())) \u0026\u0026 (!(java.util.Objects.equals(typeContext.getPackage(), ref.getPackage())))) {\n                    return true;\n                }\n                // B) we are in the context of a class which defines field which is also called \"Something\",\n                // we should still use qualified version my.pkg.Something\n                // fix of #2369\n                if ((typeContext.hasFieldConflict(ref.getSimpleName())) || (typeContext.hasNestedTypeConflict(ref.getSimpleName()))) {\n                    return true;\n                }\n            }\n            return false;\n        }else {\n            return true;\n        }\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtIntersectionTypeReference(spoon.reflect.reference.CtIntersectionTypeReference\u003cT\u003e reference) {\n        this.elementPrinterHelper.printList(reference.getBounds(), null, false, null, false, true, \"\u0026\", true, false, null, ( bound) -\u003e scan(bound));\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtTypeReference(spoon.reflect.reference.CtTypeReference\u003cT\u003e ref) {\n        visitCtTypeReference(ref, true);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtTypeAccess(spoon.reflect.code.CtTypeAccess\u003cT\u003e typeAccess) {\n        if (typeAccess.isImplicit()) {\n            return;\n        }\n        enterCtExpression(typeAccess);\n        scan(typeAccess.getAccessedType());\n        exitCtExpression(typeAccess);\n    }\n\n    private void visitCtTypeReferenceWithoutGenerics(spoon.reflect.reference.CtTypeReference\u003c?\u003e ref) {\n        visitCtTypeReference(ref, false);\n    }\n\n    private void visitCtTypeReference(spoon.reflect.reference.CtTypeReference\u003c?\u003e ref, boolean withGenerics) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        if (ref.isPrimitive()) {\n            this.elementPrinterHelper.writeAnnotations(ref);\n            this.printer.writeKeyword(ref.getSimpleName());\n            return;\n        }\n        boolean isInner \u003d (ref.getDeclaringType()) !\u003d null;\n        if (isInner) {\n            if ((!(this.context.ignoreEnclosingClass())) \u0026\u0026 (!(ref.isLocalType()))) {\n                // compute visible type which can be used to print access path to ref\n                spoon.reflect.reference.CtTypeReference\u003c?\u003e accessType \u003d ref.getAccessType();\n                if (!(accessType.isAnonymous())) {\n                    try (final spoon.reflect.visitor.PrintingContext.Writable _context \u003d this.context.modify()) {\n                        if (!withGenerics) {\n                            _context.ignoreGenerics(true);\n                        }\n                        scan(accessType);\n                    }\n                    this.printer.writeSeparator(\".\");\n                }\n            }\n            // ?? are these annotations on correct place ??\n            this.elementPrinterHelper.writeAnnotations(ref);\n            if (ref.isLocalType()) {\n                this.printer.writeIdentifier(ref.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            }else {\n                this.printer.writeIdentifier(ref.getSimpleName());\n            }\n        }else {\n            if (((ref.getPackage()) !\u003d null) \u0026\u0026 (printQualified(ref))) {\n                if (!(ref.getPackage().isUnnamedPackage())) {\n                    scan(ref.getPackage());\n                    this.printer.writeSeparator(spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                }\n            }\n            this.elementPrinterHelper.writeAnnotations(ref);\n            this.printer.writeIdentifier(ref.getSimpleName());\n        }\n        if (withGenerics \u0026\u0026 (!(this.context.ignoreGenerics()))) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context \u003d this.context.modify().ignoreEnclosingClass(false)) {\n                this.elementPrinterHelper.writeActualTypeArguments(ref);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator\u003cT\u003e operator) {\n        enterCtStatement(operator);\n        enterCtExpression(operator);\n        spoon.reflect.code.UnaryOperatorKind op \u003d operator.getKind();\n        if (spoon.reflect.visitor.OperatorHelper.isPrefixOperator(op)) {\n            this.printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(op));\n        }\n        scan(operator.getOperand());\n        if (spoon.reflect.visitor.OperatorHelper.isSufixOperator(op)) {\n            this.printer.writeOperator(spoon.reflect.visitor.OperatorHelper.getOperatorText(op));\n        }\n        exitCtExpression(operator);\n        exitCtStatement(operator);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtVariableRead(spoon.reflect.code.CtVariableRead\u003cT\u003e variableRead) {\n        enterCtExpression(variableRead);\n        this.printer.writeIdentifier(variableRead.getVariable().getSimpleName());\n        exitCtExpression(variableRead);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtVariableWrite(spoon.reflect.code.CtVariableWrite\u003cT\u003e variableWrite) {\n        enterCtExpression(variableWrite);\n        this.printer.writeIdentifier(variableWrite.getVariable().getSimpleName());\n        exitCtExpression(variableWrite);\n    }\n\n    @java.lang.Override\n    public void visitCtWhile(spoon.reflect.code.CtWhile whileLoop) {\n        enterCtStatement(whileLoop);\n        this.printer.writeKeyword(\"while\").writeSpace().writeSeparator(\"(\");\n        scan(whileLoop.getLoopingExpression());\n        this.printer.writeSeparator(\")\");\n        this.elementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());\n        exitCtStatement(whileLoop);\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression\u003cT\u003e expression) {\n        this.elementPrinterHelper.writeComment(expression);\n        this.printer.writeCodeSnippet(expression.getValue());\n    }\n\n    @java.lang.Override\n    public void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement statement) {\n        enterCtStatement(statement);\n        this.printer.writeCodeSnippet(statement.getValue());\n        exitCtStatement(statement);\n    }\n\n    public spoon.reflect.visitor.ElementPrinterHelper getElementPrinterHelper() {\n        return this.elementPrinterHelper;\n    }\n\n    public spoon.reflect.visitor.PrintingContext getContext() {\n        return this.context;\n    }\n\n    @java.lang.Override\n    public \u003cT\u003e void visitCtUnboundVariableReference(spoon.reflect.reference.CtUnboundVariableReference\u003cT\u003e reference) {\n        this.printer.writeIdentifier(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public java.lang.String printPackageInfo(spoon.reflect.declaration.CtPackage pack) {\n        reset();\n        this.elementPrinterHelper.writeComment(pack);\n        // we need to compute imports only for annotations\n        // we don\u0027t want to get all imports coming from content of package\n        for (spoon.reflect.declaration.CtAnnotation annotation : pack.getAnnotations()) {\n            this.importsContext.computeImports(annotation);\n        }\n        this.elementPrinterHelper.writeAnnotations(pack);\n        if (!(pack.isUnnamedPackage())) {\n            this.elementPrinterHelper.writePackageLine(pack.getQualifiedName());\n        }\n        this.elementPrinterHelper.writeImports(this.importsContext.getAllImports());\n        return this.printer.getPrinterHelper().toString();\n    }\n\n    @java.lang.Override\n    public java.lang.String printModuleInfo(spoon.reflect.declaration.CtModule module) {\n        reset();\n        scan(module);\n        return this.getResult();\n    }\n\n    @java.lang.Override\n    public java.lang.String getResult() {\n        return this.printer.getPrinterHelper().toString();\n    }\n\n    private void reset() {\n        this.printer.reset();\n        this.context \u003d new spoon.reflect.visitor.PrintingContext();\n        if (this.env.isAutoImports()) {\n            this.importsContext \u003d new spoon.reflect.visitor.ImportScannerImpl();\n        }else {\n            this.importsContext \u003d new spoon.reflect.visitor.MinimalImportScanner();\n        }\n    }\n\n    /**\n    Write the compilation unit header.\n     */\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter writeHeader(java.util.List\u003cspoon.reflect.declaration.CtType\u003c?\u003e\u003e types, java.util.Collection\u003cspoon.reflect.declaration.CtImport\u003e imports) {\n        this.elementPrinterHelper.writeHeader(types, imports);\n        return this;\n    }\n\n    /**\n    Write the compilation unit footer.\n     */\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter writeFooter(java.util.List\u003cspoon.reflect.declaration.CtType\u003c?\u003e\u003e types) {\n        this.elementPrinterHelper.writeFooter(types);\n        return this;\n    }\n\n    @java.lang.Override\n    public void calculate(spoon.reflect.cu.CompilationUnit sourceCompilationUnit, java.util.List\u003cspoon.reflect.declaration.CtType\u003c?\u003e\u003e types) {\n        // reset the importsContext to avoid errors with multiple CU\n        reset();\n        this.sourceCompilationUnit \u003d sourceCompilationUnit;\n        this.imports \u003d new java.util.HashSet\u003c\u003e();\n        if (sourceCompilationUnit !\u003d null) {\n            this.importsContext.initWithImports(sourceCompilationUnit.getImports());\n        }\n        for (spoon.reflect.declaration.CtType\u003c?\u003e t : types) {\n            this.imports.addAll(computeImports(t));\n        }\n        this.writeHeader(types, this.imports);\n        printTypes(types);\n    }\n\n    protected void printTypes(java.util.List\u003cspoon.reflect.declaration.CtType\u003c?\u003e\u003e types) {\n        for (spoon.reflect.declaration.CtType\u003c?\u003e t : types) {\n            scan(t);\n            if (!(this.env.isPreserveLineNumbers())) {\n                // saving lines and chars\n                this.printer.writeln().writeln();\n            }else {\n                getPrinterHelper().adjustEndPosition(t);\n            }\n        }\n        this.writeFooter(types);\n    }\n\n    @java.lang.Override\n    public java.util.Map\u003cjava.lang.Integer, java.lang.Integer\u003e getLineNumberMapping() {\n        return getPrinterHelper().getLineNumberMapping();\n    }\n\n    /**\n     *\n     * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too\n     */\n    protected spoon.reflect.visitor.TokenWriter getPrinterTokenWriter() {\n        return this.printer;\n    }\n\n    /**\n    Set {@link TokenWriter}, which has to be used to print tokens\n     */\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter setPrinterTokenWriter(spoon.reflect.visitor.TokenWriter tokenWriter) {\n        this.elementPrinterHelper \u003d new spoon.reflect.visitor.ElementPrinterHelper(tokenWriter, this, this.env);\n        this.printer \u003d tokenWriter;\n        return this;\n    }\n\n    private spoon.reflect.visitor.PrinterHelper getPrinterHelper() {\n        return this.printer.getPrinterHelper();\n    }\n}\u003e",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    }
  ],
  "failingModule": "/root/workspace/INRIA/spoon/441002125"
}