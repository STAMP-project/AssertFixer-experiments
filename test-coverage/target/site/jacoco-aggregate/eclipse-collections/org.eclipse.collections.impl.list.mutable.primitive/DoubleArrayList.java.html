<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DoubleArrayList.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.impl.list.mutable.primitive</a> &gt; <span class="el_source">DoubleArrayList.java</span></div><h1>DoubleArrayList.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2018 Goldman Sachs and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.impl.list.mutable.primitive;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.NoSuchElementException;

import org.eclipse.collections.api.DoubleIterable;
import org.eclipse.collections.api.LazyDoubleIterable;
import org.eclipse.collections.api.RichIterable;
import org.eclipse.collections.api.block.function.primitive.ObjectDoubleIntToObjectFunction;
import org.eclipse.collections.api.block.function.primitive.ObjectDoubleToObjectFunction;
import org.eclipse.collections.api.block.function.primitive.DoubleToObjectFunction;
import org.eclipse.collections.api.block.predicate.primitive.DoublePredicate;
import org.eclipse.collections.api.block.procedure.primitive.DoubleIntProcedure;
import org.eclipse.collections.api.block.procedure.primitive.DoubleProcedure;
import org.eclipse.collections.api.collection.primitive.MutableDoubleCollection;
import org.eclipse.collections.api.iterator.MutableDoubleIterator;
import org.eclipse.collections.api.iterator.DoubleIterator;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.api.list.primitive.DoubleList;
import org.eclipse.collections.api.list.primitive.ImmutableDoubleList;
import org.eclipse.collections.api.list.primitive.MutableDoubleList;
import org.eclipse.collections.api.set.primitive.DoubleSet;
import org.eclipse.collections.api.set.primitive.MutableDoubleSet;
import org.eclipse.collections.api.tuple.primitive.DoubleDoublePair;
import org.eclipse.collections.api.tuple.primitive.DoubleObjectPair;
import org.eclipse.collections.impl.factory.Lists;
import org.eclipse.collections.impl.factory.primitive.DoubleLists;
import org.eclipse.collections.impl.lazy.primitive.ReverseDoubleIterable;
import org.eclipse.collections.impl.list.mutable.FastList;
import org.eclipse.collections.impl.primitive.AbstractDoubleIterable;
import org.eclipse.collections.impl.set.mutable.primitive.DoubleHashSet;
import org.eclipse.collections.impl.tuple.primitive.PrimitiveTuples;
import org.eclipse.collections.impl.utility.Iterate;

/**
 * DoubleArrayList is similar to {@link FastList}, and is memory-optimized for double primitives.
 * This file was automatically generated from template file primitiveArrayList.stg.
 *
 * @since 3.0.
 */
public class DoubleArrayList extends AbstractDoubleIterable
        implements MutableDoubleList, Externalizable
{
    private static final long serialVersionUID = 1L;
<span class="nc" id="L61">    private static final double[] DEFAULT_SIZED_EMPTY_ARRAY = {};</span>
<span class="nc" id="L62">    private static final double[] ZERO_SIZED_ARRAY = {};</span>
    private static final int MAXIMUM_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    protected int size;
<span class="nc" id="L66">    protected transient double[] items = DEFAULT_SIZED_EMPTY_ARRAY;</span>

    public DoubleArrayList()
<span class="nc" id="L69">    {</span>
<span class="nc" id="L70">    }</span>

    public DoubleArrayList(int initialCapacity)
<span class="nc" id="L73">    {</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">        this.items = initialCapacity == 0 ? ZERO_SIZED_ARRAY : new double[initialCapacity];</span>
<span class="nc" id="L75">    }</span>

    public DoubleArrayList(double... array)
<span class="nc" id="L78">    {</span>
<span class="nc" id="L79">        this.size = array.length;</span>
<span class="nc" id="L80">        this.items = array;</span>
<span class="nc" id="L81">    }</span>

    /**
     * Creates a new list using the passed {@code elements} argument as the backing store.
     * &lt;p&gt;
     * !!! WARNING: This method uses the passed in array, so can be very unsafe if the original
     * array is held onto anywhere else. !!!
     */
    public static DoubleArrayList newListWith(double... elements)
    {
<span class="nc" id="L91">        return new DoubleArrayList(elements);</span>
    }

    public static DoubleArrayList newList(DoubleIterable source)
    {
<span class="nc" id="L96">        return DoubleArrayList.newListWith(source.toArray());</span>
    }

    public static DoubleArrayList newWithNValues(int size, double value)
    {
<span class="nc" id="L101">        DoubleArrayList newList = new DoubleArrayList(size);</span>
<span class="nc" id="L102">        newList.size = size;</span>
<span class="nc" id="L103">        Arrays.fill(newList.items, value);</span>
<span class="nc" id="L104">        return newList;</span>
    }

    @Override
    public int size()
    {
<span class="nc" id="L110">        return this.size;</span>
    }

    @Override
    public void clear()
    {
<span class="nc" id="L116">        Arrays.fill(this.items, 0, size, 0.0);</span>
<span class="nc" id="L117">        this.size = 0;</span>
<span class="nc" id="L118">    }</span>

    @Override
    public boolean contains(double value)
    {
<span class="nc bnc" id="L123" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc bnc" id="L125" title="All 2 branches missed.">            if (Double.compare(this.items[i], value) == 0)</span>
            {
<span class="nc" id="L127">                return true;</span>
            }
        }
<span class="nc" id="L130">        return false;</span>
    }

    @Override
    public double get(int index)
    {
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (index &lt; this.size)</span>
        {
<span class="nc" id="L138">            return this.items[index];</span>
        }
<span class="nc" id="L140">        throw this.newIndexOutOfBoundsException(index);</span>
    }

    private IndexOutOfBoundsException newIndexOutOfBoundsException(int index)
    {
<span class="nc" id="L145">        return new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot; Size: &quot; + this.size);</span>
    }

    @Override
    public double getFirst()
    {
<span class="nc" id="L151">        this.checkEmpty();</span>
<span class="nc" id="L152">        return this.items[0];</span>
    }

    @Override
    public double getLast()
    {
<span class="nc" id="L158">        this.checkEmpty();</span>
<span class="nc" id="L159">        return this.items[this.size() - 1];</span>
    }

    private void checkEmpty()
    {
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L166">            throw this.newIndexOutOfBoundsException(0);</span>
        }
<span class="nc" id="L168">    }</span>

    @Override
    public int indexOf(double value)
    {
<span class="nc bnc" id="L173" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (Double.compare(this.items[i], value) == 0)</span>
            {
<span class="nc" id="L177">                return i;</span>
            }
        }
<span class="nc" id="L180">        return -1;</span>
    }

    @Override
    public int lastIndexOf(double value)
    {
<span class="nc bnc" id="L186" title="All 2 branches missed.">        for (int i = this.size - 1; i &gt;= 0; i--)</span>
        {
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (Double.compare(this.items[i], value) == 0)</span>
            {
<span class="nc" id="L190">                return i;</span>
            }
        }
<span class="nc" id="L193">        return -1;</span>
    }

    public void trimToSize()
    {
<span class="nc bnc" id="L198" title="All 2 branches missed.">        if (this.size &lt; this.items.length)</span>
        {
<span class="nc" id="L200">            this.transferItemsToNewArrayWithCapacity(this.size);</span>
        }
<span class="nc" id="L202">    }</span>

    private void transferItemsToNewArrayWithCapacity(int newCapacity)
    {
<span class="nc" id="L206">        this.items = this.copyItemsWithNewCapacity(newCapacity);</span>
<span class="nc" id="L207">    }</span>

    private double[] copyItemsWithNewCapacity(int newCapacity)
    {
<span class="nc" id="L211">        double[] newItems = new double[newCapacity];</span>
<span class="nc" id="L212">        System.arraycopy(this.items, 0, newItems, 0, Math.min(this.size, newCapacity));</span>
<span class="nc" id="L213">        return newItems;</span>
    }

    private int sizePlusFiftyPercent(int oldSize)
    {
<span class="nc" id="L218">        int result = oldSize + (oldSize &gt;&gt; 1) + 1;</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">        return result &lt; oldSize ? MAXIMUM_ARRAY_SIZE : result;</span>
    }

    public void ensureCapacity(int minCapacity)
    {
<span class="nc" id="L224">        int oldCapacity = this.items.length;</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (minCapacity &gt; oldCapacity)</span>
        {
<span class="nc" id="L227">            int newCapacity = Math.max(this.sizePlusFiftyPercent(oldCapacity), minCapacity);</span>
<span class="nc" id="L228">            this.transferItemsToNewArrayWithCapacity(newCapacity);</span>
        }
<span class="nc" id="L230">    }</span>

    private void ensureCapacityForAdd()
    {
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (this.items == DEFAULT_SIZED_EMPTY_ARRAY)</span>
        {
<span class="nc" id="L236">            this.items = new double[10];</span>
        }
        else
        {
<span class="nc" id="L240">            this.transferItemsToNewArrayWithCapacity(this.sizePlusFiftyPercent(this.size));</span>
        }
<span class="nc" id="L242">    }</span>

    @Override
    public boolean add(double newItem)
    {
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (this.items.length == this.size)</span>
        {
<span class="nc" id="L249">            this.ensureCapacityForAdd();</span>
        }
<span class="nc" id="L251">        this.items[this.size] = newItem;</span>
<span class="nc" id="L252">        this.size++;</span>
<span class="nc" id="L253">        return true;</span>
    }

    @Override
    public boolean addAll(double... source)
    {
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (source.length &lt; 1)</span>
        {
<span class="nc" id="L261">            return false;</span>
        }
<span class="nc" id="L263">        this.copyItems(source.length, source);</span>
<span class="nc" id="L264">        return true;</span>
    }

    @Override
    public boolean addAll(DoubleIterable source)
    {
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (source instanceof DoubleArrayList)</span>
        {
<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (source.isEmpty())</span>
            {
<span class="nc" id="L274">                return false;</span>
            }
<span class="nc" id="L276">            DoubleArrayList other = (DoubleArrayList) source;</span>
<span class="nc" id="L277">            this.copyItems(other.size(), other.items);</span>
<span class="nc" id="L278">            return true;</span>
        }
<span class="nc" id="L280">        return this.addAll(source.toArray());</span>
    }

    private void copyItems(int sourceSize, double[] source)
    {
<span class="nc" id="L285">        int newSize = this.size + sourceSize;</span>
<span class="nc" id="L286">        this.ensureCapacity(newSize);</span>
<span class="nc" id="L287">        System.arraycopy(source, 0, this.items, this.size, sourceSize);</span>
<span class="nc" id="L288">        this.size = newSize;</span>
<span class="nc" id="L289">    }</span>

    private void throwOutOfBounds(int index)
    {
<span class="nc" id="L293">        throw this.newIndexOutOfBoundsException(index);</span>
    }

    @Override
    public void addAtIndex(int index, double element)
    {
<span class="nc bnc" id="L299" title="All 4 branches missed.">        if (index &gt; -1 &amp;&amp; index &lt; this.size)</span>
        {
<span class="nc" id="L301">            this.addAtIndexLessThanSize(index, element);</span>
        }
<span class="nc bnc" id="L303" title="All 2 branches missed.">        else if (index == this.size)</span>
        {
<span class="nc" id="L305">            this.add(element);</span>
        }
        else
        {
<span class="nc" id="L309">            this.throwOutOfBounds(index);</span>
        }
<span class="nc" id="L311">    }</span>

    private void addAtIndexLessThanSize(int index, double element)
    {
<span class="nc" id="L315">        int oldSize = this.size;</span>
<span class="nc" id="L316">        this.size++;</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (this.items.length == oldSize)</span>
        {
<span class="nc" id="L319">            double[] newItems = new double[this.sizePlusFiftyPercent(oldSize)];</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">            if (index &gt; 0)</span>
            {
<span class="nc" id="L322">                System.arraycopy(this.items, 0, newItems, 0, index);</span>
            }
<span class="nc" id="L324">            System.arraycopy(this.items, index, newItems, index + 1, oldSize - index);</span>
<span class="nc" id="L325">            this.items = newItems;</span>
<span class="nc" id="L326">        }</span>
        else
        {
<span class="nc" id="L329">            System.arraycopy(this.items, index, this.items, index + 1, oldSize - index);</span>
        }
<span class="nc" id="L331">        this.items[index] = element;</span>
<span class="nc" id="L332">    }</span>

    @Override
    public boolean addAllAtIndex(int index, double... source)
    {
<span class="nc bnc" id="L337" title="All 4 branches missed.">        if (index &gt; this.size || index &lt; 0)</span>
        {
<span class="nc" id="L339">            this.throwOutOfBounds(index);</span>
        }
<span class="nc bnc" id="L341" title="All 2 branches missed.">        if (source.length == 0)</span>
        {
<span class="nc" id="L343">            return false;</span>
        }
<span class="nc" id="L345">        int sourceSize = source.length;</span>
<span class="nc" id="L346">        int newSize = this.size + sourceSize;</span>
<span class="nc" id="L347">        this.ensureCapacity(newSize);</span>
<span class="nc" id="L348">        this.shiftElementsAtIndex(index, sourceSize);</span>
<span class="nc" id="L349">        System.arraycopy(source, 0, this.items, index, sourceSize);</span>
<span class="nc" id="L350">        this.size = newSize;</span>
<span class="nc" id="L351">        return true;</span>
    }

    @Override
    public boolean addAllAtIndex(int index, DoubleIterable source)
    {
<span class="nc" id="L357">        return this.addAllAtIndex(index, source.toArray());</span>
    }

    private void shiftElementsAtIndex(int index, int sourceSize)
    {
<span class="nc" id="L362">        int numberToMove = this.size - index;</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (numberToMove &gt; 0)</span>
        {
<span class="nc" id="L365">            System.arraycopy(this.items, index, this.items, index + sourceSize, numberToMove);</span>
        }
<span class="nc" id="L367">    }</span>

    @Override
    public boolean remove(double value)
    {
<span class="nc" id="L372">        int index = this.indexOf(value);</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (index &gt;= 0)</span>
        {
<span class="nc" id="L375">            this.removeAtIndex(index);</span>
<span class="nc" id="L376">            return true;</span>
        }
<span class="nc" id="L378">        return false;</span>
    }

    @Override
    public boolean removeIf(DoublePredicate predicate)
    {
<span class="nc" id="L384">        int currentFilledIndex = 0;</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L387">            double item = this.items[i];</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">            if (!predicate.accept(item))</span>
            {
                // keep it
<span class="nc bnc" id="L391" title="All 2 branches missed.">                if (currentFilledIndex != i)</span>
                {
<span class="nc" id="L393">                    this.items[currentFilledIndex] = item;</span>
                }
<span class="nc" id="L395">                currentFilledIndex++;</span>
            }
        }
<span class="nc bnc" id="L398" title="All 2 branches missed.">        boolean changed = currentFilledIndex &lt; this.size;</span>
<span class="nc" id="L399">        this.wipeAndResetTheEnd(currentFilledIndex);</span>
<span class="nc" id="L400">        return changed;</span>
    }

    private void wipeAndResetTheEnd(int newCurrentFilledIndex)
    {
<span class="nc bnc" id="L405" title="All 2 branches missed.">        for (int i = newCurrentFilledIndex; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L407">            this.items[i] = 0.0;</span>
        }
<span class="nc" id="L409">        this.size = newCurrentFilledIndex;</span>
<span class="nc" id="L410">    }</span>

    @Override
    public boolean removeAll(DoubleIterable source)
    {
<span class="nc" id="L415">        boolean modified = false;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">        for (int index = 0; index &lt; this.size; index++)</span>
        {
<span class="nc bnc" id="L418" title="All 2 branches missed.">            if (source.contains(this.get(index)))</span>
            {
<span class="nc" id="L420">                this.removeAtIndex(index);</span>
<span class="nc" id="L421">                index--;</span>
<span class="nc" id="L422">                modified = true;</span>
            }
        }
<span class="nc" id="L425">        return modified;</span>
    }

    @Override
    public boolean removeAll(double... source)
    {
<span class="nc" id="L431">        DoubleHashSet set = DoubleHashSet.newSetWith(source);</span>
<span class="nc" id="L432">        double[] newItems = new double[this.size];</span>
<span class="nc" id="L433">        int count = 0;</span>
<span class="nc" id="L434">        int oldSize = this.size;</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">        for (int index = 0; index &lt; this.size; index++)</span>
        {
<span class="nc bnc" id="L437" title="All 2 branches missed.">            if (!set.contains(this.items[index]))</span>
            {
<span class="nc" id="L439">                newItems[count] = this.items[index];</span>
<span class="nc" id="L440">                count++;</span>
            }
        }
<span class="nc" id="L443">        this.items = newItems;</span>
<span class="nc" id="L444">        this.size = count;</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">        return oldSize != this.size;</span>
    }

    @Override
    public boolean retainAll(DoubleIterable source)
    {
<span class="nc" id="L451">        int oldSize = this.size();</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        final DoubleSet sourceSet = source instanceof DoubleSet ? (DoubleSet) source : source.toSet();</span>
<span class="nc" id="L453">        DoubleArrayList retained = this.select(sourceSet::contains);</span>
<span class="nc" id="L454">        this.size = retained.size;</span>
<span class="nc" id="L455">        this.items = retained.items;</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">        return oldSize != this.size();</span>
    }

    @Override
    public boolean retainAll(double... source)
    {
<span class="nc" id="L462">        return this.retainAll(DoubleHashSet.newSetWith(source));</span>
    }

    @Override
    public double removeAtIndex(int index)
    {
<span class="nc" id="L468">        double previous = this.get(index);</span>
<span class="nc" id="L469">        int totalOffset = this.size - index - 1;</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">        if (totalOffset &gt; 0)</span>
        {
<span class="nc" id="L472">            System.arraycopy(this.items, index + 1, this.items, index, totalOffset);</span>
        }
<span class="nc" id="L474">        --this.size;</span>
<span class="nc" id="L475">        this.items[this.size] = 0.0;</span>
<span class="nc" id="L476">        return previous;</span>
    }

    @Override
    public double set(int index, double element)
    {
<span class="nc" id="L482">        double previous = this.get(index);</span>
<span class="nc" id="L483">        this.items[index] = element;</span>
<span class="nc" id="L484">        return previous;</span>
    }

    @Override
    public DoubleArrayList with(double element)
    {
<span class="nc" id="L490">        this.add(element);</span>
<span class="nc" id="L491">        return this;</span>
    }

    @Override
    public DoubleArrayList without(double element)
    {
<span class="nc" id="L497">        this.remove(element);</span>
<span class="nc" id="L498">        return this;</span>
    }

    @Override
    public DoubleArrayList withAll(DoubleIterable elements)
    {
<span class="nc" id="L504">        this.addAll(elements.toArray());</span>
<span class="nc" id="L505">        return this;</span>
    }

    @Override
    public DoubleArrayList withoutAll(DoubleIterable elements)
    {
<span class="nc" id="L511">        this.removeAll(elements);</span>
<span class="nc" id="L512">        return this;</span>
    }

    public DoubleArrayList with(double element1, double element2)
    {
<span class="nc" id="L517">        this.add(element1);</span>
<span class="nc" id="L518">        this.add(element2);</span>
<span class="nc" id="L519">        return this;</span>
    }

    public DoubleArrayList with(double element1, double element2, double element3)
    {
<span class="nc" id="L524">        this.add(element1);</span>
<span class="nc" id="L525">        this.add(element2);</span>
<span class="nc" id="L526">        this.add(element3);</span>
<span class="nc" id="L527">        return this;</span>
    }

    public DoubleArrayList with(double element1, double element2, double element3, double... elements)
    {
<span class="nc" id="L532">        this.add(element1);</span>
<span class="nc" id="L533">        this.add(element2);</span>
<span class="nc" id="L534">        this.add(element3);</span>
<span class="nc" id="L535">        return this.withArrayCopy(elements, 0, elements.length);</span>
    }

    private DoubleArrayList withArrayCopy(double[] elements, int begin, int length)
    {
<span class="nc" id="L540">        this.ensureCapacity(this.size + length);</span>
<span class="nc" id="L541">        System.arraycopy(elements, begin, this.items, this.size, length);</span>
<span class="nc" id="L542">        this.size += length;</span>
<span class="nc" id="L543">        return this;</span>
    }

    @Override
    public MutableDoubleIterator doubleIterator()
    {
<span class="nc" id="L549">        return new InternalDoubleIterator();</span>
    }

    @Override
    public void forEach(DoubleProcedure procedure)
    {
<span class="nc" id="L555">        this.each(procedure);</span>
<span class="nc" id="L556">    }</span>

    /**
     * @since 7.0.
     */
    @Override
    public void each(DoubleProcedure procedure)
    {
<span class="nc bnc" id="L564" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L566">            procedure.value(this.items[i]);</span>
        }
<span class="nc" id="L568">    }</span>

    @Override
    public void forEachWithIndex(DoubleIntProcedure procedure)
    {
<span class="nc bnc" id="L573" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L575">            procedure.value(this.items[i], i);</span>
        }
<span class="nc" id="L577">    }</span>

    @Override
    public &lt;T&gt; T injectInto(T injectedValue, ObjectDoubleToObjectFunction&lt;? super T, ? extends T&gt; function)
    {
<span class="nc" id="L582">        T result = injectedValue;</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L585">            result = function.valueOf(result, this.items[i]);</span>
        }
<span class="nc" id="L587">        return result;</span>
    }

    @Override
    public &lt;T&gt; T injectIntoWithIndex(T injectedValue, ObjectDoubleIntToObjectFunction&lt;? super T, ? extends T&gt; function)
    {
<span class="nc" id="L593">        T result = injectedValue;</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L596">            result = function.valueOf(result, this.items[i], i);</span>
        }
<span class="nc" id="L598">        return result;</span>
    }

    @Override
    public RichIterable&lt;DoubleIterable&gt; chunk(int size)
    {
<span class="nc bnc" id="L604" title="All 2 branches missed.">        if (size &lt;= 0)</span>
        {
<span class="nc" id="L606">            throw new IllegalArgumentException(&quot;Size for groups must be positive but was: &quot; + size);</span>
        }
<span class="nc" id="L608">        MutableList&lt;DoubleIterable&gt; result = Lists.mutable.empty();</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">        if (this.notEmpty())</span>
        {
<span class="nc bnc" id="L611" title="All 2 branches missed.">            if (this.size() &lt;= size)</span>
            {
<span class="nc" id="L613">                result.add(DoubleLists.mutable.withAll(this));</span>
            }
            else
            {
<span class="nc" id="L617">                DoubleIterator iterator = this.doubleIterator();</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">                while (iterator.hasNext())</span>
                {
<span class="nc" id="L620">                    MutableDoubleList batch = DoubleLists.mutable.empty();</span>
<span class="nc bnc" id="L621" title="All 4 branches missed.">                    for (int i = 0; i &lt; size &amp;&amp; iterator.hasNext(); i++)</span>
                    {
<span class="nc" id="L623">                        batch.add(iterator.next());</span>
                    }
<span class="nc" id="L625">                    result.add(batch);</span>
<span class="nc" id="L626">                }</span>
            }
        }
<span class="nc" id="L629">        return result;</span>
    }

    @Override
    public int count(DoublePredicate predicate)
    {
<span class="nc" id="L635">        int count = 0;</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (predicate.accept(this.items[i]))</span>
            {
<span class="nc" id="L640">                count++;</span>
            }
        }
<span class="nc" id="L643">        return count;</span>
    }

    @Override
    public boolean anySatisfy(DoublePredicate predicate)
    {
<span class="nc bnc" id="L649" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc bnc" id="L651" title="All 2 branches missed.">            if (predicate.accept(this.items[i]))</span>
            {
<span class="nc" id="L653">                return true;</span>
            }
        }
<span class="nc" id="L656">        return false;</span>
    }

    @Override
    public boolean allSatisfy(DoublePredicate predicate)
    {
<span class="nc bnc" id="L662" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc bnc" id="L664" title="All 2 branches missed.">            if (!predicate.accept(this.items[i]))</span>
            {
<span class="nc" id="L666">                return false;</span>
            }
        }
<span class="nc" id="L669">        return true;</span>
    }

    @Override
    public boolean noneSatisfy(DoublePredicate predicate)
    {
<span class="nc bnc" id="L675" title="All 2 branches missed.">        return !this.anySatisfy(predicate);</span>
    }

    @Override
    public DoubleArrayList select(DoublePredicate predicate)
    {
<span class="nc" id="L681">        return this.select(predicate, new DoubleArrayList());</span>
    }

    /**
     * @since 8.1.
     */
    @Override
    public &lt;R extends MutableDoubleCollection&gt; R select(DoublePredicate predicate, R target)
    {
<span class="nc bnc" id="L690" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L692">            double item = this.items[i];</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">            if (predicate.accept(item))</span>
            {
<span class="nc" id="L695">                target.add(item);</span>
            }
        }
<span class="nc" id="L698">        return target;</span>
    }

    @Override
    public DoubleArrayList reject(DoublePredicate predicate)
    {
<span class="nc" id="L704">        return this.reject(predicate, new DoubleArrayList());</span>
    }

    /**
     * @since 8.1.
     */
    @Override
    public &lt;R extends MutableDoubleCollection&gt; R reject(DoublePredicate predicate, R target)
    {
<span class="nc bnc" id="L713" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L715">            double item = this.items[i];</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">            if (!predicate.accept(item))</span>
            {
<span class="nc" id="L718">                target.add(item);</span>
            }
        }
<span class="nc" id="L721">        return target;</span>
    }

    @Override
    public double detectIfNone(DoublePredicate predicate, double ifNone)
    {
<span class="nc bnc" id="L727" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L729">            double item = this.items[i];</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">            if (predicate.accept(item))</span>
            {
<span class="nc" id="L732">                return item;</span>
            }
        }
<span class="nc" id="L735">        return ifNone;</span>
    }

    @Override
    public &lt;V&gt; MutableList&lt;V&gt; collect(DoubleToObjectFunction&lt;? extends V&gt; function)
    {
<span class="nc" id="L741">        return this.collect(function, FastList.newList(this.size));</span>
    }

    /**
     * @since 8.1.
     */
    @Override
    public &lt;V, R extends Collection&lt;V&gt;&gt; R collect(DoubleToObjectFunction&lt;? extends V&gt; function, R target)
    {
<span class="nc bnc" id="L750" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L752">            target.add(function.valueOf(this.items[i]));</span>
        }
<span class="nc" id="L754">        return target;</span>
    }

    @Override
    public double max()
    {
<span class="nc bnc" id="L760" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L762">            throw new NoSuchElementException();</span>
        }
<span class="nc" id="L764">        double max = this.items[0];</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">        for (int i = 1; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L767">            double value = this.items[i];</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">            if (Double.compare(max, value) &lt; 0)</span>
            {
<span class="nc" id="L770">                max = value;</span>
            }
        }
<span class="nc" id="L773">        return max;</span>
    }

    @Override
    public double min()
    {
<span class="nc bnc" id="L779" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L781">            throw new NoSuchElementException();</span>
        }
<span class="nc" id="L783">        double min = this.items[0];</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">        for (int i = 1; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L786">            double value = this.items[i];</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (Double.compare(value, min) &lt; 0)</span>
            {
<span class="nc" id="L789">                min = value;</span>
            }
        }
<span class="nc" id="L792">        return min;</span>
    }

    @Override
    public double sum()
    {
<span class="nc" id="L798">        double result = 0.0;</span>
<span class="nc" id="L799">        double compensation = 0.0;</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L802">            double adjustedValue = this.items[i] - compensation;</span>
<span class="nc" id="L803">            double nextSum = result + adjustedValue;</span>
<span class="nc" id="L804">            compensation = nextSum - result - adjustedValue;</span>
<span class="nc" id="L805">            result = nextSum;</span>
        }
<span class="nc" id="L807">        return result;</span>
    }

    @Override
    public double dotProduct(DoubleList list)
    {
<span class="nc bnc" id="L813" title="All 2 branches missed.">        if (this.size != list.size())</span>
        {
<span class="nc" id="L815">            throw new IllegalArgumentException(&quot;Lists used in dotProduct must be the same size&quot;);</span>
        }
<span class="nc" id="L817">        double sum = 0.0;</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L820">            sum += this.items[i] * list.get(i);</span>
        }
<span class="nc" id="L822">        return sum;</span>
    }

    @Override
    public double[] toArray()
    {
<span class="nc" id="L828">        double[] newItems = new double[this.size];</span>
<span class="nc" id="L829">        System.arraycopy(this.items, 0, newItems, 0, this.size);</span>
<span class="nc" id="L830">        return newItems;</span>
    }

    @Override
    public boolean equals(Object otherList)
    {
<span class="nc bnc" id="L836" title="All 2 branches missed.">        if (otherList == this)</span>
        {
<span class="nc" id="L838">            return true;</span>
        }
<span class="nc bnc" id="L840" title="All 2 branches missed.">        if (!(otherList instanceof DoubleList))</span>
        {
<span class="nc" id="L842">            return false;</span>
        }
<span class="nc" id="L844">        DoubleList list = (DoubleList) otherList;</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">        if (this.size != list.size())</span>
        {
<span class="nc" id="L847">            return false;</span>
        }
<span class="nc bnc" id="L849" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc bnc" id="L851" title="All 2 branches missed.">            if (Double.compare(this.items[i], list.get(i)) != 0)</span>
            {
<span class="nc" id="L853">                return false;</span>
            }
        }
<span class="nc" id="L856">        return true;</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L862">        int hashCode = 1;</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L865">            double item = this.items[i];</span>
<span class="nc" id="L866">            hashCode = 31 * hashCode + (int) (Double.doubleToLongBits(item) ^ Double.doubleToLongBits(item) &gt;&gt;&gt; 32);</span>
        }
<span class="nc" id="L868">        return hashCode;</span>
    }

    @Override
    public void appendString(
            Appendable appendable,
            String start,
            String separator,
            String end)
    {
        try
        {
<span class="nc" id="L880">            appendable.append(start);</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">            for (int i = 0; i &lt; this.size; i++)</span>
            {
<span class="nc bnc" id="L883" title="All 2 branches missed.">                if (i &gt; 0)</span>
                {
<span class="nc" id="L885">                    appendable.append(separator);</span>
                }
<span class="nc" id="L887">                double value = this.items[i];</span>
<span class="nc" id="L888">                appendable.append(String.valueOf(value));</span>
            }
<span class="nc" id="L890">            appendable.append(end);</span>
        }
<span class="nc" id="L892">        catch (IOException e)</span>
        {
<span class="nc" id="L894">            throw new RuntimeException(e);</span>
<span class="nc" id="L895">        }</span>
<span class="nc" id="L896">    }</span>

    @Override
    public MutableDoubleList asUnmodifiable()
    {
<span class="nc" id="L901">        return new UnmodifiableDoubleList(this);</span>
    }

    @Override
    public MutableDoubleList asSynchronized()
    {
<span class="nc" id="L907">        return new SynchronizedDoubleList(this);</span>
    }

    @Override
    public ImmutableDoubleList toImmutable()
    {
<span class="nc bnc" id="L913" title="All 2 branches missed.">        if (this.size == 0)</span>
        {
<span class="nc" id="L915">            return DoubleLists.immutable.empty();</span>
        }
<span class="nc bnc" id="L917" title="All 2 branches missed.">        if (this.size == 1)</span>
        {
<span class="nc" id="L919">            return DoubleLists.immutable.with(this.items[0]);</span>
        }
<span class="nc" id="L921">        return DoubleLists.immutable.with(this.toArray());</span>
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException
    {
<span class="nc" id="L927">        out.writeInt(this.size);</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L930">            out.writeDouble(this.items[i]);</span>
        }
<span class="nc" id="L932">    }</span>

    @Override
    public void readExternal(ObjectInput in) throws IOException
    {
<span class="nc" id="L937">        this.size = in.readInt();</span>
<span class="nc" id="L938">        this.items = new double[this.size];</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L941">            this.items[i] = in.readDouble();</span>
        }
<span class="nc" id="L943">    }</span>

    @Override
    public LazyDoubleIterable asReversed()
    {
<span class="nc" id="L948">        return ReverseDoubleIterable.adapt(this);</span>
    }

    @Override
    public DoubleArrayList reverseThis()
    {
<span class="nc" id="L954">        int endIndex = this.size - 1;</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size / 2; i++)</span>
        {
<span class="nc" id="L957">            double tempSwapValue = this.items[i];</span>
<span class="nc" id="L958">            this.items[i] = this.items[endIndex - i];</span>
<span class="nc" id="L959">            this.items[endIndex - i] = tempSwapValue;</span>
        }
<span class="nc" id="L961">        return this;</span>
    }

    @Override
    public DoubleArrayList sortThis()
    {
<span class="nc" id="L967">        Arrays.sort(this.items, 0, this.size);</span>
<span class="nc" id="L968">        return this;</span>
    }

    @Override
    public DoubleArrayList toReversed()
    {
<span class="nc" id="L974">        return DoubleArrayList.newList(this.asReversed());</span>
    }

    @Override
    public int binarySearch(double value)
    {
<span class="nc" id="L980">        return Arrays.binarySearch(this.items, 0, this.size, value);</span>
    }

    @Override
    public MutableDoubleList distinct()
    {
<span class="nc" id="L986">        DoubleArrayList target = new DoubleArrayList();</span>
<span class="nc" id="L987">        MutableDoubleSet seenSoFar = new DoubleHashSet(this.size());</span>

<span class="nc bnc" id="L989" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size; i++)</span>
        {
<span class="nc" id="L991">            double each = this.items[i];</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">            if (seenSoFar.add(each))</span>
            {
<span class="nc" id="L994">                target.add(each);</span>
            }
        }
<span class="nc" id="L997">        return target;</span>
    }

    @Override
    public MutableDoubleList subList(int fromIndex, int toIndex)
    {
<span class="nc" id="L1003">        throw new UnsupportedOperationException(&quot;subList not yet implemented!&quot;);</span>
    }

    /**
     * @since 9.1.
     */
    @Override
    public MutableList&lt;DoubleDoublePair&gt; zipDouble(DoubleIterable iterable)
    {
<span class="nc" id="L1012">        int size = this.size();</span>
<span class="nc" id="L1013">        int otherSize = iterable.size();</span>
<span class="nc" id="L1014">        MutableList&lt;DoubleDoublePair&gt; target = Lists.mutable.withInitialCapacity(Math.min(size, otherSize));</span>
<span class="nc" id="L1015">        DoubleIterator iterator = iterable.doubleIterator();</span>
<span class="nc bnc" id="L1016" title="All 4 branches missed.">        for (int i = 0; i &lt; size &amp;&amp; i &lt; otherSize; i++)</span>
        {
<span class="nc" id="L1018">            target.add(PrimitiveTuples.pair(this.items[i], iterator.next()));</span>
        }
<span class="nc" id="L1020">        return target;</span>
    }

    /**
     * Creates a new empty DoubleArrayList.
     *
     * @since 9.2.
     */
    public DoubleArrayList newEmpty()
    {
<span class="nc" id="L1030">        return new DoubleArrayList();</span>
    }

    /**
     * @since 9.1.
     */
    @Override
    public &lt;T&gt; MutableList&lt;DoubleObjectPair&lt;T&gt;&gt; zip(Iterable&lt;T&gt; iterable)
    {
<span class="nc" id="L1039">        int size = this.size();</span>
<span class="nc" id="L1040">        int otherSize = Iterate.sizeOf(iterable);</span>
<span class="nc" id="L1041">        MutableList&lt;DoubleObjectPair&lt;T&gt;&gt; target = Lists.mutable.withInitialCapacity(Math.min(size, otherSize));</span>
<span class="nc" id="L1042">        Iterator&lt;T&gt; iterator = iterable.iterator();</span>
<span class="nc bnc" id="L1043" title="All 4 branches missed.">        for (int i = 0; i &lt; size &amp;&amp; iterator.hasNext(); i++)</span>
        {
<span class="nc" id="L1045">            target.add(PrimitiveTuples.pair(this.items[i], iterator.next()));</span>
        }
<span class="nc" id="L1047">        return target;</span>
    }

<span class="nc" id="L1050">    private class InternalDoubleIterator implements MutableDoubleIterator</span>
    {
        /**
         * Index of element to be returned by subsequent call to next.
         */
        private int currentIndex;
<span class="nc" id="L1056">        private int lastIndex = -1;</span>

        @Override
        public boolean hasNext()
        {
<span class="nc bnc" id="L1061" title="All 2 branches missed.">            return this.currentIndex != DoubleArrayList.this.size();</span>
        }

        @Override
        public double next()
        {
<span class="nc bnc" id="L1067" title="All 2 branches missed.">            if (!this.hasNext())</span>
            {
<span class="nc" id="L1069">                throw new NoSuchElementException();</span>
            }
<span class="nc" id="L1071">            double next = DoubleArrayList.this.items[this.currentIndex];</span>
<span class="nc" id="L1072">            this.lastIndex = this.currentIndex++;</span>
<span class="nc" id="L1073">            return next;</span>
        }

        @Override
        public void remove()
        {
<span class="nc bnc" id="L1079" title="All 2 branches missed.">            if (this.lastIndex == -1)</span>
            {
<span class="nc" id="L1081">                throw new IllegalStateException();</span>
            }
<span class="nc" id="L1083">            DoubleArrayList.this.removeAtIndex(this.lastIndex);</span>
<span class="nc" id="L1084">            this.currentIndex--;</span>
<span class="nc" id="L1085">            this.lastIndex = -1;</span>
<span class="nc" id="L1086">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>