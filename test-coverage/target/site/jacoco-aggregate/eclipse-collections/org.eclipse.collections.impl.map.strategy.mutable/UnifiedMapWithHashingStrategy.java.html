<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>UnifiedMapWithHashingStrategy.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.impl.map.strategy.mutable</a> &gt; <span class="el_source">UnifiedMapWithHashingStrategy.java</span></div><h1>UnifiedMapWithHashingStrategy.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2016 Goldman Sachs and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.impl.map.strategy.mutable;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.Serializable;
import java.lang.ref.WeakReference;
import java.lang.reflect.Array;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

import org.eclipse.collections.api.block.HashingStrategy;
import org.eclipse.collections.api.block.function.Function;
import org.eclipse.collections.api.block.function.Function0;
import org.eclipse.collections.api.block.function.Function2;
import org.eclipse.collections.api.block.procedure.Procedure;
import org.eclipse.collections.api.block.procedure.Procedure2;
import org.eclipse.collections.api.block.procedure.primitive.ObjectIntProcedure;
import org.eclipse.collections.api.map.ImmutableMap;
import org.eclipse.collections.api.map.MapIterable;
import org.eclipse.collections.api.map.MutableMap;
import org.eclipse.collections.api.map.UnsortedMapIterable;
import org.eclipse.collections.api.tuple.Pair;
import org.eclipse.collections.impl.block.factory.Functions;
import org.eclipse.collections.impl.block.factory.Predicates;
import org.eclipse.collections.impl.block.procedure.MapCollectProcedure;
import org.eclipse.collections.impl.factory.HashingStrategyMaps;
import org.eclipse.collections.impl.factory.Sets;
import org.eclipse.collections.impl.list.mutable.FastList;
import org.eclipse.collections.impl.map.mutable.AbstractMutableMap;
import org.eclipse.collections.impl.parallel.BatchIterable;
import org.eclipse.collections.impl.set.strategy.mutable.UnifiedSetWithHashingStrategy;
import org.eclipse.collections.impl.tuple.ImmutableEntry;
import org.eclipse.collections.impl.utility.ArrayIterate;
import org.eclipse.collections.impl.utility.Iterate;

/**
 * UnifiedMapWithHashingStrategy stores key/value pairs in a single array, where alternate slots are keys and values.
 * This is nicer to CPU caches as consecutive memory addresses are very cheap to access.  Entry objects are not stored in the
 * table like in java.util.HashMap. Instead of trying to deal with collisions in the main array using Entry objects,
 * we put a special object in the key slot and put a regular Object[] in the value slot. The array contains the key value
 * pairs in consecutive slots, just like the main array, but it's a linear list with no hashing.
 * &lt;p&gt;
 * The difference between UnifiedMap and UnifiedMapWithHashingStrategy is that a HashingStrategy based UnifiedMap
 * does not rely on the hashCode or equality of the object at the key, but instead relies on a HashingStrategy
 * implementation provided by a developer to compute the hashCode and equals for the objects stored in the map.
 */

@SuppressWarnings(&quot;ObjectEquality&quot;)
public class UnifiedMapWithHashingStrategy&lt;K, V&gt; extends AbstractMutableMap&lt;K, V&gt;
        implements Externalizable, BatchIterable&lt;V&gt;
{
<span class="nc" id="L68">    protected static final Object NULL_KEY = new Object()</span>
<span class="nc" id="L69">    {</span>
        @Override
        public boolean equals(Object obj)
        {
<span class="nc" id="L73">            throw new RuntimeException(&quot;Possible corruption through unsynchronized concurrent modification.&quot;);</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L79">            throw new RuntimeException(&quot;Possible corruption through unsynchronized concurrent modification.&quot;);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L85">            return &quot;UnifiedMapWithHashingStrategy.NULL_KEY&quot;;</span>
        }
    };

<span class="nc" id="L89">    protected static final Object CHAINED_KEY = new Object()</span>
<span class="nc" id="L90">    {</span>
        @Override
        public boolean equals(Object obj)
        {
<span class="nc" id="L94">            throw new RuntimeException(&quot;Possible corruption through unsynchronized concurrent modification.&quot;);</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L100">            throw new RuntimeException(&quot;Possible corruption through unsynchronized concurrent modification.&quot;);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L106">            return &quot;UnifiedMapWithHashingStrategy.CHAINED_KEY&quot;;</span>
        }
    };

    protected static final float DEFAULT_LOAD_FACTOR = 0.75f;

    protected static final int DEFAULT_INITIAL_CAPACITY = 8;

    private static final long serialVersionUID = 1L;

    protected transient Object[] table;

    protected transient int occupied;

<span class="nc" id="L120">    protected float loadFactor = DEFAULT_LOAD_FACTOR;</span>

    protected int maxSize;

    protected HashingStrategy&lt;? super K&gt; hashingStrategy;

    /**
     * @deprecated No argument default constructor used for serialization. Instantiating an UnifiedMapWithHashingStrategyMultimap with
     * this constructor will have a null hashingStrategy and throw NullPointerException when used.
     */
    @Deprecated
    public UnifiedMapWithHashingStrategy()
<span class="nc" id="L132">    {</span>
<span class="nc" id="L133">    }</span>

    public UnifiedMapWithHashingStrategy(HashingStrategy&lt;? super K&gt; hashingStrategy)
<span class="nc" id="L136">    {</span>
<span class="nc" id="L137">        this.hashingStrategy = hashingStrategy;</span>
<span class="nc" id="L138">        this.allocate(DEFAULT_INITIAL_CAPACITY &lt;&lt; 1);</span>
<span class="nc" id="L139">    }</span>

    public UnifiedMapWithHashingStrategy(HashingStrategy&lt;? super K&gt; hashingStrategy, int initialCapacity)
    {
<span class="nc" id="L143">        this(hashingStrategy, initialCapacity, DEFAULT_LOAD_FACTOR);</span>
<span class="nc" id="L144">    }</span>

    public UnifiedMapWithHashingStrategy(HashingStrategy&lt;? super K&gt; hashingStrategy, int initialCapacity, float loadFactor)
<span class="nc" id="L147">    {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (initialCapacity &lt; 0)</span>
        {
<span class="nc" id="L150">            throw new IllegalArgumentException(&quot;initial capacity cannot be less than 0&quot;);</span>
        }
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (loadFactor &lt;= 0.0)</span>
        {
<span class="nc" id="L154">            throw new IllegalArgumentException(&quot;load factor cannot be less than or equal to 0&quot;);</span>
        }
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (loadFactor &gt; 1.0)</span>
        {
<span class="nc" id="L158">            throw new IllegalArgumentException(&quot;load factor cannot be greater than 1&quot;);</span>
        }

<span class="nc" id="L161">        this.hashingStrategy = hashingStrategy;</span>
<span class="nc" id="L162">        this.loadFactor = loadFactor;</span>
<span class="nc" id="L163">        this.init(this.fastCeil(initialCapacity / loadFactor));</span>
<span class="nc" id="L164">    }</span>

    public UnifiedMapWithHashingStrategy(HashingStrategy&lt;? super K&gt; hashingStrategy, Map&lt;? extends K, ? extends V&gt; map)
    {
<span class="nc" id="L168">        this(hashingStrategy, Math.max(map.size(), DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span>

<span class="nc" id="L170">        this.putAll(map);</span>
<span class="nc" id="L171">    }</span>

    public UnifiedMapWithHashingStrategy(HashingStrategy&lt;? super K&gt; hashingStrategy, Pair&lt;K, V&gt;... pairs)
    {
<span class="nc" id="L175">        this(hashingStrategy, Math.max(pairs.length, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span>
<span class="nc" id="L176">        ArrayIterate.forEach(pairs, new MapCollectProcedure&lt;Pair&lt;K, V&gt;, K, V&gt;(</span>
                this,
<span class="nc" id="L178">                Functions.firstOfPair(),</span>
<span class="nc" id="L179">                Functions.secondOfPair()));</span>
<span class="nc" id="L180">    }</span>

    public static &lt;K, V&gt; UnifiedMapWithHashingStrategy&lt;K, V&gt; newMap(HashingStrategy&lt;? super K&gt; hashingStrategy)
    {
<span class="nc" id="L184">        return new UnifiedMapWithHashingStrategy&lt;&gt;(hashingStrategy);</span>
    }

    public static &lt;K, V&gt; UnifiedMapWithHashingStrategy&lt;K, V&gt; newMap(
            HashingStrategy&lt;? super K&gt; hashingStrategy,
            int size)
    {
<span class="nc" id="L191">        return new UnifiedMapWithHashingStrategy&lt;&gt;(hashingStrategy, size);</span>
    }

    public static &lt;K, V&gt; UnifiedMapWithHashingStrategy&lt;K, V&gt; newMap(
            HashingStrategy&lt;? super K&gt; hashingStrategy,
            int size,
            float loadFactor)
    {
<span class="nc" id="L199">        return new UnifiedMapWithHashingStrategy&lt;&gt;(hashingStrategy, size, loadFactor);</span>
    }

    public static &lt;K, V&gt; UnifiedMapWithHashingStrategy&lt;K, V&gt; newMap(
            HashingStrategy&lt;? super K&gt; hashingStrategy,
            Map&lt;? extends K, ? extends V&gt; map)
    {
<span class="nc" id="L206">        return new UnifiedMapWithHashingStrategy&lt;&gt;(hashingStrategy, map);</span>
    }

    public static &lt;K, V&gt; UnifiedMapWithHashingStrategy&lt;K, V&gt; newMapWith(HashingStrategy&lt;? super K&gt; hashingStrategy, Iterable&lt;Pair&lt;K, V&gt;&gt; inputIterable)
    {
<span class="nc" id="L211">        UnifiedMapWithHashingStrategy&lt;K, V&gt; outputMap = UnifiedMapWithHashingStrategy.newMap(hashingStrategy);</span>

<span class="nc bnc" id="L213" title="All 2 branches missed.">        for (Pair&lt;K, V&gt; single : inputIterable)</span>
        {
<span class="nc" id="L215">            outputMap.add(single);</span>
<span class="nc" id="L216">        }</span>
<span class="nc" id="L217">        return outputMap;</span>
    }

    public static &lt;K, V&gt; UnifiedMapWithHashingStrategy&lt;K, V&gt; newMap(UnifiedMapWithHashingStrategy&lt;K, V&gt; map)
    {
<span class="nc" id="L222">        return new UnifiedMapWithHashingStrategy&lt;&gt;(map.hashingStrategy, map);</span>
    }

    public static &lt;K, V&gt; UnifiedMapWithHashingStrategy&lt;K, V&gt; newMapWith(
            HashingStrategy&lt;? super K&gt; hashingStrategy,
            Pair&lt;K, V&gt;... pairs)
    {
<span class="nc" id="L229">        return new UnifiedMapWithHashingStrategy&lt;&gt;(hashingStrategy, pairs);</span>
    }

    public static &lt;K, V&gt; UnifiedMapWithHashingStrategy&lt;K, V&gt; newWithKeysValues(
            HashingStrategy&lt;? super K&gt; hashingStrategy,
            K key, V value)
    {
<span class="nc" id="L236">        return new UnifiedMapWithHashingStrategy&lt;K, V&gt;(hashingStrategy, 1).withKeysValues(key, value);</span>
    }

    public static &lt;K, V&gt; UnifiedMapWithHashingStrategy&lt;K, V&gt; newWithKeysValues(
            HashingStrategy&lt;? super K&gt; hashingStrategy,
            K key1, V value1,
            K key2, V value2)
    {
<span class="nc" id="L244">        return new UnifiedMapWithHashingStrategy&lt;K, V&gt;(hashingStrategy, 2).withKeysValues(key1, value1, key2, value2);</span>
    }

    public static &lt;K, V&gt; UnifiedMapWithHashingStrategy&lt;K, V&gt; newWithKeysValues(
            HashingStrategy&lt;? super K&gt; hashingStrategy,
            K key1, V value1,
            K key2, V value2,
            K key3, V value3)
    {
<span class="nc" id="L253">        return new UnifiedMapWithHashingStrategy&lt;K, V&gt;(hashingStrategy, 3).withKeysValues(key1, value1, key2, value2, key3, value3);</span>
    }

    public static &lt;K, V&gt; UnifiedMapWithHashingStrategy&lt;K, V&gt; newWithKeysValues(
            HashingStrategy&lt;? super K&gt; hashingStrategy,
            K key1, V value1,
            K key2, V value2,
            K key3, V value3,
            K key4, V value4)
    {
<span class="nc" id="L263">        return new UnifiedMapWithHashingStrategy&lt;K, V&gt;(hashingStrategy, 4).withKeysValues(key1, value1, key2, value2, key3, value3, key4, value4);</span>
    }

    public UnifiedMapWithHashingStrategy&lt;K, V&gt; withKeysValues(K key, V value)
    {
<span class="nc" id="L268">        this.put(key, value);</span>
<span class="nc" id="L269">        return this;</span>
    }

    public UnifiedMapWithHashingStrategy&lt;K, V&gt; withKeysValues(K key1, V value1, K key2, V value2)
    {
<span class="nc" id="L274">        this.put(key1, value1);</span>
<span class="nc" id="L275">        this.put(key2, value2);</span>
<span class="nc" id="L276">        return this;</span>
    }

    public UnifiedMapWithHashingStrategy&lt;K, V&gt; withKeysValues(K key1, V value1, K key2, V value2, K key3, V value3)
    {
<span class="nc" id="L281">        this.put(key1, value1);</span>
<span class="nc" id="L282">        this.put(key2, value2);</span>
<span class="nc" id="L283">        this.put(key3, value3);</span>
<span class="nc" id="L284">        return this;</span>
    }

    public UnifiedMapWithHashingStrategy&lt;K, V&gt; withKeysValues(K key1, V value1, K key2, V value2, K key3, V value3, K key4, V value4)
    {
<span class="nc" id="L289">        this.put(key1, value1);</span>
<span class="nc" id="L290">        this.put(key2, value2);</span>
<span class="nc" id="L291">        this.put(key3, value3);</span>
<span class="nc" id="L292">        this.put(key4, value4);</span>
<span class="nc" id="L293">        return this;</span>
    }

    public HashingStrategy&lt;? super K&gt; hashingStrategy()
    {
<span class="nc" id="L298">        return this.hashingStrategy;</span>
    }

    @Override
    public UnifiedMapWithHashingStrategy&lt;K, V&gt; clone()
    {
<span class="nc" id="L304">        return new UnifiedMapWithHashingStrategy&lt;&gt;(this.hashingStrategy, this);</span>
    }

    @Override
    public MutableMap&lt;K, V&gt; newEmpty()
    {
<span class="nc" id="L310">        return new UnifiedMapWithHashingStrategy&lt;&gt;(this.hashingStrategy);</span>
    }

    @Override
    public MutableMap&lt;K, V&gt; newEmpty(int capacity)
    {
<span class="nc" id="L316">        return new UnifiedMapWithHashingStrategy&lt;&gt;(this.hashingStrategy, capacity, this.loadFactor);</span>
    }

    private int fastCeil(float v)
    {
<span class="nc" id="L321">        int possibleResult = (int) v;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (v - possibleResult &gt; 0.0F)</span>
        {
<span class="nc" id="L324">            possibleResult++;</span>
        }
<span class="nc" id="L326">        return possibleResult;</span>
    }

    protected int init(int initialCapacity)
    {
<span class="nc" id="L331">        int capacity = 1;</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        while (capacity &lt; initialCapacity)</span>
        {
<span class="nc" id="L334">            capacity &lt;&lt;= 1;</span>
        }

<span class="nc" id="L337">        return this.allocate(capacity);</span>
    }

    protected int allocate(int capacity)
    {
<span class="nc" id="L342">        this.allocateTable(capacity &lt;&lt; 1); // the table size is twice the capacity to handle both keys and values</span>
<span class="nc" id="L343">        this.computeMaxSize(capacity);</span>

<span class="nc" id="L345">        return capacity;</span>
    }

    protected void allocateTable(int sizeToAllocate)
    {
<span class="nc" id="L350">        this.table = new Object[sizeToAllocate];</span>
<span class="nc" id="L351">    }</span>

    protected void computeMaxSize(int capacity)
    {
        // need at least one free slot for open addressing
<span class="nc" id="L356">        this.maxSize = Math.min(capacity - 1, (int) (capacity * this.loadFactor));</span>
<span class="nc" id="L357">    }</span>

    protected int index(K key)
    {
        // This function ensures that hashCodes that differ only by
        // constant multiples at each bit position have a bounded
        // number of collisions (approximately 8 at default load factor).
<span class="nc" id="L364">        int h = this.hashingStrategy.computeHashCode(key);</span>
<span class="nc" id="L365">        h ^= h &gt;&gt;&gt; 20 ^ h &gt;&gt;&gt; 12;</span>
<span class="nc" id="L366">        h ^= h &gt;&gt;&gt; 7 ^ h &gt;&gt;&gt; 4;</span>
<span class="nc" id="L367">        return (h &amp; (this.table.length &gt;&gt; 1) - 1) &lt;&lt; 1;</span>
    }

    @Override
    public void clear()
    {
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (this.occupied == 0)</span>
        {
<span class="nc" id="L375">            return;</span>
        }
<span class="nc" id="L377">        this.occupied = 0;</span>
<span class="nc" id="L378">        Object[] set = this.table;</span>

<span class="nc bnc" id="L380" title="All 2 branches missed.">        for (int i = set.length; i-- &gt; 0; )</span>
        {
<span class="nc" id="L382">            set[i] = null;</span>
        }
<span class="nc" id="L384">    }</span>

    @Override
    public V put(K key, V value)
    {
<span class="nc" id="L389">        int index = this.index(key);</span>
<span class="nc" id="L390">        Object cur = this.table[index];</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L393">            this.table[index] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L394">            this.table[index + 1] = value;</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L397">                this.rehash(this.table.length);</span>
            }
<span class="nc" id="L399">            return null;</span>
        }
<span class="nc bnc" id="L401" title="All 4 branches missed.">        if (cur != CHAINED_KEY &amp;&amp; this.nonNullTableObjectEquals(cur, key))</span>
        {
<span class="nc" id="L403">            V result = (V) this.table[index + 1];</span>
<span class="nc" id="L404">            this.table[index + 1] = value;</span>
<span class="nc" id="L405">            return result;</span>
        }
<span class="nc" id="L407">        return this.chainedPut(key, index, value);</span>
    }

    private V chainedPut(K key, int index, V value)
    {
<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (this.table[index] == CHAINED_KEY)</span>
        {
<span class="nc" id="L414">            Object[] chain = (Object[]) this.table[index + 1];</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc bnc" id="L417" title="All 2 branches missed.">                if (chain[i] == null)</span>
                {
<span class="nc" id="L419">                    chain[i] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L420">                    chain[i + 1] = value;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                    if (++this.occupied &gt; this.maxSize)</span>
                    {
<span class="nc" id="L423">                        this.rehash(this.table.length);</span>
                    }
<span class="nc" id="L425">                    return null;</span>
                }
<span class="nc bnc" id="L427" title="All 2 branches missed.">                if (this.nonNullTableObjectEquals(chain[i], key))</span>
                {
<span class="nc" id="L429">                    V result = (V) chain[i + 1];</span>
<span class="nc" id="L430">                    chain[i + 1] = value;</span>
<span class="nc" id="L431">                    return result;</span>
                }
            }
<span class="nc" id="L434">            Object[] newChain = new Object[chain.length + 4];</span>
<span class="nc" id="L435">            System.arraycopy(chain, 0, newChain, 0, chain.length);</span>
<span class="nc" id="L436">            this.table[index + 1] = newChain;</span>
<span class="nc" id="L437">            newChain[chain.length] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L438">            newChain[chain.length + 1] = value;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L441">                this.rehash(this.table.length);</span>
            }
<span class="nc" id="L443">            return null;</span>
        }
<span class="nc" id="L445">        Object[] newChain = new Object[4];</span>
<span class="nc" id="L446">        newChain[0] = this.table[index];</span>
<span class="nc" id="L447">        newChain[1] = this.table[index + 1];</span>
<span class="nc" id="L448">        newChain[2] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L449">        newChain[3] = value;</span>
<span class="nc" id="L450">        this.table[index] = CHAINED_KEY;</span>
<span class="nc" id="L451">        this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if (++this.occupied &gt; this.maxSize)</span>
        {
<span class="nc" id="L454">            this.rehash(this.table.length);</span>
        }
<span class="nc" id="L456">        return null;</span>
    }

    @Override
    public V updateValue(K key, Function0&lt;? extends V&gt; factory, Function&lt;? super V, ? extends V&gt; function)
    {
<span class="nc" id="L462">        int index = this.index(key);</span>
<span class="nc" id="L463">        Object cur = this.table[index];</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L466">            this.table[index] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L467">            V result = function.valueOf(factory.value());</span>
<span class="nc" id="L468">            this.table[index + 1] = result;</span>
<span class="nc" id="L469">            ++this.occupied;</span>
<span class="nc" id="L470">            return result;</span>
        }
<span class="nc bnc" id="L472" title="All 4 branches missed.">        if (cur != CHAINED_KEY &amp;&amp; this.nonNullTableObjectEquals(cur, key))</span>
        {
<span class="nc" id="L474">            V oldValue = (V) this.table[index + 1];</span>
<span class="nc" id="L475">            V newValue = function.valueOf(oldValue);</span>
<span class="nc" id="L476">            this.table[index + 1] = newValue;</span>
<span class="nc" id="L477">            return newValue;</span>
        }
<span class="nc" id="L479">        return this.chainedUpdateValue(key, index, factory, function);</span>
    }

    private V chainedUpdateValue(K key, int index, Function0&lt;? extends V&gt; factory, Function&lt;? super V, ? extends V&gt; function)
    {
<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (this.table[index] == CHAINED_KEY)</span>
        {
<span class="nc" id="L486">            Object[] chain = (Object[]) this.table[index + 1];</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc bnc" id="L489" title="All 2 branches missed.">                if (chain[i] == null)</span>
                {
<span class="nc" id="L491">                    chain[i] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L492">                    V result = function.valueOf(factory.value());</span>
<span class="nc" id="L493">                    chain[i + 1] = result;</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">                    if (++this.occupied &gt; this.maxSize)</span>
                    {
<span class="nc" id="L496">                        this.rehash(this.table.length);</span>
                    }
<span class="nc" id="L498">                    return result;</span>
                }
<span class="nc bnc" id="L500" title="All 2 branches missed.">                if (this.nonNullTableObjectEquals(chain[i], key))</span>
                {
<span class="nc" id="L502">                    V oldValue = (V) chain[i + 1];</span>
<span class="nc" id="L503">                    V result = function.valueOf(oldValue);</span>
<span class="nc" id="L504">                    chain[i + 1] = result;</span>
<span class="nc" id="L505">                    return result;</span>
                }
            }
<span class="nc" id="L508">            Object[] newChain = new Object[chain.length + 4];</span>
<span class="nc" id="L509">            System.arraycopy(chain, 0, newChain, 0, chain.length);</span>
<span class="nc" id="L510">            this.table[index + 1] = newChain;</span>
<span class="nc" id="L511">            newChain[chain.length] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L512">            V result = function.valueOf(factory.value());</span>
<span class="nc" id="L513">            newChain[chain.length + 1] = result;</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L516">                this.rehash(this.table.length);</span>
            }
<span class="nc" id="L518">            return result;</span>
        }
<span class="nc" id="L520">        Object[] newChain = new Object[4];</span>
<span class="nc" id="L521">        newChain[0] = this.table[index];</span>
<span class="nc" id="L522">        newChain[1] = this.table[index + 1];</span>
<span class="nc" id="L523">        newChain[2] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L524">        V result = function.valueOf(factory.value());</span>
<span class="nc" id="L525">        newChain[3] = result;</span>
<span class="nc" id="L526">        this.table[index] = CHAINED_KEY;</span>
<span class="nc" id="L527">        this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if (++this.occupied &gt; this.maxSize)</span>
        {
<span class="nc" id="L530">            this.rehash(this.table.length);</span>
        }
<span class="nc" id="L532">        return result;</span>
    }

    @Override
    public &lt;P&gt; V updateValueWith(K key, Function0&lt;? extends V&gt; factory, Function2&lt;? super V, ? super P, ? extends V&gt; function, P parameter)
    {
<span class="nc" id="L538">        int index = this.index(key);</span>
<span class="nc" id="L539">        Object cur = this.table[index];</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L542">            this.table[index] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L543">            V result = function.value(factory.value(), parameter);</span>
<span class="nc" id="L544">            this.table[index + 1] = result;</span>
<span class="nc" id="L545">            ++this.occupied;</span>
<span class="nc" id="L546">            return result;</span>
        }
<span class="nc bnc" id="L548" title="All 4 branches missed.">        if (cur != CHAINED_KEY &amp;&amp; this.nonNullTableObjectEquals(cur, key))</span>
        {
<span class="nc" id="L550">            V oldValue = (V) this.table[index + 1];</span>
<span class="nc" id="L551">            V newValue = function.value(oldValue, parameter);</span>
<span class="nc" id="L552">            this.table[index + 1] = newValue;</span>
<span class="nc" id="L553">            return newValue;</span>
        }
<span class="nc" id="L555">        return this.chainedUpdateValueWith(key, index, factory, function, parameter);</span>
    }

    private &lt;P&gt; V chainedUpdateValueWith(
            K key,
            int index,
            Function0&lt;? extends V&gt; factory,
            Function2&lt;? super V, ? super P, ? extends V&gt; function,
            P parameter)
    {
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (this.table[index] == CHAINED_KEY)</span>
        {
<span class="nc" id="L567">            Object[] chain = (Object[]) this.table[index + 1];</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc bnc" id="L570" title="All 2 branches missed.">                if (chain[i] == null)</span>
                {
<span class="nc" id="L572">                    chain[i] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L573">                    V result = function.value(factory.value(), parameter);</span>
<span class="nc" id="L574">                    chain[i + 1] = result;</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">                    if (++this.occupied &gt; this.maxSize)</span>
                    {
<span class="nc" id="L577">                        this.rehash(this.table.length);</span>
                    }
<span class="nc" id="L579">                    return result;</span>
                }
<span class="nc bnc" id="L581" title="All 2 branches missed.">                if (this.nonNullTableObjectEquals(chain[i], key))</span>
                {
<span class="nc" id="L583">                    V oldValue = (V) chain[i + 1];</span>
<span class="nc" id="L584">                    V result = function.value(oldValue, parameter);</span>
<span class="nc" id="L585">                    chain[i + 1] = result;</span>
<span class="nc" id="L586">                    return result;</span>
                }
            }
<span class="nc" id="L589">            Object[] newChain = new Object[chain.length + 4];</span>
<span class="nc" id="L590">            System.arraycopy(chain, 0, newChain, 0, chain.length);</span>
<span class="nc" id="L591">            this.table[index + 1] = newChain;</span>
<span class="nc" id="L592">            newChain[chain.length] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L593">            V result = function.value(factory.value(), parameter);</span>
<span class="nc" id="L594">            newChain[chain.length + 1] = result;</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L597">                this.rehash(this.table.length);</span>
            }
<span class="nc" id="L599">            return result;</span>
        }
<span class="nc" id="L601">        Object[] newChain = new Object[4];</span>
<span class="nc" id="L602">        newChain[0] = this.table[index];</span>
<span class="nc" id="L603">        newChain[1] = this.table[index + 1];</span>
<span class="nc" id="L604">        newChain[2] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L605">        V result = function.value(factory.value(), parameter);</span>
<span class="nc" id="L606">        newChain[3] = result;</span>
<span class="nc" id="L607">        this.table[index] = CHAINED_KEY;</span>
<span class="nc" id="L608">        this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">        if (++this.occupied &gt; this.maxSize)</span>
        {
<span class="nc" id="L611">            this.rehash(this.table.length);</span>
        }
<span class="nc" id="L613">        return result;</span>
    }

    @Override
    public V getIfAbsentPut(K key, Function0&lt;? extends V&gt; function)
    {
<span class="nc" id="L619">        int index = this.index(key);</span>
<span class="nc" id="L620">        Object cur = this.table[index];</span>

<span class="nc bnc" id="L622" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L624">            V result = function.value();</span>
<span class="nc" id="L625">            this.table[index] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L626">            this.table[index + 1] = result;</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L629">                this.rehash(this.table.length);</span>
            }
<span class="nc" id="L631">            return result;</span>
        }
<span class="nc bnc" id="L633" title="All 4 branches missed.">        if (cur != CHAINED_KEY &amp;&amp; this.nonNullTableObjectEquals(cur, key))</span>
        {
<span class="nc" id="L635">            return (V) this.table[index + 1];</span>
        }
<span class="nc" id="L637">        return this.chainedGetIfAbsentPut(key, index, function);</span>
    }

    private V chainedGetIfAbsentPut(K key, int index, Function0&lt;? extends V&gt; function)
    {
<span class="nc" id="L642">        V result = null;</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">        if (this.table[index] == CHAINED_KEY)</span>
        {
<span class="nc" id="L645">            Object[] chain = (Object[]) this.table[index + 1];</span>
<span class="nc" id="L646">            int i = 0;</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">            for (; i &lt; chain.length; i += 2)</span>
            {
<span class="nc bnc" id="L649" title="All 2 branches missed.">                if (chain[i] == null)</span>
                {
<span class="nc" id="L651">                    result = function.value();</span>
<span class="nc" id="L652">                    chain[i] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L653">                    chain[i + 1] = result;</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">                    if (++this.occupied &gt; this.maxSize)</span>
                    {
<span class="nc" id="L656">                        this.rehash(this.table.length);</span>
                    }
                    break;
                }
<span class="nc bnc" id="L660" title="All 2 branches missed.">                if (this.nonNullTableObjectEquals(chain[i], key))</span>
                {
<span class="nc" id="L662">                    result = (V) chain[i + 1];</span>
<span class="nc" id="L663">                    break;</span>
                }
            }
<span class="nc bnc" id="L666" title="All 2 branches missed.">            if (i == chain.length)</span>
            {
<span class="nc" id="L668">                result = function.value();</span>
<span class="nc" id="L669">                Object[] newChain = new Object[chain.length + 4];</span>
<span class="nc" id="L670">                System.arraycopy(chain, 0, newChain, 0, chain.length);</span>
<span class="nc" id="L671">                newChain[i] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L672">                newChain[i + 1] = result;</span>
<span class="nc" id="L673">                this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">                if (++this.occupied &gt; this.maxSize)</span>
                {
<span class="nc" id="L676">                    this.rehash(this.table.length);</span>
                }
            }
<span class="nc" id="L679">        }</span>
        else
        {
<span class="nc" id="L682">            result = function.value();</span>
<span class="nc" id="L683">            Object[] newChain = new Object[4];</span>
<span class="nc" id="L684">            newChain[0] = this.table[index];</span>
<span class="nc" id="L685">            newChain[1] = this.table[index + 1];</span>
<span class="nc" id="L686">            newChain[2] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L687">            newChain[3] = result;</span>
<span class="nc" id="L688">            this.table[index] = CHAINED_KEY;</span>
<span class="nc" id="L689">            this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L692">                this.rehash(this.table.length);</span>
            }
        }
<span class="nc" id="L695">        return result;</span>
    }

    @Override
    public V getIfAbsentPut(K key, V value)
    {
<span class="nc" id="L701">        int index = this.index(key);</span>
<span class="nc" id="L702">        Object cur = this.table[index];</span>

<span class="nc bnc" id="L704" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L706">            this.table[index] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L707">            this.table[index + 1] = value;</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L710">                this.rehash(this.table.length);</span>
            }
<span class="nc" id="L712">            return value;</span>
        }
<span class="nc bnc" id="L714" title="All 4 branches missed.">        if (cur != CHAINED_KEY &amp;&amp; this.nonNullTableObjectEquals(cur, key))</span>
        {
<span class="nc" id="L716">            return (V) this.table[index + 1];</span>
        }
<span class="nc" id="L718">        return this.chainedGetIfAbsentPut(key, index, value);</span>
    }

    private V chainedGetIfAbsentPut(K key, int index, V value)
    {
<span class="nc" id="L723">        V result = value;</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">        if (this.table[index] == CHAINED_KEY)</span>
        {
<span class="nc" id="L726">            Object[] chain = (Object[]) this.table[index + 1];</span>
<span class="nc" id="L727">            int i = 0;</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">            for (; i &lt; chain.length; i += 2)</span>
            {
<span class="nc bnc" id="L730" title="All 2 branches missed.">                if (chain[i] == null)</span>
                {
<span class="nc" id="L732">                    chain[i] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L733">                    chain[i + 1] = value;</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">                    if (++this.occupied &gt; this.maxSize)</span>
                    {
<span class="nc" id="L736">                        this.rehash(this.table.length);</span>
                    }
                    break;
                }
<span class="nc bnc" id="L740" title="All 2 branches missed.">                if (this.nonNullTableObjectEquals(chain[i], key))</span>
                {
<span class="nc" id="L742">                    result = (V) chain[i + 1];</span>
<span class="nc" id="L743">                    break;</span>
                }
            }
<span class="nc bnc" id="L746" title="All 2 branches missed.">            if (i == chain.length)</span>
            {
<span class="nc" id="L748">                Object[] newChain = new Object[chain.length + 4];</span>
<span class="nc" id="L749">                System.arraycopy(chain, 0, newChain, 0, chain.length);</span>
<span class="nc" id="L750">                newChain[i] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L751">                newChain[i + 1] = value;</span>
<span class="nc" id="L752">                this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">                if (++this.occupied &gt; this.maxSize)</span>
                {
<span class="nc" id="L755">                    this.rehash(this.table.length);</span>
                }
            }
<span class="nc" id="L758">        }</span>
        else
        {
<span class="nc" id="L761">            Object[] newChain = new Object[4];</span>
<span class="nc" id="L762">            newChain[0] = this.table[index];</span>
<span class="nc" id="L763">            newChain[1] = this.table[index + 1];</span>
<span class="nc" id="L764">            newChain[2] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L765">            newChain[3] = value;</span>
<span class="nc" id="L766">            this.table[index] = CHAINED_KEY;</span>
<span class="nc" id="L767">            this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L770">                this.rehash(this.table.length);</span>
            }
        }
<span class="nc" id="L773">        return result;</span>
    }

    @Override
    public &lt;P&gt; V getIfAbsentPutWith(K key, Function&lt;? super P, ? extends V&gt; function, P parameter)
    {
<span class="nc" id="L779">        int index = this.index(key);</span>
<span class="nc" id="L780">        Object cur = this.table[index];</span>

<span class="nc bnc" id="L782" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L784">            V result = function.valueOf(parameter);</span>
<span class="nc" id="L785">            this.table[index] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L786">            this.table[index + 1] = result;</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L789">                this.rehash(this.table.length);</span>
            }
<span class="nc" id="L791">            return result;</span>
        }
<span class="nc bnc" id="L793" title="All 4 branches missed.">        if (cur != CHAINED_KEY &amp;&amp; this.nonNullTableObjectEquals(cur, key))</span>
        {
<span class="nc" id="L795">            return (V) this.table[index + 1];</span>
        }
<span class="nc" id="L797">        return this.chainedGetIfAbsentPutWith(key, index, function, parameter);</span>
    }

    private &lt;P&gt; V chainedGetIfAbsentPutWith(K key, int index, Function&lt;? super P, ? extends V&gt; function, P parameter)
    {
<span class="nc" id="L802">        V result = null;</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">        if (this.table[index] == CHAINED_KEY)</span>
        {
<span class="nc" id="L805">            Object[] chain = (Object[]) this.table[index + 1];</span>
<span class="nc" id="L806">            int i = 0;</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">            for (; i &lt; chain.length; i += 2)</span>
            {
<span class="nc bnc" id="L809" title="All 2 branches missed.">                if (chain[i] == null)</span>
                {
<span class="nc" id="L811">                    result = function.valueOf(parameter);</span>
<span class="nc" id="L812">                    chain[i] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L813">                    chain[i + 1] = result;</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">                    if (++this.occupied &gt; this.maxSize)</span>
                    {
<span class="nc" id="L816">                        this.rehash(this.table.length);</span>
                    }
                    break;
                }
<span class="nc bnc" id="L820" title="All 2 branches missed.">                if (this.nonNullTableObjectEquals(chain[i], key))</span>
                {
<span class="nc" id="L822">                    result = (V) chain[i + 1];</span>
<span class="nc" id="L823">                    break;</span>
                }
            }
<span class="nc bnc" id="L826" title="All 2 branches missed.">            if (i == chain.length)</span>
            {
<span class="nc" id="L828">                result = function.valueOf(parameter);</span>
<span class="nc" id="L829">                Object[] newChain = new Object[chain.length + 4];</span>
<span class="nc" id="L830">                System.arraycopy(chain, 0, newChain, 0, chain.length);</span>
<span class="nc" id="L831">                newChain[i] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L832">                newChain[i + 1] = result;</span>
<span class="nc" id="L833">                this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">                if (++this.occupied &gt; this.maxSize)</span>
                {
<span class="nc" id="L836">                    this.rehash(this.table.length);</span>
                }
            }
<span class="nc" id="L839">        }</span>
        else
        {
<span class="nc" id="L842">            result = function.valueOf(parameter);</span>
<span class="nc" id="L843">            Object[] newChain = new Object[4];</span>
<span class="nc" id="L844">            newChain[0] = this.table[index];</span>
<span class="nc" id="L845">            newChain[1] = this.table[index + 1];</span>
<span class="nc" id="L846">            newChain[2] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L847">            newChain[3] = result;</span>
<span class="nc" id="L848">            this.table[index] = CHAINED_KEY;</span>
<span class="nc" id="L849">            this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L852">                this.rehash(this.table.length);</span>
            }
        }
<span class="nc" id="L855">        return result;</span>
    }

    public int getCollidingBuckets()
    {
<span class="nc" id="L860">        int count = 0;</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L863" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L865">                count++;</span>
            }
        }
<span class="nc" id="L868">        return count;</span>
    }

    /**
     * Returns the number of JVM words that is used by this map.  A word is 4 bytes in a 32bit VM and 8 bytes in a 64bit
     * VM. Each array has a 2 word header, thus the formula is:
     * words = (internal table length + 2) + sum (for all chains (chain length + 2))
     *
     * @return the number of JVM words that is used by this map.
     */
    public int getMapMemoryUsedInWords()
    {
<span class="nc" id="L880">        int headerSize = 2;</span>
<span class="nc" id="L881">        int sizeInWords = this.table.length + headerSize;</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L884" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L886">                sizeInWords += headerSize + ((Object[]) this.table[i + 1]).length;</span>
            }
        }
<span class="nc" id="L889">        return sizeInWords;</span>
    }

    protected void rehash(int newCapacity)
    {
<span class="nc" id="L894">        int oldLength = this.table.length;</span>
<span class="nc" id="L895">        Object[] old = this.table;</span>
<span class="nc" id="L896">        this.allocate(newCapacity);</span>
<span class="nc" id="L897">        this.occupied = 0;</span>

<span class="nc bnc" id="L899" title="All 2 branches missed.">        for (int i = 0; i &lt; oldLength; i += 2)</span>
        {
<span class="nc" id="L901">            Object cur = old[i];</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L904">                Object[] chain = (Object[]) old[i + 1];</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">                for (int j = 0; j &lt; chain.length; j += 2)</span>
                {
<span class="nc bnc" id="L907" title="All 2 branches missed.">                    if (chain[j] != null)</span>
                    {
<span class="nc" id="L909">                        this.put(this.nonSentinel(chain[j]), (V) chain[j + 1]);</span>
                    }
                }
<span class="nc" id="L912">            }</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L915">                this.put(this.nonSentinel(cur), (V) old[i + 1]);</span>
            }
        }
<span class="nc" id="L918">    }</span>

    @Override
    public V get(Object key)
    {
<span class="nc" id="L923">        int index = this.index((K) key);</span>
<span class="nc" id="L924">        Object cur = this.table[index];</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">        if (cur != null)</span>
        {
<span class="nc" id="L927">            Object val = this.table[index + 1];</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L930">                return this.getFromChain((Object[]) val, (K) key);</span>
            }
<span class="nc bnc" id="L932" title="All 2 branches missed.">            if (this.nonNullTableObjectEquals(cur, (K) key))</span>
            {
<span class="nc" id="L934">                return (V) val;</span>
            }
        }
<span class="nc" id="L937">        return null;</span>
    }

    private V getFromChain(Object[] chain, K key)
    {
<span class="nc bnc" id="L942" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L944">            Object k = chain[i];</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">            if (k == null)</span>
            {
<span class="nc" id="L947">                return null;</span>
            }
<span class="nc bnc" id="L949" title="All 2 branches missed.">            if (this.nonNullTableObjectEquals(k, key))</span>
            {
<span class="nc" id="L951">                return (V) chain[i + 1];</span>
            }
        }
<span class="nc" id="L954">        return null;</span>
    }

    @Override
    public boolean containsKey(Object key)
    {
<span class="nc" id="L960">        int index = this.index((K) key);</span>
<span class="nc" id="L961">        Object cur = this.table[index];</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L964">            return false;</span>
        }
<span class="nc bnc" id="L966" title="All 4 branches missed.">        if (cur != CHAINED_KEY &amp;&amp; this.nonNullTableObjectEquals(cur, (K) key))</span>
        {
<span class="nc" id="L968">            return true;</span>
        }
<span class="nc bnc" id="L970" title="All 4 branches missed.">        return cur == CHAINED_KEY &amp;&amp; this.chainContainsKey((Object[]) this.table[index + 1], (K) key);</span>
    }

    private boolean chainContainsKey(Object[] chain, K key)
    {
<span class="nc bnc" id="L975" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L977">            Object k = chain[i];</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">            if (k == null)</span>
            {
<span class="nc" id="L980">                return false;</span>
            }
<span class="nc bnc" id="L982" title="All 2 branches missed.">            if (this.nonNullTableObjectEquals(k, key))</span>
            {
<span class="nc" id="L984">                return true;</span>
            }
        }
<span class="nc" id="L987">        return false;</span>
    }

    @Override
    public boolean containsValue(Object value)
    {
<span class="nc bnc" id="L993" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L995" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc bnc" id="L997" title="All 2 branches missed.">                if (this.chainedContainsValue((Object[]) this.table[i + 1], (V) value))</span>
                {
<span class="nc" id="L999">                    return true;</span>
                }
            }
<span class="nc bnc" id="L1002" title="All 2 branches missed.">            else if (this.table[i] != null)</span>
            {
<span class="nc bnc" id="L1004" title="All 2 branches missed.">                if (UnifiedMapWithHashingStrategy.nullSafeEquals(value, this.table[i + 1]))</span>
                {
<span class="nc" id="L1006">                    return true;</span>
                }
            }
        }
<span class="nc" id="L1010">        return false;</span>
    }

    private boolean chainedContainsValue(Object[] chain, V value)
    {
<span class="nc bnc" id="L1015" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc bnc" id="L1017" title="All 2 branches missed.">            if (chain[i] == null)</span>
            {
<span class="nc" id="L1019">                return false;</span>
            }
<span class="nc bnc" id="L1021" title="All 2 branches missed.">            if (UnifiedMapWithHashingStrategy.nullSafeEquals(value, chain[i + 1]))</span>
            {
<span class="nc" id="L1023">                return true;</span>
            }
        }
<span class="nc" id="L1026">        return false;</span>
    }

    @Override
    public void forEachKeyValue(Procedure2&lt;? super K, ? super V&gt; procedure)
    {
<span class="nc bnc" id="L1032" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1034">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1037">                this.chainedForEachEntry((Object[]) this.table[i + 1], procedure);</span>
            }
<span class="nc bnc" id="L1039" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1041">                procedure.value(this.nonSentinel(cur), (V) this.table[i + 1]);</span>
            }
        }
<span class="nc" id="L1044">    }</span>

    @Override
    public V getFirst()
    {
<span class="nc bnc" id="L1049" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1051">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1054">                Object[] chain = (Object[]) this.table[i + 1];</span>
<span class="nc" id="L1055">                return (V) chain[1];</span>
            }
<span class="nc bnc" id="L1057" title="All 2 branches missed.">            if (cur != null)</span>
            {
<span class="nc" id="L1059">                return (V) this.table[i + 1];</span>
            }
        }
<span class="nc" id="L1062">        return null;</span>
    }

    @Override
    public &lt;E&gt; MutableMap&lt;K, V&gt; collectKeysAndValues(
            Iterable&lt;E&gt; iterable,
            Function&lt;? super E, ? extends K&gt; keyFunction,
            Function&lt;? super E, ? extends V&gt; valueFunction)
    {
<span class="nc" id="L1071">        Iterate.forEach(iterable, new MapCollectProcedure&lt;&gt;(this, keyFunction, valueFunction));</span>
<span class="nc" id="L1072">        return this;</span>
    }

    @Override
    public V removeKey(K key)
    {
<span class="nc" id="L1078">        return this.remove(key);</span>
    }

    private void chainedForEachEntry(Object[] chain, Procedure2&lt;? super K, ? super V&gt; procedure)
    {
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1085">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1088">                return;</span>
            }
<span class="nc" id="L1090">            procedure.value(this.nonSentinel(cur), (V) chain[i + 1]);</span>
        }
<span class="nc" id="L1092">    }</span>

    @Override
    public int getBatchCount(int batchSize)
    {
<span class="nc" id="L1097">        return Math.max(1, this.table.length / 2 / batchSize);</span>
    }

    @Override
    public void batchForEach(Procedure&lt;? super V&gt; procedure, int sectionIndex, int sectionCount)
    {
<span class="nc" id="L1103">        int sectionSize = this.table.length / sectionCount;</span>
<span class="nc" id="L1104">        int start = sectionIndex * sectionSize;</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">        int end = sectionIndex == sectionCount - 1 ? this.table.length : start + sectionSize;</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if (start % 2 == 0)</span>
        {
<span class="nc" id="L1108">            start++;</span>
        }
<span class="nc bnc" id="L1110" title="All 2 branches missed.">        for (int i = start; i &lt; end; i += 2)</span>
        {
<span class="nc" id="L1112">            Object value = this.table[i];</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">            if (value instanceof Object[])</span>
            {
<span class="nc" id="L1115">                this.chainedForEachValue((Object[]) value, procedure);</span>
            }
<span class="nc bnc" id="L1117" title="All 6 branches missed.">            else if (value == null &amp;&amp; this.table[i - 1] != null || value != null)</span>
            {
<span class="nc" id="L1119">                procedure.value((V) value);</span>
            }
        }
<span class="nc" id="L1122">    }</span>

    @Override
    public void forEachKey(Procedure&lt;? super K&gt; procedure)
    {
<span class="nc bnc" id="L1127" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1129">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1132">                this.chainedForEachKey((Object[]) this.table[i + 1], procedure);</span>
            }
<span class="nc bnc" id="L1134" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1136">                procedure.value(this.nonSentinel(cur));</span>
            }
        }
<span class="nc" id="L1139">    }</span>

    private void chainedForEachKey(Object[] chain, Procedure&lt;? super K&gt; procedure)
    {
<span class="nc bnc" id="L1143" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1145">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1148">                return;</span>
            }
<span class="nc" id="L1150">            procedure.value(this.nonSentinel(cur));</span>
        }
<span class="nc" id="L1152">    }</span>

    @Override
    public void forEachValue(Procedure&lt;? super V&gt; procedure)
    {
<span class="nc bnc" id="L1157" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1159">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1162">                this.chainedForEachValue((Object[]) this.table[i + 1], procedure);</span>
            }
<span class="nc bnc" id="L1164" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1166">                procedure.value((V) this.table[i + 1]);</span>
            }
        }
<span class="nc" id="L1169">    }</span>

    private void chainedForEachValue(Object[] chain, Procedure&lt;? super V&gt; procedure)
    {
<span class="nc bnc" id="L1173" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1175">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1178">                return;</span>
            }
<span class="nc" id="L1180">            procedure.value((V) chain[i + 1]);</span>
        }
<span class="nc" id="L1182">    }</span>

    @Override
    public boolean isEmpty()
    {
<span class="nc bnc" id="L1187" title="All 2 branches missed.">        return this.occupied == 0;</span>
    }

    @Override
    public void putAll(Map&lt;? extends K, ? extends V&gt; map)
    {
<span class="nc bnc" id="L1193" title="All 2 branches missed.">        if (map instanceof UnifiedMapWithHashingStrategy&lt;?, ?&gt;)</span>
        {
<span class="nc" id="L1195">            this.copyMap((UnifiedMapWithHashingStrategy&lt;K, V&gt;) map);</span>
        }
<span class="nc bnc" id="L1197" title="All 2 branches missed.">        else if (map instanceof UnsortedMapIterable)</span>
        {
<span class="nc" id="L1199">            MapIterable&lt;K, V&gt; mapIterable = (MapIterable&lt;K, V&gt;) map;</span>
<span class="nc" id="L1200">            mapIterable.forEachKeyValue(this::put);</span>
<span class="nc" id="L1201">        }</span>
        else
        {
<span class="nc" id="L1204">            Iterator&lt;? extends Entry&lt;? extends K, ? extends V&gt;&gt; iterator = this.getEntrySetFrom(map).iterator();</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L1207">                Entry&lt;? extends K, ? extends V&gt; entry = iterator.next();</span>
<span class="nc" id="L1208">                this.put(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L1209">            }</span>
        }
<span class="nc" id="L1211">    }</span>

    private Set&lt;? extends Entry&lt;? extends K, ? extends V&gt;&gt; getEntrySetFrom(Map&lt;? extends K, ? extends V&gt; map)
    {
<span class="nc" id="L1215">        Set&lt;? extends Entry&lt;? extends K, ? extends V&gt;&gt; entries = map.entrySet();</span>
<span class="nc bnc" id="L1216" title="All 2 branches missed.">        if (entries != null)</span>
        {
<span class="nc" id="L1218">            return entries;</span>
        }
<span class="nc bnc" id="L1220" title="All 2 branches missed.">        if (map.isEmpty())</span>
        {
<span class="nc" id="L1222">            return Sets.immutable.&lt;Entry&lt;K, V&gt;&gt;of().castToSet();</span>
        }
<span class="nc" id="L1224">        throw new IllegalStateException(&quot;Entry set was null and size was non-zero&quot;);</span>
    }

    protected void copyMap(UnifiedMapWithHashingStrategy&lt;K, V&gt; unifiedMap)
    {
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        for (int i = 0; i &lt; unifiedMap.table.length; i += 2)</span>
        {
<span class="nc" id="L1231">            Object cur = unifiedMap.table[i];</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1234">                this.copyChain((Object[]) unifiedMap.table[i + 1]);</span>
            }
<span class="nc bnc" id="L1236" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1238">                this.put(this.nonSentinel(cur), (V) unifiedMap.table[i + 1]);</span>
            }
        }
<span class="nc" id="L1241">    }</span>

    private void copyChain(Object[] chain)
    {
<span class="nc bnc" id="L1245" title="All 2 branches missed.">        for (int j = 0; j &lt; chain.length; j += 2)</span>
        {
<span class="nc" id="L1247">            Object cur = chain[j];</span>
<span class="nc bnc" id="L1248" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1250">                break;</span>
            }
<span class="nc" id="L1252">            this.put(this.nonSentinel(cur), (V) chain[j + 1]);</span>
        }
<span class="nc" id="L1254">    }</span>

    @Override
    public V remove(Object key)
    {
<span class="nc" id="L1259">        int index = this.index((K) key);</span>
<span class="nc" id="L1260">        Object cur = this.table[index];</span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">        if (cur != null)</span>
        {
<span class="nc" id="L1263">            Object val = this.table[index + 1];</span>
<span class="nc bnc" id="L1264" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1266">                return this.removeFromChain((Object[]) val, (K) key, index);</span>
            }
<span class="nc bnc" id="L1268" title="All 2 branches missed.">            if (this.nonNullTableObjectEquals(cur, (K) key))</span>
            {
<span class="nc" id="L1270">                this.table[index] = null;</span>
<span class="nc" id="L1271">                this.table[index + 1] = null;</span>
<span class="nc" id="L1272">                this.occupied--;</span>
<span class="nc" id="L1273">                return (V) val;</span>
            }
        }
<span class="nc" id="L1276">        return null;</span>
    }

    private V removeFromChain(Object[] chain, K key, int index)
    {
<span class="nc bnc" id="L1281" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1283">            Object k = chain[i];</span>
<span class="nc bnc" id="L1284" title="All 2 branches missed.">            if (k == null)</span>
            {
<span class="nc" id="L1286">                return null;</span>
            }
<span class="nc bnc" id="L1288" title="All 2 branches missed.">            if (this.nonNullTableObjectEquals(k, key))</span>
            {
<span class="nc" id="L1290">                V val = (V) chain[i + 1];</span>
<span class="nc" id="L1291">                this.overwriteWithLastElementFromChain(chain, index, i);</span>
<span class="nc" id="L1292">                return val;</span>
            }
        }
<span class="nc" id="L1295">        return null;</span>
    }

    private void overwriteWithLastElementFromChain(Object[] chain, int index, int i)
    {
<span class="nc" id="L1300">        int j = chain.length - 2;</span>
<span class="nc bnc" id="L1301" title="All 2 branches missed.">        for (; j &gt; i; j -= 2)</span>
        {
<span class="nc bnc" id="L1303" title="All 2 branches missed.">            if (chain[j] != null)</span>
            {
<span class="nc" id="L1305">                chain[i] = chain[j];</span>
<span class="nc" id="L1306">                chain[i + 1] = chain[j + 1];</span>
<span class="nc" id="L1307">                break;</span>
            }
        }
<span class="nc" id="L1310">        chain[j] = null;</span>
<span class="nc" id="L1311">        chain[j + 1] = null;</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">        if (j == 0)</span>
        {
<span class="nc" id="L1314">            this.table[index] = null;</span>
<span class="nc" id="L1315">            this.table[index + 1] = null;</span>
        }
<span class="nc" id="L1317">        this.occupied--;</span>
<span class="nc" id="L1318">    }</span>

    @Override
    public int size()
    {
<span class="nc" id="L1323">        return this.occupied;</span>
    }

    @Override
    public Set&lt;Entry&lt;K, V&gt;&gt; entrySet()
    {
<span class="nc" id="L1329">        return new EntrySet();</span>
    }

    @Override
    public Set&lt;K&gt; keySet()
    {
<span class="nc" id="L1335">        return new KeySet();</span>
    }

    @Override
    public Collection&lt;V&gt; values()
    {
<span class="nc" id="L1341">        return new ValuesCollection();</span>
    }

    @Override
    public boolean equals(Object object)
    {
<span class="nc bnc" id="L1347" title="All 2 branches missed.">        if (this == object)</span>
        {
<span class="nc" id="L1349">            return true;</span>
        }

<span class="nc bnc" id="L1352" title="All 2 branches missed.">        if (!(object instanceof Map))</span>
        {
<span class="nc" id="L1354">            return false;</span>
        }

<span class="nc" id="L1357">        Map&lt;?, ?&gt; other = (Map&lt;?, ?&gt;) object;</span>
<span class="nc bnc" id="L1358" title="All 2 branches missed.">        if (this.size() != other.size())</span>
        {
<span class="nc" id="L1360">            return false;</span>
        }

<span class="nc bnc" id="L1363" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1365">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1366" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc bnc" id="L1368" title="All 2 branches missed.">                if (!this.chainedEquals((Object[]) this.table[i + 1], other))</span>
                {
<span class="nc" id="L1370">                    return false;</span>
                }
            }
<span class="nc bnc" id="L1373" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1375">                K key = this.nonSentinel(cur);</span>
<span class="nc" id="L1376">                V value = (V) this.table[i + 1];</span>
<span class="nc" id="L1377">                Object otherValue = other.get(key);</span>
<span class="nc bnc" id="L1378" title="All 8 branches missed.">                if (!UnifiedMapWithHashingStrategy.nullSafeEquals(otherValue, value) || (value == null &amp;&amp; otherValue == null &amp;&amp; !other.containsKey(key)))</span>
                {
<span class="nc" id="L1380">                    return false;</span>
                }
            }
        }

<span class="nc" id="L1385">        return true;</span>
    }

    private boolean chainedEquals(Object[] chain, Map&lt;?, ?&gt; other)
    {
<span class="nc bnc" id="L1390" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1392">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1393" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1395">                return true;</span>
            }
<span class="nc" id="L1397">            K key = this.nonSentinel(cur);</span>
<span class="nc" id="L1398">            V value = (V) chain[i + 1];</span>
<span class="nc" id="L1399">            Object otherValue = other.get(key);</span>
<span class="nc bnc" id="L1400" title="All 8 branches missed.">            if (!UnifiedMapWithHashingStrategy.nullSafeEquals(otherValue, value) || (value == null &amp;&amp; otherValue == null &amp;&amp; !other.containsKey(key)))</span>
            {
<span class="nc" id="L1402">                return false;</span>
            }
        }
<span class="nc" id="L1405">        return true;</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L1411">        int hashCode = 0;</span>
<span class="nc bnc" id="L1412" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1414">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1415" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1417">                hashCode += this.chainedHashCode((Object[]) this.table[i + 1]);</span>
            }
<span class="nc bnc" id="L1419" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1421">                Object value = this.table[i + 1];</span>
<span class="nc bnc" id="L1422" title="All 2 branches missed.">                hashCode += this.hashingStrategy.computeHashCode(this.nonSentinel(cur)) ^ (value == null ? 0 : value.hashCode());</span>
            }
        }
<span class="nc" id="L1425">        return hashCode;</span>
    }

    private int chainedHashCode(Object[] chain)
    {
<span class="nc" id="L1430">        int hashCode = 0;</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1433">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1436">                return hashCode;</span>
            }
<span class="nc" id="L1438">            Object value = chain[i + 1];</span>
<span class="nc bnc" id="L1439" title="All 2 branches missed.">            hashCode += this.hashingStrategy.computeHashCode(this.nonSentinel(cur)) ^ (value == null ? 0 : value.hashCode());</span>
        }
<span class="nc" id="L1441">        return hashCode;</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L1447">        StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L1448">        builder.append('{');</span>

<span class="nc" id="L1450">        this.forEachKeyValue(new Procedure2&lt;K, V&gt;()</span>
<span class="nc" id="L1451">        {</span>
<span class="nc" id="L1452">            private boolean first = true;</span>

            public void value(K key, V value)
            {
<span class="nc bnc" id="L1456" title="All 2 branches missed.">                if (this.first)</span>
                {
<span class="nc" id="L1458">                    this.first = false;</span>
                }
                else
                {
<span class="nc" id="L1462">                    builder.append(&quot;, &quot;);</span>
                }

<span class="nc bnc" id="L1465" title="All 2 branches missed.">                builder.append(key == UnifiedMapWithHashingStrategy.this ? &quot;(this Map)&quot; : key);</span>
<span class="nc" id="L1466">                builder.append('=');</span>
<span class="nc bnc" id="L1467" title="All 2 branches missed.">                builder.append(value == UnifiedMapWithHashingStrategy.this ? &quot;(this Map)&quot; : value);</span>
<span class="nc" id="L1468">            }</span>
        });

<span class="nc" id="L1471">        builder.append('}');</span>
<span class="nc" id="L1472">        return builder.toString();</span>
    }

    public boolean trimToSize()
    {
<span class="nc bnc" id="L1477" title="All 2 branches missed.">        if (this.table.length &lt;= this.fastCeil(this.occupied / this.loadFactor) &lt;&lt; 2)</span>
        {
<span class="nc" id="L1479">            return false;</span>
        }

<span class="nc" id="L1482">        Object[] temp = this.table;</span>
<span class="nc" id="L1483">        this.init(this.fastCeil(this.occupied / this.loadFactor));</span>
<span class="nc bnc" id="L1484" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L1486">            return true;</span>
        }

<span class="nc" id="L1489">        int mask = this.table.length - 1;</span>
<span class="nc bnc" id="L1490" title="All 2 branches missed.">        for (int j = 0; j &lt; temp.length; j += 2)</span>
        {
<span class="nc" id="L1492">            Object key = temp[j];</span>
<span class="nc bnc" id="L1493" title="All 2 branches missed.">            if (key == CHAINED_KEY)</span>
            {
<span class="nc" id="L1495">                Object[] chain = (Object[]) temp[j + 1];</span>
<span class="nc bnc" id="L1496" title="All 2 branches missed.">                for (int i = 0; i &lt; chain.length; i += 2)</span>
                {
<span class="nc" id="L1498">                    Object cur = chain[i];</span>
<span class="nc bnc" id="L1499" title="All 2 branches missed.">                    if (cur != null)</span>
                    {
<span class="nc" id="L1501">                        this.putForTrim((K) cur, (V) chain[i + 1], j, mask);</span>
                    }
                }
<span class="nc" id="L1504">            }</span>
<span class="nc bnc" id="L1505" title="All 2 branches missed.">            else if (key != null)</span>
            {
<span class="nc" id="L1507">                this.putForTrim((K) key, (V) temp[j + 1], j, mask);</span>
            }
        }
<span class="nc" id="L1510">        return true;</span>
    }

    private void putForTrim(K key, V value, int oldIndex, int mask)
    {
<span class="nc" id="L1515">        int index = oldIndex &amp; mask;</span>
<span class="nc" id="L1516">        Object cur = this.table[index];</span>
<span class="nc bnc" id="L1517" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L1519">            this.table[index] = key;</span>
<span class="nc" id="L1520">            this.table[index + 1] = value;</span>
<span class="nc" id="L1521">            return;</span>
        }
<span class="nc" id="L1523">        this.chainedPutForTrim(key, index, value);</span>
<span class="nc" id="L1524">    }</span>

    private void chainedPutForTrim(K key, int index, V value)
    {
<span class="nc bnc" id="L1528" title="All 2 branches missed.">        if (this.table[index] == CHAINED_KEY)</span>
        {
<span class="nc" id="L1530">            Object[] chain = (Object[]) this.table[index + 1];</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc bnc" id="L1533" title="All 2 branches missed.">                if (chain[i] == null)</span>
                {
<span class="nc" id="L1535">                    chain[i] = key;</span>
<span class="nc" id="L1536">                    chain[i + 1] = value;</span>
<span class="nc" id="L1537">                    return;</span>
                }
            }
<span class="nc" id="L1540">            Object[] newChain = new Object[chain.length + 4];</span>
<span class="nc" id="L1541">            System.arraycopy(chain, 0, newChain, 0, chain.length);</span>
<span class="nc" id="L1542">            this.table[index + 1] = newChain;</span>
<span class="nc" id="L1543">            newChain[chain.length] = UnifiedMapWithHashingStrategy.toSentinelIfNull(key);</span>
<span class="nc" id="L1544">            newChain[chain.length + 1] = value;</span>
<span class="nc" id="L1545">            return;</span>
        }
<span class="nc" id="L1547">        Object[] newChain = new Object[4];</span>
<span class="nc" id="L1548">        newChain[0] = this.table[index];</span>
<span class="nc" id="L1549">        newChain[1] = this.table[index + 1];</span>
<span class="nc" id="L1550">        newChain[2] = key;</span>
<span class="nc" id="L1551">        newChain[3] = value;</span>
<span class="nc" id="L1552">        this.table[index] = CHAINED_KEY;</span>
<span class="nc" id="L1553">        this.table[index + 1] = newChain;</span>
<span class="nc" id="L1554">    }</span>

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
    {
<span class="nc" id="L1559">        this.hashingStrategy = (HashingStrategy&lt;? super K&gt;) in.readObject();</span>
<span class="nc" id="L1560">        int size = in.readInt();</span>
<span class="nc" id="L1561">        this.loadFactor = in.readFloat();</span>
<span class="nc" id="L1562">        this.init(Math.max((int) (size / this.loadFactor) + 1,</span>
                DEFAULT_INITIAL_CAPACITY));
<span class="nc bnc" id="L1564" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1566">            this.put((K) in.readObject(), (V) in.readObject());</span>
        }
<span class="nc" id="L1568">    }</span>

    @Override
    public void writeExternal(ObjectOutput out) throws IOException
    {
<span class="nc" id="L1573">        out.writeObject(this.hashingStrategy);</span>
<span class="nc" id="L1574">        out.writeInt(this.size());</span>
<span class="nc" id="L1575">        out.writeFloat(this.loadFactor);</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1578">            Object o = this.table[i];</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">            if (o != null)</span>
            {
<span class="nc bnc" id="L1581" title="All 2 branches missed.">                if (o == CHAINED_KEY)</span>
                {
<span class="nc" id="L1583">                    this.writeExternalChain(out, (Object[]) this.table[i + 1]);</span>
                }
                else
                {
<span class="nc" id="L1587">                    out.writeObject(this.nonSentinel(o));</span>
<span class="nc" id="L1588">                    out.writeObject(this.table[i + 1]);</span>
                }
            }
        }
<span class="nc" id="L1592">    }</span>

    private void writeExternalChain(ObjectOutput out, Object[] chain) throws IOException
    {
<span class="nc bnc" id="L1596" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1598">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1599" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1601">                return;</span>
            }
<span class="nc" id="L1603">            out.writeObject(this.nonSentinel(cur));</span>
<span class="nc" id="L1604">            out.writeObject(chain[i + 1]);</span>
        }
<span class="nc" id="L1606">    }</span>

    @Override
    public void forEachWithIndex(ObjectIntProcedure&lt;? super V&gt; objectIntProcedure)
    {
<span class="nc" id="L1611">        int index = 0;</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1614">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1615" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1617">                index = this.chainedForEachValueWithIndex((Object[]) this.table[i + 1], objectIntProcedure, index);</span>
            }
<span class="nc bnc" id="L1619" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1621">                objectIntProcedure.value((V) this.table[i + 1], index++);</span>
            }
        }
<span class="nc" id="L1624">    }</span>

    private int chainedForEachValueWithIndex(Object[] chain, ObjectIntProcedure&lt;? super V&gt; objectIntProcedure, int index)
    {
<span class="nc bnc" id="L1628" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1630">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1633">                return index;</span>
            }
<span class="nc" id="L1635">            objectIntProcedure.value((V) chain[i + 1], index++);</span>
        }
<span class="nc" id="L1637">        return index;</span>
    }

    @Override
    public &lt;P&gt; void forEachWith(Procedure2&lt;? super V, ? super P&gt; procedure, P parameter)
    {
<span class="nc bnc" id="L1643" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1645">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1648">                this.chainedForEachValueWith((Object[]) this.table[i + 1], procedure, parameter);</span>
            }
<span class="nc bnc" id="L1650" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1652">                procedure.value((V) this.table[i + 1], parameter);</span>
            }
        }
<span class="nc" id="L1655">    }</span>

    private &lt;P&gt; void chainedForEachValueWith(
            Object[] chain,
            Procedure2&lt;? super V, ? super P&gt; procedure,
            P parameter)
    {
<span class="nc bnc" id="L1662" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1664">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1667">                return;</span>
            }
<span class="nc" id="L1669">            procedure.value((V) chain[i + 1], parameter);</span>
        }
<span class="nc" id="L1671">    }</span>

    @Override
    public &lt;R&gt; MutableMap&lt;K, R&gt; collectValues(Function2&lt;? super K, ? super V, ? extends R&gt; function)
    {
<span class="nc" id="L1676">        UnifiedMapWithHashingStrategy&lt;K, R&gt; target = (UnifiedMapWithHashingStrategy&lt;K, R&gt;) this.newEmpty();</span>
<span class="nc" id="L1677">        target.loadFactor = this.loadFactor;</span>
<span class="nc" id="L1678">        target.occupied = this.occupied;</span>
<span class="nc" id="L1679">        target.allocate(this.table.length &gt;&gt; 1);</span>

<span class="nc bnc" id="L1681" title="All 2 branches missed.">        for (int i = 0; i &lt; target.table.length; i += 2)</span>
        {
<span class="nc" id="L1683">            target.table[i] = this.table[i];</span>

<span class="nc bnc" id="L1685" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L1687">                Object[] chainedTable = (Object[]) this.table[i + 1];</span>
<span class="nc" id="L1688">                Object[] chainedTargetTable = new Object[chainedTable.length];</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">                for (int j = 0; j &lt; chainedTargetTable.length; j += 2)</span>
                {
<span class="nc bnc" id="L1691" title="All 2 branches missed.">                    if (chainedTable[j] != null)</span>
                    {
<span class="nc" id="L1693">                        chainedTargetTable[j] = chainedTable[j];</span>
<span class="nc" id="L1694">                        chainedTargetTable[j + 1] = function.value(this.nonSentinel(chainedTable[j]), (V) chainedTable[j + 1]);</span>
                    }
                }
<span class="nc" id="L1697">                target.table[i + 1] = chainedTargetTable;</span>
<span class="nc" id="L1698">            }</span>
<span class="nc bnc" id="L1699" title="All 2 branches missed.">            else if (this.table[i] != null)</span>
            {
<span class="nc" id="L1701">                target.table[i + 1] = function.value(this.nonSentinel(this.table[i]), (V) this.table[i + 1]);</span>
            }
        }

<span class="nc" id="L1705">        return target;</span>
    }

<span class="nc" id="L1708">    protected class KeySet implements Set&lt;K&gt;, Serializable, BatchIterable&lt;K&gt;</span>
    {
        private static final long serialVersionUID = 1L;

        @Override
        public boolean add(K key)
        {
<span class="nc" id="L1715">            throw new UnsupportedOperationException(&quot;Cannot call add() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public boolean addAll(Collection&lt;? extends K&gt; collection)
        {
<span class="nc" id="L1721">            throw new UnsupportedOperationException(&quot;Cannot call addAll() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public void clear()
        {
<span class="nc" id="L1727">            UnifiedMapWithHashingStrategy.this.clear();</span>
<span class="nc" id="L1728">        }</span>

        @Override
        public boolean contains(Object o)
        {
<span class="nc" id="L1733">            return UnifiedMapWithHashingStrategy.this.containsKey(o);</span>
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; collection)
        {
<span class="nc bnc" id="L1739" title="All 2 branches missed.">            for (Object aCollection : collection)</span>
            {
<span class="nc bnc" id="L1741" title="All 2 branches missed.">                if (!UnifiedMapWithHashingStrategy.this.containsKey(aCollection))</span>
                {
<span class="nc" id="L1743">                    return false;</span>
                }
<span class="nc" id="L1745">            }</span>
<span class="nc" id="L1746">            return true;</span>
        }

        @Override
        public boolean isEmpty()
        {
<span class="nc" id="L1752">            return UnifiedMapWithHashingStrategy.this.isEmpty();</span>
        }

        @Override
        public Iterator&lt;K&gt; iterator()
        {
<span class="nc" id="L1758">            return new KeySetIterator();</span>
        }

        @Override
        public boolean remove(Object key)
        {
<span class="nc" id="L1764">            int oldSize = UnifiedMapWithHashingStrategy.this.occupied;</span>
<span class="nc" id="L1765">            UnifiedMapWithHashingStrategy.this.remove(key);</span>
<span class="nc bnc" id="L1766" title="All 2 branches missed.">            return UnifiedMapWithHashingStrategy.this.occupied != oldSize;</span>
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; collection)
        {
<span class="nc" id="L1772">            int oldSize = UnifiedMapWithHashingStrategy.this.occupied;</span>
<span class="nc bnc" id="L1773" title="All 2 branches missed.">            for (Object object : collection)</span>
            {
<span class="nc" id="L1775">                UnifiedMapWithHashingStrategy.this.remove(object);</span>
<span class="nc" id="L1776">            }</span>
<span class="nc bnc" id="L1777" title="All 2 branches missed.">            return oldSize != UnifiedMapWithHashingStrategy.this.occupied;</span>
        }

        public void putIfFound(Object key, Map&lt;K, V&gt; other)
        {
<span class="nc" id="L1782">            int index = UnifiedMapWithHashingStrategy.this.index((K) key);</span>
<span class="nc" id="L1783">            Object cur = UnifiedMapWithHashingStrategy.this.table[index];</span>
<span class="nc bnc" id="L1784" title="All 2 branches missed.">            if (cur != null)</span>
            {
<span class="nc" id="L1786">                Object val = UnifiedMapWithHashingStrategy.this.table[index + 1];</span>
<span class="nc bnc" id="L1787" title="All 2 branches missed.">                if (cur == CHAINED_KEY)</span>
                {
<span class="nc" id="L1789">                    this.putIfFoundFromChain((Object[]) val, (K) key, other);</span>
<span class="nc" id="L1790">                    return;</span>
                }
<span class="nc bnc" id="L1792" title="All 2 branches missed.">                if (UnifiedMapWithHashingStrategy.this.nonNullTableObjectEquals(cur, (K) key))</span>
                {
<span class="nc" id="L1794">                    other.put(UnifiedMapWithHashingStrategy.this.nonSentinel(cur), (V) val);</span>
                }
            }
<span class="nc" id="L1797">        }</span>

        private void putIfFoundFromChain(Object[] chain, K key, Map&lt;K, V&gt; other)
        {
<span class="nc bnc" id="L1801" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc" id="L1803">                Object k = chain[i];</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">                if (k == null)</span>
                {
<span class="nc" id="L1806">                    return;</span>
                }
<span class="nc bnc" id="L1808" title="All 2 branches missed.">                if (UnifiedMapWithHashingStrategy.this.nonNullTableObjectEquals(k, key))</span>
                {
<span class="nc" id="L1810">                    other.put(UnifiedMapWithHashingStrategy.this.nonSentinel(k), (V) chain[i + 1]);</span>
                }
            }
<span class="nc" id="L1813">        }</span>

        @Override
        public boolean retainAll(Collection&lt;?&gt; collection)
        {
<span class="nc" id="L1818">            int retainedSize = collection.size();</span>
<span class="nc" id="L1819">            UnifiedMapWithHashingStrategy&lt;K, V&gt; retainedCopy = (UnifiedMapWithHashingStrategy&lt;K, V&gt;)</span>
<span class="nc" id="L1820">                    UnifiedMapWithHashingStrategy.this.newEmpty(retainedSize);</span>
<span class="nc bnc" id="L1821" title="All 2 branches missed.">            for (Object key : collection)</span>
            {
<span class="nc" id="L1823">                this.putIfFound(key, retainedCopy);</span>
<span class="nc" id="L1824">            }</span>
<span class="nc bnc" id="L1825" title="All 2 branches missed.">            if (retainedCopy.size() &lt; this.size())</span>
            {
<span class="nc" id="L1827">                UnifiedMapWithHashingStrategy.this.maxSize = retainedCopy.maxSize;</span>
<span class="nc" id="L1828">                UnifiedMapWithHashingStrategy.this.occupied = retainedCopy.occupied;</span>
<span class="nc" id="L1829">                UnifiedMapWithHashingStrategy.this.table = retainedCopy.table;</span>
<span class="nc" id="L1830">                return true;</span>
            }
<span class="nc" id="L1832">            return false;</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L1838">            return UnifiedMapWithHashingStrategy.this.size();</span>
        }

        @Override
        public void forEach(Procedure&lt;? super K&gt; procedure)
        {
<span class="nc" id="L1844">            UnifiedMapWithHashingStrategy.this.forEachKey(procedure);</span>
<span class="nc" id="L1845">        }</span>

        @Override
        public int getBatchCount(int batchSize)
        {
<span class="nc" id="L1850">            return UnifiedMapWithHashingStrategy.this.getBatchCount(batchSize);</span>
        }

        @Override
        public void batchForEach(Procedure&lt;? super K&gt; procedure, int sectionIndex, int sectionCount)
        {
<span class="nc" id="L1856">            Object[] map = UnifiedMapWithHashingStrategy.this.table;</span>
<span class="nc" id="L1857">            int sectionSize = map.length / sectionCount;</span>
<span class="nc" id="L1858">            int start = sectionIndex * sectionSize;</span>
<span class="nc bnc" id="L1859" title="All 2 branches missed.">            int end = sectionIndex == sectionCount - 1 ? map.length : start + sectionSize;</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">            if (start % 2 != 0)</span>
            {
<span class="nc" id="L1862">                start++;</span>
            }
<span class="nc bnc" id="L1864" title="All 2 branches missed.">            for (int i = start; i &lt; end; i += 2)</span>
            {
<span class="nc" id="L1866">                Object cur = map[i];</span>
<span class="nc bnc" id="L1867" title="All 2 branches missed.">                if (cur == CHAINED_KEY)</span>
                {
<span class="nc" id="L1869">                    UnifiedMapWithHashingStrategy.this.chainedForEachKey((Object[]) map[i + 1], procedure);</span>
                }
<span class="nc bnc" id="L1871" title="All 2 branches missed.">                else if (cur != null)</span>
                {
<span class="nc" id="L1873">                    procedure.value(UnifiedMapWithHashingStrategy.this.nonSentinel(cur));</span>
                }
            }
<span class="nc" id="L1876">        }</span>

        protected void copyKeys(Object[] result)
        {
<span class="nc" id="L1880">            Object[] table = UnifiedMapWithHashingStrategy.this.table;</span>
<span class="nc" id="L1881">            int count = 0;</span>
<span class="nc bnc" id="L1882" title="All 2 branches missed.">            for (int i = 0; i &lt; table.length; i += 2)</span>
            {
<span class="nc" id="L1884">                Object x = table[i];</span>
<span class="nc bnc" id="L1885" title="All 2 branches missed.">                if (x != null)</span>
                {
<span class="nc bnc" id="L1887" title="All 2 branches missed.">                    if (x == CHAINED_KEY)</span>
                    {
<span class="nc" id="L1889">                        Object[] chain = (Object[]) table[i + 1];</span>
<span class="nc bnc" id="L1890" title="All 2 branches missed.">                        for (int j = 0; j &lt; chain.length; j += 2)</span>
                        {
<span class="nc" id="L1892">                            Object cur = chain[j];</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">                            if (cur == null)</span>
                            {
<span class="nc" id="L1895">                                break;</span>
                            }
<span class="nc" id="L1897">                            result[count++] = UnifiedMapWithHashingStrategy.this.nonSentinel(cur);</span>
                        }
<span class="nc" id="L1899">                    }</span>
                    else
                    {
<span class="nc" id="L1902">                        result[count++] = UnifiedMapWithHashingStrategy.this.nonSentinel(x);</span>
                    }
                }
            }
<span class="nc" id="L1906">        }</span>

        @Override
        public boolean equals(Object obj)
        {
<span class="nc bnc" id="L1911" title="All 2 branches missed.">            if (obj instanceof Set)</span>
            {
<span class="nc" id="L1913">                Set&lt;?&gt; other = (Set&lt;?&gt;) obj;</span>
<span class="nc bnc" id="L1914" title="All 2 branches missed.">                if (other.size() == this.size())</span>
                {
<span class="nc" id="L1916">                    return this.containsAll(other);</span>
                }
            }
<span class="nc" id="L1919">            return false;</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L1925">            int hashCode = 0;</span>
<span class="nc" id="L1926">            Object[] table = UnifiedMapWithHashingStrategy.this.table;</span>
<span class="nc bnc" id="L1927" title="All 2 branches missed.">            for (int i = 0; i &lt; table.length; i += 2)</span>
            {
<span class="nc" id="L1929">                Object x = table[i];</span>
<span class="nc bnc" id="L1930" title="All 2 branches missed.">                if (x != null)</span>
                {
<span class="nc bnc" id="L1932" title="All 2 branches missed.">                    if (x == CHAINED_KEY)</span>
                    {
<span class="nc" id="L1934">                        Object[] chain = (Object[]) table[i + 1];</span>
<span class="nc bnc" id="L1935" title="All 2 branches missed.">                        for (int j = 0; j &lt; chain.length; j += 2)</span>
                        {
<span class="nc" id="L1937">                            Object cur = chain[j];</span>
<span class="nc bnc" id="L1938" title="All 2 branches missed.">                            if (cur == null)</span>
                            {
<span class="nc" id="L1940">                                break;</span>
                            }
<span class="nc" id="L1942">                            hashCode += UnifiedMapWithHashingStrategy.this.hashingStrategy.computeHashCode(UnifiedMapWithHashingStrategy.this.nonSentinel(cur));</span>
                        }
<span class="nc" id="L1944">                    }</span>
                    else
                    {
<span class="nc" id="L1947">                        hashCode += UnifiedMapWithHashingStrategy.this.hashingStrategy.computeHashCode(UnifiedMapWithHashingStrategy.this.nonSentinel(x));</span>
                    }
                }
            }
<span class="nc" id="L1951">            return hashCode;</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L1957">            return Iterate.makeString(this, &quot;[&quot;, &quot;, &quot;, &quot;]&quot;);</span>
        }

        @Override
        public Object[] toArray()
        {
<span class="nc" id="L1963">            int size = UnifiedMapWithHashingStrategy.this.size();</span>
<span class="nc" id="L1964">            Object[] result = new Object[size];</span>
<span class="nc" id="L1965">            this.copyKeys(result);</span>
<span class="nc" id="L1966">            return result;</span>
        }

        @Override
        public &lt;T&gt; T[] toArray(T[] result)
        {
<span class="nc" id="L1972">            int size = UnifiedMapWithHashingStrategy.this.size();</span>
<span class="nc bnc" id="L1973" title="All 2 branches missed.">            if (result.length &lt; size)</span>
            {
<span class="nc" id="L1975">                result = (T[]) Array.newInstance(result.getClass().getComponentType(), size);</span>
            }
<span class="nc" id="L1977">            this.copyKeys(result);</span>
<span class="nc bnc" id="L1978" title="All 2 branches missed.">            if (size &lt; result.length)</span>
            {
<span class="nc" id="L1980">                result[size] = null;</span>
            }
<span class="nc" id="L1982">            return result;</span>
        }

        protected Object writeReplace()
        {
<span class="nc" id="L1987">            UnifiedSetWithHashingStrategy&lt;K&gt; replace = UnifiedSetWithHashingStrategy.newSet(</span>
<span class="nc" id="L1988">                    UnifiedMapWithHashingStrategy.this.hashingStrategy, UnifiedMapWithHashingStrategy.this.size());</span>
<span class="nc bnc" id="L1989" title="All 2 branches missed.">            for (int i = 0; i &lt; UnifiedMapWithHashingStrategy.this.table.length; i += 2)</span>
            {
<span class="nc" id="L1991">                Object cur = UnifiedMapWithHashingStrategy.this.table[i];</span>
<span class="nc bnc" id="L1992" title="All 2 branches missed.">                if (cur == CHAINED_KEY)</span>
                {
<span class="nc" id="L1994">                    this.chainedAddToSet((Object[]) UnifiedMapWithHashingStrategy.this.table[i + 1], replace);</span>
                }
<span class="nc bnc" id="L1996" title="All 2 branches missed.">                else if (cur != null)</span>
                {
<span class="nc" id="L1998">                    replace.add(UnifiedMapWithHashingStrategy.this.nonSentinel(cur));</span>
                }
            }
<span class="nc" id="L2001">            return replace;</span>
        }

        private void chainedAddToSet(Object[] chain, UnifiedSetWithHashingStrategy&lt;K&gt; replace)
        {
<span class="nc bnc" id="L2006" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc" id="L2008">                Object cur = chain[i];</span>
<span class="nc bnc" id="L2009" title="All 2 branches missed.">                if (cur == null)</span>
                {
<span class="nc" id="L2011">                    return;</span>
                }
<span class="nc" id="L2013">                replace.add(UnifiedMapWithHashingStrategy.this.nonSentinel(cur));</span>
            }
<span class="nc" id="L2015">        }</span>
    }

<span class="nc" id="L2018">    protected abstract class PositionalIterator&lt;T&gt; implements Iterator&lt;T&gt;</span>
    {
        protected int count;
        protected int position;
        protected int chainPosition;
        protected boolean lastReturned;

        @Override
        public boolean hasNext()
        {
<span class="nc bnc" id="L2028" title="All 2 branches missed.">            return this.count &lt; UnifiedMapWithHashingStrategy.this.size();</span>
        }

        @Override
        public void remove()
        {
<span class="nc bnc" id="L2034" title="All 2 branches missed.">            if (!this.lastReturned)</span>
            {
<span class="nc" id="L2036">                throw new IllegalStateException(&quot;next() must be called as many times as remove()&quot;);</span>
            }
<span class="nc" id="L2038">            this.count--;</span>
<span class="nc" id="L2039">            UnifiedMapWithHashingStrategy.this.occupied--;</span>

<span class="nc bnc" id="L2041" title="All 2 branches missed.">            if (this.chainPosition != 0)</span>
            {
<span class="nc" id="L2043">                this.removeFromChain();</span>
<span class="nc" id="L2044">                return;</span>
            }

<span class="nc" id="L2047">            int pos = this.position - 2;</span>
<span class="nc" id="L2048">            Object cur = UnifiedMapWithHashingStrategy.this.table[pos];</span>
<span class="nc bnc" id="L2049" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L2051">                this.removeLastFromChain((Object[]) UnifiedMapWithHashingStrategy.this.table[pos + 1], pos);</span>
<span class="nc" id="L2052">                return;</span>
            }
<span class="nc" id="L2054">            UnifiedMapWithHashingStrategy.this.table[pos] = null;</span>
<span class="nc" id="L2055">            UnifiedMapWithHashingStrategy.this.table[pos + 1] = null;</span>
<span class="nc" id="L2056">            this.position = pos;</span>
<span class="nc" id="L2057">            this.lastReturned = false;</span>
<span class="nc" id="L2058">        }</span>

        protected void removeFromChain()
        {
<span class="nc" id="L2062">            Object[] chain = (Object[]) UnifiedMapWithHashingStrategy.this.table[this.position + 1];</span>
<span class="nc" id="L2063">            int pos = this.chainPosition - 2;</span>
<span class="nc" id="L2064">            int replacePos = this.chainPosition;</span>
<span class="nc bnc" id="L2065" title="All 4 branches missed.">            while (replacePos &lt; chain.length - 2 &amp;&amp; chain[replacePos + 2] != null)</span>
            {
<span class="nc" id="L2067">                replacePos += 2;</span>
            }
<span class="nc" id="L2069">            chain[pos] = chain[replacePos];</span>
<span class="nc" id="L2070">            chain[pos + 1] = chain[replacePos + 1];</span>
<span class="nc" id="L2071">            chain[replacePos] = null;</span>
<span class="nc" id="L2072">            chain[replacePos + 1] = null;</span>
<span class="nc" id="L2073">            this.chainPosition = pos;</span>
<span class="nc" id="L2074">            this.lastReturned = false;</span>
<span class="nc" id="L2075">        }</span>

        protected void removeLastFromChain(Object[] chain, int tableIndex)
        {
<span class="nc" id="L2079">            int pos = chain.length - 2;</span>
<span class="nc bnc" id="L2080" title="All 2 branches missed.">            while (chain[pos] == null)</span>
            {
<span class="nc" id="L2082">                pos -= 2;</span>
            }
<span class="nc bnc" id="L2084" title="All 2 branches missed.">            if (pos == 0)</span>
            {
<span class="nc" id="L2086">                UnifiedMapWithHashingStrategy.this.table[tableIndex] = null;</span>
<span class="nc" id="L2087">                UnifiedMapWithHashingStrategy.this.table[tableIndex + 1] = null;</span>
            }
            else
            {
<span class="nc" id="L2091">                chain[pos] = null;</span>
<span class="nc" id="L2092">                chain[pos + 1] = null;</span>
            }
<span class="nc" id="L2094">            this.lastReturned = false;</span>
<span class="nc" id="L2095">        }</span>
    }

<span class="nc" id="L2098">    protected class KeySetIterator extends PositionalIterator&lt;K&gt;</span>
    {
        protected K nextFromChain()
        {
<span class="nc" id="L2102">            Object[] chain = (Object[]) UnifiedMapWithHashingStrategy.this.table[this.position + 1];</span>
<span class="nc" id="L2103">            Object cur = chain[this.chainPosition];</span>
<span class="nc" id="L2104">            this.chainPosition += 2;</span>
<span class="nc bnc" id="L2105" title="All 4 branches missed.">            if (this.chainPosition &gt;= chain.length</span>
                    || chain[this.chainPosition] == null)
            {
<span class="nc" id="L2108">                this.chainPosition = 0;</span>
<span class="nc" id="L2109">                this.position += 2;</span>
            }
<span class="nc" id="L2111">            this.lastReturned = true;</span>
<span class="nc" id="L2112">            return UnifiedMapWithHashingStrategy.this.nonSentinel(cur);</span>
        }

        @Override
        public K next()
        {
<span class="nc bnc" id="L2118" title="All 2 branches missed.">            if (!this.hasNext())</span>
            {
<span class="nc" id="L2120">                throw new NoSuchElementException(&quot;next() called, but the iterator is exhausted&quot;);</span>
            }
<span class="nc" id="L2122">            this.count++;</span>
<span class="nc" id="L2123">            Object[] table = UnifiedMapWithHashingStrategy.this.table;</span>
<span class="nc bnc" id="L2124" title="All 2 branches missed.">            if (this.chainPosition != 0)</span>
            {
<span class="nc" id="L2126">                return this.nextFromChain();</span>
            }
<span class="nc bnc" id="L2128" title="All 2 branches missed.">            while (table[this.position] == null)</span>
            {
<span class="nc" id="L2130">                this.position += 2;</span>
            }
<span class="nc" id="L2132">            Object cur = table[this.position];</span>
<span class="nc bnc" id="L2133" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L2135">                return this.nextFromChain();</span>
            }
<span class="nc" id="L2137">            this.position += 2;</span>
<span class="nc" id="L2138">            this.lastReturned = true;</span>
<span class="nc" id="L2139">            return UnifiedMapWithHashingStrategy.this.nonSentinel(cur);</span>
        }
    }

    private static boolean nullSafeEquals(Object value, Object other)
    {
<span class="nc bnc" id="L2145" title="All 2 branches missed.">        if (value == null)</span>
        {
<span class="nc bnc" id="L2147" title="All 2 branches missed.">            if (other == null)</span>
            {
<span class="nc" id="L2149">                return true;</span>
            }
        }
<span class="nc bnc" id="L2152" title="All 4 branches missed.">        else if (other == value || value.equals(other))</span>
        {
<span class="nc" id="L2154">            return true;</span>
        }
<span class="nc" id="L2156">        return false;</span>
    }

<span class="nc" id="L2159">    protected class EntrySet implements Set&lt;Entry&lt;K, V&gt;&gt;, Serializable, BatchIterable&lt;Entry&lt;K, V&gt;&gt;</span>
    {
        private static final long serialVersionUID = 1L;
<span class="nc" id="L2162">        private transient WeakReference&lt;UnifiedMapWithHashingStrategy&lt;K, V&gt;&gt; holder = new WeakReference&lt;&gt;(UnifiedMapWithHashingStrategy.this);</span>

        @Override
        public boolean add(Entry&lt;K, V&gt; entry)
        {
<span class="nc" id="L2167">            throw new UnsupportedOperationException(&quot;Cannot call add() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public boolean addAll(Collection&lt;? extends Entry&lt;K, V&gt;&gt; collection)
        {
<span class="nc" id="L2173">            throw new UnsupportedOperationException(&quot;Cannot call addAll() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public void clear()
        {
<span class="nc" id="L2179">            UnifiedMapWithHashingStrategy.this.clear();</span>
<span class="nc" id="L2180">        }</span>

        public boolean containsEntry(Entry&lt;?, ?&gt; entry)
        {
<span class="nc bnc" id="L2184" title="All 2 branches missed.">            return this.getEntry(entry) != null;</span>
        }

        private Entry&lt;K, V&gt; getEntry(Entry&lt;?, ?&gt; entry)
        {
<span class="nc" id="L2189">            K key = (K) entry.getKey();</span>
<span class="nc" id="L2190">            V value = (V) entry.getValue();</span>
<span class="nc" id="L2191">            int index = UnifiedMapWithHashingStrategy.this.index(key);</span>

<span class="nc" id="L2193">            Object cur = UnifiedMapWithHashingStrategy.this.table[index];</span>
<span class="nc" id="L2194">            Object curValue = UnifiedMapWithHashingStrategy.this.table[index + 1];</span>
<span class="nc bnc" id="L2195" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L2197">                return this.chainGetEntry((Object[]) curValue, key, value);</span>
            }
<span class="nc bnc" id="L2199" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L2201">                return null;</span>
            }
<span class="nc bnc" id="L2203" title="All 2 branches missed.">            if (UnifiedMapWithHashingStrategy.this.nonNullTableObjectEquals(cur, key))</span>
            {
<span class="nc bnc" id="L2205" title="All 2 branches missed.">                if (UnifiedMapWithHashingStrategy.nullSafeEquals(value, curValue))</span>
                {
<span class="nc" id="L2207">                    return ImmutableEntry.of(UnifiedMapWithHashingStrategy.this.nonSentinel(cur), (V) curValue);</span>
                }
            }
<span class="nc" id="L2210">            return null;</span>
        }

        private Entry&lt;K, V&gt; chainGetEntry(Object[] chain, K key, V value)
        {
<span class="nc bnc" id="L2215" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc" id="L2217">                Object cur = chain[i];</span>
<span class="nc bnc" id="L2218" title="All 2 branches missed.">                if (cur == null)</span>
                {
<span class="nc" id="L2220">                    return null;</span>
                }
<span class="nc bnc" id="L2222" title="All 2 branches missed.">                if (UnifiedMapWithHashingStrategy.this.nonNullTableObjectEquals(cur, key))</span>
                {
<span class="nc" id="L2224">                    Object curValue = chain[i + 1];</span>
<span class="nc bnc" id="L2225" title="All 2 branches missed.">                    if (UnifiedMapWithHashingStrategy.nullSafeEquals(value, curValue))</span>
                    {
<span class="nc" id="L2227">                        return ImmutableEntry.of(UnifiedMapWithHashingStrategy.this.nonSentinel(cur), (V) curValue);</span>
                    }
                }
            }
<span class="nc" id="L2231">            return null;</span>
        }

        @Override
        public boolean contains(Object o)
        {
<span class="nc bnc" id="L2237" title="All 4 branches missed.">            return o instanceof Entry &amp;&amp; this.containsEntry((Entry&lt;?, ?&gt;) o);</span>
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; collection)
        {
<span class="nc bnc" id="L2243" title="All 2 branches missed.">            for (Object obj : collection)</span>
            {
<span class="nc bnc" id="L2245" title="All 2 branches missed.">                if (!this.contains(obj))</span>
                {
<span class="nc" id="L2247">                    return false;</span>
                }
<span class="nc" id="L2249">            }</span>
<span class="nc" id="L2250">            return true;</span>
        }

        @Override
        public boolean isEmpty()
        {
<span class="nc" id="L2256">            return UnifiedMapWithHashingStrategy.this.isEmpty();</span>
        }

        @Override
        public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator()
        {
<span class="nc" id="L2262">            return new EntrySetIterator(this.holder);</span>
        }

        @Override
        public boolean remove(Object e)
        {
<span class="nc bnc" id="L2268" title="All 2 branches missed.">            if (!(e instanceof Entry))</span>
            {
<span class="nc" id="L2270">                return false;</span>
            }
<span class="nc" id="L2272">            Entry&lt;?, ?&gt; entry = (Entry&lt;?, ?&gt;) e;</span>
<span class="nc" id="L2273">            K key = (K) entry.getKey();</span>
<span class="nc" id="L2274">            V value = (V) entry.getValue();</span>

<span class="nc" id="L2276">            int index = UnifiedMapWithHashingStrategy.this.index(key);</span>

<span class="nc" id="L2278">            Object cur = UnifiedMapWithHashingStrategy.this.table[index];</span>
<span class="nc bnc" id="L2279" title="All 2 branches missed.">            if (cur != null)</span>
            {
<span class="nc" id="L2281">                Object val = UnifiedMapWithHashingStrategy.this.table[index + 1];</span>
<span class="nc bnc" id="L2282" title="All 2 branches missed.">                if (cur == CHAINED_KEY)</span>
                {
<span class="nc" id="L2284">                    return this.removeFromChain((Object[]) val, key, value, index);</span>
                }
<span class="nc bnc" id="L2286" title="All 4 branches missed.">                if (UnifiedMapWithHashingStrategy.this.nonNullTableObjectEquals(cur, key) &amp;&amp; UnifiedMapWithHashingStrategy.nullSafeEquals(value, val))</span>
                {
<span class="nc" id="L2288">                    UnifiedMapWithHashingStrategy.this.table[index] = null;</span>
<span class="nc" id="L2289">                    UnifiedMapWithHashingStrategy.this.table[index + 1] = null;</span>
<span class="nc" id="L2290">                    UnifiedMapWithHashingStrategy.this.occupied--;</span>
<span class="nc" id="L2291">                    return true;</span>
                }
            }
<span class="nc" id="L2294">            return false;</span>
        }

        private boolean removeFromChain(Object[] chain, K key, V value, int index)
        {
<span class="nc bnc" id="L2299" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc" id="L2301">                Object k = chain[i];</span>
<span class="nc bnc" id="L2302" title="All 2 branches missed.">                if (k == null)</span>
                {
<span class="nc" id="L2304">                    return false;</span>
                }
<span class="nc bnc" id="L2306" title="All 2 branches missed.">                if (UnifiedMapWithHashingStrategy.this.nonNullTableObjectEquals(k, key))</span>
                {
<span class="nc" id="L2308">                    V val = (V) chain[i + 1];</span>
<span class="nc bnc" id="L2309" title="All 2 branches missed.">                    if (UnifiedMapWithHashingStrategy.nullSafeEquals(val, value))</span>
                    {
<span class="nc" id="L2311">                        UnifiedMapWithHashingStrategy.this.overwriteWithLastElementFromChain(chain, index, i);</span>
<span class="nc" id="L2312">                        return true;</span>
                    }
                }
            }
<span class="nc" id="L2316">            return false;</span>
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; collection)
        {
<span class="nc" id="L2322">            boolean changed = false;</span>
<span class="nc bnc" id="L2323" title="All 2 branches missed.">            for (Object obj : collection)</span>
            {
<span class="nc bnc" id="L2325" title="All 2 branches missed.">                if (this.remove(obj))</span>
                {
<span class="nc" id="L2327">                    changed = true;</span>
                }
<span class="nc" id="L2329">            }</span>
<span class="nc" id="L2330">            return changed;</span>
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; collection)
        {
<span class="nc" id="L2336">            int retainedSize = collection.size();</span>
<span class="nc" id="L2337">            UnifiedMapWithHashingStrategy&lt;K, V&gt; retainedCopy = (UnifiedMapWithHashingStrategy&lt;K, V&gt;)</span>
<span class="nc" id="L2338">                    UnifiedMapWithHashingStrategy.this.newEmpty(retainedSize);</span>
<span class="nc bnc" id="L2339" title="All 2 branches missed.">            for (Object obj : collection)</span>
            {
<span class="nc bnc" id="L2341" title="All 2 branches missed.">                if (obj instanceof Entry)</span>
                {
<span class="nc" id="L2343">                    Entry&lt;?, ?&gt; otherEntry = (Entry&lt;?, ?&gt;) obj;</span>
<span class="nc" id="L2344">                    Entry&lt;K, V&gt; thisEntry = this.getEntry(otherEntry);</span>
<span class="nc bnc" id="L2345" title="All 2 branches missed.">                    if (thisEntry != null)</span>
                    {
<span class="nc" id="L2347">                        retainedCopy.put(thisEntry.getKey(), thisEntry.getValue());</span>
                    }
                }
<span class="nc" id="L2350">            }</span>
<span class="nc bnc" id="L2351" title="All 2 branches missed.">            if (retainedCopy.size() &lt; this.size())</span>
            {
<span class="nc" id="L2353">                UnifiedMapWithHashingStrategy.this.maxSize = retainedCopy.maxSize;</span>
<span class="nc" id="L2354">                UnifiedMapWithHashingStrategy.this.occupied = retainedCopy.occupied;</span>
<span class="nc" id="L2355">                UnifiedMapWithHashingStrategy.this.table = retainedCopy.table;</span>
<span class="nc" id="L2356">                return true;</span>
            }
<span class="nc" id="L2358">            return false;</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L2364">            return UnifiedMapWithHashingStrategy.this.size();</span>
        }

        @Override
        public void forEach(Procedure&lt;? super Entry&lt;K, V&gt;&gt; procedure)
        {
<span class="nc bnc" id="L2370" title="All 2 branches missed.">            for (int i = 0; i &lt; UnifiedMapWithHashingStrategy.this.table.length; i += 2)</span>
            {
<span class="nc" id="L2372">                Object cur = UnifiedMapWithHashingStrategy.this.table[i];</span>
<span class="nc bnc" id="L2373" title="All 2 branches missed.">                if (cur == CHAINED_KEY)</span>
                {
<span class="nc" id="L2375">                    this.chainedForEachEntry((Object[]) UnifiedMapWithHashingStrategy.this.table[i + 1], procedure);</span>
                }
<span class="nc bnc" id="L2377" title="All 2 branches missed.">                else if (cur != null)</span>
                {
<span class="nc" id="L2379">                    procedure.value(ImmutableEntry.of(UnifiedMapWithHashingStrategy.this.nonSentinel(cur), (V) UnifiedMapWithHashingStrategy.this.table[i + 1]));</span>
                }
            }
<span class="nc" id="L2382">        }</span>

        private void chainedForEachEntry(Object[] chain, Procedure&lt;? super Entry&lt;K, V&gt;&gt; procedure)
        {
<span class="nc bnc" id="L2386" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc" id="L2388">                Object cur = chain[i];</span>
<span class="nc bnc" id="L2389" title="All 2 branches missed.">                if (cur == null)</span>
                {
<span class="nc" id="L2391">                    return;</span>
                }
<span class="nc" id="L2393">                procedure.value(ImmutableEntry.of(UnifiedMapWithHashingStrategy.this.nonSentinel(cur), (V) chain[i + 1]));</span>
            }
<span class="nc" id="L2395">        }</span>

        @Override
        public int getBatchCount(int batchSize)
        {
<span class="nc" id="L2400">            return UnifiedMapWithHashingStrategy.this.getBatchCount(batchSize);</span>
        }

        @Override
        public void batchForEach(Procedure&lt;? super Entry&lt;K, V&gt;&gt; procedure, int sectionIndex, int sectionCount)
        {
<span class="nc" id="L2406">            Object[] map = UnifiedMapWithHashingStrategy.this.table;</span>
<span class="nc" id="L2407">            int sectionSize = map.length / sectionCount;</span>
<span class="nc" id="L2408">            int start = sectionIndex * sectionSize;</span>
<span class="nc bnc" id="L2409" title="All 2 branches missed.">            int end = sectionIndex == sectionCount - 1 ? map.length : start + sectionSize;</span>
<span class="nc bnc" id="L2410" title="All 2 branches missed.">            if (start % 2 != 0)</span>
            {
<span class="nc" id="L2412">                start++;</span>
            }
<span class="nc bnc" id="L2414" title="All 2 branches missed.">            for (int i = start; i &lt; end; i += 2)</span>
            {
<span class="nc" id="L2416">                Object cur = map[i];</span>
<span class="nc bnc" id="L2417" title="All 2 branches missed.">                if (cur == CHAINED_KEY)</span>
                {
<span class="nc" id="L2419">                    this.chainedForEachEntry((Object[]) map[i + 1], procedure);</span>
                }
<span class="nc bnc" id="L2421" title="All 2 branches missed.">                else if (cur != null)</span>
                {
<span class="nc" id="L2423">                    procedure.value(ImmutableEntry.of(UnifiedMapWithHashingStrategy.this.nonSentinel(cur), (V) map[i + 1]));</span>
                }
            }
<span class="nc" id="L2426">        }</span>

        protected void copyEntries(Object[] result)
        {
<span class="nc" id="L2430">            Object[] table = UnifiedMapWithHashingStrategy.this.table;</span>
<span class="nc" id="L2431">            int count = 0;</span>
<span class="nc bnc" id="L2432" title="All 2 branches missed.">            for (int i = 0; i &lt; table.length; i += 2)</span>
            {
<span class="nc" id="L2434">                Object x = table[i];</span>
<span class="nc bnc" id="L2435" title="All 2 branches missed.">                if (x != null)</span>
                {
<span class="nc bnc" id="L2437" title="All 2 branches missed.">                    if (x == CHAINED_KEY)</span>
                    {
<span class="nc" id="L2439">                        Object[] chain = (Object[]) table[i + 1];</span>
<span class="nc bnc" id="L2440" title="All 2 branches missed.">                        for (int j = 0; j &lt; chain.length; j += 2)</span>
                        {
<span class="nc" id="L2442">                            Object cur = chain[j];</span>
<span class="nc bnc" id="L2443" title="All 2 branches missed.">                            if (cur == null)</span>
                            {
<span class="nc" id="L2445">                                break;</span>
                            }
<span class="nc" id="L2447">                            result[count++] =</span>
<span class="nc" id="L2448">                                    new WeakBoundEntry&lt;&gt;(UnifiedMapWithHashingStrategy.this.nonSentinel(cur), (V) chain[j + 1], this.holder,</span>
                                            UnifiedMapWithHashingStrategy.this.hashingStrategy);
                        }
<span class="nc" id="L2451">                    }</span>
                    else
                    {
<span class="nc" id="L2454">                        result[count++] = new WeakBoundEntry&lt;&gt;(UnifiedMapWithHashingStrategy.this.nonSentinel(x), (V) table[i + 1], this.holder,</span>
                                UnifiedMapWithHashingStrategy.this.hashingStrategy);
                    }
                }
            }
<span class="nc" id="L2459">        }</span>

        @Override
        public Object[] toArray()
        {
<span class="nc" id="L2464">            Object[] result = new Object[UnifiedMapWithHashingStrategy.this.size()];</span>
<span class="nc" id="L2465">            this.copyEntries(result);</span>
<span class="nc" id="L2466">            return result;</span>
        }

        @Override
        public &lt;T&gt; T[] toArray(T[] result)
        {
<span class="nc" id="L2472">            int size = UnifiedMapWithHashingStrategy.this.size();</span>
<span class="nc bnc" id="L2473" title="All 2 branches missed.">            if (result.length &lt; size)</span>
            {
<span class="nc" id="L2475">                result = (T[]) Array.newInstance(result.getClass().getComponentType(), size);</span>
            }
<span class="nc" id="L2477">            this.copyEntries(result);</span>
<span class="nc bnc" id="L2478" title="All 2 branches missed.">            if (size &lt; result.length)</span>
            {
<span class="nc" id="L2480">                result[size] = null;</span>
            }
<span class="nc" id="L2482">            return result;</span>
        }

        private void readObject(ObjectInputStream in)
                throws IOException, ClassNotFoundException
        {
<span class="nc" id="L2488">            in.defaultReadObject();</span>
<span class="nc" id="L2489">            this.holder = new WeakReference&lt;&gt;(UnifiedMapWithHashingStrategy.this);</span>
<span class="nc" id="L2490">        }</span>

        @Override
        public boolean equals(Object obj)
        {
<span class="nc bnc" id="L2495" title="All 2 branches missed.">            if (obj instanceof Set)</span>
            {
<span class="nc" id="L2497">                Set&lt;?&gt; other = (Set&lt;?&gt;) obj;</span>
<span class="nc bnc" id="L2498" title="All 2 branches missed.">                if (other.size() == this.size())</span>
                {
<span class="nc" id="L2500">                    return this.containsAll(other);</span>
                }
            }
<span class="nc" id="L2503">            return false;</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L2509">            return UnifiedMapWithHashingStrategy.this.hashCode();</span>
        }
    }

    protected class EntrySetIterator extends PositionalIterator&lt;Entry&lt;K, V&gt;&gt;
    {
        private final WeakReference&lt;UnifiedMapWithHashingStrategy&lt;K, V&gt;&gt; holder;

        protected EntrySetIterator(WeakReference&lt;UnifiedMapWithHashingStrategy&lt;K, V&gt;&gt; holder)
<span class="nc" id="L2518">        {</span>
<span class="nc" id="L2519">            this.holder = holder;</span>
<span class="nc" id="L2520">        }</span>

        protected Entry&lt;K, V&gt; nextFromChain()
        {
<span class="nc" id="L2524">            Object[] chain = (Object[]) UnifiedMapWithHashingStrategy.this.table[this.position + 1];</span>
<span class="nc" id="L2525">            Object cur = chain[this.chainPosition];</span>
<span class="nc" id="L2526">            Object value = chain[this.chainPosition + 1];</span>
<span class="nc" id="L2527">            this.chainPosition += 2;</span>
<span class="nc bnc" id="L2528" title="All 4 branches missed.">            if (this.chainPosition &gt;= chain.length</span>
                    || chain[this.chainPosition] == null)
            {
<span class="nc" id="L2531">                this.chainPosition = 0;</span>
<span class="nc" id="L2532">                this.position += 2;</span>
            }
<span class="nc" id="L2534">            this.lastReturned = true;</span>
<span class="nc" id="L2535">            return new WeakBoundEntry&lt;&gt;(UnifiedMapWithHashingStrategy.this.nonSentinel(cur), (V) value, this.holder,</span>
                    UnifiedMapWithHashingStrategy.this.hashingStrategy);
        }

        @Override
        public Entry&lt;K, V&gt; next()
        {
<span class="nc bnc" id="L2542" title="All 2 branches missed.">            if (!this.hasNext())</span>
            {
<span class="nc" id="L2544">                throw new NoSuchElementException(&quot;next() called, but the iterator is exhausted&quot;);</span>
            }
<span class="nc" id="L2546">            this.count++;</span>
<span class="nc" id="L2547">            Object[] table = UnifiedMapWithHashingStrategy.this.table;</span>
<span class="nc bnc" id="L2548" title="All 2 branches missed.">            if (this.chainPosition != 0)</span>
            {
<span class="nc" id="L2550">                return this.nextFromChain();</span>
            }
<span class="nc bnc" id="L2552" title="All 2 branches missed.">            while (table[this.position] == null)</span>
            {
<span class="nc" id="L2554">                this.position += 2;</span>
            }
<span class="nc" id="L2556">            Object cur = table[this.position];</span>
<span class="nc" id="L2557">            Object value = table[this.position + 1];</span>
<span class="nc bnc" id="L2558" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L2560">                return this.nextFromChain();</span>
            }
<span class="nc" id="L2562">            this.position += 2;</span>
<span class="nc" id="L2563">            this.lastReturned = true;</span>
<span class="nc" id="L2564">            return new WeakBoundEntry&lt;&gt;(UnifiedMapWithHashingStrategy.this.nonSentinel(cur), (V) value, this.holder,</span>
                    UnifiedMapWithHashingStrategy.this.hashingStrategy);
        }
    }

    protected static class WeakBoundEntry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt;
    {
        protected final K key;
        protected V value;
        protected final WeakReference&lt;UnifiedMapWithHashingStrategy&lt;K, V&gt;&gt; holder;
        protected final HashingStrategy&lt;? super K&gt; hashingStrategy;

        protected WeakBoundEntry(
                K key,
                V value,
                WeakReference&lt;UnifiedMapWithHashingStrategy&lt;K, V&gt;&gt; holder,
                HashingStrategy&lt;? super K&gt; hashingStrategy)
<span class="nc" id="L2581">        {</span>
<span class="nc" id="L2582">            this.key = key;</span>
<span class="nc" id="L2583">            this.value = value;</span>
<span class="nc" id="L2584">            this.holder = holder;</span>
<span class="nc" id="L2585">            this.hashingStrategy = hashingStrategy;</span>
<span class="nc" id="L2586">        }</span>

        @Override
        public K getKey()
        {
<span class="nc" id="L2591">            return this.key;</span>
        }

        @Override
        public V getValue()
        {
<span class="nc" id="L2597">            return this.value;</span>
        }

        @Override
        public V setValue(V value)
        {
<span class="nc" id="L2603">            this.value = value;</span>
<span class="nc" id="L2604">            UnifiedMapWithHashingStrategy&lt;K, V&gt; map = this.holder.get();</span>
<span class="nc bnc" id="L2605" title="All 4 branches missed.">            if (map != null &amp;&amp; map.containsKey(this.key))</span>
            {
<span class="nc" id="L2607">                return map.put(this.key, value);</span>
            }
<span class="nc" id="L2609">            return null;</span>
        }

        @Override
        public boolean equals(Object obj)
        {
<span class="nc bnc" id="L2615" title="All 2 branches missed.">            if (obj instanceof Entry)</span>
            {
<span class="nc" id="L2617">                Entry&lt;?, ?&gt; other = (Entry&lt;?, ?&gt;) obj;</span>
<span class="nc" id="L2618">                K otherKey = (K) other.getKey();</span>
<span class="nc" id="L2619">                V otherValue = (V) other.getValue();</span>
<span class="nc bnc" id="L2620" title="All 2 branches missed.">                return this.hashingStrategy.equals(this.key, otherKey)</span>
<span class="nc bnc" id="L2621" title="All 2 branches missed.">                        &amp;&amp; UnifiedMapWithHashingStrategy.nullSafeEquals(this.value, otherValue);</span>
            }
<span class="nc" id="L2623">            return false;</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc bnc" id="L2629" title="All 2 branches missed.">            return this.hashingStrategy.computeHashCode(this.key)</span>
<span class="nc" id="L2630">                    ^ (this.value == null ? 0 : this.value.hashCode());</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L2636">            return this.key + &quot;=&quot; + this.value;</span>
        }
    }

<span class="nc" id="L2640">    protected class ValuesCollection extends ValuesCollectionCommon&lt;V&gt;</span>
            implements Serializable, BatchIterable&lt;V&gt;
    {
        private static final long serialVersionUID = 1L;

        @Override
        public void clear()
        {
<span class="nc" id="L2648">            UnifiedMapWithHashingStrategy.this.clear();</span>
<span class="nc" id="L2649">        }</span>

        @Override
        public boolean contains(Object o)
        {
<span class="nc" id="L2654">            return UnifiedMapWithHashingStrategy.this.containsValue(o);</span>
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; collection)
        {
            // todo: this is N^2. if c is large, we should copy the values to a set.
<span class="nc" id="L2661">            return Iterate.allSatisfy(collection, Predicates.in(this));</span>
        }

        @Override
        public boolean isEmpty()
        {
<span class="nc" id="L2667">            return UnifiedMapWithHashingStrategy.this.isEmpty();</span>
        }

        @Override
        public Iterator&lt;V&gt; iterator()
        {
<span class="nc" id="L2673">            return new ValuesIterator();</span>
        }

        @Override
        public boolean remove(Object o)
        {
            // this is so slow that the extra overhead of the iterator won't be noticeable
<span class="nc bnc" id="L2680" title="All 2 branches missed.">            if (o == null)</span>
            {
<span class="nc bnc" id="L2682" title="All 2 branches missed.">                for (Iterator&lt;V&gt; it = this.iterator(); it.hasNext(); )</span>
                {
<span class="nc bnc" id="L2684" title="All 2 branches missed.">                    if (it.next() == null)</span>
                    {
<span class="nc" id="L2686">                        it.remove();</span>
<span class="nc" id="L2687">                        return true;</span>
                    }
                }
            }
            else
            {
<span class="nc bnc" id="L2693" title="All 2 branches missed.">                for (Iterator&lt;V&gt; it = this.iterator(); it.hasNext(); )</span>
                {
<span class="nc" id="L2695">                    V o2 = it.next();</span>
<span class="nc bnc" id="L2696" title="All 4 branches missed.">                    if (o == o2 || o2.equals(o))</span>
                    {
<span class="nc" id="L2698">                        it.remove();</span>
<span class="nc" id="L2699">                        return true;</span>
                    }
<span class="nc" id="L2701">                }</span>
            }
<span class="nc" id="L2703">            return false;</span>
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; collection)
        {
            // todo: this is N^2. if c is large, we should copy the values to a set.
<span class="nc" id="L2710">            boolean changed = false;</span>

<span class="nc bnc" id="L2712" title="All 2 branches missed.">            for (Object obj : collection)</span>
            {
<span class="nc bnc" id="L2714" title="All 2 branches missed.">                if (this.remove(obj))</span>
                {
<span class="nc" id="L2716">                    changed = true;</span>
                }
<span class="nc" id="L2718">            }</span>
<span class="nc" id="L2719">            return changed;</span>
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; collection)
        {
<span class="nc" id="L2725">            boolean modified = false;</span>
<span class="nc" id="L2726">            Iterator&lt;V&gt; e = this.iterator();</span>
<span class="nc bnc" id="L2727" title="All 2 branches missed.">            while (e.hasNext())</span>
            {
<span class="nc bnc" id="L2729" title="All 2 branches missed.">                if (!collection.contains(e.next()))</span>
                {
<span class="nc" id="L2731">                    e.remove();</span>
<span class="nc" id="L2732">                    modified = true;</span>
                }
            }
<span class="nc" id="L2735">            return modified;</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L2741">            return UnifiedMapWithHashingStrategy.this.size();</span>
        }

        @Override
        public void forEach(Procedure&lt;? super V&gt; procedure)
        {
<span class="nc" id="L2747">            UnifiedMapWithHashingStrategy.this.forEachValue(procedure);</span>
<span class="nc" id="L2748">        }</span>

        @Override
        public int getBatchCount(int batchSize)
        {
<span class="nc" id="L2753">            return UnifiedMapWithHashingStrategy.this.getBatchCount(batchSize);</span>
        }

        @Override
        public void batchForEach(Procedure&lt;? super V&gt; procedure, int sectionIndex, int sectionCount)
        {
<span class="nc" id="L2759">            UnifiedMapWithHashingStrategy.this.batchForEach(procedure, sectionIndex, sectionCount);</span>
<span class="nc" id="L2760">        }</span>

        protected void copyValues(Object[] result)
        {
<span class="nc" id="L2764">            int count = 0;</span>
<span class="nc bnc" id="L2765" title="All 2 branches missed.">            for (int i = 0; i &lt; UnifiedMapWithHashingStrategy.this.table.length; i += 2)</span>
            {
<span class="nc" id="L2767">                Object x = UnifiedMapWithHashingStrategy.this.table[i];</span>
<span class="nc bnc" id="L2768" title="All 2 branches missed.">                if (x != null)</span>
                {
<span class="nc bnc" id="L2770" title="All 2 branches missed.">                    if (x == CHAINED_KEY)</span>
                    {
<span class="nc" id="L2772">                        Object[] chain = (Object[]) UnifiedMapWithHashingStrategy.this.table[i + 1];</span>
<span class="nc bnc" id="L2773" title="All 2 branches missed.">                        for (int j = 0; j &lt; chain.length; j += 2)</span>
                        {
<span class="nc" id="L2775">                            Object cur = chain[j];</span>
<span class="nc bnc" id="L2776" title="All 2 branches missed.">                            if (cur == null)</span>
                            {
<span class="nc" id="L2778">                                break;</span>
                            }
<span class="nc" id="L2780">                            result[count++] = chain[j + 1];</span>
                        }
<span class="nc" id="L2782">                    }</span>
                    else
                    {
<span class="nc" id="L2785">                        result[count++] = UnifiedMapWithHashingStrategy.this.table[i + 1];</span>
                    }
                }
            }
<span class="nc" id="L2789">        }</span>

        @Override
        public Object[] toArray()
        {
<span class="nc" id="L2794">            int size = UnifiedMapWithHashingStrategy.this.size();</span>
<span class="nc" id="L2795">            Object[] result = new Object[size];</span>
<span class="nc" id="L2796">            this.copyValues(result);</span>
<span class="nc" id="L2797">            return result;</span>
        }

        @Override
        public &lt;T&gt; T[] toArray(T[] result)
        {
<span class="nc" id="L2803">            int size = UnifiedMapWithHashingStrategy.this.size();</span>
<span class="nc bnc" id="L2804" title="All 2 branches missed.">            if (result.length &lt; size)</span>
            {
<span class="nc" id="L2806">                result = (T[]) Array.newInstance(result.getClass().getComponentType(), size);</span>
            }
<span class="nc" id="L2808">            this.copyValues(result);</span>
<span class="nc bnc" id="L2809" title="All 2 branches missed.">            if (size &lt; result.length)</span>
            {
<span class="nc" id="L2811">                result[size] = null;</span>
            }
<span class="nc" id="L2813">            return result;</span>
        }

        protected Object writeReplace()
        {
<span class="nc" id="L2818">            FastList&lt;V&gt; replace = FastList.newList(UnifiedMapWithHashingStrategy.this.size());</span>
<span class="nc bnc" id="L2819" title="All 2 branches missed.">            for (int i = 0; i &lt; UnifiedMapWithHashingStrategy.this.table.length; i += 2)</span>
            {
<span class="nc" id="L2821">                Object cur = UnifiedMapWithHashingStrategy.this.table[i];</span>
<span class="nc bnc" id="L2822" title="All 2 branches missed.">                if (cur == CHAINED_KEY)</span>
                {
<span class="nc" id="L2824">                    this.chainedAddToList((Object[]) UnifiedMapWithHashingStrategy.this.table[i + 1], replace);</span>
                }
<span class="nc bnc" id="L2826" title="All 2 branches missed.">                else if (cur != null)</span>
                {
<span class="nc" id="L2828">                    replace.add((V) UnifiedMapWithHashingStrategy.this.table[i + 1]);</span>
                }
            }
<span class="nc" id="L2831">            return replace;</span>
        }

        private void chainedAddToList(Object[] chain, FastList&lt;V&gt; replace)
        {
<span class="nc bnc" id="L2836" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc" id="L2838">                Object cur = chain[i];</span>
<span class="nc bnc" id="L2839" title="All 2 branches missed.">                if (cur == null)</span>
                {
<span class="nc" id="L2841">                    return;</span>
                }
<span class="nc" id="L2843">                replace.add((V) chain[i + 1]);</span>
            }
<span class="nc" id="L2845">        }</span>

        @Override
        public String toString()
        {
<span class="nc" id="L2850">            return Iterate.makeString(this, &quot;[&quot;, &quot;, &quot;, &quot;]&quot;);</span>
        }
    }

<span class="nc" id="L2854">    protected class ValuesIterator extends PositionalIterator&lt;V&gt;</span>
    {
        protected V nextFromChain()
        {
<span class="nc" id="L2858">            Object[] chain = (Object[]) UnifiedMapWithHashingStrategy.this.table[this.position + 1];</span>
<span class="nc" id="L2859">            V val = (V) chain[this.chainPosition + 1];</span>
<span class="nc" id="L2860">            this.chainPosition += 2;</span>
<span class="nc bnc" id="L2861" title="All 4 branches missed.">            if (this.chainPosition &gt;= chain.length</span>
                    || chain[this.chainPosition] == null)
            {
<span class="nc" id="L2864">                this.chainPosition = 0;</span>
<span class="nc" id="L2865">                this.position += 2;</span>
            }
<span class="nc" id="L2867">            this.lastReturned = true;</span>
<span class="nc" id="L2868">            return val;</span>
        }

        @Override
        public V next()
        {
<span class="nc bnc" id="L2874" title="All 2 branches missed.">            if (!this.hasNext())</span>
            {
<span class="nc" id="L2876">                throw new NoSuchElementException(&quot;next() called, but the iterator is exhausted&quot;);</span>
            }
<span class="nc" id="L2878">            this.count++;</span>
<span class="nc" id="L2879">            Object[] table = UnifiedMapWithHashingStrategy.this.table;</span>
<span class="nc bnc" id="L2880" title="All 2 branches missed.">            if (this.chainPosition != 0)</span>
            {
<span class="nc" id="L2882">                return this.nextFromChain();</span>
            }
<span class="nc bnc" id="L2884" title="All 2 branches missed.">            while (table[this.position] == null)</span>
            {
<span class="nc" id="L2886">                this.position += 2;</span>
            }
<span class="nc" id="L2888">            Object cur = table[this.position];</span>
<span class="nc" id="L2889">            Object val = table[this.position + 1];</span>
<span class="nc bnc" id="L2890" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L2892">                return this.nextFromChain();</span>
            }
<span class="nc" id="L2894">            this.position += 2;</span>
<span class="nc" id="L2895">            this.lastReturned = true;</span>
<span class="nc" id="L2896">            return (V) val;</span>
        }
    }

    private K nonSentinel(Object key)
    {
<span class="nc bnc" id="L2902" title="All 2 branches missed.">        return key == NULL_KEY ? null : (K) key;</span>
    }

    private static Object toSentinelIfNull(Object key)
    {
<span class="nc bnc" id="L2907" title="All 2 branches missed.">        if (key == null)</span>
        {
<span class="nc" id="L2909">            return NULL_KEY;</span>
        }
<span class="nc" id="L2911">        return key;</span>
    }

    private boolean nonNullTableObjectEquals(Object cur, K key)
    {
<span class="nc bnc" id="L2916" title="All 8 branches missed.">        return cur == key || (cur == NULL_KEY ? key == null : this.hashingStrategy.equals(this.nonSentinel(cur), key));</span>
    }

    @Override
    public ImmutableMap&lt;K, V&gt; toImmutable()
    {
<span class="nc" id="L2922">        return HashingStrategyMaps.immutable.withAll(this);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>