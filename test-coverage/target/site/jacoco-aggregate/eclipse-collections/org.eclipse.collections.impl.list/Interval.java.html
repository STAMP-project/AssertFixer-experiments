<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Interval.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.impl.list</a> &gt; <span class="el_source">Interval.java</span></div><h1>Interval.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2016 Goldman Sachs.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.impl.list;

import java.io.Serializable;
import java.math.BigInteger;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.NoSuchElementException;
import java.util.RandomAccess;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;

import org.eclipse.collections.api.LazyIterable;
import org.eclipse.collections.api.bag.MutableBag;
import org.eclipse.collections.api.block.function.Function;
import org.eclipse.collections.api.block.function.Function2;
import org.eclipse.collections.api.block.function.primitive.DoubleObjectToDoubleFunction;
import org.eclipse.collections.api.block.function.primitive.IntObjectToIntFunction;
import org.eclipse.collections.api.block.function.primitive.LongObjectToLongFunction;
import org.eclipse.collections.api.block.predicate.Predicate;
import org.eclipse.collections.api.block.procedure.Procedure;
import org.eclipse.collections.api.block.procedure.Procedure2;
import org.eclipse.collections.api.block.procedure.primitive.IntIntProcedure;
import org.eclipse.collections.api.block.procedure.primitive.IntObjectProcedure;
import org.eclipse.collections.api.block.procedure.primitive.IntProcedure;
import org.eclipse.collections.api.block.procedure.primitive.ObjectIntProcedure;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.api.set.MutableSet;
import org.eclipse.collections.impl.bag.mutable.HashBag;
import org.eclipse.collections.impl.block.procedure.CollectProcedure;
import org.eclipse.collections.impl.block.procedure.CollectionAddProcedure;
import org.eclipse.collections.impl.block.procedure.RejectProcedure;
import org.eclipse.collections.impl.block.procedure.SelectProcedure;
import org.eclipse.collections.impl.factory.Lists;
import org.eclipse.collections.impl.lazy.AbstractLazyIterable;
import org.eclipse.collections.impl.list.mutable.FastList;
import org.eclipse.collections.impl.list.mutable.MutableListIterator;
import org.eclipse.collections.impl.set.mutable.UnifiedSet;

/**
 * An Interval is a range of integers that may be iterated over using a step value.  Interval
 * is an OO implementation of a for-loop.
 */
public final class Interval
        extends AbstractLazyIterable&lt;Integer&gt;
        implements List&lt;Integer&gt;, Serializable, RandomAccess
{
    private static final long serialVersionUID = 1L;

    private final int from;
    private final int to;
    private final int step;

    private Interval(int from, int to, int step)
<span class="nc" id="L66">    {</span>
<span class="nc" id="L67">        this.from = from;</span>
<span class="nc" id="L68">        this.to = to;</span>
<span class="nc" id="L69">        this.step = step;</span>
<span class="nc" id="L70">    }</span>

    /**
     * This static {@code from} method allows Interval to act as a fluent builder for itself.
     * It works in conjunction with the instance methods {@link #to(int)} and {@link #by(int)}.
     * &lt;p&gt;
     * Usage Example:
     * &lt;pre&gt;
     * Interval interval1 = Interval.from(1).to(5);         // results in: 1, 2, 3, 4, 5.
     * Interval interval2 = Interval.from(1).to(10).by(2);  // results in: 1, 3, 5, 7, 9.
     * &lt;/pre&gt;
     */
    public static Interval from(int newFrom)
    {
<span class="nc" id="L84">        return Interval.fromToBy(newFrom, newFrom, 1);</span>
    }

    /**
     * This instance {@code to} method allows Interval to act as a fluent builder for itself.
     * It works in conjunction with the static method {@link #from(int)} and instance method {@link #by(int)}.
     * &lt;p&gt;
     * Usage Example:
     * &lt;pre&gt;
     * Interval interval1 = Interval.from(1).to(5);         // results in: 1, 2, 3, 4, 5.
     * Interval interval2 = Interval.from(1).to(10).by(2);  // results in: 1, 3, 5, 7, 9.
     * &lt;/pre&gt;
     */
    public Interval to(int newTo)
    {
<span class="nc" id="L99">        return Interval.fromToBy(this.from, newTo, this.step);</span>
    }

    /**
     * This instance {@code by} method allows Interval to act as a fluent builder for itself.
     * It works in conjunction with the static method {@link #from(int)} and instance method {@link #to(int)}.
     * &lt;p&gt;
     * Usage Example:
     * &lt;pre&gt;
     * Interval interval1 = Interval.from(1).to(5);         // results in: 1, 2, 3, 4, 5.
     * Interval interval2 = Interval.from(1).to(10).by(2);  // results in: 1, 3, 5, 7, 9.
     * &lt;/pre&gt;
     */
    public Interval by(int newStep)
    {
<span class="nc" id="L114">        return Interval.fromToBy(this.from, this.to, newStep);</span>
    }

    /**
     * Returns an Interval starting at zero.
     * &lt;p&gt;
     * Usage Example:
     * &lt;pre&gt;
     * Interval interval1 = Interval.zero().to(5);         // results in: 0, 1, 2, 3, 4, 5.
     * Interval interval2 = Interval.zero().to(10).by(2);  // results in: 0, 2, 4, 6, 8, 10.
     * &lt;/pre&gt;
     */
    public static Interval zero()
    {
<span class="nc" id="L128">        return Interval.from(0);</span>
    }

    /**
     * Returns an Interval starting from 1 to the specified count value with a step value of 1.
     */
    public static Interval oneTo(int count)
    {
<span class="nc" id="L136">        return Interval.oneToBy(count, 1);</span>
    }

    /**
     * Returns an Interval starting from 1 to the specified count value with a step value of step.
     */
    public static Interval oneToBy(int count, int step)
    {
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (count &lt; 1)</span>
        {
<span class="nc" id="L146">            throw new IllegalArgumentException(&quot;Only positive ranges allowed using oneToBy&quot;);</span>
        }
<span class="nc" id="L148">        return Interval.fromToBy(1, count, step);</span>
    }

    /**
     * Returns an Interval starting from 0 to the specified count value with a step value of 1.
     */
    public static Interval zeroTo(int count)
    {
<span class="nc" id="L156">        return Interval.zeroToBy(count, 1);</span>
    }

    /**
     * Returns an Interval starting from 0 to the specified count value with a step value of step.
     */
    public static Interval zeroToBy(int count, int step)
    {
<span class="nc" id="L164">        return Interval.fromToBy(0, count, step);</span>
    }

    /**
     * Returns an Interval starting from the value from to the specified value to with a step value of 1.
     */
    public static Interval fromTo(int from, int to)
    {
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (from &lt;= to)</span>
        {
<span class="nc" id="L174">            return Interval.fromToBy(from, to, 1);</span>
        }
<span class="nc" id="L176">        return Interval.fromToBy(from, to, -1);</span>
    }

    /**
     * Returns an Interval representing the even values from the value from to the value to.
     */
    public static Interval evensFromTo(int from, int to)
    {
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (from % 2 != 0)</span>
        {
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (from &lt; to)</span>
            {
<span class="nc" id="L188">                from++;</span>
            }
            else
            {
<span class="nc" id="L192">                from--;</span>
            }
        }
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (to % 2 != 0)</span>
        {
<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (to &gt; from)</span>
            {
<span class="nc" id="L199">                to--;</span>
            }
            else
            {
<span class="nc" id="L203">                to++;</span>
            }
        }
<span class="nc bnc" id="L206" title="All 2 branches missed.">        return Interval.fromToBy(from, to, to &gt; from ? 2 : -2);</span>
    }

    /**
     * Returns an Interval representing the odd values from the value from to the value to.
     */
    public static Interval oddsFromTo(int from, int to)
    {
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (from % 2 == 0)</span>
        {
<span class="nc bnc" id="L216" title="All 2 branches missed.">            if (from &lt; to)</span>
            {
<span class="nc" id="L218">                from++;</span>
            }
            else
            {
<span class="nc" id="L222">                from--;</span>
            }
        }
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (to % 2 == 0)</span>
        {
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if (to &gt; from)</span>
            {
<span class="nc" id="L229">                to--;</span>
            }
            else
            {
<span class="nc" id="L233">                to++;</span>
            }
        }
<span class="nc bnc" id="L236" title="All 2 branches missed.">        return Interval.fromToBy(from, to, to &gt; from ? 2 : -2);</span>
    }

    /**
     * Returns an Set representing the Integer values from the value from to the value to.
     */
    public static MutableSet&lt;Integer&gt; toSet(int from, int to)
    {
<span class="nc" id="L244">        MutableSet&lt;Integer&gt; targetCollection = UnifiedSet.newSet();</span>
<span class="nc" id="L245">        Interval.fromTo(from, to).forEach(CollectionAddProcedure.on(targetCollection));</span>
<span class="nc" id="L246">        return targetCollection;</span>
    }

    /**
     * Returns a MutableList representing the Integer values from the value from to the value to in reverse.
     */
    public static MutableList&lt;Integer&gt; toReverseList(int from, int to)
    {
<span class="nc" id="L254">        return Interval.fromTo(from, to).reverseThis().toList();</span>
    }

    /**
     * Returns an Integer array with the values inclusively between from and to.
     */
    public static Integer[] toArray(int from, int to)
    {
<span class="nc" id="L262">        return Interval.fromTo(from, to).toArray();</span>
    }

    public static Integer[] toReverseArray(int from, int to)
    {
<span class="nc" id="L267">        return Interval.fromTo(from, to).reverseThis().toArray();</span>
    }

    /**
     * Returns an Interval for the range of integers inclusively between from and to with the specified
     * stepBy value.
     */
    public static Interval fromToBy(int from, int to, int stepBy)
    {
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (stepBy == 0)</span>
        {
<span class="nc" id="L278">            throw new IllegalArgumentException(&quot;Cannot use a step by of 0&quot;);</span>
        }
<span class="nc bnc" id="L280" title="All 8 branches missed.">        if (from &gt; to &amp;&amp; stepBy &gt; 0 || from &lt; to &amp;&amp; stepBy &lt; 0)</span>
        {
<span class="nc" id="L282">            throw new IllegalArgumentException(&quot;Step by is incorrect for the range&quot;);</span>
        }
<span class="nc" id="L284">        return new Interval(from, to, stepBy);</span>
    }

    /**
     * Returns true if the Interval contains all of the specified int values.
     */
    public boolean containsAll(int... values)
    {
<span class="nc bnc" id="L292" title="All 2 branches missed.">        for (int value : values)</span>
        {
<span class="nc bnc" id="L294" title="All 2 branches missed.">            if (!this.contains(value))</span>
            {
<span class="nc" id="L296">                return false;</span>
            }
        }
<span class="nc" id="L299">        return true;</span>
    }

    /**
     * Returns true if the Interval contains none of the specified int values.
     */
    public boolean containsNone(int... values)
    {
<span class="nc bnc" id="L307" title="All 2 branches missed.">        for (int value : values)</span>
        {
<span class="nc bnc" id="L309" title="All 2 branches missed.">            if (this.contains(value))</span>
            {
<span class="nc" id="L311">                return false;</span>
            }
        }
<span class="nc" id="L314">        return true;</span>
    }

    @Override
    public boolean contains(Object object)
    {
<span class="nc bnc" id="L320" title="All 4 branches missed.">        return object instanceof Integer &amp;&amp; this.contains(((Integer) object).intValue());</span>
    }

    /**
     * Returns true if the Interval contains the specified int value.
     */
    public boolean contains(int value)
    {
<span class="nc bnc" id="L328" title="All 4 branches missed.">        return this.isWithinBoundaries(value) &amp;&amp; (value - this.from) % this.step == 0;</span>
    }

    private boolean isWithinBoundaries(int value)
    {
<span class="nc bnc" id="L333" title="All 12 branches missed.">        return this.step &gt; 0 &amp;&amp; this.from &lt;= value &amp;&amp; value &lt;= this.to</span>
                || this.step &lt; 0 &amp;&amp; this.to &lt;= value &amp;&amp; value &lt;= this.from;
    }

    /**
     * Returns the Number result of calculating factorial for the range.
     */
    public Number factorial()
    {
<span class="nc" id="L342">        this.failIfOutOfFactorialRange();</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        return this.from == 0 ? Integer.valueOf(1) : this.product();</span>
    }

    /**
     * Returns the Number result of calculating product for the range.
     */
    public Number product()
    {
<span class="nc" id="L351">        return this.bigIntegerProduct();</span>
    }

    /**
     * Returns the BigInteger result of calculating product for the range.
     */
    private BigInteger bigIntegerProduct()
    {
<span class="nc" id="L359">        return this.injectInto(BigInteger.valueOf(1L), (result, each) -&gt; result.multiply(BigInteger.valueOf(each.longValue())));</span>
    }

    private void failIfOutOfFactorialRange()
    {
<span class="nc bnc" id="L364" title="All 4 branches missed.">        if (this.from &lt; 0 || this.step != 1)</span>
        {
<span class="nc" id="L366">            throw new IllegalStateException(&quot;Cannot calculate factorial on negative ranges&quot;);</span>
        }
<span class="nc" id="L368">    }</span>

    public void forEachWithIndex(IntIntProcedure procedure)
    {
<span class="nc" id="L372">        int index = 0;</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (this.goForward())</span>
        {
<span class="nc bnc" id="L375" title="All 2 branches missed.">            for (int i = this.from; i &lt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L377">                procedure.value(i, index++);</span>
            }
        }
        else
        {
<span class="nc bnc" id="L382" title="All 2 branches missed.">            for (int i = this.from; i &gt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L384">                procedure.value(i, index++);</span>
            }
        }
<span class="nc" id="L387">    }</span>

    @Override
    public void forEachWithIndex(ObjectIntProcedure&lt;? super Integer&gt; objectIntProcedure)
    {
<span class="nc" id="L392">        this.forEachWithIndex((IntIntProcedure) objectIntProcedure::value);</span>
<span class="nc" id="L393">    }</span>

    public &lt;P&gt; void forEachWith(IntObjectProcedure&lt;? super P&gt; procedure, P parameter)
    {
<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (this.goForward())</span>
        {
<span class="nc bnc" id="L399" title="All 2 branches missed.">            for (int i = this.from; i &lt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L401">                procedure.value(i, parameter);</span>
            }
        }
        else
        {
<span class="nc bnc" id="L406" title="All 2 branches missed.">            for (int i = this.from; i &gt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L408">                procedure.value(i, parameter);</span>
            }
        }
<span class="nc" id="L411">    }</span>

    public boolean goForward()
    {
<span class="nc bnc" id="L415" title="All 4 branches missed.">        return this.from &lt;= this.to &amp;&amp; this.step &gt; 0;</span>
    }

    @Override
    public &lt;P&gt; void forEachWith(Procedure2&lt;? super Integer, ? super P&gt; procedure, P parameter)
    {
<span class="nc" id="L421">        this.forEachWith((IntObjectProcedure&lt;P&gt;) procedure::value, parameter);</span>
<span class="nc" id="L422">    }</span>

    public void forEach(IntProcedure procedure)
    {
<span class="nc bnc" id="L426" title="All 2 branches missed.">        if (this.goForward())</span>
        {
<span class="nc bnc" id="L428" title="All 2 branches missed.">            for (int i = this.from; i &lt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L430">                procedure.value(i);</span>
            }
        }
        else
        {
<span class="nc bnc" id="L435" title="All 2 branches missed.">            for (int i = this.from; i &gt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L437">                procedure.value(i);</span>
            }
        }
<span class="nc" id="L440">    }</span>

    @Override
    public void each(Procedure&lt;? super Integer&gt; procedure)
    {
<span class="nc" id="L445">        this.forEach((IntProcedure) procedure::value);</span>
<span class="nc" id="L446">    }</span>

    /**
     * This method executes a void procedure against an executor, passing the current index of the
     * interval.
     */
    public void forEach(Procedure&lt;? super Integer&gt; procedure, Executor executor)
    {
<span class="nc" id="L454">        CountDownLatch latch = new CountDownLatch(this.size());</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        if (this.goForward())</span>
        {
            // Iterates in forward direction because step value is negative
<span class="nc bnc" id="L458" title="All 2 branches missed.">            for (int i = this.from; i &lt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L460">                this.executeAndCountdown(procedure, executor, latch, i);</span>
            }
        }
        else
        {
            // Iterates in reverse because step value is negative
<span class="nc bnc" id="L466" title="All 2 branches missed.">            for (int i = this.from; i &gt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L468">                this.executeAndCountdown(procedure, executor, latch, i);</span>
            }
        }
        try
        {
<span class="nc" id="L473">            latch.await();</span>
        }
<span class="nc" id="L475">        catch (InterruptedException e)</span>
        {
            // do nothing here;
<span class="nc" id="L478">        }</span>
<span class="nc" id="L479">    }</span>

    private void executeAndCountdown(
            Procedure&lt;? super Integer&gt; procedure,
            Executor executor,
            CountDownLatch latch,
            Integer integer)
    {
<span class="nc" id="L487">        executor.execute(() -&gt; {</span>
            try
            {
<span class="nc" id="L490">                procedure.value(integer);</span>
            }
            finally
            {
<span class="nc" id="L494">                latch.countDown();</span>
            }
<span class="nc" id="L496">        });</span>
<span class="nc" id="L497">    }</span>

    /**
     * This method runs a runnable a specified number of times against on the current thread.
     */
    public void run(Runnable runnable)
    {
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (this.goForward())</span>
        {
<span class="nc bnc" id="L506" title="All 2 branches missed.">            for (int i = this.from; i &lt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L508">                runnable.run();</span>
            }
        }
        else
        {
<span class="nc bnc" id="L513" title="All 2 branches missed.">            for (int i = this.from; i &gt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L515">                runnable.run();</span>
            }
        }
<span class="nc" id="L518">    }</span>

    /**
     * This method runs a runnable a specified number of times against an executor.  The method is effectively
     * asynchronous because it does not wait for all of the runnables to finish.
     */
    public void run(Runnable runnable, Executor executor)
    {
<span class="nc bnc" id="L526" title="All 2 branches missed.">        if (this.goForward())</span>
        {
<span class="nc bnc" id="L528" title="All 2 branches missed.">            for (int i = this.from; i &lt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L530">                executor.execute(runnable);</span>
            }
        }
        else
        {
<span class="nc bnc" id="L535" title="All 2 branches missed.">            for (int i = this.from; i &gt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L537">                executor.execute(runnable);</span>
            }
        }
<span class="nc" id="L540">    }</span>

    @Override
    public &lt;R&gt; R injectInto(R injectValue, Function2&lt;? super R, ? super Integer, ? extends R&gt; function)
    {
<span class="nc" id="L545">        R result = injectValue;</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if (this.goForward())</span>
        {
<span class="nc bnc" id="L548" title="All 2 branches missed.">            for (int i = this.from; i &lt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L550">                result = function.value(result, i);</span>
            }
        }
        else
        {
<span class="nc bnc" id="L555" title="All 2 branches missed.">            for (int i = this.from; i &gt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L557">                result = function.value(result, i);</span>
            }
        }
<span class="nc" id="L560">        return result;</span>
    }

    @Override
    public int injectInto(int injectedValue, IntObjectToIntFunction&lt;? super Integer&gt; function)
    {
<span class="nc" id="L566">        int result = injectedValue;</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">        if (this.goForward())</span>
        {
<span class="nc bnc" id="L569" title="All 2 branches missed.">            for (int i = this.from; i &lt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L571">                result = function.intValueOf(result, i);</span>
            }
        }
        else
        {
<span class="nc bnc" id="L576" title="All 2 branches missed.">            for (int i = this.from; i &gt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L578">                result = function.intValueOf(result, i);</span>
            }
        }
<span class="nc" id="L581">        return result;</span>
    }

    @Override
    public long injectInto(long injectedValue, LongObjectToLongFunction&lt;? super Integer&gt; function)
    {
<span class="nc" id="L587">        long result = injectedValue;</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">        if (this.goForward())</span>
        {
<span class="nc bnc" id="L590" title="All 2 branches missed.">            for (int i = this.from; i &lt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L592">                result = function.longValueOf(result, i);</span>
            }
        }
        else
        {
<span class="nc bnc" id="L597" title="All 2 branches missed.">            for (int i = this.from; i &gt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L599">                result = function.longValueOf(result, i);</span>
            }
        }
<span class="nc" id="L602">        return result;</span>
    }

    @Override
    public double injectInto(double injectedValue, DoubleObjectToDoubleFunction&lt;? super Integer&gt; function)
    {
<span class="nc" id="L608">        double result = injectedValue;</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">        if (this.goForward())</span>
        {
<span class="nc bnc" id="L611" title="All 2 branches missed.">            for (int i = this.from; i &lt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L613">                result = function.doubleValueOf(result, i);</span>
            }
        }
        else
        {
<span class="nc bnc" id="L618" title="All 2 branches missed.">            for (int i = this.from; i &gt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L620">                result = function.doubleValueOf(result, i);</span>
            }
        }
<span class="nc" id="L623">        return result;</span>
    }

    public void reverseForEach(Procedure&lt;? super Integer&gt; procedure)
    {
<span class="nc" id="L628">        this.reverseThis().forEach(procedure);</span>
<span class="nc" id="L629">    }</span>

    public &lt;R&gt; R reverseInjectInto(R injectValue, Function2&lt;R, Integer, R&gt; function)
    {
<span class="nc" id="L633">        return this.reverseThis().injectInto(injectValue, function);</span>
    }

    public &lt;R extends Collection&lt;Integer&gt;&gt; R addAllTo(R targetCollection)
    {
<span class="nc" id="L638">        this.forEach(CollectionAddProcedure.on(targetCollection));</span>
<span class="nc" id="L639">        return targetCollection;</span>
    }

    @Override
    public &lt;T, R extends Collection&lt;T&gt;&gt; R collect(
            Function&lt;? super Integer, ? extends T&gt; function,
            R target)
    {
<span class="nc" id="L647">        CollectProcedure&lt;Integer, T&gt; procedure = new CollectProcedure&lt;&gt;(function, target);</span>
<span class="nc" id="L648">        this.forEach(procedure);</span>
<span class="nc" id="L649">        return target;</span>
    }

    @Override
    public &lt;R extends Collection&lt;Integer&gt;&gt; R select(Predicate&lt;? super Integer&gt; predicate, R target)
    {
<span class="nc" id="L655">        SelectProcedure&lt;Integer&gt; procedure = new SelectProcedure&lt;&gt;(predicate, target);</span>
<span class="nc" id="L656">        this.forEach(procedure);</span>
<span class="nc" id="L657">        return target;</span>
    }

    @Override
    public &lt;R extends Collection&lt;Integer&gt;&gt; R reject(Predicate&lt;? super Integer&gt; predicate, R target)
    {
<span class="nc" id="L663">        RejectProcedure&lt;Integer&gt; procedure = new RejectProcedure&lt;&gt;(predicate, target);</span>
<span class="nc" id="L664">        this.forEach(procedure);</span>
<span class="nc" id="L665">        return target;</span>
    }

    @Override
    public boolean equals(Object otherList)
    {
<span class="nc bnc" id="L671" title="All 2 branches missed.">        if (otherList == this)</span>
        {
<span class="nc" id="L673">            return true;</span>
        }
<span class="nc bnc" id="L675" title="All 2 branches missed.">        if (!(otherList instanceof List))</span>
        {
<span class="nc" id="L677">            return false;</span>
        }
<span class="nc" id="L679">        List&lt;?&gt; list = (List&lt;?&gt;) otherList;</span>

<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (otherList instanceof RandomAccess)</span>
        {
<span class="nc bnc" id="L683" title="All 2 branches missed.">            if (this.size() != list.size())</span>
            {
<span class="nc" id="L685">                return false;</span>
            }
        }
<span class="nc" id="L688">        ListIterator&lt;?&gt; listIterator = ((List&lt;?&gt;) otherList).listIterator();</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">        if (this.goForward())</span>
        {
<span class="nc bnc" id="L691" title="All 4 branches missed.">            for (int i = this.from; i &lt;= this.to &amp;&amp; listIterator.hasNext(); i += this.step)</span>
            {
<span class="nc" id="L693">                Object object = listIterator.next();</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">                if (this.intObjectEqual(i, object))</span>
                {
<span class="nc" id="L696">                    return false;</span>
                }
            }
        }
        else
        {
<span class="nc bnc" id="L702" title="All 4 branches missed.">            for (int i = this.from; i &gt;= this.to &amp;&amp; listIterator.hasNext(); i += this.step)</span>
            {
<span class="nc" id="L704">                Object object = listIterator.next();</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                if (this.intObjectEqual(i, object))</span>
                {
<span class="nc" id="L707">                    return false;</span>
                }
            }
        }

<span class="nc bnc" id="L712" title="All 2 branches missed.">        return !listIterator.hasNext();</span>
    }

    private boolean intObjectEqual(int i, Object object)
    {
<span class="nc bnc" id="L717" title="All 6 branches missed.">        return object == null || !(object instanceof Integer) || ((Integer) object).intValue() != i;</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L723">        int hashCode = 1;</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">        if (this.goForward())</span>
        {
<span class="nc bnc" id="L726" title="All 2 branches missed.">            for (int i = this.from; i &lt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L728">                hashCode = 31 * hashCode + i;</span>
            }
        }
        else
        {
<span class="nc bnc" id="L733" title="All 2 branches missed.">            for (int i = this.from; i &gt;= this.to; i += this.step)</span>
            {
<span class="nc" id="L735">                hashCode = 31 * hashCode + i;</span>
            }
        }
<span class="nc" id="L738">        return hashCode;</span>
    }

    /**
     * Returns a new interval with the from and to values reversed and the step value negated.
     */
    public Interval reverseThis()
    {
<span class="nc" id="L746">        return Interval.fromToBy(this.to, this.from, -this.step);</span>
    }

    /**
     * Calculates and returns the size of the interval.
     */
    @Override
    public int size()
    {
<span class="nc" id="L755">        return (this.to - this.from) / this.step + 1;</span>
    }

    @Override
    public Integer[] toArray()
    {
<span class="nc" id="L761">        Integer[] result = new Integer[this.size()];</span>
<span class="nc" id="L762">        this.forEachWithIndex((ObjectIntProcedure&lt;Integer&gt;) (each, index) -&gt; result[index] = each);</span>
<span class="nc" id="L763">        return result;</span>
    }

    /**
     * Converts the interval to an Integer array
     */
    public int[] toIntArray()
    {
<span class="nc" id="L771">        int[] result = new int[this.size()];</span>
<span class="nc" id="L772">        this.forEachWithIndex((IntIntProcedure) (each, index) -&gt; result[index] = each);</span>
<span class="nc" id="L773">        return result;</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L779">        return &quot;Interval from: &quot; + this.from + &quot; to: &quot; + this.to + &quot; step: &quot; + this.step + &quot; size: &quot; + this.size();</span>
    }

    @Override
    public Iterator&lt;Integer&gt; iterator()
    {
<span class="nc" id="L785">        return new IntegerIterator();</span>
    }

<span class="nc" id="L788">    private class IntegerIterator implements Iterator&lt;Integer&gt;</span>
    {
<span class="nc" id="L790">        private int current = Interval.this.from;</span>

        @Override
        public boolean hasNext()
        {
<span class="nc bnc" id="L795" title="All 2 branches missed.">            if (Interval.this.from &lt;= Interval.this.to)</span>
            {
<span class="nc bnc" id="L797" title="All 2 branches missed.">                return this.current &lt;= Interval.this.to;</span>
            }
<span class="nc bnc" id="L799" title="All 2 branches missed.">            return this.current &gt;= Interval.this.to;</span>
        }

        @Override
        public Integer next()
        {
<span class="nc bnc" id="L805" title="All 2 branches missed.">            if (this.hasNext())</span>
            {
<span class="nc" id="L807">                Integer result = this.current;</span>
<span class="nc" id="L808">                this.current += Interval.this.step;</span>
<span class="nc" id="L809">                return result;</span>
            }
<span class="nc" id="L811">            throw new NoSuchElementException();</span>
        }

        @Override
        public void remove()
        {
<span class="nc" id="L817">            throw new UnsupportedOperationException(&quot;Cannot remove a value from an Interval&quot;);</span>
        }
    }

    @Override
    public Integer getFirst()
    {
<span class="nc" id="L824">        return this.from;</span>
    }

    @Override
    public Integer getLast()
    {
<span class="nc" id="L830">        return this.locationAfterN(this.size() - 1);</span>
    }

    public void forEach(Procedure&lt;? super Integer&gt; procedure, int startIndex, int endIndex)
    {
<span class="nc" id="L835">        this.checkBounds(&quot;startIndex&quot;, startIndex);</span>
<span class="nc" id="L836">        this.checkBounds(&quot;endIndex&quot;, endIndex);</span>

<span class="nc bnc" id="L838" title="All 2 branches missed.">        if (startIndex &lt;= endIndex)</span>
        {
<span class="nc bnc" id="L840" title="All 2 branches missed.">            for (int i = startIndex; i &lt;= endIndex; i++)</span>
            {
<span class="nc" id="L842">                procedure.value(this.locationAfterN(i));</span>
            }
        }
        else
        {
<span class="nc bnc" id="L847" title="All 2 branches missed.">            for (int i = startIndex; i &gt;= endIndex; i--)</span>
            {
<span class="nc" id="L849">                procedure.value(this.locationAfterN(i));</span>
            }
        }
<span class="nc" id="L852">    }</span>

    public void forEachWithIndex(ObjectIntProcedure&lt;? super Integer&gt; objectIntProcedure, int startIndex, int endIndex)
    {
<span class="nc" id="L856">        this.checkBounds(&quot;startIndex&quot;, startIndex);</span>
<span class="nc" id="L857">        this.checkBounds(&quot;endIndex&quot;, endIndex);</span>

<span class="nc bnc" id="L859" title="All 2 branches missed.">        if (startIndex &lt;= endIndex)</span>
        {
<span class="nc bnc" id="L861" title="All 2 branches missed.">            for (int i = startIndex; i &lt;= endIndex; i++)</span>
            {
<span class="nc" id="L863">                objectIntProcedure.value(this.locationAfterN(i), i);</span>
            }
        }
        else
        {
<span class="nc bnc" id="L868" title="All 2 branches missed.">            for (int i = startIndex; i &gt;= endIndex; i--)</span>
            {
<span class="nc" id="L870">                objectIntProcedure.value(this.locationAfterN(i), i);</span>
            }
        }
<span class="nc" id="L873">    }</span>

    @Override
    public Integer get(int index)
    {
<span class="nc" id="L878">        this.checkBounds(&quot;index&quot;, index);</span>
<span class="nc" id="L879">        return this.locationAfterN(index);</span>
    }

    private void checkBounds(String name, int index)
    {
<span class="nc bnc" id="L884" title="All 4 branches missed.">        if (index &lt; 0 || index &gt;= this.size())</span>
        {
<span class="nc" id="L886">            throw new IndexOutOfBoundsException(name + &quot;: &quot; + index + ' ' + this);</span>
        }
<span class="nc" id="L888">    }</span>

    private int locationAfterN(int index)
    {
<span class="nc bnc" id="L892" title="All 2 branches missed.">        if (index &lt;= 0)</span>
        {
<span class="nc" id="L894">            return this.from;</span>
        }
<span class="nc bnc" id="L896" title="All 2 branches missed.">        if (this.step &gt; 0)</span>
        {
<span class="nc" id="L898">            return (int) Math.min((long) this.from + (long) this.step * (long) index, this.to);</span>
        }
<span class="nc" id="L900">        return (int) Math.max((long) this.from + (long) this.step * (long) index, this.to);</span>
    }

    @Override
    public int indexOf(Object object)
    {
<span class="nc bnc" id="L906" title="All 2 branches missed.">        if (!(object instanceof Integer))</span>
        {
<span class="nc" id="L908">            return -1;</span>
        }
<span class="nc" id="L910">        Integer value = (Integer) object;</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">        if (!this.isWithinBoundaries(value))</span>
        {
<span class="nc" id="L913">            return -1;</span>
        }

<span class="nc" id="L916">        int diff = value - this.from;</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">        if (diff % this.step == 0)</span>
        {
<span class="nc" id="L919">            return diff / this.step;</span>
        }

<span class="nc" id="L922">        return -1;</span>
    }

    @Override
    public int lastIndexOf(Object object)
    {
<span class="nc" id="L928">        return this.indexOf(object);</span>
    }

    @Override
    public MutableList&lt;Integer&gt; toList()
    {
<span class="nc" id="L934">        FastList&lt;Integer&gt; list = FastList.newList(this.size());</span>
<span class="nc" id="L935">        this.forEach(CollectionAddProcedure.on(list));</span>
<span class="nc" id="L936">        return list;</span>
    }

    @Override
    public MutableSet&lt;Integer&gt; toSet()
    {
<span class="nc" id="L942">        MutableSet&lt;Integer&gt; set = UnifiedSet.newSet(this.size());</span>
<span class="nc" id="L943">        this.forEach(CollectionAddProcedure.on(set));</span>
<span class="nc" id="L944">        return set;</span>
    }

    @Override
    public MutableBag&lt;Integer&gt; toBag()
    {
<span class="nc" id="L950">        MutableBag&lt;Integer&gt; bag = HashBag.newBag(this.size());</span>
<span class="nc" id="L951">        this.forEach(CollectionAddProcedure.on(bag));</span>
<span class="nc" id="L952">        return bag;</span>
    }

    @Override
    public boolean add(Integer integer)
    {
<span class="nc" id="L958">        throw new UnsupportedOperationException(&quot;Cannot call add() on &quot; + this.getClass().getSimpleName());</span>
    }

    @Override
    public boolean remove(Object o)
    {
<span class="nc" id="L964">        throw new UnsupportedOperationException(&quot;Cannot call remove() on &quot; + this.getClass().getSimpleName());</span>
    }

    @Override
    @SuppressWarnings(&quot;TypeParameterExtendsFinalClass&quot;)
    public boolean addAll(Collection&lt;? extends Integer&gt; collection)
    {
<span class="nc" id="L971">        throw new UnsupportedOperationException(&quot;Cannot call addAll() on &quot; + this.getClass().getSimpleName());</span>
    }

    @Override
    @SuppressWarnings(&quot;TypeParameterExtendsFinalClass&quot;)
    public boolean addAll(int index, Collection&lt;? extends Integer&gt; collection)
    {
<span class="nc" id="L978">        throw new UnsupportedOperationException(&quot;Cannot call addAll() on &quot; + this.getClass().getSimpleName());</span>
    }

    @Override
    public boolean removeAll(Collection&lt;?&gt; collection)
    {
<span class="nc" id="L984">        throw new UnsupportedOperationException(&quot;Cannot call removeAll() on &quot; + this.getClass().getSimpleName());</span>
    }

    @Override
    public boolean retainAll(Collection&lt;?&gt; collection)
    {
<span class="nc" id="L990">        throw new UnsupportedOperationException(&quot;Cannot call retainAll() on &quot; + this.getClass().getSimpleName());</span>
    }

    @Override
    public void clear()
    {
<span class="nc" id="L996">        throw new UnsupportedOperationException(&quot;Cannot call clear() on &quot; + this.getClass().getSimpleName());</span>
    }

    @Override
    public Integer set(int index, Integer element)
    {
<span class="nc" id="L1002">        throw new UnsupportedOperationException(&quot;Cannot call set() on &quot; + this.getClass().getSimpleName());</span>
    }

    @Override
    public void add(int index, Integer element)
    {
<span class="nc" id="L1008">        throw new UnsupportedOperationException(&quot;Cannot call add() on &quot; + this.getClass().getSimpleName());</span>
    }

    @Override
    public Integer remove(int index)
    {
<span class="nc" id="L1014">        throw new UnsupportedOperationException(&quot;Cannot call remove() on &quot; + this.getClass().getSimpleName());</span>
    }

    @Override
    public ListIterator&lt;Integer&gt; listIterator()
    {
<span class="nc" id="L1020">        return new MutableListIterator&lt;&gt;(this, 0);</span>
    }

    @Override
    public ListIterator&lt;Integer&gt; listIterator(int index)
    {
<span class="nc" id="L1026">        return new MutableListIterator&lt;&gt;(this, index);</span>
    }

    @Override
    public Interval subList(int fromIndex, int toIndex)
    {
<span class="nc" id="L1032">        return Interval.fromToBy(this.get(fromIndex), this.get(toIndex - 1), this.step);</span>
    }

    @Override
    public LazyIterable&lt;Integer&gt; take(int count)
    {
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        if (count &lt; 0)</span>
        {
<span class="nc" id="L1040">            throw new IllegalArgumentException(&quot;Count must be greater than zero, but was: &quot; + count);</span>
        }

<span class="nc bnc" id="L1043" title="All 4 branches missed.">        if (count &gt; 0 &amp;&amp; this.notEmpty())</span>
        {
<span class="nc" id="L1045">            return Interval.fromToBy(this.from, this.locationAfterN(count - 1), this.step);</span>
        }
<span class="nc" id="L1047">        return Lists.immutable.&lt;Integer&gt;empty().asLazy();</span>
    }

    @Override
    public LazyIterable&lt;Integer&gt; drop(int count)
    {
<span class="nc bnc" id="L1053" title="All 2 branches missed.">        if (count &lt; 0)</span>
        {
<span class="nc" id="L1055">            throw new IllegalArgumentException(&quot;Count must be greater than zero, but was: &quot; + count);</span>
        }

<span class="nc bnc" id="L1058" title="All 2 branches missed.">        if (count &gt;= this.size())</span>
        {
<span class="nc" id="L1060">            return Lists.immutable.&lt;Integer&gt;of().asLazy();</span>
        }

<span class="nc" id="L1063">        return Interval.fromToBy(this.locationAfterN(count), this.to, this.step);</span>
    }

    @Override
    public LazyIterable&lt;Integer&gt; distinct()
    {
<span class="nc" id="L1069">        return this;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>