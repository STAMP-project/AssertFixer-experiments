<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DoubleHashSet.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.impl.set.mutable.primitive</a> &gt; <span class="el_source">DoubleHashSet.java</span></div><h1>DoubleHashSet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2018 Goldman Sachs and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.impl.set.mutable.primitive;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collection;
import java.util.NoSuchElementException;

import org.eclipse.collections.api.DoubleIterable;
import org.eclipse.collections.api.RichIterable;
import org.eclipse.collections.api.block.function.primitive.DoubleToObjectFunction;
import org.eclipse.collections.api.block.function.primitive.ObjectDoubleToObjectFunction;
import org.eclipse.collections.api.block.predicate.primitive.DoublePredicate;
import org.eclipse.collections.api.block.procedure.primitive.DoubleProcedure;
import org.eclipse.collections.api.collection.primitive.MutableDoubleCollection;
import org.eclipse.collections.api.iterator.DoubleIterator;
import org.eclipse.collections.api.iterator.MutableDoubleIterator;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.impl.factory.Lists;
import org.eclipse.collections.api.set.ImmutableSet;
import org.eclipse.collections.api.set.MutableSet;
import org.eclipse.collections.api.set.primitive.ImmutableDoubleSet;
import org.eclipse.collections.api.set.primitive.MutableDoubleSet;
import org.eclipse.collections.api.set.primitive.DoubleSet;
import org.eclipse.collections.impl.factory.primitive.DoubleSets;
import org.eclipse.collections.impl.set.immutable.primitive.ImmutableDoubleSetSerializationProxy;
import org.eclipse.collections.impl.set.mutable.UnifiedSet;
import org.eclipse.collections.impl.SpreadFunctions;
import org.eclipse.collections.impl.set.immutable.primitive.AbstractImmutableDoubleSet;
import org.eclipse.collections.impl.set.primitive.AbstractDoubleSet;

/**
 * This file was automatically generated from template file primitiveHashSet.stg.
 *
 * @since 3.0.
 */
public class DoubleHashSet extends AbstractDoubleSet implements MutableDoubleSet, Externalizable
{
    private static final long serialVersionUID = 1L;
    private static final int OCCUPIED_DATA_RATIO = 2;
    private static final int OCCUPIED_SENTINEL_RATIO = 4;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    private static final double EMPTY = 0.0;
    private static final double REMOVED = 1.0;
    private static final int CACHE_LINE_SIZE = 64;
    private static final int KEY_SIZE = 8;
    private static final int INITIAL_LINEAR_PROBE = CACHE_LINE_SIZE / KEY_SIZE / 2; /* half a cache line */

    private double[] table;
    private int occupiedWithData;
    private int occupiedWithSentinels;
    // The 32 bits of this integer indicate whether the items 0.0 to 31.0 are present in the set.
    private int zeroToThirtyOne;
    private int zeroToThirtyOneOccupied;
    private transient boolean copyOnWrite;

    public DoubleHashSet()
<span class="nc" id="L71">    {</span>
<span class="nc" id="L72">        this.allocateTable(DEFAULT_INITIAL_CAPACITY);</span>
<span class="nc" id="L73">    }</span>

    public DoubleHashSet(int initialCapacity)
<span class="nc" id="L76">    {</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">        if (initialCapacity &lt; 0)</span>
        {
<span class="nc" id="L79">            throw new IllegalArgumentException(&quot;initial capacity cannot be less than 0&quot;);</span>
        }
<span class="nc" id="L81">        int capacity = this.smallestPowerOfTwoGreaterThan(this.fastCeil(initialCapacity * OCCUPIED_DATA_RATIO));</span>
<span class="nc" id="L82">        this.allocateTable(capacity);</span>
<span class="nc" id="L83">    }</span>

    public DoubleHashSet(double... elements)
    {
<span class="nc" id="L87">        this();</span>
<span class="nc" id="L88">        this.addAll(elements);</span>
<span class="nc" id="L89">    }</span>

    public DoubleHashSet(DoubleHashSet set)
<span class="nc" id="L92">    {</span>
<span class="nc" id="L93">        this.occupiedWithData = set.occupiedWithData;</span>
<span class="nc" id="L94">        this.occupiedWithSentinels = set.occupiedWithSentinels;</span>
<span class="nc" id="L95">        this.zeroToThirtyOneOccupied = set.zeroToThirtyOneOccupied;</span>
<span class="nc" id="L96">        this.zeroToThirtyOne = set.zeroToThirtyOne;</span>
<span class="nc" id="L97">        this.allocateTable(set.table.length);</span>

<span class="nc" id="L99">        System.arraycopy(set.table, 0, this.table, 0, set.table.length);</span>
<span class="nc" id="L100">    }</span>

    private int smallestPowerOfTwoGreaterThan(int n)
    {
<span class="nc bnc" id="L104" title="All 2 branches missed.">        return n &gt; 1 ? Integer.highestOneBit(n - 1) &lt;&lt; 1 : 1;</span>
    }

    private int fastCeil(float v)
    {
<span class="nc" id="L109">        int possibleResult = (int) v;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (v - possibleResult &gt; 0.0F)</span>
        {
<span class="nc" id="L112">            possibleResult++;</span>
        }
<span class="nc" id="L114">        return possibleResult;</span>
    }

    public static DoubleHashSet newSet(DoubleIterable source)
    {
<span class="nc bnc" id="L119" title="All 2 branches missed.">        if (source instanceof DoubleHashSet)</span>
        {
<span class="nc" id="L121">            return new DoubleHashSet((DoubleHashSet) source);</span>
        }

<span class="nc" id="L124">        return DoubleHashSet.newSetWith(source.toArray());</span>
    }

    public static DoubleHashSet newSetWith(double... source)
    {
<span class="nc" id="L129">        return new DoubleHashSet(source);</span>
    }

    private static boolean isBetweenZeroAndThirtyOne(double value)
    {
<span class="nc bnc" id="L134" title="All 6 branches missed.">        return Double.compare(value, 0.0) &gt;= 0 &amp;&amp; Double.compare(value, 31.0) &lt;= 0 &amp;&amp; Double.compare(value, Math.floor(value)) == 0;</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L140">        int result = 0;</span>
<span class="nc" id="L141">        int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        while (zeroToThirtyOne != 0)</span>
        {
<span class="nc" id="L144">            double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc" id="L145">            result += (int) (Double.doubleToLongBits(value) ^ Double.doubleToLongBits(value) &gt;&gt;&gt; 32);</span>
<span class="nc" id="L146">            zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L147">        }</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (this.table != null)</span>
        {
<span class="nc bnc" id="L150" title="All 2 branches missed.">            for (int i = 0; i &lt; this.table.length; i++)</span>
            {
<span class="nc bnc" id="L152" title="All 2 branches missed.">                if (isNonSentinel(this.table[i]))</span>
                {
<span class="nc" id="L154">                    result += (int) (Double.doubleToLongBits(this.table[i]) ^ Double.doubleToLongBits(this.table[i]) &gt;&gt;&gt; 32);</span>
                }
            }
        }
<span class="nc" id="L158">        return result;</span>
    }

    @Override
    public int size()
    {
<span class="nc" id="L164">        return this.occupiedWithData + this.zeroToThirtyOneOccupied;</span>
    }

    @Override
    public void appendString(Appendable appendable, String start, String separator, String end)
    {
        try
        {
<span class="nc" id="L172">            appendable.append(start);</span>

<span class="nc" id="L174">            int count = 0;</span>
<span class="nc" id="L175">            int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">            while (zeroToThirtyOne != 0)</span>
            {
<span class="nc" id="L178">                double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">                if (count &gt; 0)</span>
                {
<span class="nc" id="L181">                    appendable.append(separator);</span>
                }
<span class="nc" id="L183">                count++;</span>
<span class="nc" id="L184">                appendable.append(String.valueOf(value));</span>
<span class="nc" id="L185">                zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L186">            }</span>

<span class="nc bnc" id="L188" title="All 2 branches missed.">            for (double value : this.table)</span>
            {
<span class="nc bnc" id="L190" title="All 2 branches missed.">                if (isNonSentinel(value))</span>
                {
<span class="nc bnc" id="L192" title="All 2 branches missed.">                    if (count &gt; 0)</span>
                    {
<span class="nc" id="L194">                        appendable.append(separator);</span>
                    }
<span class="nc" id="L196">                    count++;</span>
<span class="nc" id="L197">                    appendable.append(String.valueOf(value));</span>
                }
            }
<span class="nc" id="L200">            appendable.append(end);</span>
        }
<span class="nc" id="L202">        catch (IOException e)</span>
        {
<span class="nc" id="L204">            throw new RuntimeException(e);</span>
<span class="nc" id="L205">        }</span>
<span class="nc" id="L206">    }</span>

    @Override
    public boolean add(double element)
    {
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (isBetweenZeroAndThirtyOne(element))</span>
        {
<span class="nc" id="L213">            int initial = this.zeroToThirtyOne;</span>
<span class="nc" id="L214">            this.zeroToThirtyOne |= 1 &lt;&lt; (int) element;</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">            if (this.zeroToThirtyOne != initial)</span>
            {
<span class="nc" id="L217">                this.zeroToThirtyOneOccupied++;</span>
<span class="nc" id="L218">                return true;</span>
            }
<span class="nc" id="L220">            return false;</span>
        }

<span class="nc" id="L223">        int index = this.probe(element);</span>

<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (Double.compare(this.table[index], element) == 0)</span>
        {
            // element already present in set
<span class="nc" id="L228">            return false;</span>
        }

<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (this.copyOnWrite)</span>
        {
<span class="nc" id="L233">            this.copyTable();</span>
        }
<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (Double.compare(this.table[index], REMOVED) == 0)</span>
        {
<span class="nc" id="L237">            --this.occupiedWithSentinels;</span>
        }
<span class="nc" id="L239">        this.table[index] = element;</span>
<span class="nc" id="L240">        ++this.occupiedWithData;</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (this.occupiedWithData &gt; this.maxOccupiedWithData())</span>
        {
<span class="nc" id="L243">            this.rehashAndGrow();</span>
        }
<span class="nc" id="L245">        return true;</span>
    }

    @Override
    public boolean addAll(double... source)
    {
<span class="nc" id="L251">        int oldSize = this.size();</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        for (double item : source)</span>
        {
<span class="nc" id="L254">            this.add(item);</span>
        }
<span class="nc bnc" id="L256" title="All 2 branches missed.">        return this.size() != oldSize;</span>
    }

    @Override
    public boolean addAll(DoubleIterable source)
    {
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (source.isEmpty())</span>
        {
<span class="nc" id="L264">            return false;</span>
        }
<span class="nc" id="L266">        int oldSize = this.size();</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (source instanceof DoubleHashSet)</span>
        {
<span class="nc" id="L269">            DoubleHashSet hashSet = (DoubleHashSet) source;</span>
<span class="nc" id="L270">            this.zeroToThirtyOne |= hashSet.zeroToThirtyOne;</span>
<span class="nc" id="L271">            this.zeroToThirtyOneOccupied = Integer.bitCount(this.zeroToThirtyOne);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">            for (double item : hashSet.table)</span>
            {
<span class="nc bnc" id="L274" title="All 2 branches missed.">                if (isNonSentinel(item))</span>
                {
<span class="nc" id="L276">                    this.add(item);</span>
                }
            }
<span class="nc" id="L279">        }</span>
        else
        {
<span class="nc" id="L282">            DoubleIterator iterator = source.doubleIterator();</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L285">                double item = iterator.next();</span>
<span class="nc" id="L286">                this.add(item);</span>
<span class="nc" id="L287">            }</span>
        }
<span class="nc bnc" id="L289" title="All 2 branches missed.">        return this.size() != oldSize;</span>
    }

    @Override
    public boolean remove(double value)
    {
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (isBetweenZeroAndThirtyOne(value))</span>
        {
<span class="nc" id="L297">            return this.removeZeroToThirtyOne(value);</span>
        }
<span class="nc" id="L299">        int index = this.probe(value);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (Double.compare(this.table[index], value) == 0)</span>
        {
<span class="nc bnc" id="L302" title="All 2 branches missed.">            if (this.copyOnWrite)</span>
            {
<span class="nc" id="L304">                this.copyTable();</span>
            }
<span class="nc" id="L306">            this.table[index] = REMOVED;</span>
<span class="nc" id="L307">            this.occupiedWithData--;</span>
<span class="nc" id="L308">            this.occupiedWithSentinels++;</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">            if (this.occupiedWithSentinels &gt; this.maxOccupiedWithSentinels())</span>
            {
<span class="nc" id="L311">                this.rehash();</span>
            }

<span class="nc" id="L314">            return true;</span>
        }
<span class="nc" id="L316">        return false;</span>
    }

    private boolean removeZeroToThirtyOne(double value)
    {
<span class="nc" id="L321">        int initial = this.zeroToThirtyOne;</span>
<span class="nc" id="L322">        this.zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (this.zeroToThirtyOne == initial)</span>
        {
<span class="nc" id="L325">            return false;</span>
        }
<span class="nc" id="L327">        this.zeroToThirtyOneOccupied--;</span>
<span class="nc" id="L328">        return true;</span>
    }

    @Override
    public boolean removeAll(DoubleIterable source)
    {
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (source.isEmpty())</span>
        {
<span class="nc" id="L336">            return false;</span>
        }
<span class="nc" id="L338">        int oldSize = this.size();</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (source instanceof DoubleHashSet)</span>
        {
<span class="nc" id="L341">            DoubleHashSet hashSet = (DoubleHashSet) source;</span>
<span class="nc" id="L342">            this.zeroToThirtyOne &amp;= ~hashSet.zeroToThirtyOne;</span>
<span class="nc" id="L343">            this.zeroToThirtyOneOccupied = Integer.bitCount(this.zeroToThirtyOne);</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            for (double item : hashSet.table)</span>
            {
<span class="nc bnc" id="L346" title="All 2 branches missed.">                if (isNonSentinel(item))</span>
                {
<span class="nc" id="L348">                    this.remove(item);</span>
                }
            }
<span class="nc" id="L351">        }</span>
        else
        {
<span class="nc" id="L354">            DoubleIterator iterator = source.doubleIterator();</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L357">                double item = iterator.next();</span>
<span class="nc" id="L358">                this.remove(item);</span>
<span class="nc" id="L359">            }</span>
        }
<span class="nc bnc" id="L361" title="All 2 branches missed.">        return this.size() != oldSize;</span>
    }

    @Override
    public boolean removeAll(double... source)
    {
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (source.length == 0)</span>
        {
<span class="nc" id="L369">            return false;</span>
        }
<span class="nc" id="L371">        int oldSize = this.size();</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">        for (double item : source)</span>
        {
<span class="nc" id="L374">            this.remove(item);</span>
        }
<span class="nc bnc" id="L376" title="All 2 branches missed.">        return this.size() != oldSize;</span>
    }

    @Override
    public boolean retainAll(DoubleIterable source)
    {
<span class="nc" id="L382">        int oldSize = this.size();</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">        final DoubleSet sourceSet = source instanceof DoubleSet ? (DoubleSet) source : source.toSet();</span>
<span class="nc" id="L384">        DoubleHashSet retained = this.select(sourceSet::contains);</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (retained.size() != oldSize)</span>
        {
<span class="nc" id="L387">            this.zeroToThirtyOne = retained.zeroToThirtyOne;</span>
<span class="nc" id="L388">            this.zeroToThirtyOneOccupied = retained.zeroToThirtyOneOccupied;</span>
<span class="nc" id="L389">            this.occupiedWithData = retained.occupiedWithData;</span>
<span class="nc" id="L390">            this.occupiedWithSentinels = retained.occupiedWithSentinels;</span>
<span class="nc" id="L391">            this.table = retained.table;</span>
<span class="nc" id="L392">            return true;</span>
        }
<span class="nc" id="L394">        return false;</span>
    }

    @Override
    public boolean retainAll(double... source)
    {
<span class="nc" id="L400">        return this.retainAll(DoubleHashSet.newSetWith(source));</span>
    }

    @Override
    public void clear()
    {
<span class="nc" id="L406">        this.zeroToThirtyOneOccupied = 0;</span>
<span class="nc" id="L407">        this.occupiedWithData = 0;</span>
<span class="nc" id="L408">        this.occupiedWithSentinels = 0;</span>

<span class="nc" id="L410">        this.zeroToThirtyOne = 0;</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (this.copyOnWrite)</span>
        {
<span class="nc" id="L413">            this.table = new double[this.table.length];</span>
<span class="nc" id="L414">            this.copyOnWrite = false;</span>
        }
        else
        {
<span class="nc" id="L418">            Arrays.fill(this.table, EMPTY);</span>
        }
<span class="nc" id="L420">    }</span>

    @Override
    public DoubleHashSet with(double element)
    {
<span class="nc" id="L425">        this.add(element);</span>
<span class="nc" id="L426">        return this;</span>
    }

    @Override
    public DoubleHashSet without(double element)
    {
<span class="nc" id="L432">        this.remove(element);</span>
<span class="nc" id="L433">        return this;</span>
    }

    @Override
    public DoubleHashSet withAll(DoubleIterable elements)
    {
<span class="nc" id="L439">        this.addAll(elements.toArray());</span>
<span class="nc" id="L440">        return this;</span>
    }

    @Override
    public DoubleHashSet withoutAll(DoubleIterable elements)
    {
<span class="nc" id="L446">        this.removeAll(elements);</span>
<span class="nc" id="L447">        return this;</span>
    }

    @Override
    public MutableDoubleSet asUnmodifiable()
    {
<span class="nc" id="L453">        return new UnmodifiableDoubleSet(this);</span>
    }

    @Override
    public MutableDoubleSet asSynchronized()
    {
<span class="nc" id="L459">        return new SynchronizedDoubleSet(this);</span>
    }

    @Override
    public ImmutableDoubleSet toImmutable()
    {
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (this.size() == 0)</span>
        {
<span class="nc" id="L467">            return DoubleSets.immutable.with();</span>
        }
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (this.size() == 1)</span>
        {
<span class="nc" id="L471">            return DoubleSets.immutable.with(this.doubleIterator().next());</span>
        }
<span class="nc" id="L473">        DoubleHashSet mutableSet = DoubleHashSet.newSetWith(this.toArray());</span>
<span class="nc" id="L474">        return new ImmutableDoubleHashSet(mutableSet.table, mutableSet.occupiedWithData, mutableSet.zeroToThirtyOne, mutableSet.zeroToThirtyOneOccupied);</span>
    }

    @Override
    public MutableDoubleIterator doubleIterator()
    {
<span class="nc" id="L480">        return new InternalDoubleIterator();</span>
    }

    @Override
    public double[] toArray()
    {
<span class="nc" id="L486">        double[] array = new double[this.size()];</span>

<span class="nc" id="L488">        int j = 0;</span>
<span class="nc" id="L489">        int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">        while (zeroToThirtyOne != 0)</span>
        {
<span class="nc" id="L492">            double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc" id="L493">            array[j] = value;</span>
<span class="nc" id="L494">            j++;</span>
<span class="nc" id="L495">            zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L496">        }</span>

<span class="nc bnc" id="L498" title="All 4 branches missed.">        for (int i = 0; i &lt; this.table.length &amp;&amp; j &lt; this.size(); i++)</span>
        {
<span class="nc bnc" id="L500" title="All 2 branches missed.">            if (isNonSentinel(this.table[i]))</span>
            {
<span class="nc" id="L502">                array[j] = this.table[i];</span>
<span class="nc" id="L503">                j++;</span>
            }
        }
<span class="nc" id="L506">        return array;</span>
    }

    @Override
    public boolean contains(double value)
    {
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (isBetweenZeroAndThirtyOne(value))</span>
        {
<span class="nc" id="L514">            int temp = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">            return ((temp &gt;&gt;&gt; (int) value) &amp; 1) != 0;</span>
        }
<span class="nc bnc" id="L517" title="All 2 branches missed.">        return Double.compare(this.table[this.probe(value)], value) == 0;</span>
    }

    @Override
    public void forEach(DoubleProcedure procedure)
    {
<span class="nc" id="L523">        this.each(procedure);</span>
<span class="nc" id="L524">    }</span>

    /**
     * @since 7.0.
     */
    @Override
    public void each(DoubleProcedure procedure)
    {
<span class="nc" id="L532">        int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">        while (zeroToThirtyOne != 0)</span>
        {
<span class="nc" id="L535">            double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc" id="L536">            procedure.value(value);</span>
<span class="nc" id="L537">            zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L538">        }</span>

<span class="nc bnc" id="L540" title="All 2 branches missed.">        for (double value : this.table)</span>
        {
<span class="nc bnc" id="L542" title="All 2 branches missed.">            if (isNonSentinel(value))</span>
            {
<span class="nc" id="L544">                procedure.value(value);</span>
            }
        }
<span class="nc" id="L547">    }</span>

    @Override
    public DoubleHashSet select(DoublePredicate predicate)
    {
<span class="nc" id="L552">        return this.select(predicate, new DoubleHashSet());</span>
    }

    /**
     * @since 8.1.
     */
    @Override
    public &lt;R extends MutableDoubleCollection&gt; R select(DoublePredicate predicate, R target)
    {
<span class="nc" id="L561">        int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">        while (zeroToThirtyOne != 0)</span>
        {
<span class="nc" id="L564">            double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">            if (predicate.accept(value))</span>
            {
<span class="nc" id="L567">                target.add(value);</span>
            }
<span class="nc" id="L569">            zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L570">        }</span>

<span class="nc bnc" id="L572" title="All 2 branches missed.">        for (double value : this.table)</span>
        {
<span class="nc bnc" id="L574" title="All 2 branches missed.">            if (isNonSentinel(value))</span>
            {
<span class="nc bnc" id="L576" title="All 2 branches missed.">                if (predicate.accept(value))</span>
                {
<span class="nc" id="L578">                    target.add(value);</span>
                }
            }
        }
<span class="nc" id="L582">        return target;</span>
    }

    @Override
    public DoubleHashSet reject(DoublePredicate predicate)
    {
<span class="nc" id="L588">        return this.reject(predicate, new DoubleHashSet());</span>
    }

    /**
     * @since 8.1.
     */
    @Override
    public &lt;R extends MutableDoubleCollection&gt; R reject(DoublePredicate predicate, R target)
    {
<span class="nc" id="L597">        int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">        while (zeroToThirtyOne != 0)</span>
        {
<span class="nc" id="L600">            double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">            if (!predicate.accept(value))</span>
            {
<span class="nc" id="L603">                target.add(value);</span>
            }
<span class="nc" id="L605">            zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L606">        }</span>

<span class="nc bnc" id="L608" title="All 2 branches missed.">        for (double value : this.table)</span>
        {
<span class="nc bnc" id="L610" title="All 2 branches missed.">            if (isNonSentinel(value))</span>
            {
<span class="nc bnc" id="L612" title="All 2 branches missed.">                if (!predicate.accept(value))</span>
                {
<span class="nc" id="L614">                    target.add(value);</span>
                }
            }
        }
<span class="nc" id="L618">        return target;</span>
    }

    @Override
    public &lt;V&gt; MutableSet&lt;V&gt; collect(DoubleToObjectFunction&lt;? extends V&gt; function)
    {
<span class="nc" id="L624">        return this.collect(function, UnifiedSet.newSet(this.size()));</span>
    }

    /**
     * @since 8.1.
     */
    @Override
    public &lt;V, R extends Collection&lt;V&gt;&gt; R collect(DoubleToObjectFunction&lt;? extends V&gt; function, R target)
    {
<span class="nc" id="L633">        int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">        while (zeroToThirtyOne != 0)</span>
        {
<span class="nc" id="L636">            double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc" id="L637">            target.add(function.valueOf(value));</span>
<span class="nc" id="L638">            zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L639">        }</span>

<span class="nc bnc" id="L641" title="All 2 branches missed.">        for (double value : this.table)</span>
        {
<span class="nc bnc" id="L643" title="All 2 branches missed.">            if (isNonSentinel(value))</span>
            {
<span class="nc" id="L645">                target.add(function.valueOf(value));</span>
            }
        }
<span class="nc" id="L648">        return target;</span>
    }

    @Override
    public double detectIfNone(DoublePredicate predicate, double ifNone)
    {
<span class="nc" id="L654">        int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">        while (zeroToThirtyOne != 0)</span>
        {
<span class="nc" id="L657">            double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">            if (predicate.accept(value))</span>
            {
<span class="nc" id="L660">                return value;</span>
            }
<span class="nc" id="L662">            zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L663">        }</span>

<span class="nc bnc" id="L665" title="All 2 branches missed.">        for (double value : this.table)</span>
        {
<span class="nc bnc" id="L667" title="All 2 branches missed.">            if (isNonSentinel(value))</span>
            {
<span class="nc bnc" id="L669" title="All 2 branches missed.">                if (predicate.accept(value))</span>
                {
<span class="nc" id="L671">                    return value;</span>
                }
            }
        }
<span class="nc" id="L675">        return ifNone;</span>
    }

    @Override
    public int count(DoublePredicate predicate)
    {
<span class="nc" id="L681">        int count = 0;</span>
<span class="nc" id="L682">        int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">        while (zeroToThirtyOne != 0)</span>
        {
<span class="nc" id="L685">            double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">            if (predicate.accept(value))</span>
            {
<span class="nc" id="L688">                count++;</span>
            }
<span class="nc" id="L690">            zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L691">        }</span>

<span class="nc bnc" id="L693" title="All 2 branches missed.">        for (double value : this.table)</span>
        {
<span class="nc bnc" id="L695" title="All 2 branches missed.">            if (isNonSentinel(value))</span>
            {
<span class="nc bnc" id="L697" title="All 2 branches missed.">                if (predicate.accept(value))</span>
                {
<span class="nc" id="L699">                    count++;</span>
                }
            }
        }
<span class="nc" id="L703">        return count;</span>
    }

    @Override
    public boolean anySatisfy(DoublePredicate predicate)
    {
<span class="nc" id="L709">        int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">        while (zeroToThirtyOne != 0)</span>
        {
<span class="nc" id="L712">            double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">            if (predicate.accept(value))</span>
            {
<span class="nc" id="L715">                return true;</span>
            }
<span class="nc" id="L717">            zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L718">        }</span>

<span class="nc bnc" id="L720" title="All 2 branches missed.">        for (double value : this.table)</span>
        {
<span class="nc bnc" id="L722" title="All 2 branches missed.">            if (isNonSentinel(value))</span>
            {
<span class="nc bnc" id="L724" title="All 2 branches missed.">                if (predicate.accept(value))</span>
                {
<span class="nc" id="L726">                    return true;</span>
                }
            }
        }
<span class="nc" id="L730">        return false;</span>
    }

    @Override
    public boolean allSatisfy(DoublePredicate predicate)
    {
<span class="nc" id="L736">        int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">        while (zeroToThirtyOne != 0)</span>
        {
<span class="nc" id="L739">            double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">            if (!predicate.accept(value))</span>
            {
<span class="nc" id="L742">                return false;</span>
            }
<span class="nc" id="L744">            zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L745">        }</span>

<span class="nc bnc" id="L747" title="All 2 branches missed.">        for (double value : this.table)</span>
        {
<span class="nc bnc" id="L749" title="All 2 branches missed.">            if (isNonSentinel(value))</span>
            {
<span class="nc bnc" id="L751" title="All 2 branches missed.">                if (!predicate.accept(value))</span>
                {
<span class="nc" id="L753">                    return false;</span>
                }
            }
        }
<span class="nc" id="L757">        return true;</span>
    }

    @Override
    public boolean noneSatisfy(DoublePredicate predicate)
    {
<span class="nc bnc" id="L763" title="All 2 branches missed.">        return !this.anySatisfy(predicate);</span>
    }

    @Override
    public double sum()
    {
<span class="nc" id="L769">        double result = 0.0;</span>
<span class="nc" id="L770">        double compensation = 0.0;</span>

<span class="nc" id="L772">        int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">        while (zeroToThirtyOne != 0)</span>
        {
<span class="nc" id="L775">            double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc" id="L776">            double adjustedValue = value - compensation;</span>
<span class="nc" id="L777">            double nextSum = result + adjustedValue;</span>
<span class="nc" id="L778">            compensation = nextSum - result - adjustedValue;</span>
<span class="nc" id="L779">            result = nextSum;</span>
<span class="nc" id="L780">            zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L781">        }</span>

<span class="nc bnc" id="L783" title="All 2 branches missed.">        for (double value : this.table)</span>
        {
<span class="nc bnc" id="L785" title="All 2 branches missed.">            if (isNonSentinel(value))</span>
            {
<span class="nc" id="L787">                double adjustedValue = value - compensation;</span>
<span class="nc" id="L788">                double nextSum = result + adjustedValue;</span>
<span class="nc" id="L789">                compensation = nextSum - result - adjustedValue;</span>
<span class="nc" id="L790">                result = nextSum;</span>
            }
        }
<span class="nc" id="L793">        return result;</span>
    }

    @Override
    public double max()
    {
<span class="nc bnc" id="L799" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L801">            throw new NoSuchElementException();</span>
        }
<span class="nc" id="L803">        double max = 31 - Integer.numberOfLeadingZeros(this.zeroToThirtyOne);</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">        boolean isMaxSet = this.zeroToThirtyOneOccupied != 0;</span>

<span class="nc bnc" id="L806" title="All 2 branches missed.">        for (double value : this.table)</span>
        {
<span class="nc bnc" id="L808" title="All 6 branches missed.">            if (isNonSentinel(value) &amp;&amp; (!isMaxSet || Double.compare(max, value) &lt; 0))</span>
            {
<span class="nc" id="L810">                max = value;</span>
<span class="nc" id="L811">                isMaxSet = true;</span>
            }
        }
<span class="nc" id="L814">        return max;</span>
    }

    @Override
    public double min()
    {
<span class="nc bnc" id="L820" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L822">            throw new NoSuchElementException();</span>
        }
<span class="nc" id="L824">        double min = (double) Integer.numberOfTrailingZeros(this.zeroToThirtyOne);</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">        boolean isMinSet = this.zeroToThirtyOneOccupied != 0;</span>

<span class="nc bnc" id="L827" title="All 2 branches missed.">        for (double value : this.table)</span>
        {
<span class="nc bnc" id="L829" title="All 6 branches missed.">            if (isNonSentinel(value) &amp;&amp; (!isMinSet || Double.compare(value, min) &lt; 0))</span>
            {
<span class="nc" id="L831">                min = value;</span>
<span class="nc" id="L832">                isMinSet = true;</span>
            }
        }
<span class="nc" id="L835">        return min;</span>
    }

    @Override
    public DoubleSet freeze()
    {
<span class="nc bnc" id="L841" title="All 2 branches missed.">        if (this.size() == 0)</span>
        {
<span class="nc" id="L843">            return DoubleSets.immutable.with();</span>
        }
<span class="nc bnc" id="L845" title="All 2 branches missed.">        if (this.size() == 1)</span>
        {
<span class="nc" id="L847">            return DoubleSets.immutable.with(this.doubleIterator().next());</span>
        }
<span class="nc" id="L849">        this.copyOnWrite = true;</span>
<span class="nc" id="L850">        return new ImmutableDoubleHashSet(this.table, this.occupiedWithData, this.zeroToThirtyOne, this.zeroToThirtyOneOccupied);</span>
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException
    {
<span class="nc" id="L856">        out.writeInt(this.size());</span>

<span class="nc" id="L858">        int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">        while (zeroToThirtyOne != 0)</span>
        {
<span class="nc" id="L861">            double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc" id="L862">            out.writeDouble(value);</span>
<span class="nc" id="L863">            zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L864">        }</span>

<span class="nc bnc" id="L866" title="All 2 branches missed.">        for (double value : this.table)</span>
        {
<span class="nc bnc" id="L868" title="All 2 branches missed.">            if (isNonSentinel(value))</span>
            {
<span class="nc" id="L870">                out.writeDouble(value);</span>
            }
        }
<span class="nc" id="L873">    }</span>

    @Override
    public void readExternal(ObjectInput in) throws IOException
    {
<span class="nc" id="L878">        int size = in.readInt();</span>

<span class="nc bnc" id="L880" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L882">            this.add(in.readDouble());</span>
        }
<span class="nc" id="L884">    }</span>

    @Override
    public &lt;T&gt; T injectInto(T injectedValue, ObjectDoubleToObjectFunction&lt;? super T, ? extends T&gt; function)
    {
<span class="nc" id="L889">        T result = injectedValue;</span>
<span class="nc" id="L890">        int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">        while (zeroToThirtyOne != 0)</span>
        {
<span class="nc" id="L893">            double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc" id="L894">            result = function.valueOf(result, value);</span>
<span class="nc" id="L895">            zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L896">        }</span>

<span class="nc bnc" id="L898" title="All 2 branches missed.">        for (double value : this.table)</span>
        {
<span class="nc bnc" id="L900" title="All 2 branches missed.">            if (isNonSentinel(value))</span>
            {
<span class="nc" id="L902">                result = function.valueOf(result, value);</span>
            }
        }
<span class="nc" id="L905">        return result;</span>
    }

    @Override
    public RichIterable&lt;DoubleIterable&gt; chunk(int size)
    {
<span class="nc bnc" id="L911" title="All 2 branches missed.">        if (size &lt;= 0)</span>
        {
<span class="nc" id="L913">            throw new IllegalArgumentException(&quot;Size for groups must be positive but was: &quot; + size);</span>
        }
<span class="nc" id="L915">        MutableList&lt;DoubleIterable&gt; result = Lists.mutable.empty();</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">        if (this.notEmpty())</span>
        {
<span class="nc bnc" id="L918" title="All 2 branches missed.">            if (this.size() &lt;= size)</span>
            {
<span class="nc" id="L920">                result.add(DoubleSets.mutable.withAll(this));</span>
            }
            else
            {
<span class="nc" id="L924">                DoubleIterator iterator = this.doubleIterator();</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">                while (iterator.hasNext())</span>
                {
<span class="nc" id="L927">                    MutableDoubleSet batch = DoubleSets.mutable.empty();</span>
<span class="nc bnc" id="L928" title="All 4 branches missed.">                    for (int i = 0; i &lt; size &amp;&amp; iterator.hasNext(); i++)</span>
                    {
<span class="nc" id="L930">                        batch.add(iterator.next());</span>
                    }
<span class="nc" id="L932">                    result.add(batch);</span>
<span class="nc" id="L933">                }</span>
            }
        }
<span class="nc" id="L936">        return result;</span>
    }

    /**
     * Creates a new empty DoubleHashSet.
     *
     * @since 9.2.
     */
    public DoubleHashSet newEmpty()
    {
<span class="nc" id="L946">        return new DoubleHashSet();</span>
    }

    /**
     * Rehashes every element in the set into a new backing table of the smallest possible size and eliminating removed sentinels.
     */
    public void compact()
    {
<span class="nc" id="L954">        this.rehash(this.smallestPowerOfTwoGreaterThan(this.size()));</span>
<span class="nc" id="L955">    }</span>

    private void rehash()
    {
<span class="nc" id="L959">        this.rehash(this.table.length);</span>
<span class="nc" id="L960">    }</span>

    private void rehashAndGrow()
    {
<span class="nc" id="L964">        this.rehash(this.table.length &lt;&lt; 1);</span>
<span class="nc" id="L965">    }</span>

    private void rehash(int newCapacity)
    {
<span class="nc" id="L969">        int oldLength = this.table.length;</span>
<span class="nc" id="L970">        double[] old = this.table;</span>
<span class="nc" id="L971">        this.allocateTable(newCapacity);</span>
<span class="nc" id="L972">        this.occupiedWithData = 0;</span>
<span class="nc" id="L973">        this.occupiedWithSentinels = 0;</span>

<span class="nc bnc" id="L975" title="All 2 branches missed.">        for (int i = 0; i &lt; oldLength; i++)</span>
        {
<span class="nc bnc" id="L977" title="All 2 branches missed.">            if (isNonSentinel(old[i]))</span>
            {
<span class="nc" id="L979">                this.add(old[i]);</span>
            }
        }
<span class="nc" id="L982">    }</span>

    private void allocateTable(int sizeToAllocate)
    {
<span class="nc" id="L986">        this.table = new double[sizeToAllocate];</span>
<span class="nc" id="L987">    }</span>

    // exposed for testing
    int probe(double element)
    {
<span class="nc" id="L992">        int index = this.spreadAndMask(element);</span>
<span class="nc" id="L993">        double valueAtIndex = this.table[index];</span>

<span class="nc bnc" id="L995" title="All 4 branches missed.">        if (Double.compare(valueAtIndex, element) == 0 || Double.compare(valueAtIndex, EMPTY) == 0)</span>
        {
<span class="nc" id="L997">            return index;</span>
        }

<span class="nc bnc" id="L1000" title="All 2 branches missed.">        int removedIndex = Double.compare(valueAtIndex, REMOVED) == 0 ? index : -1;</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">        for (int i = 1; i &lt; INITIAL_LINEAR_PROBE; i++)</span>
        {
<span class="nc" id="L1003">            int nextIndex = (index + i) &amp; (this.table.length - 1);</span>
<span class="nc" id="L1004">            valueAtIndex = this.table[nextIndex];</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">            if (Double.compare(valueAtIndex, element) == 0)</span>
            {
<span class="nc" id="L1007">                return nextIndex;</span>
            }
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            if (Double.compare(valueAtIndex, EMPTY) == 0)</span>
            {
<span class="nc bnc" id="L1011" title="All 2 branches missed.">                return removedIndex == -1 ? nextIndex : removedIndex;</span>
            }
<span class="nc bnc" id="L1013" title="All 4 branches missed.">            if (Double.compare(valueAtIndex, REMOVED) == 0 &amp;&amp; removedIndex == -1)</span>
            {
<span class="nc" id="L1015">                removedIndex = nextIndex;</span>
            }
        }
<span class="nc" id="L1018">        return this.probeTwo(element, removedIndex);</span>
    }

    int probeTwo(double element, int removedIndex)
    {
<span class="nc" id="L1023">        int index = this.spreadTwoAndMask(element);</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">        for (int i = 0; i &lt; INITIAL_LINEAR_PROBE; i++)</span>
        {
<span class="nc" id="L1026">            int nextIndex = (index + i) &amp; (this.table.length - 1);</span>
<span class="nc" id="L1027">            double valueAtIndex = this.table[nextIndex];</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">            if (Double.compare(valueAtIndex, element) == 0)</span>
            {
<span class="nc" id="L1030">                return nextIndex;</span>
            }
<span class="nc bnc" id="L1032" title="All 2 branches missed.">            if (Double.compare(valueAtIndex, EMPTY) == 0)</span>
            {
<span class="nc bnc" id="L1034" title="All 2 branches missed.">                return removedIndex == -1 ? nextIndex : removedIndex;</span>
            }
<span class="nc bnc" id="L1036" title="All 4 branches missed.">            if (Double.compare(valueAtIndex, REMOVED) == 0 &amp;&amp; removedIndex == -1)</span>
            {
<span class="nc" id="L1038">                removedIndex = nextIndex;</span>
            }
        }
<span class="nc" id="L1041">        return this.probeThree(element, removedIndex);</span>
    }

    int probeThree(double element, int removedIndex)
    {
<span class="nc" id="L1046">        int nextIndex = (int) Long.reverse(SpreadFunctions.doubleSpreadOne(element));</span>
<span class="nc" id="L1047">        int spreadTwo = (int) Long.reverse(SpreadFunctions.doubleSpreadTwo(element)) | 1;</span>

        while (true)
        {
<span class="nc" id="L1051">            nextIndex = this.mask(nextIndex + spreadTwo);</span>
<span class="nc" id="L1052">            double valueAtIndex = this.table[nextIndex];</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">            if (Double.compare(valueAtIndex, element) == 0)</span>
            {
<span class="nc" id="L1055">                return nextIndex;</span>
            }
<span class="nc bnc" id="L1057" title="All 2 branches missed.">            if (Double.compare(valueAtIndex, EMPTY) == 0)</span>
            {
<span class="nc bnc" id="L1059" title="All 2 branches missed.">                return removedIndex == -1 ? nextIndex : removedIndex;</span>
            }
<span class="nc bnc" id="L1061" title="All 4 branches missed.">            if (Double.compare(valueAtIndex, REMOVED) == 0 &amp;&amp; removedIndex == -1)</span>
            {
<span class="nc" id="L1063">                removedIndex = nextIndex;</span>
            }
<span class="nc" id="L1065">        }</span>
    }

    // exposed for testing
    int spreadAndMask(double element)
    {
<span class="nc" id="L1071">        long code = SpreadFunctions.doubleSpreadOne(element);</span>
<span class="nc" id="L1072">        return this.mask((int) code);</span>
    }

    int spreadTwoAndMask(double element)
    {
<span class="nc" id="L1077">        long code = SpreadFunctions.doubleSpreadTwo(element);</span>
<span class="nc" id="L1078">        return this.mask((int) code);</span>
    }

    private int mask(int spread)
    {
<span class="nc" id="L1083">        return spread &amp; (this.table.length - 1);</span>
    }

    private void copyTable()
    {
<span class="nc" id="L1088">        this.copyOnWrite = false;</span>
<span class="nc" id="L1089">        double[] copy = new double[this.table.length];</span>
<span class="nc" id="L1090">        System.arraycopy(this.table, 0, copy, 0, this.table.length);</span>
<span class="nc" id="L1091">        this.table = copy;</span>
<span class="nc" id="L1092">    }</span>

    private int maxOccupiedWithData()
    {
<span class="nc" id="L1096">        int capacity = this.table.length;</span>
        // need at least one free slot for open addressing
<span class="nc" id="L1098">        return Math.min(capacity - 1, capacity / OCCUPIED_DATA_RATIO);</span>
    }

    private int maxOccupiedWithSentinels()
    {
<span class="nc" id="L1103">        return this.table.length / OCCUPIED_SENTINEL_RATIO;</span>
    }

    private static boolean isNonSentinel(double value)
    {
<span class="nc bnc" id="L1108" title="All 4 branches missed.">        return Double.compare(value, EMPTY) != 0 &amp;&amp; Double.compare(value, REMOVED) != 0;</span>
    }

    private static final class ImmutableDoubleHashSet extends AbstractImmutableDoubleSet implements Serializable
    {
        private static final long serialVersionUID = 1L;
        private final double[] table;
        private final int occupied;
        // The 32 bits of this integer indicate whether the items 0.0 to 31.0 are present in the set.
        private final int zeroToThirtyOne;
        private final int zeroToThirtyOneOccupied;

        private ImmutableDoubleHashSet(double[] table, int occupied, int zeroToThirtyOne, int zeroToThirtyOneOccupied)
<span class="nc" id="L1121">        {</span>
<span class="nc" id="L1122">            this.checkOptimizedSize(occupied + zeroToThirtyOneOccupied);</span>
<span class="nc" id="L1123">            this.occupied = occupied;</span>
<span class="nc" id="L1124">            this.zeroToThirtyOneOccupied = zeroToThirtyOneOccupied;</span>
<span class="nc" id="L1125">            this.zeroToThirtyOne = zeroToThirtyOne;</span>
<span class="nc" id="L1126">            this.table = table;</span>
<span class="nc" id="L1127">        }</span>

        private void checkOptimizedSize(int length)
        {
<span class="nc bnc" id="L1131" title="All 2 branches missed.">            if (length &lt;= 1)</span>
            {
<span class="nc" id="L1133">                throw new IllegalArgumentException(&quot;Use DoubleSets.immutable.with() to instantiate an optimized collection&quot;);</span>
            }
<span class="nc" id="L1135">        }</span>

        public static ImmutableDoubleSet newSetWith(double... elements)
        {
<span class="nc" id="L1139">            return DoubleHashSet.newSetWith(elements).toImmutable();</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L1145">            int result = 0;</span>
<span class="nc" id="L1146">            int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">            while (zeroToThirtyOne != 0)</span>
            {
<span class="nc" id="L1149">                double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc" id="L1150">                result += (int) (Double.doubleToLongBits(value) ^ Double.doubleToLongBits(value) &gt;&gt;&gt; 32);</span>
<span class="nc" id="L1151">                zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L1152">            }</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">            if (this.table != null)</span>
            {
<span class="nc bnc" id="L1155" title="All 2 branches missed.">                for (int i = 0; i &lt; this.table.length; i++)</span>
                {
<span class="nc bnc" id="L1157" title="All 2 branches missed.">                    if (isNonSentinel(this.table[i]))</span>
                    {
<span class="nc" id="L1159">                        result += (int) (Double.doubleToLongBits(this.table[i]) ^ Double.doubleToLongBits(this.table[i]) &gt;&gt;&gt; 32);</span>
                    }
                }
            }
<span class="nc" id="L1163">            return result;</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L1169">            return this.occupied + this.zeroToThirtyOneOccupied;</span>
        }

        @Override
        public void appendString(Appendable appendable, String start, String separator, String end)
        {
            try
            {
<span class="nc" id="L1177">                appendable.append(start);</span>

<span class="nc" id="L1179">                int count = 0;</span>
<span class="nc" id="L1180">                int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L1181" title="All 2 branches missed.">                while (zeroToThirtyOne != 0)</span>
                {
<span class="nc" id="L1183">                    double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">                    if (count &gt; 0)</span>
                    {
<span class="nc" id="L1186">                        appendable.append(separator);</span>
                    }
<span class="nc" id="L1188">                    count++;</span>
<span class="nc" id="L1189">                    appendable.append(String.valueOf(value));</span>
<span class="nc" id="L1190">                    zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L1191">                }</span>

<span class="nc bnc" id="L1193" title="All 2 branches missed.">                for (double value : this.table)</span>
                {
<span class="nc bnc" id="L1195" title="All 2 branches missed.">                    if (isNonSentinel(value))</span>
                    {
<span class="nc bnc" id="L1197" title="All 2 branches missed.">                        if (count &gt; 0)</span>
                        {
<span class="nc" id="L1199">                            appendable.append(separator);</span>
                        }
<span class="nc" id="L1201">                        count++;</span>
<span class="nc" id="L1202">                        appendable.append(String.valueOf(value));</span>
                    }
                }
<span class="nc" id="L1205">                appendable.append(end);</span>
            }
<span class="nc" id="L1207">            catch (IOException e)</span>
            {
<span class="nc" id="L1209">                throw new RuntimeException(e);</span>
<span class="nc" id="L1210">            }</span>
<span class="nc" id="L1211">        }</span>

        @Override
        public DoubleIterator doubleIterator()
        {
<span class="nc" id="L1216">            return new InternalDoubleIterator();</span>
        }

        @Override
        public double[] toArray()
        {
<span class="nc" id="L1222">            double[] array = new double[this.size()];</span>

<span class="nc" id="L1224">            int j = 0;</span>
<span class="nc" id="L1225">            int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">            while (zeroToThirtyOne != 0)</span>
            {
<span class="nc" id="L1228">                double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc" id="L1229">                array[j] = value;</span>
<span class="nc" id="L1230">                j++;</span>
<span class="nc" id="L1231">                zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L1232">            }</span>

<span class="nc bnc" id="L1234" title="All 4 branches missed.">            for (int i = 0; i &lt; this.table.length &amp;&amp; j &lt; this.size(); i++)</span>
            {
<span class="nc bnc" id="L1236" title="All 2 branches missed.">                if (isNonSentinel(this.table[i]))</span>
                {
<span class="nc" id="L1238">                    array[j] = this.table[i];</span>
<span class="nc" id="L1239">                    j++;</span>
                }
            }
<span class="nc" id="L1242">            return array;</span>
        }

        @Override
        public boolean contains(double value)
        {
<span class="nc bnc" id="L1248" title="All 2 branches missed.">            if (isBetweenZeroAndThirtyOne(value))</span>
            {
<span class="nc" id="L1250">                int temp = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L1251" title="All 2 branches missed.">                return ((temp &gt;&gt;&gt; (int) value) &amp; 1) != 0;</span>
            }
<span class="nc bnc" id="L1253" title="All 2 branches missed.">            return Double.compare(this.table[this.probe(value)], value) == 0;</span>
        }

        @Override
        public void forEach(DoubleProcedure procedure)
        {
<span class="nc" id="L1259">            this.each(procedure);</span>
<span class="nc" id="L1260">        }</span>

        @Override
        public void each(DoubleProcedure procedure)
        {
<span class="nc" id="L1265">            int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">            while (zeroToThirtyOne != 0)</span>
            {
<span class="nc" id="L1268">                double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc" id="L1269">                procedure.value(value);</span>
<span class="nc" id="L1270">                zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L1271">            }</span>

<span class="nc bnc" id="L1273" title="All 2 branches missed.">            for (double value : this.table)</span>
            {
<span class="nc bnc" id="L1275" title="All 2 branches missed.">                if (isNonSentinel(value))</span>
                {
<span class="nc" id="L1277">                    procedure.value(value);</span>
                }
            }
<span class="nc" id="L1280">        }</span>

        @Override
        public ImmutableDoubleSet select(DoublePredicate predicate)
        {
<span class="nc" id="L1285">            return this.select(predicate, new DoubleHashSet()).toImmutable();</span>
        }

        @Override
        public ImmutableDoubleSet reject(DoublePredicate predicate)
        {
<span class="nc" id="L1291">            return this.reject(predicate, new DoubleHashSet()).toImmutable();</span>
        }

        @Override
        public &lt;V&gt; ImmutableSet&lt;V&gt; collect(DoubleToObjectFunction&lt;? extends V&gt; function)
        {
<span class="nc" id="L1297">            MutableSet&lt;V&gt; set = this.collect(function, UnifiedSet.newSet(this.size()));</span>
<span class="nc" id="L1298">            return set.toImmutable();</span>
        }

        @Override
        public double detectIfNone(DoublePredicate predicate, double ifNone)
        {
<span class="nc" id="L1304">            int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">            while (zeroToThirtyOne != 0)</span>
            {
<span class="nc" id="L1307">                double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">                if (predicate.accept(value))</span>
                {
<span class="nc" id="L1310">                    return value;</span>
                }
<span class="nc" id="L1312">                zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L1313">            }</span>

<span class="nc bnc" id="L1315" title="All 2 branches missed.">            for (double value : this.table)</span>
            {
<span class="nc bnc" id="L1317" title="All 2 branches missed.">                if (isNonSentinel(value))</span>
                {
<span class="nc bnc" id="L1319" title="All 2 branches missed.">                    if (predicate.accept(value))</span>
                    {
<span class="nc" id="L1321">                        return value;</span>
                    }
                }
            }
<span class="nc" id="L1325">            return ifNone;</span>
        }

        @Override
        public int count(DoublePredicate predicate)
        {
<span class="nc" id="L1331">            int count = 0;</span>
<span class="nc" id="L1332">            int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">            while (zeroToThirtyOne != 0)</span>
            {
<span class="nc" id="L1335">                double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">                if (predicate.accept(value))</span>
                {
<span class="nc" id="L1338">                    count++;</span>
                }
<span class="nc" id="L1340">                zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L1341">            }</span>

<span class="nc bnc" id="L1343" title="All 2 branches missed.">            for (double value : this.table)</span>
            {
<span class="nc bnc" id="L1345" title="All 2 branches missed.">                if (isNonSentinel(value))</span>
                {
<span class="nc bnc" id="L1347" title="All 2 branches missed.">                    if (predicate.accept(value))</span>
                    {
<span class="nc" id="L1349">                        count++;</span>
                    }
                }
            }
<span class="nc" id="L1353">            return count;</span>
        }

        @Override
        public boolean anySatisfy(DoublePredicate predicate)
        {
<span class="nc" id="L1359">            int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">            while (zeroToThirtyOne != 0)</span>
            {
<span class="nc" id="L1362">                double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">                if (predicate.accept(value))</span>
                {
<span class="nc" id="L1365">                    return true;</span>
                }
<span class="nc" id="L1367">                zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L1368">            }</span>

<span class="nc bnc" id="L1370" title="All 2 branches missed.">            for (double value : this.table)</span>
            {
<span class="nc bnc" id="L1372" title="All 2 branches missed.">                if (isNonSentinel(value))</span>
                {
<span class="nc bnc" id="L1374" title="All 2 branches missed.">                    if (predicate.accept(value))</span>
                    {
<span class="nc" id="L1376">                        return true;</span>
                    }
                }
            }
<span class="nc" id="L1380">            return false;</span>
        }

        @Override
        public boolean allSatisfy(DoublePredicate predicate)
        {
<span class="nc" id="L1386">            int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">            while (zeroToThirtyOne != 0)</span>
            {
<span class="nc" id="L1389">                double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc bnc" id="L1390" title="All 2 branches missed.">                if (!predicate.accept(value))</span>
                {
<span class="nc" id="L1392">                    return false;</span>
                }
<span class="nc" id="L1394">                zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L1395">            }</span>

<span class="nc bnc" id="L1397" title="All 2 branches missed.">            for (double value : this.table)</span>
            {
<span class="nc bnc" id="L1399" title="All 2 branches missed.">                if (isNonSentinel(value))</span>
                {
<span class="nc bnc" id="L1401" title="All 2 branches missed.">                    if (!predicate.accept(value))</span>
                    {
<span class="nc" id="L1403">                        return false;</span>
                    }
                }
            }
<span class="nc" id="L1407">            return true;</span>
        }

        @Override
        public boolean noneSatisfy(DoublePredicate predicate)
        {
<span class="nc bnc" id="L1413" title="All 2 branches missed.">            return !this.anySatisfy(predicate);</span>
        }

        @Override
        public double sum()
        {
<span class="nc" id="L1419">            double result = 0.0;</span>
<span class="nc" id="L1420">            double compensation = 0.0;</span>

<span class="nc" id="L1422">            int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L1423" title="All 2 branches missed.">            while (zeroToThirtyOne != 0)</span>
            {
<span class="nc" id="L1425">                double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc" id="L1426">                double adjustedValue = value - compensation;</span>
<span class="nc" id="L1427">                double nextSum = result + adjustedValue;</span>
<span class="nc" id="L1428">                compensation = nextSum - result - adjustedValue;</span>
<span class="nc" id="L1429">                result = nextSum;</span>
<span class="nc" id="L1430">                zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L1431">            }</span>

<span class="nc bnc" id="L1433" title="All 2 branches missed.">            for (double value : this.table)</span>
            {
<span class="nc bnc" id="L1435" title="All 2 branches missed.">                if (isNonSentinel(value))</span>
                {
<span class="nc" id="L1437">                    double adjustedValue = value - compensation;</span>
<span class="nc" id="L1438">                    double nextSum = result + adjustedValue;</span>
<span class="nc" id="L1439">                    compensation = nextSum - result - adjustedValue;</span>
<span class="nc" id="L1440">                    result = nextSum;</span>
                }
            }
<span class="nc" id="L1443">            return result;</span>
        }

        @Override
        public double max()
        {
<span class="nc bnc" id="L1449" title="All 2 branches missed.">            if (this.isEmpty())</span>
            {
<span class="nc" id="L1451">                throw new NoSuchElementException();</span>
            }
<span class="nc" id="L1453">            double max = 31 - Integer.numberOfLeadingZeros(this.zeroToThirtyOne);</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">            boolean isMaxSet = this.zeroToThirtyOneOccupied != 0;</span>

<span class="nc bnc" id="L1456" title="All 2 branches missed.">            for (double value : this.table)</span>
            {
<span class="nc bnc" id="L1458" title="All 6 branches missed.">                if (isNonSentinel(value) &amp;&amp; (!isMaxSet || Double.compare(max, value) &lt; 0))</span>
                {
<span class="nc" id="L1460">                    max = value;</span>
<span class="nc" id="L1461">                    isMaxSet = true;</span>
                }
            }
<span class="nc" id="L1464">            return max;</span>
        }

        @Override
        public double min()
        {
<span class="nc bnc" id="L1470" title="All 2 branches missed.">            if (this.isEmpty())</span>
            {
<span class="nc" id="L1472">                throw new NoSuchElementException();</span>
            }
<span class="nc" id="L1474">            double min = (double) Integer.numberOfTrailingZeros(this.zeroToThirtyOne);</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">            boolean isMinSet = this.zeroToThirtyOneOccupied != 0;</span>

<span class="nc bnc" id="L1477" title="All 2 branches missed.">            for (double value : this.table)</span>
            {
<span class="nc bnc" id="L1479" title="All 6 branches missed.">                if (isNonSentinel(value) &amp;&amp; (!isMinSet || Double.compare(value, min) &lt; 0))</span>
                {
<span class="nc" id="L1481">                    min = value;</span>
<span class="nc" id="L1482">                    isMinSet = true;</span>
                }
            }
<span class="nc" id="L1485">            return min;</span>
        }

        @Override
        public &lt;T&gt; T injectInto(T injectedValue, ObjectDoubleToObjectFunction&lt;? super T, ? extends T&gt; function)
        {
<span class="nc" id="L1491">            T result = injectedValue;</span>
<span class="nc" id="L1492">            int zeroToThirtyOne = this.zeroToThirtyOne;</span>
<span class="nc bnc" id="L1493" title="All 2 branches missed.">            while (zeroToThirtyOne != 0)</span>
            {
<span class="nc" id="L1495">                double value = (double) Integer.numberOfTrailingZeros(zeroToThirtyOne);</span>
<span class="nc" id="L1496">                result = function.valueOf(result, value);</span>
<span class="nc" id="L1497">                zeroToThirtyOne &amp;= ~(1 &lt;&lt; (int) value);</span>
<span class="nc" id="L1498">            }</span>

<span class="nc bnc" id="L1500" title="All 2 branches missed.">            for (double value : this.table)</span>
            {
<span class="nc bnc" id="L1502" title="All 2 branches missed.">                if (isNonSentinel(value))</span>
                {
<span class="nc" id="L1504">                    result = function.valueOf(result, value);</span>
                }
            }
<span class="nc" id="L1507">            return result;</span>
        }

        private Object writeReplace()
        {
<span class="nc" id="L1512">            return new ImmutableDoubleSetSerializationProxy(this);</span>
        }

        // exposed for testing
        int probe(double element)
        {
<span class="nc" id="L1518">            int index = this.spreadAndMask(element);</span>
<span class="nc" id="L1519">            double valueAtIndex = this.table[index];</span>

<span class="nc bnc" id="L1521" title="All 4 branches missed.">            if (Double.compare(valueAtIndex, element) == 0 || Double.compare(valueAtIndex, EMPTY) == 0)</span>
            {
<span class="nc" id="L1523">                return index;</span>
            }

<span class="nc bnc" id="L1526" title="All 2 branches missed.">            int removedIndex = Double.compare(valueAtIndex, REMOVED) == 0 ? index : -1;</span>
<span class="nc bnc" id="L1527" title="All 2 branches missed.">            for (int i = 1; i &lt; INITIAL_LINEAR_PROBE; i++)</span>
            {
<span class="nc" id="L1529">                int nextIndex = (index + i) &amp; (this.table.length - 1);</span>
<span class="nc" id="L1530">                valueAtIndex = this.table[nextIndex];</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">                if (Double.compare(valueAtIndex, element) == 0)</span>
                {
<span class="nc" id="L1533">                    return nextIndex;</span>
                }
<span class="nc bnc" id="L1535" title="All 2 branches missed.">                if (Double.compare(valueAtIndex, EMPTY) == 0)</span>
                {
<span class="nc bnc" id="L1537" title="All 2 branches missed.">                    return removedIndex == -1 ? nextIndex : removedIndex;</span>
                }
<span class="nc bnc" id="L1539" title="All 4 branches missed.">                if (Double.compare(valueAtIndex, REMOVED) == 0 &amp;&amp; removedIndex == -1)</span>
                {
<span class="nc" id="L1541">                    removedIndex = nextIndex;</span>
                }
            }
<span class="nc" id="L1544">            return this.probeTwo(element, removedIndex);</span>
        }

        int probeTwo(double element, int removedIndex)
        {
<span class="nc" id="L1549">            int index = this.spreadTwoAndMask(element);</span>
<span class="nc bnc" id="L1550" title="All 2 branches missed.">            for (int i = 0; i &lt; INITIAL_LINEAR_PROBE; i++)</span>
            {
<span class="nc" id="L1552">                int nextIndex = (index + i) &amp; (this.table.length - 1);</span>
<span class="nc" id="L1553">                double valueAtIndex = this.table[nextIndex];</span>
<span class="nc bnc" id="L1554" title="All 2 branches missed.">                if (Double.compare(valueAtIndex, element) == 0)</span>
                {
<span class="nc" id="L1556">                    return nextIndex;</span>
                }
<span class="nc bnc" id="L1558" title="All 2 branches missed.">                if (Double.compare(valueAtIndex, EMPTY) == 0)</span>
                {
<span class="nc bnc" id="L1560" title="All 2 branches missed.">                    return removedIndex == -1 ? nextIndex : removedIndex;</span>
                }
<span class="nc bnc" id="L1562" title="All 4 branches missed.">                if (Double.compare(valueAtIndex, REMOVED) == 0 &amp;&amp; removedIndex == -1)</span>
                {
<span class="nc" id="L1564">                    removedIndex = nextIndex;</span>
                }
            }
<span class="nc" id="L1567">            return this.probeThree(element, removedIndex);</span>
        }

        int probeThree(double element, int removedIndex)
        {
<span class="nc" id="L1572">            int nextIndex = (int) Long.reverse(SpreadFunctions.doubleSpreadOne(element));</span>
<span class="nc" id="L1573">            int spreadTwo = (int) Long.reverse(SpreadFunctions.doubleSpreadTwo(element)) | 1;</span>

            while (true)
            {
<span class="nc" id="L1577">                nextIndex = this.mask(nextIndex + spreadTwo);</span>
<span class="nc" id="L1578">                double valueAtIndex = this.table[nextIndex];</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">                if (Double.compare(valueAtIndex, element) == 0)</span>
                {
<span class="nc" id="L1581">                    return nextIndex;</span>
                }
<span class="nc bnc" id="L1583" title="All 2 branches missed.">                if (Double.compare(valueAtIndex, EMPTY) == 0)</span>
                {
<span class="nc bnc" id="L1585" title="All 2 branches missed.">                    return removedIndex == -1 ? nextIndex : removedIndex;</span>
                }
<span class="nc bnc" id="L1587" title="All 4 branches missed.">                if (Double.compare(valueAtIndex, REMOVED) == 0 &amp;&amp; removedIndex == -1)</span>
                {
<span class="nc" id="L1589">                    removedIndex = nextIndex;</span>
                }
<span class="nc" id="L1591">            }</span>
        }

        // exposed for testing
        int spreadAndMask(double element)
        {
<span class="nc" id="L1597">            long code = SpreadFunctions.doubleSpreadOne(element);</span>
<span class="nc" id="L1598">            return this.mask((int) code);</span>
        }

        int spreadTwoAndMask(double element)
        {
<span class="nc" id="L1603">            long code = SpreadFunctions.doubleSpreadTwo(element);</span>
<span class="nc" id="L1604">            return this.mask((int) code);</span>
        }

        private int mask(int spread)
        {
<span class="nc" id="L1609">            return spread &amp; (this.table.length - 1);</span>
        }

<span class="nc" id="L1612">        private class InternalDoubleIterator implements DoubleIterator</span>
        {
            private int count;
            private int position;
            private double zeroToThirtyOne;

            public boolean hasNext()
            {
<span class="nc bnc" id="L1620" title="All 2 branches missed.">                return this.count &lt; ImmutableDoubleHashSet.this.size();</span>
            }

            public double next()
            {
<span class="nc bnc" id="L1625" title="All 2 branches missed.">                if (!this.hasNext())</span>
                {
<span class="nc" id="L1627">                    throw new NoSuchElementException(&quot;next() called, but the iterator is exhausted&quot;);</span>
                }
<span class="nc" id="L1629">                this.count++;</span>

<span class="nc bnc" id="L1631" title="All 2 branches missed.">                while (this.zeroToThirtyOne &lt; 32)</span>
                {
<span class="nc bnc" id="L1633" title="All 2 branches missed.">                    if (ImmutableDoubleHashSet.this.contains(this.zeroToThirtyOne))</span>
                    {
<span class="nc" id="L1635">                        double result = this.zeroToThirtyOne;</span>
<span class="nc" id="L1636">                        this.zeroToThirtyOne++;</span>
<span class="nc" id="L1637">                        return result;</span>
                    }
<span class="nc" id="L1639">                    this.zeroToThirtyOne++;</span>
                }

<span class="nc" id="L1642">                double[] table = ImmutableDoubleHashSet.this.table;</span>
<span class="nc bnc" id="L1643" title="All 2 branches missed.">                while (!isNonSentinel(table[this.position]))</span>
                {
<span class="nc" id="L1645">                    this.position++;</span>
                }
<span class="nc" id="L1647">                double result = table[this.position];</span>
<span class="nc" id="L1648">                this.position++;</span>
<span class="nc" id="L1649">                return result;</span>
            }
        }
    }

<span class="nc" id="L1654">    private class InternalDoubleIterator implements MutableDoubleIterator</span>
    {
        private int count;
        private int position;
        private double zeroToThirtyOne;

        @Override
        public boolean hasNext()
        {
<span class="nc bnc" id="L1663" title="All 2 branches missed.">            return this.count &lt; DoubleHashSet.this.size();</span>
        }

        @Override
        public double next()
        {
<span class="nc bnc" id="L1669" title="All 2 branches missed.">            if (!this.hasNext())</span>
            {
<span class="nc" id="L1671">                throw new NoSuchElementException(&quot;next() called, but the iterator is exhausted&quot;);</span>
            }
<span class="nc" id="L1673">            this.count++;</span>

<span class="nc bnc" id="L1675" title="All 2 branches missed.">            while (this.zeroToThirtyOne &lt; 32)</span>
            {
<span class="nc bnc" id="L1677" title="All 2 branches missed.">                if (DoubleHashSet.this.contains(this.zeroToThirtyOne))</span>
                {
<span class="nc" id="L1679">                    double result = this.zeroToThirtyOne;</span>
<span class="nc" id="L1680">                    this.zeroToThirtyOne++;</span>
<span class="nc" id="L1681">                    return result;</span>
                }
<span class="nc" id="L1683">                this.zeroToThirtyOne++;</span>
            }

<span class="nc" id="L1686">            double[] table = DoubleHashSet.this.table;</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">            while (!isNonSentinel(table[this.position]))</span>
            {
<span class="nc" id="L1689">                this.position++;</span>
            }
<span class="nc" id="L1691">            double result = table[this.position];</span>
<span class="nc" id="L1692">            this.position++;</span>
<span class="nc" id="L1693">            return result;</span>
        }

        @Override
        public void remove()
        {
<span class="nc bnc" id="L1699" title="All 2 branches missed.">            if (this.count == 0)</span>
            {
<span class="nc" id="L1701">                throw new IllegalStateException();</span>
            }
            double removeValue;
<span class="nc bnc" id="L1704" title="All 4 branches missed.">            if (this.zeroToThirtyOne &lt;= 32.0 &amp;&amp; this.position == 0)</span>
            {
<span class="nc bnc" id="L1706" title="All 2 branches missed.">                if (DoubleHashSet.this.zeroToThirtyOne != (DoubleHashSet.this.zeroToThirtyOne | 1 &lt;&lt; ((int) this.zeroToThirtyOne - 1)))</span>
                {
<span class="nc" id="L1708">                    throw new IllegalStateException();</span>
                }
<span class="nc" id="L1710">                removeValue = this.zeroToThirtyOne - 1;</span>
            }
<span class="nc bnc" id="L1712" title="All 2 branches missed.">            else if (Double.compare(DoubleHashSet.this.table[this.position - 1], REMOVED) == 0)</span>
            {
<span class="nc" id="L1714">                throw new IllegalStateException();</span>
            }
            else
            {
<span class="nc" id="L1718">                removeValue = DoubleHashSet.this.table[this.position - 1];</span>
            }
<span class="nc bnc" id="L1720" title="All 2 branches missed.">            if (DoubleHashSet.isBetweenZeroAndThirtyOne(removeValue))</span>
            {
<span class="nc" id="L1722">                DoubleHashSet.this.removeZeroToThirtyOne(removeValue);</span>
            }
<span class="nc bnc" id="L1724" title="All 2 branches missed.">            else if (Double.compare(DoubleHashSet.this.table[this.position - 1], removeValue) == 0)</span>
            {
<span class="nc bnc" id="L1726" title="All 2 branches missed.">                if (DoubleHashSet.this.copyOnWrite)</span>
                {
<span class="nc" id="L1728">                    DoubleHashSet.this.copyTable();</span>
                }
<span class="nc" id="L1730">                DoubleHashSet.this.table[position - 1] = REMOVED;</span>
<span class="nc" id="L1731">                DoubleHashSet.this.occupiedWithData--;</span>
<span class="nc" id="L1732">                DoubleHashSet.this.occupiedWithSentinels++;</span>
            }

<span class="nc" id="L1735">            this.count--;</span>
<span class="nc" id="L1736">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>