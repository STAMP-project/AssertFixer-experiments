<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ByteHashSet.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.impl.set.mutable.primitive</a> &gt; <span class="el_source">ByteHashSet.java</span></div><h1>ByteHashSet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2018 Goldman Sachs and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.impl.set.mutable.primitive;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.Serializable;
import java.util.Arrays;
import java.util.NoSuchElementException;

import org.eclipse.collections.api.ByteIterable;
import org.eclipse.collections.api.LazyByteIterable;
import org.eclipse.collections.api.RichIterable;
import org.eclipse.collections.api.bag.primitive.MutableByteBag;
import org.eclipse.collections.api.block.function.primitive.ByteToObjectFunction;
import org.eclipse.collections.api.block.function.primitive.ObjectByteToObjectFunction;
import org.eclipse.collections.api.block.predicate.primitive.BytePredicate;
import org.eclipse.collections.api.block.procedure.primitive.ByteProcedure;
import org.eclipse.collections.api.iterator.ByteIterator;
import org.eclipse.collections.api.iterator.MutableByteIterator;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.api.list.primitive.MutableByteList;
import org.eclipse.collections.api.set.ImmutableSet;
import org.eclipse.collections.api.set.MutableSet;
import org.eclipse.collections.api.set.primitive.ByteSet;
import org.eclipse.collections.api.set.primitive.ImmutableByteSet;
import org.eclipse.collections.api.set.primitive.MutableByteSet;
import org.eclipse.collections.impl.bag.mutable.primitive.ByteHashBag;
import org.eclipse.collections.impl.block.procedure.checked.primitive.CheckedByteProcedure;
import org.eclipse.collections.impl.factory.Lists;
import org.eclipse.collections.impl.factory.primitive.ByteSets;
import org.eclipse.collections.impl.lazy.primitive.LazyByteIterableAdapter;
import org.eclipse.collections.impl.list.mutable.primitive.ByteArrayList;
import org.eclipse.collections.impl.set.immutable.primitive.ImmutableByteSetSerializationProxy;
import org.eclipse.collections.impl.set.mutable.UnifiedSet;

public final class ByteHashSet implements MutableByteSet, Externalizable
{
    private static final long serialVersionUID = 1L;
    private static final byte MAX_BYTE_GROUP_1 = -65;
    private static final byte MAX_BYTE_GROUP_2 = -1;
    private static final byte MAX_BYTE_GROUP_3 = 63;
    private long bitGroup1; // -128 to -65
    private long bitGroup2; //-64 to -1
    private long bitGroup3; //0 to 63
    private long bitGroup4; // 64 to 127
    private short size;

    public ByteHashSet()
<span class="nc" id="L60">    {</span>
<span class="nc" id="L61">    }</span>

    /**
     * Use {@link ByteHashSet#ByteHashSet()} instead.
     *
     * @deprecated since 5.0.
     */
    @Deprecated
    public ByteHashSet(int initialCapacity)
<span class="nc" id="L70">    {</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">        if (initialCapacity &lt; 0)</span>
        {
<span class="nc" id="L73">            throw new IllegalArgumentException(&quot;initial capacity cannot be less than 0&quot;);</span>
        }
<span class="nc" id="L75">    }</span>

    public ByteHashSet(ByteHashSet set)
<span class="nc" id="L78">    {</span>
<span class="nc" id="L79">        this.size = set.size;</span>
<span class="nc" id="L80">        this.bitGroup3 = set.bitGroup3;</span>
<span class="nc" id="L81">        this.bitGroup4 = set.bitGroup4;</span>
<span class="nc" id="L82">        this.bitGroup1 = set.bitGroup1;</span>
<span class="nc" id="L83">        this.bitGroup2 = set.bitGroup2;</span>
<span class="nc" id="L84">    }</span>

    public ByteHashSet(byte... elements)
    {
<span class="nc" id="L88">        this();</span>
<span class="nc" id="L89">        this.addAll(elements);</span>
<span class="nc" id="L90">    }</span>

    public static ByteHashSet newSet(ByteIterable source)
    {
<span class="nc bnc" id="L94" title="All 2 branches missed.">        if (source instanceof ByteHashSet)</span>
        {
<span class="nc" id="L96">            return new ByteHashSet((ByteHashSet) source);</span>
        }

<span class="nc" id="L99">        return ByteHashSet.newSetWith(source.toArray());</span>
    }

    public static ByteHashSet newSetWith(byte... source)
    {
<span class="nc" id="L104">        return new ByteHashSet(source);</span>
    }

    @Override
    public boolean add(byte element)
    {
<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (element &lt;= MAX_BYTE_GROUP_1)</span>
        {
<span class="nc" id="L112">            long initial = this.bitGroup1;</span>

<span class="nc" id="L114">            this.bitGroup1 |= 1L &lt;&lt; (byte) ((element + 1) * -1);</span>

<span class="nc bnc" id="L116" title="All 2 branches missed.">            if (this.bitGroup1 != initial)</span>
            {
<span class="nc" id="L118">                this.size++;</span>
<span class="nc" id="L119">                return true;</span>
            }
<span class="nc" id="L121">        }</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        else if (element &lt;= MAX_BYTE_GROUP_2)</span>
        {
<span class="nc" id="L124">            long initial = this.bitGroup2;</span>

<span class="nc" id="L126">            this.bitGroup2 |= 1L &lt;&lt; (byte) ((element + 1) * -1);</span>

<span class="nc bnc" id="L128" title="All 2 branches missed.">            if (this.bitGroup2 != initial)</span>
            {
<span class="nc" id="L130">                this.size++;</span>
<span class="nc" id="L131">                return true;</span>
            }
<span class="nc" id="L133">        }</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        else if (element &lt;= MAX_BYTE_GROUP_3)</span>
        {
<span class="nc" id="L136">            long initial = this.bitGroup3;</span>

<span class="nc" id="L138">            this.bitGroup3 |= 1L &lt;&lt; element;</span>

<span class="nc bnc" id="L140" title="All 2 branches missed.">            if (this.bitGroup3 != initial)</span>
            {
<span class="nc" id="L142">                this.size++;</span>
<span class="nc" id="L143">                return true;</span>
            }
<span class="nc" id="L145">        }</span>
        else
        {
<span class="nc" id="L148">            long initial = this.bitGroup4;</span>

<span class="nc" id="L150">            this.bitGroup4 |= 1L &lt;&lt; element;</span>

<span class="nc bnc" id="L152" title="All 2 branches missed.">            if (this.bitGroup4 != initial)</span>
            {
<span class="nc" id="L154">                this.size++;</span>
<span class="nc" id="L155">                return true;</span>
            }
        }

<span class="nc" id="L159">        return false;</span>
    }

    @Override
    public boolean remove(byte value)
    {
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (value &lt;= MAX_BYTE_GROUP_1)</span>
        {
<span class="nc" id="L167">            long initial = this.bitGroup1;</span>
<span class="nc" id="L168">            this.bitGroup1 &amp;= ~(1L &lt;&lt; (byte) ((value + 1) * -1));</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (this.bitGroup1 == initial)</span>
            {
<span class="nc" id="L171">                return false;</span>
            }
<span class="nc" id="L173">            this.size--;</span>
<span class="nc" id="L174">            return true;</span>
        }
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (value &lt;= MAX_BYTE_GROUP_2)</span>
        {
<span class="nc" id="L178">            long initial = this.bitGroup2;</span>
<span class="nc" id="L179">            this.bitGroup2 &amp;= ~(1L &lt;&lt; (byte) ((value + 1) * -1));</span>

<span class="nc bnc" id="L181" title="All 2 branches missed.">            if (this.bitGroup2 == initial)</span>
            {
<span class="nc" id="L183">                return false;</span>
            }
<span class="nc" id="L185">            this.size--;</span>
<span class="nc" id="L186">            return true;</span>
        }
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (value &lt;= MAX_BYTE_GROUP_3)</span>
        {
<span class="nc" id="L190">            long initial = this.bitGroup3;</span>
<span class="nc" id="L191">            this.bitGroup3 &amp;= ~(1L &lt;&lt; value);</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">            if (this.bitGroup3 == initial)</span>
            {
<span class="nc" id="L194">                return false;</span>
            }
<span class="nc" id="L196">            this.size--;</span>
<span class="nc" id="L197">            return true;</span>
        }

<span class="nc" id="L200">        long initial = this.bitGroup4;</span>
<span class="nc" id="L201">        this.bitGroup4 &amp;= ~(1L &lt;&lt; value);</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (this.bitGroup4 == initial)</span>
        {
<span class="nc" id="L204">            return false;</span>
        }
<span class="nc" id="L206">        this.size--;</span>
<span class="nc" id="L207">        return true;</span>
    }

    @Override
    public boolean contains(byte value)
    {
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (value &lt;= MAX_BYTE_GROUP_1)</span>
        {
<span class="nc bnc" id="L215" title="All 2 branches missed.">            return ((this.bitGroup1 &gt;&gt;&gt; (byte) ((value + 1) * -1)) &amp; 1L) != 0;</span>
        }
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (value &lt;= MAX_BYTE_GROUP_2)</span>
        {
<span class="nc bnc" id="L219" title="All 2 branches missed.">            return ((this.bitGroup2 &gt;&gt;&gt; (byte) ((value + 1) * -1)) &amp; 1L) != 0;</span>
        }
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (value &lt;= MAX_BYTE_GROUP_3)</span>
        {
<span class="nc bnc" id="L223" title="All 2 branches missed.">            return ((this.bitGroup3 &gt;&gt;&gt; value) &amp; 1L) != 0;</span>
        }

<span class="nc bnc" id="L226" title="All 2 branches missed.">        return ((this.bitGroup4 &gt;&gt;&gt; value) &amp; 1L) != 0;</span>
    }

    @Override
    public boolean equals(Object obj)
    {
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (this == obj)</span>
        {
<span class="nc" id="L234">            return true;</span>
        }

<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (!(obj instanceof ByteSet))</span>
        {
<span class="nc" id="L239">            return false;</span>
        }

<span class="nc" id="L242">        ByteSet other = (ByteSet) obj;</span>
<span class="nc bnc" id="L243" title="All 4 branches missed.">        return this.size() == other.size() &amp;&amp; this.containsAll(other.toArray());</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L249">        return (int) this.sum();</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L255">        return this.makeString(&quot;[&quot;, &quot;, &quot;, &quot;]&quot;);</span>
    }

    @Override
    public int size()
    {
<span class="nc" id="L261">        return this.size;</span>
    }

    @Override
    public boolean isEmpty()
    {
<span class="nc bnc" id="L267" title="All 2 branches missed.">        return this.size() == 0;</span>
    }

    @Override
    public boolean notEmpty()
    {
<span class="nc bnc" id="L273" title="All 2 branches missed.">        return this.size() != 0;</span>
    }

    @Override
    public String makeString()
    {
<span class="nc" id="L279">        return this.makeString(&quot;, &quot;);</span>
    }

    @Override
    public String makeString(String separator)
    {
<span class="nc" id="L285">        return this.makeString(&quot;&quot;, separator, &quot;&quot;);</span>
    }

    @Override
    public String makeString(String start, String separator, String end)
    {
<span class="nc" id="L291">        Appendable stringBuilder = new StringBuilder();</span>
<span class="nc" id="L292">        this.appendString(stringBuilder, start, separator, end);</span>
<span class="nc" id="L293">        return stringBuilder.toString();</span>
    }

    @Override
    public void appendString(Appendable appendable)
    {
<span class="nc" id="L299">        this.appendString(appendable, &quot;, &quot;);</span>
<span class="nc" id="L300">    }</span>

    @Override
    public void appendString(Appendable appendable, String separator)
    {
<span class="nc" id="L305">        this.appendString(appendable, &quot;&quot;, separator, &quot;&quot;);</span>
<span class="nc" id="L306">    }</span>

    @Override
    public void appendString(Appendable appendable, String start, String separator, String end)
    {
        try
        {
<span class="nc" id="L313">            appendable.append(start);</span>
<span class="nc" id="L314">            int count = 0;</span>
<span class="nc" id="L315">            ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L317" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc bnc" id="L319" title="All 2 branches missed.">                if (count &gt; 0)</span>
                {
<span class="nc" id="L321">                    appendable.append(separator);</span>
                }

<span class="nc" id="L324">                count++;</span>
<span class="nc" id="L325">                appendable.append(String.valueOf(iterator.next()));</span>
            }

<span class="nc" id="L328">            appendable.append(end);</span>
        }
<span class="nc" id="L330">        catch (IOException e)</span>
        {
<span class="nc" id="L332">            throw new RuntimeException(e);</span>
<span class="nc" id="L333">        }</span>
<span class="nc" id="L334">    }</span>

    @Override
    public boolean addAll(byte... source)
    {
<span class="nc" id="L339">        int oldSize = this.size();</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        for (byte item : source)</span>
        {
<span class="nc" id="L342">            this.add(item);</span>
        }
<span class="nc bnc" id="L344" title="All 2 branches missed.">        return this.size() != oldSize;</span>
    }

    @Override
    public boolean addAll(ByteIterable source)
    {
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (source.isEmpty())</span>
        {
<span class="nc" id="L352">            return false;</span>
        }
<span class="nc" id="L354">        int oldSize = this.size();</span>

<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (source instanceof ByteHashSet)</span>
        {
<span class="nc" id="L358">            ByteHashSet hashSet = (ByteHashSet) source;</span>

<span class="nc" id="L360">            this.size = 0;</span>
<span class="nc" id="L361">            this.bitGroup3 |= hashSet.bitGroup3;</span>
<span class="nc" id="L362">            this.size += Long.bitCount(this.bitGroup3);</span>

<span class="nc" id="L364">            this.bitGroup4 |= hashSet.bitGroup4;</span>
<span class="nc" id="L365">            this.size += Long.bitCount(this.bitGroup4);</span>

<span class="nc" id="L367">            this.bitGroup2 |= hashSet.bitGroup2;</span>
<span class="nc" id="L368">            this.size += Long.bitCount(this.bitGroup2);</span>

<span class="nc" id="L370">            this.bitGroup1 |= hashSet.bitGroup1;</span>
<span class="nc" id="L371">            this.size += Long.bitCount(this.bitGroup1);</span>
<span class="nc" id="L372">        }</span>
        else
        {
<span class="nc" id="L375">            ByteIterator iterator = source.byteIterator();</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L378">                byte item = iterator.next();</span>
<span class="nc" id="L379">                this.add(item);</span>
<span class="nc" id="L380">            }</span>
        }
<span class="nc bnc" id="L382" title="All 2 branches missed.">        return this.size() != oldSize;</span>
    }

    @Override
    public boolean removeAll(ByteIterable source)
    {
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (source.isEmpty())</span>
        {
<span class="nc" id="L390">            return false;</span>
        }
<span class="nc" id="L392">        int oldSize = this.size();</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (source instanceof ByteHashSet)</span>
        {
<span class="nc" id="L395">            this.size = 0;</span>
<span class="nc" id="L396">            ByteHashSet hashSet = (ByteHashSet) source;</span>
<span class="nc" id="L397">            this.bitGroup3 &amp;= ~hashSet.bitGroup3;</span>
<span class="nc" id="L398">            this.size += Long.bitCount(this.bitGroup3);</span>

<span class="nc" id="L400">            this.bitGroup4 &amp;= ~hashSet.bitGroup4;</span>
<span class="nc" id="L401">            this.size += Long.bitCount(this.bitGroup4);</span>

<span class="nc" id="L403">            this.bitGroup2 &amp;= ~hashSet.bitGroup2;</span>
<span class="nc" id="L404">            this.size += Long.bitCount(this.bitGroup2);</span>

<span class="nc" id="L406">            this.bitGroup1 &amp;= ~hashSet.bitGroup1;</span>
<span class="nc" id="L407">            this.size += Long.bitCount(this.bitGroup1);</span>
<span class="nc" id="L408">        }</span>
        else
        {
<span class="nc" id="L411">            ByteIterator iterator = source.byteIterator();</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L414">                byte item = iterator.next();</span>
<span class="nc" id="L415">                this.remove(item);</span>
<span class="nc" id="L416">            }</span>
        }
<span class="nc bnc" id="L418" title="All 2 branches missed.">        return this.size() != oldSize;</span>
    }

    @Override
    public boolean removeAll(byte... source)
    {
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (source.length == 0)</span>
        {
<span class="nc" id="L426">            return false;</span>
        }
<span class="nc" id="L428">        int oldSize = this.size();</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">        for (byte item : source)</span>
        {
<span class="nc" id="L431">            this.remove(item);</span>
        }
<span class="nc bnc" id="L433" title="All 2 branches missed.">        return this.size() != oldSize;</span>
    }

    @Override
    public boolean retainAll(ByteIterable source)
    {
<span class="nc" id="L439">        int oldSize = this.size();</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">        ByteSet sourceSet = source instanceof ByteSet ? (ByteSet) source : source.toSet();</span>

<span class="nc" id="L442">        ByteHashSet retained = this.select(sourceSet::contains);</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">        if (retained.size() != oldSize)</span>
        {
<span class="nc" id="L445">            this.bitGroup3 = retained.bitGroup3;</span>
<span class="nc" id="L446">            this.bitGroup4 = retained.bitGroup4;</span>
<span class="nc" id="L447">            this.bitGroup1 = retained.bitGroup1;</span>
<span class="nc" id="L448">            this.bitGroup2 = retained.bitGroup2;</span>
<span class="nc" id="L449">            this.size = retained.size;</span>
<span class="nc" id="L450">            return true;</span>
        }

<span class="nc" id="L453">        return false;</span>
    }

    @Override
    public boolean retainAll(byte... source)
    {
<span class="nc" id="L459">        return this.retainAll(ByteHashSet.newSetWith(source));</span>
    }

    @Override
    public void clear()
    {
<span class="nc" id="L465">        this.size = 0;</span>
<span class="nc" id="L466">        this.bitGroup3 = 0L;</span>
<span class="nc" id="L467">        this.bitGroup4 = 0L;</span>
<span class="nc" id="L468">        this.bitGroup1 = 0L;</span>
<span class="nc" id="L469">        this.bitGroup2 = 0L;</span>
<span class="nc" id="L470">    }</span>

    @Override
    public ByteHashSet with(byte element)
    {
<span class="nc" id="L475">        this.add(element);</span>
<span class="nc" id="L476">        return this;</span>
    }

    @Override
    public ByteHashSet without(byte element)
    {
<span class="nc" id="L482">        this.remove(element);</span>
<span class="nc" id="L483">        return this;</span>
    }

    @Override
    public ByteHashSet withAll(ByteIterable elements)
    {
<span class="nc" id="L489">        this.addAll(elements.toArray());</span>
<span class="nc" id="L490">        return this;</span>
    }

    @Override
    public ByteHashSet withoutAll(ByteIterable elements)
    {
<span class="nc" id="L496">        this.removeAll(elements);</span>
<span class="nc" id="L497">        return this;</span>
    }

    @Override
    public MutableByteSet asUnmodifiable()
    {
<span class="nc" id="L503">        return new UnmodifiableByteSet(this);</span>
    }

    @Override
    public MutableByteSet asSynchronized()
    {
<span class="nc" id="L509">        return new SynchronizedByteSet(this);</span>
    }

    @Override
    public ImmutableByteSet toImmutable()
    {
<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (this.size() == 0)</span>
        {
<span class="nc" id="L517">            return ByteSets.immutable.with();</span>
        }
<span class="nc bnc" id="L519" title="All 2 branches missed.">        if (this.size() == 1)</span>
        {
<span class="nc" id="L521">            return ByteSets.immutable.with(this.byteIterator().next());</span>
        }
<span class="nc" id="L523">        ByteHashSet mutableSet = ByteHashSet.newSetWith(this.toArray());</span>
<span class="nc" id="L524">        return new ImmutableByteHashSet(mutableSet.bitGroup3, mutableSet.bitGroup4,</span>
                mutableSet.bitGroup1, mutableSet.bitGroup2, mutableSet.size);
    }

    /**
     * @since 9.2.
     */
    @Override
    public ByteHashSet newEmpty()
    {
<span class="nc" id="L534">        return new ByteHashSet();</span>
    }

    @Override
    public MutableByteIterator byteIterator()
    {
<span class="nc" id="L540">        return new MutableInternalByteIterator();</span>
    }

    @Override
    public byte[] toArray()
    {
<span class="nc" id="L546">        byte[] array = new byte[this.size()];</span>
<span class="nc" id="L547">        int index = 0;</span>

<span class="nc" id="L549">        ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L551" title="All 2 branches missed.">        while (iterator.hasNext())</span>
        {
<span class="nc" id="L553">            byte nextByte = iterator.next();</span>
<span class="nc" id="L554">            array[index] = nextByte;</span>
<span class="nc" id="L555">            index++;</span>
<span class="nc" id="L556">        }</span>

<span class="nc" id="L558">        return array;</span>
    }

    @Override
    public boolean containsAll(byte... source)
    {
<span class="nc bnc" id="L564" title="All 2 branches missed.">        for (byte item : source)</span>
        {
<span class="nc bnc" id="L566" title="All 2 branches missed.">            if (!this.contains(item))</span>
            {
<span class="nc" id="L568">                return false;</span>
            }
        }
<span class="nc" id="L571">        return true;</span>
    }

    @Override
    public boolean containsAll(ByteIterable source)
    {
<span class="nc bnc" id="L577" title="All 2 branches missed.">        for (ByteIterator iterator = source.byteIterator(); iterator.hasNext(); )</span>
        {
<span class="nc bnc" id="L579" title="All 2 branches missed.">            if (!this.contains(iterator.next()))</span>
            {
<span class="nc" id="L581">                return false;</span>
            }
        }
<span class="nc" id="L584">        return true;</span>
    }

    @Override
    public void forEach(ByteProcedure procedure)
    {
<span class="nc" id="L590">        this.each(procedure);</span>
<span class="nc" id="L591">    }</span>

    /**
     * @since 7.0.
     */
    @Override
    public void each(ByteProcedure procedure)
    {
<span class="nc" id="L599">        long bitGroup1 = this.bitGroup1;</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">        while (bitGroup1 != 0L)</span>
        {
<span class="nc" id="L602">            byte value = (byte) Long.numberOfTrailingZeros(bitGroup1);</span>
<span class="nc" id="L603">            procedure.value((byte) ((value + 65) * -1));</span>
<span class="nc" id="L604">            bitGroup1 &amp;= ~(1L &lt;&lt; (byte) (value + 64));</span>
<span class="nc" id="L605">        }</span>

<span class="nc" id="L607">        long bitGroup2 = this.bitGroup2;</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">        while (bitGroup2 != 0L)</span>
        {
<span class="nc" id="L610">            byte value = (byte) Long.numberOfTrailingZeros(bitGroup2);</span>
<span class="nc" id="L611">            procedure.value((byte) ((value + 1) * -1));</span>
<span class="nc" id="L612">            bitGroup2 &amp;= ~(1L &lt;&lt; value);</span>
<span class="nc" id="L613">        }</span>

<span class="nc" id="L615">        long bitGroup3 = this.bitGroup3;</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        while (bitGroup3 != 0L)</span>
        {
<span class="nc" id="L618">            byte value = (byte) Long.numberOfTrailingZeros(bitGroup3);</span>
<span class="nc" id="L619">            procedure.value(value);</span>
<span class="nc" id="L620">            bitGroup3 &amp;= ~(1L &lt;&lt; value);</span>
<span class="nc" id="L621">        }</span>

<span class="nc" id="L623">        long bitGroup4 = this.bitGroup4;</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">        while (bitGroup4 != 0L)</span>
        {
<span class="nc" id="L626">            byte value = (byte) Long.numberOfTrailingZeros(bitGroup4);</span>
<span class="nc" id="L627">            procedure.value((byte) (value + 64));</span>
<span class="nc" id="L628">            bitGroup4 &amp;= ~(1L &lt;&lt; (byte) (value + 64));</span>
<span class="nc" id="L629">        }</span>
<span class="nc" id="L630">    }</span>

    @Override
    public ByteHashSet select(BytePredicate predicate)
    {
<span class="nc" id="L635">        ByteHashSet result = new ByteHashSet();</span>

<span class="nc" id="L637">        this.forEach(value -&gt; {</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (predicate.accept(value))</span>
            {
<span class="nc" id="L640">                result.add(value);</span>
            }
<span class="nc" id="L642">        });</span>

<span class="nc" id="L644">        return result;</span>
    }

    @Override
    public MutableByteSet reject(BytePredicate predicate)
    {
<span class="nc" id="L650">        MutableByteSet result = new ByteHashSet();</span>

<span class="nc" id="L652">        this.forEach(value -&gt; {</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">            if (!predicate.accept(value))</span>
            {
<span class="nc" id="L655">                result.add(value);</span>
            }
<span class="nc" id="L657">        });</span>

<span class="nc" id="L659">        return result;</span>
    }

    @Override
    public &lt;V&gt; MutableSet&lt;V&gt; collect(ByteToObjectFunction&lt;? extends V&gt; function)
    {
<span class="nc" id="L665">        MutableSet&lt;V&gt; target = UnifiedSet.newSet(this.size());</span>

<span class="nc" id="L667">        this.forEach(each -&gt; target.add(function.valueOf(each)));</span>

<span class="nc" id="L669">        return target;</span>
    }

    @Override
    public byte detectIfNone(BytePredicate predicate, byte ifNone)
    {
<span class="nc" id="L675">        ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L677" title="All 2 branches missed.">        while (iterator.hasNext())</span>
        {
<span class="nc" id="L679">            byte nextByte = iterator.next();</span>

<span class="nc bnc" id="L681" title="All 2 branches missed.">            if (predicate.accept(nextByte))</span>
            {
<span class="nc" id="L683">                return nextByte;</span>
            }
<span class="nc" id="L685">        }</span>

<span class="nc" id="L687">        return ifNone;</span>
    }

    @Override
    public int count(BytePredicate predicate)
    {
<span class="nc" id="L693">        int count = 0;</span>
<span class="nc" id="L694">        ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L696" title="All 2 branches missed.">        while (iterator.hasNext())</span>
        {
<span class="nc bnc" id="L698" title="All 2 branches missed.">            if (predicate.accept(iterator.next()))</span>
            {
<span class="nc" id="L700">                count++;</span>
            }
        }

<span class="nc" id="L704">        return count;</span>
    }

    @Override
    public boolean anySatisfy(BytePredicate predicate)
    {
<span class="nc" id="L710">        ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L712" title="All 2 branches missed.">        while (iterator.hasNext())</span>
        {
<span class="nc bnc" id="L714" title="All 2 branches missed.">            if (predicate.accept(iterator.next()))</span>
            {
<span class="nc" id="L716">                return true;</span>
            }
        }

<span class="nc" id="L720">        return false;</span>
    }

    @Override
    public boolean allSatisfy(BytePredicate predicate)
    {
<span class="nc" id="L726">        ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L728" title="All 2 branches missed.">        while (iterator.hasNext())</span>
        {
<span class="nc bnc" id="L730" title="All 2 branches missed.">            if (!predicate.accept(iterator.next()))</span>
            {
<span class="nc" id="L732">                return false;</span>
            }
        }

<span class="nc" id="L736">        return true;</span>
    }

    @Override
    public boolean noneSatisfy(BytePredicate predicate)
    {
<span class="nc" id="L742">        ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L744" title="All 2 branches missed.">        while (iterator.hasNext())</span>
        {
<span class="nc bnc" id="L746" title="All 2 branches missed.">            if (predicate.accept(iterator.next()))</span>
            {
<span class="nc" id="L748">                return false;</span>
            }
        }

<span class="nc" id="L752">        return true;</span>
    }

    @Override
    public MutableByteList toList()
    {
<span class="nc" id="L758">        return ByteArrayList.newList(this);</span>
    }

    @Override
    public MutableByteSet toSet()
    {
<span class="nc" id="L764">        return ByteHashSet.newSet(this);</span>
    }

    @Override
    public MutableByteBag toBag()
    {
<span class="nc" id="L770">        return ByteHashBag.newBag(this);</span>
    }

    @Override
    public LazyByteIterable asLazy()
    {
<span class="nc" id="L776">        return new LazyByteIterableAdapter(this);</span>
    }

    @Override
    public long sum()
    {
<span class="nc" id="L782">        long result = 0L;</span>

<span class="nc" id="L784">        ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L786" title="All 2 branches missed.">        while (iterator.hasNext())</span>
        {
<span class="nc" id="L788">            result += iterator.next();</span>
        }

<span class="nc" id="L791">        return result;</span>
    }

    @Override
    public byte max()
    {
<span class="nc bnc" id="L797" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L799">            throw new NoSuchElementException();</span>
        }
<span class="nc" id="L801">        byte max = 0;</span>

<span class="nc bnc" id="L803" title="All 2 branches missed.">        if (this.bitGroup4 != 0L)</span>
        {
            //the highest has to be from this
<span class="nc" id="L806">            max = (byte) (127 - Long.numberOfLeadingZeros(this.bitGroup4));</span>
        }
<span class="nc bnc" id="L808" title="All 2 branches missed.">        else if (this.bitGroup3 != 0L)</span>
        {
<span class="nc" id="L810">            max = (byte) (63 - Long.numberOfLeadingZeros(this.bitGroup3));</span>
        }
<span class="nc bnc" id="L812" title="All 2 branches missed.">        else if (this.bitGroup2 != 0L)</span>
        {
<span class="nc" id="L814">            max = (byte) ((Long.numberOfTrailingZeros(this.bitGroup2) + 1) * -1);</span>
        }
<span class="nc bnc" id="L816" title="All 2 branches missed.">        else if (this.bitGroup1 != 0L)</span>
        {
<span class="nc" id="L818">            max = (byte) ((Long.numberOfTrailingZeros(this.bitGroup1) + 65) * -1);</span>
        }

<span class="nc" id="L821">        return max;</span>
    }

    @Override
    public byte maxIfEmpty(byte defaultValue)
    {
<span class="nc bnc" id="L827" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L829">            return defaultValue;</span>
        }
<span class="nc" id="L831">        return this.max();</span>
    }

    @Override
    public byte min()
    {
<span class="nc bnc" id="L837" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L839">            throw new NoSuchElementException();</span>
        }

<span class="nc" id="L842">        byte min = 0;</span>

<span class="nc bnc" id="L844" title="All 2 branches missed.">        if (this.bitGroup1 != 0L)</span>
        {
            //the minimum has to be from this
<span class="nc" id="L847">            min = (byte) (128 - Long.numberOfLeadingZeros(this.bitGroup1));</span>
<span class="nc" id="L848">            min *= -1;</span>
        }
<span class="nc bnc" id="L850" title="All 2 branches missed.">        else if (this.bitGroup2 != 0L)</span>
        {
<span class="nc" id="L852">            min = (byte) ((64 - Long.numberOfLeadingZeros(this.bitGroup2)) * -1);</span>
        }
<span class="nc bnc" id="L854" title="All 2 branches missed.">        else if (this.bitGroup3 != 0L)</span>
        {
<span class="nc" id="L856">            min = (byte) Long.numberOfTrailingZeros(this.bitGroup3);</span>
        }
<span class="nc bnc" id="L858" title="All 2 branches missed.">        else if (this.bitGroup4 != 0L)</span>
        {
<span class="nc" id="L860">            min = (byte) (Long.numberOfTrailingZeros(this.bitGroup4) + 64);</span>
        }

<span class="nc" id="L863">        return min;</span>
    }

    @Override
    public byte minIfEmpty(byte defaultValue)
    {
<span class="nc bnc" id="L869" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L871">            return defaultValue;</span>
        }
<span class="nc" id="L873">        return this.min();</span>
    }

    @Override
    public double average()
    {
<span class="nc bnc" id="L879" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L881">            throw new ArithmeticException();</span>
        }
<span class="nc" id="L883">        return (double) this.sum() / (double) this.size();</span>
    }

    @Override
    public double median()
    {
<span class="nc bnc" id="L889" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L891">            throw new ArithmeticException();</span>
        }
<span class="nc" id="L893">        byte[] sortedArray = this.toSortedArray();</span>
<span class="nc" id="L894">        int middleIndex = sortedArray.length &gt;&gt; 1;</span>
<span class="nc bnc" id="L895" title="All 4 branches missed.">        if (sortedArray.length &gt; 1 &amp;&amp; (sortedArray.length &amp; 1) == 0)</span>
        {
<span class="nc" id="L897">            byte first = sortedArray[middleIndex];</span>
<span class="nc" id="L898">            byte second = sortedArray[middleIndex - 1];</span>
<span class="nc" id="L899">            return ((double) first + (double) second) / 2.0;</span>
        }
<span class="nc" id="L901">        return (double) sortedArray[middleIndex];</span>
    }

    @Override
    public byte[] toSortedArray()
    {
<span class="nc" id="L907">        byte[] array = this.toArray();</span>
<span class="nc" id="L908">        Arrays.sort(array);</span>
<span class="nc" id="L909">        return array;</span>
    }

    @Override
    public MutableByteList toSortedList()
    {
<span class="nc" id="L915">        return ByteArrayList.newList(this).sortThis();</span>
    }

    @Override
    public ByteSet freeze()
    {
<span class="nc bnc" id="L921" title="All 2 branches missed.">        if (this.size() == 0)</span>
        {
<span class="nc" id="L923">            return ByteSets.immutable.with();</span>
        }
<span class="nc bnc" id="L925" title="All 2 branches missed.">        if (this.size() == 1)</span>
        {
<span class="nc" id="L927">            return ByteSets.immutable.with(this.byteIterator().next());</span>
        }

<span class="nc" id="L930">        return new ImmutableByteHashSet(this.bitGroup3, this.bitGroup4,</span>
                this.bitGroup1, this.bitGroup2, this.size);
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException
    {
<span class="nc" id="L937">        out.writeInt(this.size());</span>

<span class="nc" id="L939">        this.forEach(new CheckedByteProcedure()</span>
<span class="nc" id="L940">        {</span>
            public void safeValue(byte each) throws IOException
            {
<span class="nc" id="L943">                out.writeByte(each);</span>
<span class="nc" id="L944">            }</span>
        });
<span class="nc" id="L946">    }</span>

    @Override
    public void readExternal(ObjectInput in) throws IOException
    {
<span class="nc" id="L951">        int size = in.readInt();</span>

<span class="nc bnc" id="L953" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L955">            this.add(in.readByte());</span>
        }
<span class="nc" id="L957">    }</span>

    @Override
    public &lt;T&gt; T injectInto(T injectedValue, ObjectByteToObjectFunction&lt;? super T, ? extends T&gt; function)
    {
<span class="nc" id="L962">        T result = injectedValue;</span>

<span class="nc" id="L964">        ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L966" title="All 2 branches missed.">        while (iterator.hasNext())</span>
        {
<span class="nc" id="L968">            result = function.valueOf(result, iterator.next());</span>
        }

<span class="nc" id="L971">        return result;</span>
    }

    @Override
    public RichIterable&lt;ByteIterable&gt; chunk(int size)
    {
<span class="nc bnc" id="L977" title="All 2 branches missed.">        if (size &lt;= 0)</span>
        {
<span class="nc" id="L979">            throw new IllegalArgumentException(&quot;Size for groups must be positive but was: &quot; + size);</span>
        }
<span class="nc" id="L981">        MutableList&lt;ByteIterable&gt; result = Lists.mutable.empty();</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">        if (this.notEmpty())</span>
        {
<span class="nc bnc" id="L984" title="All 2 branches missed.">            if (this.size() &lt;= size)</span>
            {
<span class="nc" id="L986">                result.add(ByteSets.mutable.withAll(this));</span>
            }
            else
            {
<span class="nc" id="L990">                ByteIterator iterator = this.byteIterator();</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">                while (iterator.hasNext())</span>
                {
<span class="nc" id="L993">                    MutableByteSet batch = ByteSets.mutable.empty();</span>
<span class="nc bnc" id="L994" title="All 4 branches missed.">                    for (int i = 0; i &lt; size &amp;&amp; iterator.hasNext(); i++)</span>
                    {
<span class="nc" id="L996">                        batch.add(iterator.next());</span>
                    }
<span class="nc" id="L998">                    result.add(batch);</span>
<span class="nc" id="L999">                }</span>
            }
        }
<span class="nc" id="L1002">        return result;</span>
    }

    private static final class ImmutableByteHashSet implements ImmutableByteSet, Serializable
    {
        private static final long serialVersionUID = 1L;
        private final long bitGroup1; // -128 to -65
        private final long bitGroup2; //-64 to -1
        private final long bitGroup3; //0 to 63
        private final long bitGroup4; // 64 to 127
        private final short size;

        private ImmutableByteHashSet(
                long bitGroup3,
                long bitGroup4,
                long bitGroup1,
                long bitGroup2,
                short size)
<span class="nc" id="L1020">        {</span>
<span class="nc" id="L1021">            this.bitGroup3 = bitGroup3;</span>
<span class="nc" id="L1022">            this.bitGroup4 = bitGroup4;</span>
<span class="nc" id="L1023">            this.bitGroup1 = bitGroup1;</span>
<span class="nc" id="L1024">            this.bitGroup2 = bitGroup2;</span>
<span class="nc" id="L1025">            this.size = size;</span>
<span class="nc" id="L1026">        }</span>

        @Override
        public boolean equals(Object obj)
        {
<span class="nc bnc" id="L1031" title="All 2 branches missed.">            if (this == obj)</span>
            {
<span class="nc" id="L1033">                return true;</span>
            }

<span class="nc bnc" id="L1036" title="All 2 branches missed.">            if (!(obj instanceof ByteSet))</span>
            {
<span class="nc" id="L1038">                return false;</span>
            }

<span class="nc" id="L1041">            ByteSet other = (ByteSet) obj;</span>
<span class="nc bnc" id="L1042" title="All 4 branches missed.">            return this.size() == other.size() &amp;&amp; this.containsAll(other.toArray());</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L1048">            return (int) this.sum();</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L1054">            return this.makeString(&quot;[&quot;, &quot;, &quot;, &quot;]&quot;);</span>
        }

        @Override
        public ImmutableByteSet newWith(byte element)
        {
<span class="nc" id="L1060">            return ByteHashSet.newSet(this).with(element).toImmutable();</span>
        }

        @Override
        public ImmutableByteSet newWithout(byte element)
        {
<span class="nc" id="L1066">            return ByteHashSet.newSet(this).without(element).toImmutable();</span>
        }

        @Override
        public ImmutableByteSet newWithAll(ByteIterable elements)
        {
<span class="nc" id="L1072">            return ByteHashSet.newSet(this).withAll(elements).toImmutable();</span>
        }

        @Override
        public ImmutableByteSet newWithoutAll(ByteIterable elements)
        {
<span class="nc" id="L1078">            return ByteHashSet.newSet(this).withoutAll(elements).toImmutable();</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L1084">            return this.size;</span>
        }

        @Override
        public boolean isEmpty()
        {
<span class="nc bnc" id="L1090" title="All 2 branches missed.">            return this.size() == 0;</span>
        }

        @Override
        public boolean notEmpty()
        {
<span class="nc bnc" id="L1096" title="All 2 branches missed.">            return this.size() != 0;</span>
        }

        @Override
        public String makeString()
        {
<span class="nc" id="L1102">            return this.makeString(&quot;, &quot;);</span>
        }

        @Override
        public String makeString(String separator)
        {
<span class="nc" id="L1108">            return this.makeString(&quot;&quot;, separator, &quot;&quot;);</span>
        }

        @Override
        public String makeString(String start, String separator, String end)
        {
<span class="nc" id="L1114">            Appendable stringBuilder = new StringBuilder();</span>
<span class="nc" id="L1115">            this.appendString(stringBuilder, start, separator, end);</span>
<span class="nc" id="L1116">            return stringBuilder.toString();</span>
        }

        @Override
        public void appendString(Appendable appendable)
        {
<span class="nc" id="L1122">            this.appendString(appendable, &quot;, &quot;);</span>
<span class="nc" id="L1123">        }</span>

        @Override
        public void appendString(Appendable appendable, String separator)
        {
<span class="nc" id="L1128">            this.appendString(appendable, &quot;&quot;, separator, &quot;&quot;);</span>
<span class="nc" id="L1129">        }</span>

        @Override
        public void appendString(Appendable appendable, String start, String separator, String end)
        {
            try
            {
<span class="nc" id="L1136">                appendable.append(start);</span>
<span class="nc" id="L1137">                int count = 0;</span>
<span class="nc" id="L1138">                ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L1140" title="All 2 branches missed.">                while (iterator.hasNext())</span>
                {
<span class="nc" id="L1142">                    byte nextByte = iterator.next();</span>

<span class="nc bnc" id="L1144" title="All 2 branches missed.">                    if (count &gt; 0)</span>
                    {
<span class="nc" id="L1146">                        appendable.append(separator);</span>
                    }

<span class="nc" id="L1149">                    count++;</span>
<span class="nc" id="L1150">                    appendable.append(String.valueOf(nextByte));</span>
<span class="nc" id="L1151">                }</span>

<span class="nc" id="L1153">                appendable.append(end);</span>
            }
<span class="nc" id="L1155">            catch (IOException e)</span>
            {
<span class="nc" id="L1157">                throw new RuntimeException(e);</span>
<span class="nc" id="L1158">            }</span>
<span class="nc" id="L1159">        }</span>

        @Override
        public ByteIterator byteIterator()
        {
<span class="nc" id="L1164">            return new InternalByteIterator();</span>
        }

        @Override
        public byte[] toArray()
        {
<span class="nc" id="L1170">            byte[] array = new byte[this.size()];</span>
<span class="nc" id="L1171">            int index = 0;</span>

<span class="nc" id="L1173">            ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L1175" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L1177">                byte nextByte = iterator.next();</span>
<span class="nc" id="L1178">                array[index] = nextByte;</span>
<span class="nc" id="L1179">                index++;</span>
<span class="nc" id="L1180">            }</span>

<span class="nc" id="L1182">            return array;</span>
        }

        @Override
        public boolean contains(byte value)
        {
<span class="nc bnc" id="L1188" title="All 2 branches missed.">            if (value &lt;= MAX_BYTE_GROUP_1)</span>
            {
<span class="nc bnc" id="L1190" title="All 2 branches missed.">                return ((this.bitGroup1 &gt;&gt;&gt; (byte) ((value + 1) * -1)) &amp; 1L) != 0;</span>
            }
<span class="nc bnc" id="L1192" title="All 2 branches missed.">            if (value &lt;= MAX_BYTE_GROUP_2)</span>
            {
<span class="nc bnc" id="L1194" title="All 2 branches missed.">                return ((this.bitGroup2 &gt;&gt;&gt; (byte) ((value + 1) * -1)) &amp; 1L) != 0;</span>
            }
<span class="nc bnc" id="L1196" title="All 2 branches missed.">            if (value &lt;= MAX_BYTE_GROUP_3)</span>
            {
<span class="nc bnc" id="L1198" title="All 2 branches missed.">                return ((this.bitGroup3 &gt;&gt;&gt; value) &amp; 1L) != 0;</span>
            }

<span class="nc bnc" id="L1201" title="All 2 branches missed.">            return ((this.bitGroup4 &gt;&gt;&gt; value) &amp; 1L) != 0;</span>
        }

        @Override
        public boolean containsAll(byte... source)
        {
<span class="nc bnc" id="L1207" title="All 2 branches missed.">            for (byte item : source)</span>
            {
<span class="nc bnc" id="L1209" title="All 2 branches missed.">                if (!this.contains(item))</span>
                {
<span class="nc" id="L1211">                    return false;</span>
                }
            }
<span class="nc" id="L1214">            return true;</span>
        }

        @Override
        public boolean containsAll(ByteIterable source)
        {
<span class="nc bnc" id="L1220" title="All 2 branches missed.">            for (ByteIterator iterator = source.byteIterator(); iterator.hasNext(); )</span>
            {
<span class="nc bnc" id="L1222" title="All 2 branches missed.">                if (!this.contains(iterator.next()))</span>
                {
<span class="nc" id="L1224">                    return false;</span>
                }
            }
<span class="nc" id="L1227">            return true;</span>
        }

        @Override
        public void forEach(ByteProcedure procedure)
        {
<span class="nc" id="L1233">            this.each(procedure);</span>
<span class="nc" id="L1234">        }</span>

        @Override
        public void each(ByteProcedure procedure)
        {
<span class="nc" id="L1239">            long bitGroup1 = this.bitGroup1;</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">            while (bitGroup1 != 0L)</span>
            {
<span class="nc" id="L1242">                byte value = (byte) Long.numberOfTrailingZeros(bitGroup1);</span>
<span class="nc" id="L1243">                procedure.value((byte) ((value + 65) * -1));</span>
<span class="nc" id="L1244">                bitGroup1 &amp;= ~(1L &lt;&lt; (byte) (value + 64));</span>
<span class="nc" id="L1245">            }</span>

<span class="nc" id="L1247">            long bitGroup2 = this.bitGroup2;</span>
<span class="nc bnc" id="L1248" title="All 2 branches missed.">            while (bitGroup2 != 0L)</span>
            {
<span class="nc" id="L1250">                byte value = (byte) Long.numberOfTrailingZeros(bitGroup2);</span>
<span class="nc" id="L1251">                procedure.value((byte) ((value + 1) * -1));</span>
<span class="nc" id="L1252">                bitGroup2 &amp;= ~(1L &lt;&lt; value);</span>
<span class="nc" id="L1253">            }</span>

<span class="nc" id="L1255">            long bitGroup3 = this.bitGroup3;</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">            while (bitGroup3 != 0L)</span>
            {
<span class="nc" id="L1258">                byte value = (byte) Long.numberOfTrailingZeros(bitGroup3);</span>
<span class="nc" id="L1259">                procedure.value(value);</span>
<span class="nc" id="L1260">                bitGroup3 &amp;= ~(1L &lt;&lt; value);</span>
<span class="nc" id="L1261">            }</span>

<span class="nc" id="L1263">            long bitGroup4 = this.bitGroup4;</span>
<span class="nc bnc" id="L1264" title="All 2 branches missed.">            while (bitGroup4 != 0L)</span>
            {
<span class="nc" id="L1266">                byte value = (byte) Long.numberOfTrailingZeros(bitGroup4);</span>
<span class="nc" id="L1267">                procedure.value((byte) (value + 64));</span>
<span class="nc" id="L1268">                bitGroup4 &amp;= ~(1L &lt;&lt; (byte) (value + 64));</span>
<span class="nc" id="L1269">            }</span>
<span class="nc" id="L1270">        }</span>

        @Override
        public ImmutableByteSet select(BytePredicate predicate)
        {
<span class="nc" id="L1275">            MutableByteSet result = new ByteHashSet();</span>

<span class="nc" id="L1277">            this.forEach(value -&gt; {</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">                if (predicate.accept(value))</span>
                {
<span class="nc" id="L1280">                    result.add(value);</span>
                }
<span class="nc" id="L1282">            });</span>

<span class="nc" id="L1284">            return result.toImmutable();</span>
        }

        @Override
        public ImmutableByteSet reject(BytePredicate predicate)
        {
<span class="nc" id="L1290">            MutableByteSet result = new ByteHashSet();</span>

<span class="nc" id="L1292">            this.forEach(value -&gt; {</span>
<span class="nc bnc" id="L1293" title="All 2 branches missed.">                if (!predicate.accept(value))</span>
                {
<span class="nc" id="L1295">                    result.add(value);</span>
                }
<span class="nc" id="L1297">            });</span>

<span class="nc" id="L1299">            return result.toImmutable();</span>
        }

        @Override
        public &lt;V&gt; ImmutableSet&lt;V&gt; collect(ByteToObjectFunction&lt;? extends V&gt; function)
        {
<span class="nc" id="L1305">            MutableSet&lt;V&gt; target = UnifiedSet.newSet(this.size());</span>

<span class="nc" id="L1307">            this.forEach(each -&gt; target.add(function.valueOf(each)));</span>

<span class="nc" id="L1309">            return target.toImmutable();</span>
        }

        @Override
        public byte detectIfNone(BytePredicate predicate, byte ifNone)
        {
<span class="nc" id="L1315">            ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L1317" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L1319">                byte nextByte = iterator.next();</span>

<span class="nc bnc" id="L1321" title="All 2 branches missed.">                if (predicate.accept(nextByte))</span>
                {
<span class="nc" id="L1323">                    return nextByte;</span>
                }
<span class="nc" id="L1325">            }</span>

<span class="nc" id="L1327">            return ifNone;</span>
        }

        @Override
        public int count(BytePredicate predicate)
        {
<span class="nc" id="L1333">            int count = 0;</span>
<span class="nc" id="L1334">            ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L1336" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc bnc" id="L1338" title="All 2 branches missed.">                if (predicate.accept(iterator.next()))</span>
                {
<span class="nc" id="L1340">                    count++;</span>
                }
            }

<span class="nc" id="L1344">            return count;</span>
        }

        @Override
        public boolean anySatisfy(BytePredicate predicate)
        {
<span class="nc" id="L1350">            ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L1352" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc bnc" id="L1354" title="All 2 branches missed.">                if (predicate.accept(iterator.next()))</span>
                {
<span class="nc" id="L1356">                    return true;</span>
                }
            }

<span class="nc" id="L1360">            return false;</span>
        }

        @Override
        public boolean allSatisfy(BytePredicate predicate)
        {
<span class="nc" id="L1366">            ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L1368" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc bnc" id="L1370" title="All 2 branches missed.">                if (!predicate.accept(iterator.next()))</span>
                {
<span class="nc" id="L1372">                    return false;</span>
                }
            }

<span class="nc" id="L1376">            return true;</span>
        }

        @Override
        public boolean noneSatisfy(BytePredicate predicate)
        {
<span class="nc" id="L1382">            ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L1384" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc bnc" id="L1386" title="All 2 branches missed.">                if (predicate.accept(iterator.next()))</span>
                {
<span class="nc" id="L1388">                    return false;</span>
                }
            }

<span class="nc" id="L1392">            return true;</span>
        }

        @Override
        public MutableByteList toList()
        {
<span class="nc" id="L1398">            return ByteArrayList.newList(this);</span>
        }

        @Override
        public MutableByteSet toSet()
        {
<span class="nc" id="L1404">            return ByteHashSet.newSet(this);</span>
        }

        @Override
        public MutableByteBag toBag()
        {
<span class="nc" id="L1410">            return ByteHashBag.newBag(this);</span>
        }

        @Override
        public LazyByteIterable asLazy()
        {
<span class="nc" id="L1416">            return new LazyByteIterableAdapter(this);</span>
        }

        @Override
        public long sum()
        {
<span class="nc" id="L1422">            long result = 0L;</span>

<span class="nc" id="L1424">            ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L1426" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L1428">                result += iterator.next();</span>
            }

<span class="nc" id="L1431">            return result;</span>
        }

        @Override
        public byte max()
        {
<span class="nc" id="L1437">            byte max = 0;</span>

<span class="nc bnc" id="L1439" title="All 2 branches missed.">            if (this.bitGroup4 != 0L)</span>
            {
                //the highest has to be from this
<span class="nc" id="L1442">                max = (byte) (127 - Long.numberOfLeadingZeros(this.bitGroup4));</span>
            }
<span class="nc bnc" id="L1444" title="All 2 branches missed.">            else if (this.bitGroup3 != 0L)</span>
            {
<span class="nc" id="L1446">                max = (byte) (63 - Long.numberOfLeadingZeros(this.bitGroup3));</span>
            }
<span class="nc bnc" id="L1448" title="All 2 branches missed.">            else if (this.bitGroup2 != 0L)</span>
            {
<span class="nc" id="L1450">                max = (byte) ((Long.numberOfTrailingZeros(this.bitGroup2) + 1) * -1);</span>
            }
<span class="nc bnc" id="L1452" title="All 2 branches missed.">            else if (this.bitGroup1 != 0L)</span>
            {
<span class="nc" id="L1454">                max = (byte) ((Long.numberOfTrailingZeros(this.bitGroup1) + 65) * -1);</span>
            }

<span class="nc" id="L1457">            return max;</span>
        }

        @Override
        public byte maxIfEmpty(byte defaultValue)
        {
<span class="nc" id="L1463">            return this.max();</span>
        }

        @Override
        public byte min()
        {
<span class="nc" id="L1469">            byte min = 0;</span>

<span class="nc bnc" id="L1471" title="All 2 branches missed.">            if (this.bitGroup1 != 0L)</span>
            {
                //the minimum has to be from this
<span class="nc" id="L1474">                min = (byte) (128 - Long.numberOfLeadingZeros(this.bitGroup1));</span>
<span class="nc" id="L1475">                min *= -1;</span>
            }
<span class="nc bnc" id="L1477" title="All 2 branches missed.">            else if (this.bitGroup2 != 0L)</span>
            {
<span class="nc" id="L1479">                min = (byte) ((64 - Long.numberOfLeadingZeros(this.bitGroup2)) * -1);</span>
            }
<span class="nc bnc" id="L1481" title="All 2 branches missed.">            else if (this.bitGroup3 != 0L)</span>
            {
<span class="nc" id="L1483">                min = (byte) Long.numberOfTrailingZeros(this.bitGroup3);</span>
            }
<span class="nc bnc" id="L1485" title="All 2 branches missed.">            else if (this.bitGroup4 != 0L)</span>
            {
<span class="nc" id="L1487">                min = (byte) (Long.numberOfTrailingZeros(this.bitGroup4) + 64);</span>
            }

<span class="nc" id="L1490">            return min;</span>
        }

        @Override
        public byte minIfEmpty(byte defaultValue)
        {
<span class="nc" id="L1496">            return this.min();</span>
        }

        @Override
        public double average()
        {
<span class="nc" id="L1502">            return (double) this.sum() / (double) this.size();</span>
        }

        @Override
        public double median()
        {
<span class="nc" id="L1508">            byte[] sortedArray = this.toSortedArray();</span>
<span class="nc" id="L1509">            int middleIndex = sortedArray.length &gt;&gt; 1;</span>
<span class="nc bnc" id="L1510" title="All 4 branches missed.">            if (sortedArray.length &gt; 1 &amp;&amp; (sortedArray.length &amp; 1) == 0)</span>
            {
<span class="nc" id="L1512">                byte first = sortedArray[middleIndex];</span>
<span class="nc" id="L1513">                byte second = sortedArray[middleIndex - 1];</span>
<span class="nc" id="L1514">                return ((double) first + (double) second) / 2.0;</span>
            }
<span class="nc" id="L1516">            return (double) sortedArray[middleIndex];</span>
        }

        @Override
        public byte[] toSortedArray()
        {
<span class="nc" id="L1522">            byte[] array = this.toArray();</span>
<span class="nc" id="L1523">            Arrays.sort(array);</span>
<span class="nc" id="L1524">            return array;</span>
        }

        @Override
        public MutableByteList toSortedList()
        {
<span class="nc" id="L1530">            return ByteArrayList.newList(this).sortThis();</span>
        }

        @Override
        public &lt;T&gt; T injectInto(T injectedValue, ObjectByteToObjectFunction&lt;? super T, ? extends T&gt; function)
        {
<span class="nc" id="L1536">            T result = injectedValue;</span>

<span class="nc" id="L1538">            ByteIterator iterator = this.byteIterator();</span>

<span class="nc bnc" id="L1540" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L1542">                result = function.valueOf(result, iterator.next());</span>
            }

<span class="nc" id="L1545">            return result;</span>
        }

        @Override
        public RichIterable&lt;ByteIterable&gt; chunk(int size)
        {
<span class="nc bnc" id="L1551" title="All 2 branches missed.">            if (size &lt;= 0)</span>
            {
<span class="nc" id="L1553">                throw new IllegalArgumentException(&quot;Size for groups must be positive but was: &quot; + size);</span>
            }
<span class="nc bnc" id="L1555" title="All 2 branches missed.">            if (this.isEmpty())</span>
            {
<span class="nc" id="L1557">                return Lists.mutable.empty();</span>
            }

<span class="nc" id="L1560">            ByteIterator iterator = this.byteIterator();</span>
<span class="nc" id="L1561">            MutableList&lt;ByteIterable&gt; result = Lists.mutable.empty();</span>
<span class="nc bnc" id="L1562" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L1564">                MutableByteSet batch = ByteSets.mutable.empty();</span>
<span class="nc bnc" id="L1565" title="All 4 branches missed.">                for (int i = 0; i &lt; size &amp;&amp; iterator.hasNext(); i++)</span>
                {
<span class="nc" id="L1567">                    batch.add(iterator.next());</span>
                }
<span class="nc" id="L1569">                result.add(batch);</span>
<span class="nc" id="L1570">            }</span>
<span class="nc" id="L1571">            return result;</span>
        }

        @Override
        public ByteSet freeze()
        {
<span class="nc" id="L1577">            return this;</span>
        }

        @Override
        public ImmutableByteSet toImmutable()
        {
<span class="nc" id="L1583">            return this;</span>
        }

        private Object writeReplace()
        {
<span class="nc" id="L1588">            return new ImmutableByteSetSerializationProxy(this);</span>
        }

<span class="nc" id="L1591">        private class InternalByteIterator implements ByteIterator</span>
        {
            private int count;
<span class="nc" id="L1594">            private byte minusOneTwentyEightToPlusOneTwentySeven = -128;</span>

            @Override
            public boolean hasNext()
            {
<span class="nc bnc" id="L1599" title="All 2 branches missed.">                return this.count &lt; ImmutableByteHashSet.this.size();</span>
            }

            @Override
            public byte next()
            {
<span class="nc bnc" id="L1605" title="All 2 branches missed.">                if (!this.hasNext())</span>
                {
<span class="nc" id="L1607">                    throw new NoSuchElementException(&quot;next() called, but the iterator is exhausted&quot;);</span>
                }
<span class="nc" id="L1609">                this.count++;</span>

<span class="nc bnc" id="L1611" title="All 2 branches missed.">                while (this.minusOneTwentyEightToPlusOneTwentySeven &lt;= 127)</span>
                {
<span class="nc bnc" id="L1613" title="All 2 branches missed.">                    if (ImmutableByteHashSet.this.contains(this.minusOneTwentyEightToPlusOneTwentySeven))</span>
                    {
<span class="nc" id="L1615">                        byte result = this.minusOneTwentyEightToPlusOneTwentySeven;</span>
<span class="nc" id="L1616">                        this.minusOneTwentyEightToPlusOneTwentySeven++;</span>
<span class="nc" id="L1617">                        return result;</span>
                    }
<span class="nc" id="L1619">                    this.minusOneTwentyEightToPlusOneTwentySeven++;</span>
                }

<span class="nc" id="L1622">                throw new NoSuchElementException(&quot;no more element, unexpected situation&quot;);</span>
            }
        }
    }

<span class="nc" id="L1627">    private class MutableInternalByteIterator implements MutableByteIterator</span>
    {
        private int count;
<span class="nc" id="L1630">        private byte minusOneTwentyEightToPlusOneTwentySeven = -128;</span>

        @Override
        public boolean hasNext()
        {
<span class="nc bnc" id="L1635" title="All 2 branches missed.">            return this.count &lt; ByteHashSet.this.size();</span>
        }

        @Override
        public byte next()
        {
<span class="nc bnc" id="L1641" title="All 2 branches missed.">            if (!this.hasNext())</span>
            {
<span class="nc" id="L1643">                throw new NoSuchElementException(&quot;next() called, but the iterator is exhausted&quot;);</span>
            }

<span class="nc" id="L1646">            this.count++;</span>

<span class="nc bnc" id="L1648" title="All 2 branches missed.">            while (this.minusOneTwentyEightToPlusOneTwentySeven &lt;= 127)</span>
            {
<span class="nc bnc" id="L1650" title="All 2 branches missed.">                if (ByteHashSet.this.contains(this.minusOneTwentyEightToPlusOneTwentySeven))</span>
                {
<span class="nc" id="L1652">                    byte result = this.minusOneTwentyEightToPlusOneTwentySeven;</span>
<span class="nc" id="L1653">                    this.minusOneTwentyEightToPlusOneTwentySeven++;</span>
<span class="nc" id="L1654">                    return result;</span>
                }
<span class="nc" id="L1656">                this.minusOneTwentyEightToPlusOneTwentySeven++;</span>
            }

<span class="nc" id="L1659">            throw new NoSuchElementException(&quot;no more element, unexpected situation&quot;);</span>
        }

        @Override
        public void remove()
        {
<span class="nc bnc" id="L1665" title="All 4 branches missed.">            if (this.count == 0 || !ByteHashSet.this.remove((byte) (this.minusOneTwentyEightToPlusOneTwentySeven - 1)))</span>
            {
<span class="nc" id="L1667">                throw new IllegalStateException();</span>
            }
<span class="nc" id="L1669">            this.count--;</span>
<span class="nc" id="L1670">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>