<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ImmutableArrayBag.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.impl.bag.immutable</a> &gt; <span class="el_source">ImmutableArrayBag.java</span></div><h1>ImmutableArrayBag.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2018 Goldman Sachs and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.impl.bag.immutable;

import java.io.Serializable;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Optional;

import org.eclipse.collections.api.RichIterable;
import org.eclipse.collections.api.bag.Bag;
import org.eclipse.collections.api.bag.ImmutableBag;
import org.eclipse.collections.api.bag.MutableBag;
import org.eclipse.collections.api.block.function.Function;
import org.eclipse.collections.api.block.predicate.Predicate;
import org.eclipse.collections.api.block.predicate.Predicate2;
import org.eclipse.collections.api.block.predicate.primitive.IntPredicate;
import org.eclipse.collections.api.block.procedure.Procedure;
import org.eclipse.collections.api.block.procedure.primitive.ObjectIntProcedure;
import org.eclipse.collections.api.map.MutableMap;
import org.eclipse.collections.api.multimap.bag.ImmutableBagMultimap;
import org.eclipse.collections.api.ordered.OrderedIterable;
import org.eclipse.collections.api.set.ImmutableSet;
import org.eclipse.collections.api.tuple.Pair;
import org.eclipse.collections.impl.bag.mutable.HashBag;
import org.eclipse.collections.impl.block.factory.Predicates2;
import org.eclipse.collections.impl.factory.Bags;
import org.eclipse.collections.impl.map.mutable.UnifiedMap;
import org.eclipse.collections.impl.multimap.bag.HashBagMultimap;
import org.eclipse.collections.impl.set.mutable.UnifiedSet;
import org.eclipse.collections.impl.utility.ArrayIterate;
import org.eclipse.collections.impl.utility.Iterate;

/**
 * @since 1.0
 */
public class ImmutableArrayBag&lt;T&gt;
        extends AbstractImmutableBag&lt;T&gt;
        implements Serializable
{
    static final int MAXIMUM_USEFUL_ARRAY_BAG_SIZE = 20;

    private static final long serialVersionUID = 1L;

    private final T[] keys;
    private final int[] counts;

    ImmutableArrayBag(T[] keys, int[] counts)
<span class="nc" id="L59">    {</span>
<span class="nc" id="L60">        this.keys = keys;</span>
<span class="nc" id="L61">        this.counts = counts;</span>

<span class="nc bnc" id="L63" title="All 2 branches missed.">        if (this.keys.length != this.counts.length)</span>
        {
<span class="nc" id="L65">            throw new IllegalArgumentException();</span>
        }
<span class="nc" id="L67">    }</span>

    public static &lt;T&gt; ImmutableArrayBag&lt;T&gt; newBagWith(T... elements)
    {
<span class="nc" id="L71">        return ImmutableArrayBag.copyFrom(Bags.mutable.with(elements));</span>
    }

    public static &lt;T&gt; ImmutableArrayBag&lt;T&gt; copyFrom(Bag&lt;T&gt; bag)
    {
<span class="nc" id="L76">        int distinctItemCount = bag.sizeDistinct();</span>
<span class="nc" id="L77">        T[] newKeys = (T[]) new Object[distinctItemCount];</span>
<span class="nc" id="L78">        int[] newCounts = new int[distinctItemCount];</span>
<span class="nc" id="L79">        bag.forEachWithOccurrences(new ObjectIntProcedure&lt;T&gt;()</span>
<span class="nc" id="L80">        {</span>
            private int index;

            public void value(T each, int count)
            {
<span class="nc" id="L85">                newKeys[this.index] = each;</span>
<span class="nc" id="L86">                newCounts[this.index] = count;</span>
<span class="nc" id="L87">                this.index++;</span>
<span class="nc" id="L88">            }</span>
        });
<span class="nc" id="L90">        return new ImmutableArrayBag&lt;&gt;(newKeys, newCounts);</span>
    }

    @Override
    public void forEachWithOccurrences(ObjectIntProcedure&lt;? super T&gt; objectIntProcedure)
    {
<span class="nc bnc" id="L96" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc" id="L98">            objectIntProcedure.value(this.keys[i], this.counts[i]);</span>
        }
<span class="nc" id="L100">    }</span>

    @Override
    public int sizeDistinct()
    {
<span class="nc" id="L105">        return this.keys.length;</span>
    }

    @Override
    public int size()
    {
<span class="nc" id="L111">        int sum = 0;</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">        for (int value : this.counts)</span>
        {
<span class="nc" id="L114">            sum += value;</span>
        }
<span class="nc" id="L116">        return sum;</span>
    }

    @Override
    public int occurrencesOf(Object item)
    {
<span class="nc" id="L122">        int index = ArrayIterate.detectIndexWith(this.keys, Predicates2.equal(), item);</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (index &gt; -1)</span>
        {
<span class="nc" id="L125">            return this.counts[index];</span>
        }
<span class="nc" id="L127">        return 0;</span>
    }

    @Override
    public ImmutableBag&lt;T&gt; newWith(T element)
    {
<span class="nc" id="L133">        int elementIndex = ArrayIterate.detectIndexWith(this.keys, Predicates2.equal(), element);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        int distinctItemCount = this.sizeDistinct() + (elementIndex == -1 ? 1 : 0);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (distinctItemCount &gt; MAXIMUM_USEFUL_ARRAY_BAG_SIZE)</span>
        {
<span class="nc" id="L137">            return HashBag.newBag(this).with(element).toImmutable();</span>
        }
<span class="nc" id="L139">        return this.newArrayBagWith(element, elementIndex, distinctItemCount);</span>
    }

    private ImmutableBag&lt;T&gt; newArrayBagWith(T element, int elementIndex, int distinctItemCount)
    {
<span class="nc" id="L144">        T[] newKeys = (T[]) new Object[distinctItemCount];</span>
<span class="nc" id="L145">        int[] newCounts = new int[distinctItemCount];</span>
<span class="nc" id="L146">        System.arraycopy(this.keys, 0, newKeys, 0, this.keys.length);</span>
<span class="nc" id="L147">        System.arraycopy(this.counts, 0, newCounts, 0, this.counts.length);</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (elementIndex == -1)</span>
        {
<span class="nc" id="L150">            newKeys[distinctItemCount - 1] = element;</span>
<span class="nc" id="L151">            newCounts[distinctItemCount - 1] = 1;</span>
        }
        else
        {
<span class="nc" id="L155">            newCounts[elementIndex]++;</span>
        }
<span class="nc" id="L157">        return new ImmutableArrayBag&lt;&gt;(newKeys, newCounts);</span>
    }

    @Override
    public ImmutableBag&lt;T&gt; newWithout(T element)
    {
<span class="nc" id="L163">        int elementIndex = ArrayIterate.detectIndexWith(this.keys, Predicates2.equal(), element);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (elementIndex &gt; -1)</span>
        {
<span class="nc bnc" id="L166" title="All 2 branches missed.">            int distinctItemCount = this.sizeDistinct() - (this.counts[elementIndex] == 1 ? 1 : 0);</span>
<span class="nc" id="L167">            T[] newKeys = (T[]) new Object[distinctItemCount];</span>
<span class="nc" id="L168">            int[] newCounts = new int[distinctItemCount];</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (distinctItemCount == this.sizeDistinct())</span>
            {
<span class="nc" id="L171">                System.arraycopy(this.keys, 0, newKeys, 0, distinctItemCount);</span>
<span class="nc" id="L172">                System.arraycopy(this.counts, 0, newCounts, 0, distinctItemCount);</span>
<span class="nc" id="L173">                newCounts[elementIndex]--;</span>
            }
            else
            {
<span class="nc" id="L177">                System.arraycopy(this.keys, 0, newKeys, 0, elementIndex);</span>
<span class="nc" id="L178">                System.arraycopy(this.counts, 0, newCounts, 0, elementIndex);</span>
<span class="nc" id="L179">                System.arraycopy(this.keys, elementIndex + 1, newKeys, elementIndex, newKeys.length - elementIndex);</span>
<span class="nc" id="L180">                System.arraycopy(this.counts, elementIndex + 1, newCounts, elementIndex, newCounts.length - elementIndex);</span>
            }
<span class="nc" id="L182">            return new ImmutableArrayBag&lt;&gt;(newKeys, newCounts);</span>
        }
<span class="nc" id="L184">        return this;</span>
    }

    @Override
    public MutableMap&lt;T, Integer&gt; toMapOfItemToCount()
    {
<span class="nc" id="L190">        MutableMap&lt;T, Integer&gt; map = UnifiedMap.newMap(this.size());</span>
<span class="nc" id="L191">        this.forEachWithOccurrences(map::put);</span>
<span class="nc" id="L192">        return map;</span>
    }

    @Override
    public ImmutableBag&lt;T&gt; newWithAll(Iterable&lt;? extends T&gt; elements)
    {
<span class="nc" id="L198">        return Bags.immutable.withAll(Iterate.addAllTo(elements, HashBag.newBag(this)));</span>
    }

    @Override
    public ImmutableBag&lt;T&gt; selectByOccurrences(IntPredicate predicate)
    {
<span class="nc" id="L204">        MutableBag&lt;T&gt; result = HashBag.newBag();</span>
<span class="nc" id="L205">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            if (predicate.accept(occurrences))</span>
            {
<span class="nc" id="L208">                result.addOccurrences(each, occurrences);</span>
            }
<span class="nc" id="L210">        });</span>
<span class="nc" id="L211">        return result.toImmutable();</span>
    }

    @Override
    public &lt;S&gt; ImmutableBag&lt;S&gt; selectInstancesOf(Class&lt;S&gt; clazz)
    {
<span class="nc" id="L217">        MutableBag&lt;S&gt; result = HashBag.newBag();</span>
<span class="nc" id="L218">        this.forEachWithOccurrences((each, index) -&gt; {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (clazz.isInstance(each))</span>
            {
<span class="nc" id="L221">                result.addOccurrences((S) each, index);</span>
            }
<span class="nc" id="L223">        });</span>
<span class="nc" id="L224">        return ImmutableArrayBag.copyFrom(result);</span>
    }

    @Override
    public &lt;V&gt; ImmutableBagMultimap&lt;V, T&gt; groupBy(Function&lt;? super T, ? extends V&gt; function)
    {
<span class="nc" id="L230">        return this.groupBy(function, HashBagMultimap.&lt;V, T&gt;newMultimap()).toImmutable();</span>
    }

    @Override
    public &lt;V&gt; ImmutableBagMultimap&lt;V, T&gt; groupByEach(Function&lt;? super T, ? extends Iterable&lt;V&gt;&gt; function)
    {
<span class="nc" id="L236">        return this.groupByEach(function, HashBagMultimap.newMultimap()).toImmutable();</span>
    }

    @Override
    public T getFirst()
    {
<span class="nc" id="L242">        return ArrayIterate.getFirst(this.keys);</span>
    }

    @Override
    public T getLast()
    {
<span class="nc" id="L248">        return ArrayIterate.getLast(this.keys);</span>
    }

    @Override
    public T getOnly()
    {
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (this.counts.length == 0)</span>
        {
<span class="nc" id="L256">            throw new IllegalStateException(&quot;Size must be 1 but was 0&quot;);</span>
        }

<span class="nc bnc" id="L259" title="All 4 branches missed.">        if (this.counts.length &gt; 1 || this.counts[0] &gt; 1)</span>
        {
<span class="nc" id="L261">            throw new IllegalStateException(&quot;Size must be 1 but was greater than 1&quot;);</span>
        }

<span class="nc" id="L264">        return this.getFirst();</span>
    }

    @Override
    public ImmutableBag&lt;T&gt; select(Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L270">        return this.select(predicate, HashBag.newBag()).toImmutable();</span>
    }

    @Override
    public ImmutableBag&lt;T&gt; reject(Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L276">        return this.reject(predicate, HashBag.newBag()).toImmutable();</span>
    }

    @Override
    public &lt;V&gt; ImmutableBag&lt;V&gt; collect(Function&lt;? super T, ? extends V&gt; function)
    {
<span class="nc" id="L282">        MutableBag&lt;V&gt; result = this.collect(function, HashBag.newBag());</span>
<span class="nc" id="L283">        return ImmutableArrayBag.copyFrom(result);</span>
    }

    @Override
    public &lt;V&gt; ImmutableBag&lt;V&gt; collectIf(
            Predicate&lt;? super T&gt; predicate,
            Function&lt;? super T, ? extends V&gt; function)
    {
<span class="nc" id="L291">        MutableBag&lt;V&gt; result = this.collectIf(predicate, function, HashBag.newBag());</span>
<span class="nc" id="L292">        return ImmutableArrayBag.copyFrom(result);</span>
    }

    @Override
    public &lt;V&gt; ImmutableBag&lt;V&gt; flatCollect(Function&lt;? super T, ? extends Iterable&lt;V&gt;&gt; function)
    {
<span class="nc" id="L298">        return this.flatCollect(function, HashBag.newBag()).toImmutable();</span>
    }

    @Override
    public boolean equals(Object other)
    {
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (this == other)</span>
        {
<span class="nc" id="L306">            return true;</span>
        }
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (!(other instanceof Bag))</span>
        {
<span class="nc" id="L310">            return false;</span>
        }
<span class="nc" id="L312">        Bag&lt;?&gt; bag = (Bag&lt;?&gt;) other;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (this.size() != bag.size())</span>
        {
<span class="nc" id="L315">            return false;</span>
        }
<span class="nc bnc" id="L317" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L319" title="All 2 branches missed.">            if (this.counts[i] != bag.occurrencesOf(this.keys[i]))</span>
            {
<span class="nc" id="L321">                return false;</span>
            }
        }
<span class="nc" id="L324">        return true;</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L330">        int sum = 0;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc" id="L333">            T each = this.keys[i];</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            sum += (each == null ? 0 : each.hashCode()) ^ this.counts[i];</span>
        }
<span class="nc" id="L336">        return sum;</span>
    }

    @Override
    public void each(Procedure&lt;? super T&gt; procedure)
    {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc" id="L344">            T key = this.keys[i];</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">            for (int j = 1; j &lt;= this.counts[i]; j++)</span>
            {
<span class="nc" id="L347">                procedure.value(key);</span>
            }
        }
<span class="nc" id="L350">    }</span>

    @Override
    public Iterator&lt;T&gt; iterator()
    {
<span class="nc" id="L355">        return new ArrayBagIterator();</span>
    }

    @Override
    public boolean anySatisfy(Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L361">        return ArrayIterate.anySatisfy(this.keys, predicate);</span>
    }

    @Override
    public &lt;P&gt; boolean anySatisfyWith(Predicate2&lt;? super T, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L367">        return ArrayIterate.anySatisfyWith(this.keys, predicate, parameter);</span>
    }

    @Override
    public boolean allSatisfy(Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L373">        return ArrayIterate.allSatisfy(this.keys, predicate);</span>
    }

    @Override
    public &lt;P&gt; boolean allSatisfyWith(Predicate2&lt;? super T, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L379">        return ArrayIterate.allSatisfyWith(this.keys, predicate, parameter);</span>
    }

    @Override
    public boolean noneSatisfy(Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L385">        return ArrayIterate.noneSatisfy(this.keys, predicate);</span>
    }

    @Override
    public &lt;P&gt; boolean noneSatisfyWith(Predicate2&lt;? super T, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L391">        return ArrayIterate.noneSatisfyWith(this.keys, predicate, parameter);</span>
    }

    @Override
    public T detect(Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L397">        return ArrayIterate.detect(this.keys, predicate);</span>
    }

    @Override
    public &lt;P&gt; T detectWith(Predicate2&lt;? super T, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L403">        return ArrayIterate.detectWith(this.keys, predicate, parameter);</span>
    }

    @Override
    public Optional&lt;T&gt; detectOptional(Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L409">        return ArrayIterate.detectOptional(this.keys, predicate);</span>
    }

    @Override
    public &lt;P&gt; Optional&lt;T&gt; detectWithOptional(Predicate2&lt;? super T, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L415">        return ArrayIterate.detectWithOptional(this.keys, predicate, parameter);</span>
    }

    @Override
    public T min(Comparator&lt;? super T&gt; comparator)
    {
<span class="nc" id="L421">        return ArrayIterate.min(this.keys, comparator);</span>
    }

    @Override
    public T max(Comparator&lt;? super T&gt; comparator)
    {
<span class="nc" id="L427">        return ArrayIterate.max(this.keys, comparator);</span>
    }

    @Override
    public T min()
    {
<span class="nc" id="L433">        return ArrayIterate.min(this.keys);</span>
    }

    @Override
    public T max()
    {
<span class="nc" id="L439">        return ArrayIterate.max(this.keys);</span>
    }

    @Override
    public &lt;V extends Comparable&lt;? super V&gt;&gt; T minBy(Function&lt;? super T, ? extends V&gt; function)
    {
<span class="nc" id="L445">        return ArrayIterate.minBy(this.keys, function);</span>
    }

    @Override
    public &lt;V extends Comparable&lt;? super V&gt;&gt; T maxBy(Function&lt;? super T, ? extends V&gt; function)
    {
<span class="nc" id="L451">        return ArrayIterate.maxBy(this.keys, function);</span>
    }

    /**
     * @deprecated in 6.0. Use {@link OrderedIterable#zip(Iterable)} instead.
     */
    @Override
    @Deprecated
    public &lt;S&gt; ImmutableBag&lt;Pair&lt;T, S&gt;&gt; zip(Iterable&lt;S&gt; that)
    {
<span class="nc bnc" id="L461" title="All 4 branches missed.">        if (that instanceof Collection || that instanceof RichIterable)</span>
        {
<span class="nc" id="L463">            int thatSize = Iterate.sizeOf(that);</span>
<span class="nc" id="L464">            HashBag&lt;Pair&lt;T, S&gt;&gt; target = HashBag.newBag(Math.min(this.size(), thatSize));</span>
<span class="nc" id="L465">            return this.zip(that, target).toImmutable();</span>
        }
<span class="nc" id="L467">        return this.zip(that, HashBag.newBag()).toImmutable();</span>
    }

    /**
     * @deprecated in 6.0. Use {@link OrderedIterable#zipWithIndex()} instead.
     */
    @Override
    @Deprecated
    public ImmutableSet&lt;Pair&lt;T, Integer&gt;&gt; zipWithIndex()
    {
<span class="nc" id="L477">        return this.zipWithIndex(UnifiedSet.newSet(this.size())).toImmutable();</span>
    }

    protected Object writeReplace()
    {
<span class="nc" id="L482">        return new ImmutableBagSerializationProxy&lt;&gt;(this);</span>
    }

    private final class ArrayBagIterator
            implements Iterator&lt;T&gt;
    {
        private int position;
<span class="nc" id="L489">        private int remainingOccurrences = -1;</span>

        private ArrayBagIterator()
<span class="nc" id="L492">        {</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">            this.remainingOccurrences = ImmutableArrayBag.this.sizeDistinct() &gt; 0 ? ImmutableArrayBag.this.counts[0] : 0;</span>
<span class="nc" id="L494">        }</span>

        @Override
        public boolean hasNext()
        {
<span class="nc bnc" id="L499" title="All 2 branches missed.">            return this.position != ImmutableArrayBag.this.keys.length</span>
<span class="nc bnc" id="L500" title="All 4 branches missed.">                    &amp;&amp; !(this.position == ImmutableArrayBag.this.keys.length - 1 &amp;&amp; this.remainingOccurrences == 0);</span>
        }

        @Override
        public T next()
        {
<span class="nc bnc" id="L506" title="All 2 branches missed.">            if (!this.hasNext())</span>
            {
<span class="nc" id="L508">                throw new NoSuchElementException();</span>
            }

<span class="nc" id="L511">            T result = ImmutableArrayBag.this.keys[this.position];</span>

<span class="nc" id="L513">            this.remainingOccurrences--;</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">            if (this.remainingOccurrences == 0)</span>
            {
<span class="nc" id="L516">                this.position++;</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                if (this.position != ImmutableArrayBag.this.keys.length)</span>
                {
<span class="nc" id="L519">                    this.remainingOccurrences = ImmutableArrayBag.this.counts[this.position];</span>
                }
            }
<span class="nc" id="L522">            return result;</span>
        }

        @Override
        public void remove()
        {
<span class="nc" id="L528">            throw new UnsupportedOperationException(&quot;Cannot remove from an ImmutableArrayBag&quot;);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>