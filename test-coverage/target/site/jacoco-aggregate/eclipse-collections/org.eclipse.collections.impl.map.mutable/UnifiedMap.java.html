<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>UnifiedMap.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.impl.map.mutable</a> &gt; <span class="el_source">UnifiedMap.java</span></div><h1>UnifiedMap.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2016 Goldman Sachs.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.impl.map.mutable;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.Serializable;
import java.lang.ref.WeakReference;
import java.lang.reflect.Array;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Set;

import org.eclipse.collections.api.block.function.Function;
import org.eclipse.collections.api.block.function.Function0;
import org.eclipse.collections.api.block.function.Function2;
import org.eclipse.collections.api.block.predicate.Predicate;
import org.eclipse.collections.api.block.predicate.Predicate2;
import org.eclipse.collections.api.block.procedure.Procedure;
import org.eclipse.collections.api.block.procedure.Procedure2;
import org.eclipse.collections.api.block.procedure.primitive.ObjectIntProcedure;
import org.eclipse.collections.api.map.ImmutableMap;
import org.eclipse.collections.api.map.MapIterable;
import org.eclipse.collections.api.map.MutableMap;
import org.eclipse.collections.api.map.UnsortedMapIterable;
import org.eclipse.collections.api.tuple.Pair;
import org.eclipse.collections.impl.block.factory.Functions;
import org.eclipse.collections.impl.block.factory.Predicates;
import org.eclipse.collections.impl.block.procedure.MapCollectProcedure;
import org.eclipse.collections.impl.factory.Maps;
import org.eclipse.collections.impl.factory.Sets;
import org.eclipse.collections.impl.list.mutable.FastList;
import org.eclipse.collections.impl.parallel.BatchIterable;
import org.eclipse.collections.impl.set.mutable.UnifiedSet;
import org.eclipse.collections.impl.tuple.ImmutableEntry;
import org.eclipse.collections.impl.tuple.Tuples;
import org.eclipse.collections.impl.utility.ArrayIterate;
import org.eclipse.collections.impl.utility.Iterate;

/**
 * UnifiedMap stores key/value pairs in a single array, where alternate slots are keys and values.  This is nicer to CPU caches as
 * consecutive memory addresses are very cheap to access.  Entry objects are not stored in the table like in java.util.HashMap.
 * Instead of trying to deal with collisions in the main array using Entry objects, we put a special object in
 * the key slot and put a regular Object[] in the value slot. The array contains the key value pairs in consecutive slots,
 * just like the main array, but it's a linear list with no hashing.
 * &lt;p&gt;
 * The final result is a Map implementation that's leaner than java.util.HashMap and faster than Trove's THashMap.
 * The best of both approaches unified together, and thus the name UnifiedMap.
 */

@SuppressWarnings(&quot;ObjectEquality&quot;)
public class UnifiedMap&lt;K, V&gt; extends AbstractMutableMap&lt;K, V&gt;
        implements Externalizable, BatchIterable&lt;V&gt;
{
<span class="nc" id="L69">    protected static final Object NULL_KEY = new Object()</span>
<span class="nc" id="L70">    {</span>
        @Override
        public boolean equals(Object obj)
        {
<span class="nc" id="L74">            throw new RuntimeException(&quot;Possible corruption through unsynchronized concurrent modification.&quot;);</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L80">            throw new RuntimeException(&quot;Possible corruption through unsynchronized concurrent modification.&quot;);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L86">            return &quot;UnifiedMap.NULL_KEY&quot;;</span>
        }
    };

<span class="nc" id="L90">    protected static final Object CHAINED_KEY = new Object()</span>
<span class="nc" id="L91">    {</span>
        @Override
        public boolean equals(Object obj)
        {
<span class="nc" id="L95">            throw new RuntimeException(&quot;Possible corruption through unsynchronized concurrent modification.&quot;);</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L101">            throw new RuntimeException(&quot;Possible corruption through unsynchronized concurrent modification.&quot;);</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L107">            return &quot;UnifiedMap.CHAINED_KEY&quot;;</span>
        }
    };

    protected static final float DEFAULT_LOAD_FACTOR = 0.75f;

    protected static final int DEFAULT_INITIAL_CAPACITY = 8;

    private static final long serialVersionUID = 1L;

    protected transient Object[] table;

    protected transient int occupied;

<span class="nc" id="L121">    protected float loadFactor = DEFAULT_LOAD_FACTOR;</span>

    protected int maxSize;

    public UnifiedMap()
<span class="nc" id="L126">    {</span>
<span class="nc" id="L127">        this.allocate(DEFAULT_INITIAL_CAPACITY &lt;&lt; 1);</span>
<span class="nc" id="L128">    }</span>

    public UnifiedMap(int initialCapacity)
    {
<span class="nc" id="L132">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span>
<span class="nc" id="L133">    }</span>

    public UnifiedMap(int initialCapacity, float loadFactor)
<span class="nc" id="L136">    {</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (initialCapacity &lt; 0)</span>
        {
<span class="nc" id="L139">            throw new IllegalArgumentException(&quot;initial capacity cannot be less than 0&quot;);</span>
        }
<span class="nc bnc" id="L141" title="All 2 branches missed.">        if (loadFactor &lt;= 0.0)</span>
        {
<span class="nc" id="L143">            throw new IllegalArgumentException(&quot;load factor cannot be less than or equal to 0&quot;);</span>
        }
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (loadFactor &gt; 1.0)</span>
        {
<span class="nc" id="L147">            throw new IllegalArgumentException(&quot;load factor cannot be greater than 1&quot;);</span>
        }

<span class="nc" id="L150">        this.loadFactor = loadFactor;</span>
<span class="nc" id="L151">        this.init(this.fastCeil(initialCapacity / loadFactor));</span>
<span class="nc" id="L152">    }</span>

    public UnifiedMap(Map&lt;? extends K, ? extends V&gt; map)
    {
<span class="nc" id="L156">        this(Math.max(map.size(), DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span>

<span class="nc" id="L158">        this.putAll(map);</span>
<span class="nc" id="L159">    }</span>

    public UnifiedMap(Pair&lt;K, V&gt;... pairs)
    {
<span class="nc" id="L163">        this(Math.max(pairs.length, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span>
<span class="nc" id="L164">        ArrayIterate.forEach(pairs, new MapCollectProcedure&lt;Pair&lt;K, V&gt;, K, V&gt;(</span>
                this,
<span class="nc" id="L166">                Functions.firstOfPair(),</span>
<span class="nc" id="L167">                Functions.secondOfPair()));</span>
<span class="nc" id="L168">    }</span>

    public static &lt;K, V&gt; UnifiedMap&lt;K, V&gt; newMap()
    {
<span class="nc" id="L172">        return new UnifiedMap&lt;&gt;();</span>
    }

    public static &lt;K, V&gt; UnifiedMap&lt;K, V&gt; newMap(int size)
    {
<span class="nc" id="L177">        return new UnifiedMap&lt;&gt;(size);</span>
    }

    public static &lt;K, V&gt; UnifiedMap&lt;K, V&gt; newMap(int size, float loadFactor)
    {
<span class="nc" id="L182">        return new UnifiedMap&lt;&gt;(size, loadFactor);</span>
    }

    public static &lt;K, V&gt; UnifiedMap&lt;K, V&gt; newMap(Map&lt;? extends K, ? extends V&gt; map)
    {
<span class="nc" id="L187">        return new UnifiedMap&lt;&gt;(map);</span>
    }

    public static &lt;K, V&gt; UnifiedMap&lt;K, V&gt; newMapWith(Pair&lt;K, V&gt;... pairs)
    {
<span class="nc" id="L192">        return new UnifiedMap&lt;&gt;(pairs);</span>
    }

    public static &lt;K, V&gt; UnifiedMap&lt;K, V&gt; newMapWith(Iterable&lt;Pair&lt;K, V&gt;&gt; inputIterable)
    {
<span class="nc" id="L197">        UnifiedMap&lt;K, V&gt; outputMap = UnifiedMap.newMap();</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">        for (Pair&lt;K, V&gt; single : inputIterable)</span>
        {
<span class="nc" id="L200">            outputMap.add(single);</span>
<span class="nc" id="L201">        }</span>
<span class="nc" id="L202">        return outputMap;</span>
    }

    public static &lt;K, V&gt; UnifiedMap&lt;K, V&gt; newWithKeysValues(K key, V value)
    {
<span class="nc" id="L207">        return new UnifiedMap&lt;K, V&gt;(1).withKeysValues(key, value);</span>
    }

    public static &lt;K, V&gt; UnifiedMap&lt;K, V&gt; newWithKeysValues(K key1, V value1, K key2, V value2)
    {
<span class="nc" id="L212">        return new UnifiedMap&lt;K, V&gt;(2).withKeysValues(key1, value1, key2, value2);</span>
    }

    public static &lt;K, V&gt; UnifiedMap&lt;K, V&gt; newWithKeysValues(K key1, V value1, K key2, V value2, K key3, V value3)
    {
<span class="nc" id="L217">        return new UnifiedMap&lt;K, V&gt;(3).withKeysValues(key1, value1, key2, value2, key3, value3);</span>
    }

    public static &lt;K, V&gt; UnifiedMap&lt;K, V&gt; newWithKeysValues(
            K key1, V value1,
            K key2, V value2,
            K key3, V value3,
            K key4, V value4)
    {
<span class="nc" id="L226">        return new UnifiedMap&lt;K, V&gt;(4).withKeysValues(key1, value1, key2, value2, key3, value3, key4, value4);</span>
    }

    public UnifiedMap&lt;K, V&gt; withKeysValues(K key, V value)
    {
<span class="nc" id="L231">        this.put(key, value);</span>
<span class="nc" id="L232">        return this;</span>
    }

    public UnifiedMap&lt;K, V&gt; withKeysValues(K key1, V value1, K key2, V value2)
    {
<span class="nc" id="L237">        this.put(key1, value1);</span>
<span class="nc" id="L238">        this.put(key2, value2);</span>
<span class="nc" id="L239">        return this;</span>
    }

    public UnifiedMap&lt;K, V&gt; withKeysValues(K key1, V value1, K key2, V value2, K key3, V value3)
    {
<span class="nc" id="L244">        this.put(key1, value1);</span>
<span class="nc" id="L245">        this.put(key2, value2);</span>
<span class="nc" id="L246">        this.put(key3, value3);</span>
<span class="nc" id="L247">        return this;</span>
    }

    public UnifiedMap&lt;K, V&gt; withKeysValues(K key1, V value1, K key2, V value2, K key3, V value3, K key4, V value4)
    {
<span class="nc" id="L252">        this.put(key1, value1);</span>
<span class="nc" id="L253">        this.put(key2, value2);</span>
<span class="nc" id="L254">        this.put(key3, value3);</span>
<span class="nc" id="L255">        this.put(key4, value4);</span>
<span class="nc" id="L256">        return this;</span>
    }

    @Override
    public UnifiedMap&lt;K, V&gt; clone()
    {
<span class="nc" id="L262">        return new UnifiedMap&lt;&gt;(this);</span>
    }

    @Override
    public MutableMap&lt;K, V&gt; newEmpty()
    {
<span class="nc" id="L268">        return new UnifiedMap&lt;&gt;();</span>
    }

    @Override
    public MutableMap&lt;K, V&gt; newEmpty(int capacity)
    {
<span class="nc" id="L274">        return new UnifiedMap&lt;&gt;(capacity, this.loadFactor);</span>
    }

    private int fastCeil(float v)
    {
<span class="nc" id="L279">        int possibleResult = (int) v;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (v - possibleResult &gt; 0.0F)</span>
        {
<span class="nc" id="L282">            possibleResult++;</span>
        }
<span class="nc" id="L284">        return possibleResult;</span>
    }

    protected int init(int initialCapacity)
    {
<span class="nc" id="L289">        int capacity = 1;</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">        while (capacity &lt; initialCapacity)</span>
        {
<span class="nc" id="L292">            capacity &lt;&lt;= 1;</span>
        }

<span class="nc" id="L295">        return this.allocate(capacity);</span>
    }

    protected int allocate(int capacity)
    {
<span class="nc" id="L300">        this.allocateTable(capacity &lt;&lt; 1); // the table size is twice the capacity to handle both keys and values</span>
<span class="nc" id="L301">        this.computeMaxSize(capacity);</span>

<span class="nc" id="L303">        return capacity;</span>
    }

    protected void allocateTable(int sizeToAllocate)
    {
<span class="nc" id="L308">        this.table = new Object[sizeToAllocate];</span>
<span class="nc" id="L309">    }</span>

    protected void computeMaxSize(int capacity)
    {
<span class="nc" id="L313">        this.maxSize = Math.min(capacity - 1, (int) (capacity * this.loadFactor));</span>
<span class="nc" id="L314">    }</span>

    protected int index(Object key)
    {
        // This function ensures that hashCodes that differ only by
        // constant multiples at each bit position have a bounded
        // number of collisions (approximately 8 at default load factor).
<span class="nc bnc" id="L321" title="All 2 branches missed.">        int h = key == null ? 0 : key.hashCode();</span>
<span class="nc" id="L322">        h ^= h &gt;&gt;&gt; 20 ^ h &gt;&gt;&gt; 12;</span>
<span class="nc" id="L323">        h ^= h &gt;&gt;&gt; 7 ^ h &gt;&gt;&gt; 4;</span>
<span class="nc" id="L324">        return (h &amp; (this.table.length &gt;&gt; 1) - 1) &lt;&lt; 1;</span>
    }

    @Override
    public void clear()
    {
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (this.occupied == 0)</span>
        {
<span class="nc" id="L332">            return;</span>
        }
<span class="nc" id="L334">        this.occupied = 0;</span>
<span class="nc" id="L335">        Object[] set = this.table;</span>

<span class="nc bnc" id="L337" title="All 2 branches missed.">        for (int i = set.length; i-- &gt; 0; )</span>
        {
<span class="nc" id="L339">            set[i] = null;</span>
        }
<span class="nc" id="L341">    }</span>

    @Override
    public V put(K key, V value)
    {
<span class="nc" id="L346">        int index = this.index(key);</span>
<span class="nc" id="L347">        Object cur = this.table[index];</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L350">            this.table[index] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L351">            this.table[index + 1] = value;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L354">                this.rehash(this.table.length);</span>
            }
<span class="nc" id="L356">            return null;</span>
        }
<span class="nc bnc" id="L358" title="All 4 branches missed.">        if (cur != CHAINED_KEY &amp;&amp; this.nonNullTableObjectEquals(cur, key))</span>
        {
<span class="nc" id="L360">            V result = (V) this.table[index + 1];</span>
<span class="nc" id="L361">            this.table[index + 1] = value;</span>
<span class="nc" id="L362">            return result;</span>
        }
<span class="nc" id="L364">        return this.chainedPut(key, index, value);</span>
    }

    private V chainedPut(K key, int index, V value)
    {
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (this.table[index] == CHAINED_KEY)</span>
        {
<span class="nc" id="L371">            Object[] chain = (Object[]) this.table[index + 1];</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc bnc" id="L374" title="All 2 branches missed.">                if (chain[i] == null)</span>
                {
<span class="nc" id="L376">                    chain[i] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L377">                    chain[i + 1] = value;</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                    if (++this.occupied &gt; this.maxSize)</span>
                    {
<span class="nc" id="L380">                        this.rehash(this.table.length);</span>
                    }
<span class="nc" id="L382">                    return null;</span>
                }
<span class="nc bnc" id="L384" title="All 2 branches missed.">                if (this.nonNullTableObjectEquals(chain[i], key))</span>
                {
<span class="nc" id="L386">                    V result = (V) chain[i + 1];</span>
<span class="nc" id="L387">                    chain[i + 1] = value;</span>
<span class="nc" id="L388">                    return result;</span>
                }
            }
<span class="nc" id="L391">            Object[] newChain = new Object[chain.length + 4];</span>
<span class="nc" id="L392">            System.arraycopy(chain, 0, newChain, 0, chain.length);</span>
<span class="nc" id="L393">            this.table[index + 1] = newChain;</span>
<span class="nc" id="L394">            newChain[chain.length] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L395">            newChain[chain.length + 1] = value;</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L398">                this.rehash(this.table.length);</span>
            }
<span class="nc" id="L400">            return null;</span>
        }
<span class="nc" id="L402">        Object[] newChain = new Object[4];</span>
<span class="nc" id="L403">        newChain[0] = this.table[index];</span>
<span class="nc" id="L404">        newChain[1] = this.table[index + 1];</span>
<span class="nc" id="L405">        newChain[2] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L406">        newChain[3] = value;</span>
<span class="nc" id="L407">        this.table[index] = CHAINED_KEY;</span>
<span class="nc" id="L408">        this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">        if (++this.occupied &gt; this.maxSize)</span>
        {
<span class="nc" id="L411">            this.rehash(this.table.length);</span>
        }
<span class="nc" id="L413">        return null;</span>
    }

    @Override
    public V updateValue(K key, Function0&lt;? extends V&gt; factory, Function&lt;? super V, ? extends V&gt; function)
    {
<span class="nc" id="L419">        int index = this.index(key);</span>
<span class="nc" id="L420">        Object cur = this.table[index];</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L423">            this.table[index] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L424">            V result = function.valueOf(factory.value());</span>
<span class="nc" id="L425">            this.table[index + 1] = result;</span>
<span class="nc" id="L426">            ++this.occupied;</span>
<span class="nc" id="L427">            return result;</span>
        }
<span class="nc bnc" id="L429" title="All 4 branches missed.">        if (cur != CHAINED_KEY &amp;&amp; this.nonNullTableObjectEquals(cur, key))</span>
        {
<span class="nc" id="L431">            V oldValue = (V) this.table[index + 1];</span>
<span class="nc" id="L432">            V newValue = function.valueOf(oldValue);</span>
<span class="nc" id="L433">            this.table[index + 1] = newValue;</span>
<span class="nc" id="L434">            return newValue;</span>
        }
<span class="nc" id="L436">        return this.chainedUpdateValue(key, index, factory, function);</span>
    }

    private V chainedUpdateValue(K key, int index, Function0&lt;? extends V&gt; factory, Function&lt;? super V, ? extends V&gt; function)
    {
<span class="nc bnc" id="L441" title="All 2 branches missed.">        if (this.table[index] == CHAINED_KEY)</span>
        {
<span class="nc" id="L443">            Object[] chain = (Object[]) this.table[index + 1];</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc bnc" id="L446" title="All 2 branches missed.">                if (chain[i] == null)</span>
                {
<span class="nc" id="L448">                    chain[i] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L449">                    V result = function.valueOf(factory.value());</span>
<span class="nc" id="L450">                    chain[i + 1] = result;</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">                    if (++this.occupied &gt; this.maxSize)</span>
                    {
<span class="nc" id="L453">                        this.rehash(this.table.length);</span>
                    }
<span class="nc" id="L455">                    return result;</span>
                }
<span class="nc bnc" id="L457" title="All 2 branches missed.">                if (this.nonNullTableObjectEquals(chain[i], key))</span>
                {
<span class="nc" id="L459">                    V oldValue = (V) chain[i + 1];</span>
<span class="nc" id="L460">                    V result = function.valueOf(oldValue);</span>
<span class="nc" id="L461">                    chain[i + 1] = result;</span>
<span class="nc" id="L462">                    return result;</span>
                }
            }
<span class="nc" id="L465">            Object[] newChain = new Object[chain.length + 4];</span>
<span class="nc" id="L466">            System.arraycopy(chain, 0, newChain, 0, chain.length);</span>
<span class="nc" id="L467">            this.table[index + 1] = newChain;</span>
<span class="nc" id="L468">            newChain[chain.length] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L469">            V result = function.valueOf(factory.value());</span>
<span class="nc" id="L470">            newChain[chain.length + 1] = result;</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L473">                this.rehash(this.table.length);</span>
            }
<span class="nc" id="L475">            return result;</span>
        }
<span class="nc" id="L477">        Object[] newChain = new Object[4];</span>
<span class="nc" id="L478">        newChain[0] = this.table[index];</span>
<span class="nc" id="L479">        newChain[1] = this.table[index + 1];</span>
<span class="nc" id="L480">        newChain[2] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L481">        V result = function.valueOf(factory.value());</span>
<span class="nc" id="L482">        newChain[3] = result;</span>
<span class="nc" id="L483">        this.table[index] = CHAINED_KEY;</span>
<span class="nc" id="L484">        this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">        if (++this.occupied &gt; this.maxSize)</span>
        {
<span class="nc" id="L487">            this.rehash(this.table.length);</span>
        }
<span class="nc" id="L489">        return result;</span>
    }

    @Override
    public &lt;P&gt; V updateValueWith(K key, Function0&lt;? extends V&gt; factory, Function2&lt;? super V, ? super P, ? extends V&gt; function, P parameter)
    {
<span class="nc" id="L495">        int index = this.index(key);</span>
<span class="nc" id="L496">        Object cur = this.table[index];</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L499">            this.table[index] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L500">            V result = function.value(factory.value(), parameter);</span>
<span class="nc" id="L501">            this.table[index + 1] = result;</span>
<span class="nc" id="L502">            ++this.occupied;</span>
<span class="nc" id="L503">            return result;</span>
        }
<span class="nc bnc" id="L505" title="All 4 branches missed.">        if (cur != CHAINED_KEY &amp;&amp; this.nonNullTableObjectEquals(cur, key))</span>
        {
<span class="nc" id="L507">            V oldValue = (V) this.table[index + 1];</span>
<span class="nc" id="L508">            V newValue = function.value(oldValue, parameter);</span>
<span class="nc" id="L509">            this.table[index + 1] = newValue;</span>
<span class="nc" id="L510">            return newValue;</span>
        }
<span class="nc" id="L512">        return this.chainedUpdateValueWith(key, index, factory, function, parameter);</span>
    }

    private &lt;P&gt; V chainedUpdateValueWith(
            K key,
            int index,
            Function0&lt;? extends V&gt; factory,
            Function2&lt;? super V, ? super P, ? extends V&gt; function,
            P parameter)
    {
<span class="nc bnc" id="L522" title="All 2 branches missed.">        if (this.table[index] == CHAINED_KEY)</span>
        {
<span class="nc" id="L524">            Object[] chain = (Object[]) this.table[index + 1];</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc bnc" id="L527" title="All 2 branches missed.">                if (chain[i] == null)</span>
                {
<span class="nc" id="L529">                    chain[i] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L530">                    V result = function.value(factory.value(), parameter);</span>
<span class="nc" id="L531">                    chain[i + 1] = result;</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">                    if (++this.occupied &gt; this.maxSize)</span>
                    {
<span class="nc" id="L534">                        this.rehash(this.table.length);</span>
                    }
<span class="nc" id="L536">                    return result;</span>
                }
<span class="nc bnc" id="L538" title="All 2 branches missed.">                if (this.nonNullTableObjectEquals(chain[i], key))</span>
                {
<span class="nc" id="L540">                    V oldValue = (V) chain[i + 1];</span>
<span class="nc" id="L541">                    V result = function.value(oldValue, parameter);</span>
<span class="nc" id="L542">                    chain[i + 1] = result;</span>
<span class="nc" id="L543">                    return result;</span>
                }
            }
<span class="nc" id="L546">            Object[] newChain = new Object[chain.length + 4];</span>
<span class="nc" id="L547">            System.arraycopy(chain, 0, newChain, 0, chain.length);</span>
<span class="nc" id="L548">            this.table[index + 1] = newChain;</span>
<span class="nc" id="L549">            newChain[chain.length] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L550">            V result = function.value(factory.value(), parameter);</span>
<span class="nc" id="L551">            newChain[chain.length + 1] = result;</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L554">                this.rehash(this.table.length);</span>
            }
<span class="nc" id="L556">            return result;</span>
        }
<span class="nc" id="L558">        Object[] newChain = new Object[4];</span>
<span class="nc" id="L559">        newChain[0] = this.table[index];</span>
<span class="nc" id="L560">        newChain[1] = this.table[index + 1];</span>
<span class="nc" id="L561">        newChain[2] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L562">        V result = function.value(factory.value(), parameter);</span>
<span class="nc" id="L563">        newChain[3] = result;</span>
<span class="nc" id="L564">        this.table[index] = CHAINED_KEY;</span>
<span class="nc" id="L565">        this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">        if (++this.occupied &gt; this.maxSize)</span>
        {
<span class="nc" id="L568">            this.rehash(this.table.length);</span>
        }
<span class="nc" id="L570">        return result;</span>
    }

    @Override
    public V getIfAbsentPut(K key, Function0&lt;? extends V&gt; function)
    {
<span class="nc" id="L576">        int index = this.index(key);</span>
<span class="nc" id="L577">        Object cur = this.table[index];</span>

<span class="nc bnc" id="L579" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L581">            V result = function.value();</span>
<span class="nc" id="L582">            this.table[index] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L583">            this.table[index + 1] = result;</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L586">                this.rehash(this.table.length);</span>
            }
<span class="nc" id="L588">            return result;</span>
        }
<span class="nc bnc" id="L590" title="All 4 branches missed.">        if (cur != CHAINED_KEY &amp;&amp; this.nonNullTableObjectEquals(cur, key))</span>
        {
<span class="nc" id="L592">            return (V) this.table[index + 1];</span>
        }
<span class="nc" id="L594">        return this.chainedGetIfAbsentPut(key, index, function);</span>
    }

    private V chainedGetIfAbsentPut(K key, int index, Function0&lt;? extends V&gt; function)
    {
<span class="nc" id="L599">        V result = null;</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">        if (this.table[index] == CHAINED_KEY)</span>
        {
<span class="nc" id="L602">            Object[] chain = (Object[]) this.table[index + 1];</span>
<span class="nc" id="L603">            int i = 0;</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">            for (; i &lt; chain.length; i += 2)</span>
            {
<span class="nc bnc" id="L606" title="All 2 branches missed.">                if (chain[i] == null)</span>
                {
<span class="nc" id="L608">                    result = function.value();</span>
<span class="nc" id="L609">                    chain[i] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L610">                    chain[i + 1] = result;</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">                    if (++this.occupied &gt; this.maxSize)</span>
                    {
<span class="nc" id="L613">                        this.rehash(this.table.length);</span>
                    }
                    break;
                }
<span class="nc bnc" id="L617" title="All 2 branches missed.">                if (this.nonNullTableObjectEquals(chain[i], key))</span>
                {
<span class="nc" id="L619">                    result = (V) chain[i + 1];</span>
<span class="nc" id="L620">                    break;</span>
                }
            }
<span class="nc bnc" id="L623" title="All 2 branches missed.">            if (i == chain.length)</span>
            {
<span class="nc" id="L625">                result = function.value();</span>
<span class="nc" id="L626">                Object[] newChain = new Object[chain.length + 4];</span>
<span class="nc" id="L627">                System.arraycopy(chain, 0, newChain, 0, chain.length);</span>
<span class="nc" id="L628">                newChain[i] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L629">                newChain[i + 1] = result;</span>
<span class="nc" id="L630">                this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">                if (++this.occupied &gt; this.maxSize)</span>
                {
<span class="nc" id="L633">                    this.rehash(this.table.length);</span>
                }
            }
<span class="nc" id="L636">        }</span>
        else
        {
<span class="nc" id="L639">            result = function.value();</span>
<span class="nc" id="L640">            Object[] newChain = new Object[4];</span>
<span class="nc" id="L641">            newChain[0] = this.table[index];</span>
<span class="nc" id="L642">            newChain[1] = this.table[index + 1];</span>
<span class="nc" id="L643">            newChain[2] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L644">            newChain[3] = result;</span>
<span class="nc" id="L645">            this.table[index] = CHAINED_KEY;</span>
<span class="nc" id="L646">            this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L649">                this.rehash(this.table.length);</span>
            }
        }
<span class="nc" id="L652">        return result;</span>
    }

    @Override
    public V getIfAbsentPut(K key, V value)
    {
<span class="nc" id="L658">        int index = this.index(key);</span>
<span class="nc" id="L659">        Object cur = this.table[index];</span>

<span class="nc bnc" id="L661" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L663">            this.table[index] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L664">            this.table[index + 1] = value;</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L667">                this.rehash(this.table.length);</span>
            }
<span class="nc" id="L669">            return value;</span>
        }
<span class="nc bnc" id="L671" title="All 4 branches missed.">        if (cur != CHAINED_KEY &amp;&amp; this.nonNullTableObjectEquals(cur, key))</span>
        {
<span class="nc" id="L673">            return (V) this.table[index + 1];</span>
        }
<span class="nc" id="L675">        return this.chainedGetIfAbsentPut(key, index, value);</span>
    }

    private V chainedGetIfAbsentPut(K key, int index, V value)
    {
<span class="nc" id="L680">        V result = value;</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (this.table[index] == CHAINED_KEY)</span>
        {
<span class="nc" id="L683">            Object[] chain = (Object[]) this.table[index + 1];</span>
<span class="nc" id="L684">            int i = 0;</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">            for (; i &lt; chain.length; i += 2)</span>
            {
<span class="nc bnc" id="L687" title="All 2 branches missed.">                if (chain[i] == null)</span>
                {
<span class="nc" id="L689">                    chain[i] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L690">                    chain[i + 1] = value;</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">                    if (++this.occupied &gt; this.maxSize)</span>
                    {
<span class="nc" id="L693">                        this.rehash(this.table.length);</span>
                    }
                    break;
                }
<span class="nc bnc" id="L697" title="All 2 branches missed.">                if (this.nonNullTableObjectEquals(chain[i], key))</span>
                {
<span class="nc" id="L699">                    result = (V) chain[i + 1];</span>
<span class="nc" id="L700">                    break;</span>
                }
            }
<span class="nc bnc" id="L703" title="All 2 branches missed.">            if (i == chain.length)</span>
            {
<span class="nc" id="L705">                Object[] newChain = new Object[chain.length + 4];</span>
<span class="nc" id="L706">                System.arraycopy(chain, 0, newChain, 0, chain.length);</span>
<span class="nc" id="L707">                newChain[i] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L708">                newChain[i + 1] = value;</span>
<span class="nc" id="L709">                this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">                if (++this.occupied &gt; this.maxSize)</span>
                {
<span class="nc" id="L712">                    this.rehash(this.table.length);</span>
                }
            }
<span class="nc" id="L715">        }</span>
        else
        {
<span class="nc" id="L718">            Object[] newChain = new Object[4];</span>
<span class="nc" id="L719">            newChain[0] = this.table[index];</span>
<span class="nc" id="L720">            newChain[1] = this.table[index + 1];</span>
<span class="nc" id="L721">            newChain[2] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L722">            newChain[3] = value;</span>
<span class="nc" id="L723">            this.table[index] = CHAINED_KEY;</span>
<span class="nc" id="L724">            this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L727">                this.rehash(this.table.length);</span>
            }
        }
<span class="nc" id="L730">        return result;</span>
    }

    @Override
    public &lt;P&gt; V getIfAbsentPutWith(K key, Function&lt;? super P, ? extends V&gt; function, P parameter)
    {
<span class="nc" id="L736">        int index = this.index(key);</span>
<span class="nc" id="L737">        Object cur = this.table[index];</span>

<span class="nc bnc" id="L739" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L741">            V result = function.valueOf(parameter);</span>
<span class="nc" id="L742">            this.table[index] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L743">            this.table[index + 1] = result;</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L746">                this.rehash(this.table.length);</span>
            }
<span class="nc" id="L748">            return result;</span>
        }
<span class="nc bnc" id="L750" title="All 4 branches missed.">        if (cur != CHAINED_KEY &amp;&amp; this.nonNullTableObjectEquals(cur, key))</span>
        {
<span class="nc" id="L752">            return (V) this.table[index + 1];</span>
        }
<span class="nc" id="L754">        return this.chainedGetIfAbsentPutWith(key, index, function, parameter);</span>
    }

    private &lt;P&gt; V chainedGetIfAbsentPutWith(K key, int index, Function&lt;? super P, ? extends V&gt; function, P parameter)
    {
<span class="nc" id="L759">        V result = null;</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">        if (this.table[index] == CHAINED_KEY)</span>
        {
<span class="nc" id="L762">            Object[] chain = (Object[]) this.table[index + 1];</span>
<span class="nc" id="L763">            int i = 0;</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">            for (; i &lt; chain.length; i += 2)</span>
            {
<span class="nc bnc" id="L766" title="All 2 branches missed.">                if (chain[i] == null)</span>
                {
<span class="nc" id="L768">                    result = function.valueOf(parameter);</span>
<span class="nc" id="L769">                    chain[i] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L770">                    chain[i + 1] = result;</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">                    if (++this.occupied &gt; this.maxSize)</span>
                    {
<span class="nc" id="L773">                        this.rehash(this.table.length);</span>
                    }
                    break;
                }
<span class="nc bnc" id="L777" title="All 2 branches missed.">                if (this.nonNullTableObjectEquals(chain[i], key))</span>
                {
<span class="nc" id="L779">                    result = (V) chain[i + 1];</span>
<span class="nc" id="L780">                    break;</span>
                }
            }
<span class="nc bnc" id="L783" title="All 2 branches missed.">            if (i == chain.length)</span>
            {
<span class="nc" id="L785">                result = function.valueOf(parameter);</span>
<span class="nc" id="L786">                Object[] newChain = new Object[chain.length + 4];</span>
<span class="nc" id="L787">                System.arraycopy(chain, 0, newChain, 0, chain.length);</span>
<span class="nc" id="L788">                newChain[i] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L789">                newChain[i + 1] = result;</span>
<span class="nc" id="L790">                this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">                if (++this.occupied &gt; this.maxSize)</span>
                {
<span class="nc" id="L793">                    this.rehash(this.table.length);</span>
                }
            }
<span class="nc" id="L796">        }</span>
        else
        {
<span class="nc" id="L799">            result = function.valueOf(parameter);</span>
<span class="nc" id="L800">            Object[] newChain = new Object[4];</span>
<span class="nc" id="L801">            newChain[0] = this.table[index];</span>
<span class="nc" id="L802">            newChain[1] = this.table[index + 1];</span>
<span class="nc" id="L803">            newChain[2] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L804">            newChain[3] = result;</span>
<span class="nc" id="L805">            this.table[index] = CHAINED_KEY;</span>
<span class="nc" id="L806">            this.table[index + 1] = newChain;</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">            if (++this.occupied &gt; this.maxSize)</span>
            {
<span class="nc" id="L809">                this.rehash(this.table.length);</span>
            }
        }
<span class="nc" id="L812">        return result;</span>
    }

    public int getCollidingBuckets()
    {
<span class="nc" id="L817">        int count = 0;</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L820" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L822">                count++;</span>
            }
        }
<span class="nc" id="L825">        return count;</span>
    }

    /**
     * Returns the number of JVM words that is used by this map.  A word is 4 bytes in a 32bit VM and 8 bytes in a 64bit
     * VM. Each array has a 2 word header, thus the formula is:
     * words = (internal table length + 2) + sum (for all chains (chain length + 2))
     *
     * @return the number of JVM words that is used by this map.
     */
    public int getMapMemoryUsedInWords()
    {
<span class="nc" id="L837">        int headerSize = 2;</span>
<span class="nc" id="L838">        int sizeInWords = this.table.length + headerSize;</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L841" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L843">                sizeInWords += headerSize + ((Object[]) this.table[i + 1]).length;</span>
            }
        }
<span class="nc" id="L846">        return sizeInWords;</span>
    }

    protected void rehash(int newCapacity)
    {
<span class="nc" id="L851">        int oldLength = this.table.length;</span>
<span class="nc" id="L852">        Object[] old = this.table;</span>
<span class="nc" id="L853">        this.allocate(newCapacity);</span>
<span class="nc" id="L854">        this.occupied = 0;</span>

<span class="nc bnc" id="L856" title="All 2 branches missed.">        for (int i = 0; i &lt; oldLength; i += 2)</span>
        {
<span class="nc" id="L858">            Object cur = old[i];</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L861">                Object[] chain = (Object[]) old[i + 1];</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">                for (int j = 0; j &lt; chain.length; j += 2)</span>
                {
<span class="nc bnc" id="L864" title="All 2 branches missed.">                    if (chain[j] != null)</span>
                    {
<span class="nc" id="L866">                        this.put(this.nonSentinel(chain[j]), (V) chain[j + 1]);</span>
                    }
                }
<span class="nc" id="L869">            }</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L872">                this.put(this.nonSentinel(cur), (V) old[i + 1]);</span>
            }
        }
<span class="nc" id="L875">    }</span>

    @Override
    public V get(Object key)
    {
<span class="nc" id="L880">        int index = this.index(key);</span>
<span class="nc" id="L881">        Object cur = this.table[index];</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">        if (cur != null)</span>
        {
<span class="nc" id="L884">            Object val = this.table[index + 1];</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L887">                return this.getFromChain((Object[]) val, (K) key);</span>
            }
<span class="nc bnc" id="L889" title="All 2 branches missed.">            if (this.nonNullTableObjectEquals(cur, (K) key))</span>
            {
<span class="nc" id="L891">                return (V) val;</span>
            }
        }
<span class="nc" id="L894">        return null;</span>
    }

    private V getFromChain(Object[] chain, K key)
    {
<span class="nc bnc" id="L899" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L901">            Object k = chain[i];</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">            if (k == null)</span>
            {
<span class="nc" id="L904">                return null;</span>
            }
<span class="nc bnc" id="L906" title="All 2 branches missed.">            if (this.nonNullTableObjectEquals(k, key))</span>
            {
<span class="nc" id="L908">                return (V) chain[i + 1];</span>
            }
        }
<span class="nc" id="L911">        return null;</span>
    }

    @Override
    public boolean containsKey(Object key)
    {
<span class="nc" id="L917">        int index = this.index(key);</span>
<span class="nc" id="L918">        Object cur = this.table[index];</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L921">            return false;</span>
        }
<span class="nc bnc" id="L923" title="All 4 branches missed.">        if (cur != CHAINED_KEY &amp;&amp; this.nonNullTableObjectEquals(cur, (K) key))</span>
        {
<span class="nc" id="L925">            return true;</span>
        }
<span class="nc bnc" id="L927" title="All 4 branches missed.">        return cur == CHAINED_KEY &amp;&amp; this.chainContainsKey((Object[]) this.table[index + 1], (K) key);</span>
    }

    private boolean chainContainsKey(Object[] chain, K key)
    {
<span class="nc bnc" id="L932" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L934">            Object k = chain[i];</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">            if (k == null)</span>
            {
<span class="nc" id="L937">                return false;</span>
            }
<span class="nc bnc" id="L939" title="All 2 branches missed.">            if (this.nonNullTableObjectEquals(k, key))</span>
            {
<span class="nc" id="L941">                return true;</span>
            }
        }
<span class="nc" id="L944">        return false;</span>
    }

    @Override
    public boolean containsValue(Object value)
    {
<span class="nc bnc" id="L950" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L952" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc bnc" id="L954" title="All 2 branches missed.">                if (this.chainedContainsValue((Object[]) this.table[i + 1], (V) value))</span>
                {
<span class="nc" id="L956">                    return true;</span>
                }
            }
<span class="nc bnc" id="L959" title="All 2 branches missed.">            else if (this.table[i] != null)</span>
            {
<span class="nc bnc" id="L961" title="All 2 branches missed.">                if (UnifiedMap.nullSafeEquals(value, this.table[i + 1]))</span>
                {
<span class="nc" id="L963">                    return true;</span>
                }
            }
        }
<span class="nc" id="L967">        return false;</span>
    }

    private boolean chainedContainsValue(Object[] chain, V value)
    {
<span class="nc bnc" id="L972" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc bnc" id="L974" title="All 2 branches missed.">            if (chain[i] == null)</span>
            {
<span class="nc" id="L976">                return false;</span>
            }
<span class="nc bnc" id="L978" title="All 2 branches missed.">            if (UnifiedMap.nullSafeEquals(value, chain[i + 1]))</span>
            {
<span class="nc" id="L980">                return true;</span>
            }
        }
<span class="nc" id="L983">        return false;</span>
    }

    @Override
    public void forEachKeyValue(Procedure2&lt;? super K, ? super V&gt; procedure)
    {
<span class="nc bnc" id="L989" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L991">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L994">                this.chainedForEachEntry((Object[]) this.table[i + 1], procedure);</span>
            }
<span class="nc bnc" id="L996" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L998">                procedure.value(this.nonSentinel(cur), (V) this.table[i + 1]);</span>
            }
        }
<span class="nc" id="L1001">    }</span>

    @Override
    public V getFirst()
    {
<span class="nc bnc" id="L1006" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1008">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1011">                Object[] chain = (Object[]) this.table[i + 1];</span>
<span class="nc" id="L1012">                return (V) chain[1];</span>
            }
<span class="nc bnc" id="L1014" title="All 2 branches missed.">            if (cur != null)</span>
            {
<span class="nc" id="L1016">                return (V) this.table[i + 1];</span>
            }
        }
<span class="nc" id="L1019">        return null;</span>
    }

    @Override
    public &lt;E&gt; MutableMap&lt;K, V&gt; collectKeysAndValues(
            Iterable&lt;E&gt; iterable,
            Function&lt;? super E, ? extends K&gt; keyFunction,
            Function&lt;? super E, ? extends V&gt; valueFunction)
    {
<span class="nc" id="L1028">        Iterate.forEach(iterable, new MapCollectProcedure&lt;&gt;(this, keyFunction, valueFunction));</span>
<span class="nc" id="L1029">        return this;</span>
    }

    @Override
    public V removeKey(K key)
    {
<span class="nc" id="L1035">        return this.remove(key);</span>
    }

    private void chainedForEachEntry(Object[] chain, Procedure2&lt;? super K, ? super V&gt; procedure)
    {
<span class="nc bnc" id="L1040" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1042">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1045">                return;</span>
            }
<span class="nc" id="L1047">            procedure.value(this.nonSentinel(cur), (V) chain[i + 1]);</span>
        }
<span class="nc" id="L1049">    }</span>

    @Override
    public int getBatchCount(int batchSize)
    {
<span class="nc" id="L1054">        return Math.max(1, this.table.length / 2 / batchSize);</span>
    }

    @Override
    public void batchForEach(Procedure&lt;? super V&gt; procedure, int sectionIndex, int sectionCount)
    {
<span class="nc" id="L1060">        int sectionSize = this.table.length / sectionCount;</span>
<span class="nc" id="L1061">        int start = sectionIndex * sectionSize;</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">        int end = sectionIndex == sectionCount - 1 ? this.table.length : start + sectionSize;</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">        if (start % 2 == 0)</span>
        {
<span class="nc" id="L1065">            start++;</span>
        }
<span class="nc bnc" id="L1067" title="All 2 branches missed.">        for (int i = start; i &lt; end; i += 2)</span>
        {
<span class="nc" id="L1069">            Object value = this.table[i];</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">            if (value instanceof Object[])</span>
            {
<span class="nc" id="L1072">                this.chainedForEachValue((Object[]) value, procedure);</span>
            }
<span class="nc bnc" id="L1074" title="All 6 branches missed.">            else if (value == null &amp;&amp; this.table[i - 1] != null || value != null)</span>
            {
<span class="nc" id="L1076">                procedure.value((V) value);</span>
            }
        }
<span class="nc" id="L1079">    }</span>

    @Override
    public void forEachKey(Procedure&lt;? super K&gt; procedure)
    {
<span class="nc bnc" id="L1084" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1086">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1089">                this.chainedForEachKey((Object[]) this.table[i + 1], procedure);</span>
            }
<span class="nc bnc" id="L1091" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1093">                procedure.value(this.nonSentinel(cur));</span>
            }
        }
<span class="nc" id="L1096">    }</span>

    private void chainedForEachKey(Object[] chain, Procedure&lt;? super K&gt; procedure)
    {
<span class="nc bnc" id="L1100" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1102">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1105">                return;</span>
            }
<span class="nc" id="L1107">            procedure.value(this.nonSentinel(cur));</span>
        }
<span class="nc" id="L1109">    }</span>

    @Override
    public void forEachValue(Procedure&lt;? super V&gt; procedure)
    {
<span class="nc bnc" id="L1114" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1116">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1119">                this.chainedForEachValue((Object[]) this.table[i + 1], procedure);</span>
            }
<span class="nc bnc" id="L1121" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1123">                procedure.value((V) this.table[i + 1]);</span>
            }
        }
<span class="nc" id="L1126">    }</span>

    private void chainedForEachValue(Object[] chain, Procedure&lt;? super V&gt; procedure)
    {
<span class="nc bnc" id="L1130" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1132">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1135">                return;</span>
            }
<span class="nc" id="L1137">            procedure.value((V) chain[i + 1]);</span>
        }
<span class="nc" id="L1139">    }</span>

    @Override
    public boolean isEmpty()
    {
<span class="nc bnc" id="L1144" title="All 2 branches missed.">        return this.occupied == 0;</span>
    }

    @Override
    public void putAll(Map&lt;? extends K, ? extends V&gt; map)
    {
<span class="nc bnc" id="L1150" title="All 2 branches missed.">        if (map instanceof UnifiedMap&lt;?, ?&gt;)</span>
        {
<span class="nc" id="L1152">            this.copyMap((UnifiedMap&lt;K, V&gt;) map);</span>
        }
<span class="nc bnc" id="L1154" title="All 2 branches missed.">        else if (map instanceof UnsortedMapIterable)</span>
        {
<span class="nc" id="L1156">            MapIterable&lt;K, V&gt; mapIterable = (MapIterable&lt;K, V&gt;) map;</span>
<span class="nc" id="L1157">            mapIterable.forEachKeyValue(this::put);</span>
<span class="nc" id="L1158">        }</span>
        else
        {
<span class="nc" id="L1161">            Iterator&lt;? extends Entry&lt;? extends K, ? extends V&gt;&gt; iterator = this.getEntrySetFrom(map).iterator();</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L1164">                Entry&lt;? extends K, ? extends V&gt; entry = iterator.next();</span>
<span class="nc" id="L1165">                this.put(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L1166">            }</span>
        }
<span class="nc" id="L1168">    }</span>

    private Set&lt;? extends Entry&lt;? extends K, ? extends V&gt;&gt; getEntrySetFrom(Map&lt;? extends K, ? extends V&gt; map)
    {
<span class="nc" id="L1172">        Set&lt;? extends Entry&lt;? extends K, ? extends V&gt;&gt; entries = map.entrySet();</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">        if (entries != null)</span>
        {
<span class="nc" id="L1175">            return entries;</span>
        }
<span class="nc bnc" id="L1177" title="All 2 branches missed.">        if (map.isEmpty())</span>
        {
<span class="nc" id="L1179">            return Sets.immutable.&lt;Entry&lt;K, V&gt;&gt;of().castToSet();</span>
        }
<span class="nc" id="L1181">        throw new IllegalStateException(&quot;Entry set was null and size was non-zero&quot;);</span>
    }

    protected void copyMap(UnifiedMap&lt;K, V&gt; unifiedMap)
    {
<span class="nc bnc" id="L1186" title="All 2 branches missed.">        for (int i = 0; i &lt; unifiedMap.table.length; i += 2)</span>
        {
<span class="nc" id="L1188">            Object cur = unifiedMap.table[i];</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1191">                this.copyChain((Object[]) unifiedMap.table[i + 1]);</span>
            }
<span class="nc bnc" id="L1193" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1195">                this.put(this.nonSentinel(cur), (V) unifiedMap.table[i + 1]);</span>
            }
        }
<span class="nc" id="L1198">    }</span>

    private void copyChain(Object[] chain)
    {
<span class="nc bnc" id="L1202" title="All 2 branches missed.">        for (int j = 0; j &lt; chain.length; j += 2)</span>
        {
<span class="nc" id="L1204">            Object cur = chain[j];</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1207">                break;</span>
            }
<span class="nc" id="L1209">            this.put(this.nonSentinel(cur), (V) chain[j + 1]);</span>
        }
<span class="nc" id="L1211">    }</span>

    @Override
    public V remove(Object key)
    {
<span class="nc" id="L1216">        int index = this.index(key);</span>
<span class="nc" id="L1217">        Object cur = this.table[index];</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">        if (cur != null)</span>
        {
<span class="nc" id="L1220">            Object val = this.table[index + 1];</span>
<span class="nc bnc" id="L1221" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1223">                return this.removeFromChain((Object[]) val, (K) key, index);</span>
            }
<span class="nc bnc" id="L1225" title="All 2 branches missed.">            if (this.nonNullTableObjectEquals(cur, (K) key))</span>
            {
<span class="nc" id="L1227">                this.table[index] = null;</span>
<span class="nc" id="L1228">                this.table[index + 1] = null;</span>
<span class="nc" id="L1229">                this.occupied--;</span>
<span class="nc" id="L1230">                return (V) val;</span>
            }
        }
<span class="nc" id="L1233">        return null;</span>
    }

    private V removeFromChain(Object[] chain, K key, int index)
    {
<span class="nc bnc" id="L1238" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1240">            Object k = chain[i];</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">            if (k == null)</span>
            {
<span class="nc" id="L1243">                return null;</span>
            }
<span class="nc bnc" id="L1245" title="All 2 branches missed.">            if (this.nonNullTableObjectEquals(k, key))</span>
            {
<span class="nc" id="L1247">                V val = (V) chain[i + 1];</span>
<span class="nc" id="L1248">                this.overwriteWithLastElementFromChain(chain, index, i);</span>
<span class="nc" id="L1249">                return val;</span>
            }
        }
<span class="nc" id="L1252">        return null;</span>
    }

    private void overwriteWithLastElementFromChain(Object[] chain, int index, int i)
    {
<span class="nc" id="L1257">        int j = chain.length - 2;</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">        for (; j &gt; i; j -= 2)</span>
        {
<span class="nc bnc" id="L1260" title="All 2 branches missed.">            if (chain[j] != null)</span>
            {
<span class="nc" id="L1262">                chain[i] = chain[j];</span>
<span class="nc" id="L1263">                chain[i + 1] = chain[j + 1];</span>
<span class="nc" id="L1264">                break;</span>
            }
        }
<span class="nc" id="L1267">        chain[j] = null;</span>
<span class="nc" id="L1268">        chain[j + 1] = null;</span>
<span class="nc bnc" id="L1269" title="All 2 branches missed.">        if (j == 0)</span>
        {
<span class="nc" id="L1271">            this.table[index] = null;</span>
<span class="nc" id="L1272">            this.table[index + 1] = null;</span>
        }
<span class="nc" id="L1274">        this.occupied--;</span>
<span class="nc" id="L1275">    }</span>

    @Override
    public int size()
    {
<span class="nc" id="L1280">        return this.occupied;</span>
    }

    @Override
    public Set&lt;Entry&lt;K, V&gt;&gt; entrySet()
    {
<span class="nc" id="L1286">        return new EntrySet();</span>
    }

    @Override
    public Set&lt;K&gt; keySet()
    {
<span class="nc" id="L1292">        return new KeySet();</span>
    }

    @Override
    public Collection&lt;V&gt; values()
    {
<span class="nc" id="L1298">        return new ValuesCollection();</span>
    }

    @Override
    public boolean equals(Object object)
    {
<span class="nc bnc" id="L1304" title="All 2 branches missed.">        if (this == object)</span>
        {
<span class="nc" id="L1306">            return true;</span>
        }

<span class="nc bnc" id="L1309" title="All 2 branches missed.">        if (!(object instanceof Map))</span>
        {
<span class="nc" id="L1311">            return false;</span>
        }

<span class="nc" id="L1314">        Map&lt;?, ?&gt; other = (Map&lt;?, ?&gt;) object;</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">        if (this.size() != other.size())</span>
        {
<span class="nc" id="L1317">            return false;</span>
        }

<span class="nc bnc" id="L1320" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1322">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc bnc" id="L1325" title="All 2 branches missed.">                if (!this.chainedEquals((Object[]) this.table[i + 1], other))</span>
                {
<span class="nc" id="L1327">                    return false;</span>
                }
            }
<span class="nc bnc" id="L1330" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1332">                K key = this.nonSentinel(cur);</span>
<span class="nc" id="L1333">                V value = (V) this.table[i + 1];</span>
<span class="nc" id="L1334">                Object otherValue = other.get(key);</span>
<span class="nc bnc" id="L1335" title="All 8 branches missed.">                if (!UnifiedMap.nullSafeEquals(otherValue, value) || (value == null &amp;&amp; otherValue == null &amp;&amp; !other.containsKey(key)))</span>
                {
<span class="nc" id="L1337">                    return false;</span>
                }
            }
        }

<span class="nc" id="L1342">        return true;</span>
    }

    private boolean chainedEquals(Object[] chain, Map&lt;?, ?&gt; other)
    {
<span class="nc bnc" id="L1347" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1349">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1352">                return true;</span>
            }
<span class="nc" id="L1354">            K key = this.nonSentinel(cur);</span>
<span class="nc" id="L1355">            V value = (V) chain[i + 1];</span>
<span class="nc" id="L1356">            Object otherValue = other.get(key);</span>
<span class="nc bnc" id="L1357" title="All 8 branches missed.">            if (!UnifiedMap.nullSafeEquals(otherValue, value) || (value == null &amp;&amp; otherValue == null &amp;&amp; !other.containsKey(key)))</span>
            {
<span class="nc" id="L1359">                return false;</span>
            }
        }
<span class="nc" id="L1362">        return true;</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L1368">        int hashCode = 0;</span>
<span class="nc bnc" id="L1369" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1371">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1374">                hashCode += this.chainedHashCode((Object[]) this.table[i + 1]);</span>
            }
<span class="nc bnc" id="L1376" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1378">                Object value = this.table[i + 1];</span>
<span class="nc bnc" id="L1379" title="All 4 branches missed.">                hashCode += (cur == NULL_KEY ? 0 : cur.hashCode()) ^ (value == null ? 0 : value.hashCode());</span>
            }
        }
<span class="nc" id="L1382">        return hashCode;</span>
    }

    private int chainedHashCode(Object[] chain)
    {
<span class="nc" id="L1387">        int hashCode = 0;</span>
<span class="nc bnc" id="L1388" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1390">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1393">                return hashCode;</span>
            }
<span class="nc" id="L1395">            Object value = chain[i + 1];</span>
<span class="nc bnc" id="L1396" title="All 4 branches missed.">            hashCode += (cur == NULL_KEY ? 0 : cur.hashCode()) ^ (value == null ? 0 : value.hashCode());</span>
        }
<span class="nc" id="L1398">        return hashCode;</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L1404">        StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L1405">        builder.append('{');</span>

<span class="nc" id="L1407">        this.forEachKeyValue(new Procedure2&lt;K, V&gt;()</span>
<span class="nc" id="L1408">        {</span>
<span class="nc" id="L1409">            private boolean first = true;</span>

            public void value(K key, V value)
            {
<span class="nc bnc" id="L1413" title="All 2 branches missed.">                if (this.first)</span>
                {
<span class="nc" id="L1415">                    this.first = false;</span>
                }
                else
                {
<span class="nc" id="L1419">                    builder.append(&quot;, &quot;);</span>
                }

<span class="nc bnc" id="L1422" title="All 2 branches missed.">                builder.append(key == UnifiedMap.this ? &quot;(this Map)&quot; : key);</span>
<span class="nc" id="L1423">                builder.append('=');</span>
<span class="nc bnc" id="L1424" title="All 2 branches missed.">                builder.append(value == UnifiedMap.this ? &quot;(this Map)&quot; : value);</span>
<span class="nc" id="L1425">            }</span>
        });

<span class="nc" id="L1428">        builder.append('}');</span>
<span class="nc" id="L1429">        return builder.toString();</span>
    }

    public boolean trimToSize()
    {
<span class="nc bnc" id="L1434" title="All 2 branches missed.">        if (this.table.length &lt;= this.fastCeil(this.occupied / this.loadFactor) &lt;&lt; 2)</span>
        {
<span class="nc" id="L1436">            return false;</span>
        }

<span class="nc" id="L1439">        Object[] temp = this.table;</span>
<span class="nc" id="L1440">        this.init(this.fastCeil(this.occupied / this.loadFactor));</span>
<span class="nc bnc" id="L1441" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L1443">            return true;</span>
        }

<span class="nc" id="L1446">        int mask = this.table.length - 1;</span>
<span class="nc bnc" id="L1447" title="All 2 branches missed.">        for (int j = 0; j &lt; temp.length; j += 2)</span>
        {
<span class="nc" id="L1449">            Object key = temp[j];</span>
<span class="nc bnc" id="L1450" title="All 2 branches missed.">            if (key == CHAINED_KEY)</span>
            {
<span class="nc" id="L1452">                Object[] chain = (Object[]) temp[j + 1];</span>
<span class="nc bnc" id="L1453" title="All 2 branches missed.">                for (int i = 0; i &lt; chain.length; i += 2)</span>
                {
<span class="nc" id="L1455">                    Object cur = chain[i];</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">                    if (cur != null)</span>
                    {
<span class="nc" id="L1458">                        this.putForTrim((K) cur, (V) chain[i + 1], j, mask);</span>
                    }
                }
<span class="nc" id="L1461">            }</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">            else if (key != null)</span>
            {
<span class="nc" id="L1464">                this.putForTrim((K) key, (V) temp[j + 1], j, mask);</span>
            }
        }
<span class="nc" id="L1467">        return true;</span>
    }

    private void putForTrim(K key, V value, int oldIndex, int mask)
    {
<span class="nc" id="L1472">        int index = oldIndex &amp; mask;</span>
<span class="nc" id="L1473">        Object cur = this.table[index];</span>
<span class="nc bnc" id="L1474" title="All 2 branches missed.">        if (cur == null)</span>
        {
<span class="nc" id="L1476">            this.table[index] = key;</span>
<span class="nc" id="L1477">            this.table[index + 1] = value;</span>
<span class="nc" id="L1478">            return;</span>
        }
<span class="nc" id="L1480">        this.chainedPutForTrim(key, index, value);</span>
<span class="nc" id="L1481">    }</span>

    private void chainedPutForTrim(K key, int index, V value)
    {
<span class="nc bnc" id="L1485" title="All 2 branches missed.">        if (this.table[index] == CHAINED_KEY)</span>
        {
<span class="nc" id="L1487">            Object[] chain = (Object[]) this.table[index + 1];</span>
<span class="nc bnc" id="L1488" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc bnc" id="L1490" title="All 2 branches missed.">                if (chain[i] == null)</span>
                {
<span class="nc" id="L1492">                    chain[i] = key;</span>
<span class="nc" id="L1493">                    chain[i + 1] = value;</span>
<span class="nc" id="L1494">                    return;</span>
                }
            }
<span class="nc" id="L1497">            Object[] newChain = new Object[chain.length + 4];</span>
<span class="nc" id="L1498">            System.arraycopy(chain, 0, newChain, 0, chain.length);</span>
<span class="nc" id="L1499">            this.table[index + 1] = newChain;</span>
<span class="nc" id="L1500">            newChain[chain.length] = UnifiedMap.toSentinelIfNull(key);</span>
<span class="nc" id="L1501">            newChain[chain.length + 1] = value;</span>
<span class="nc" id="L1502">            return;</span>
        }
<span class="nc" id="L1504">        Object[] newChain = new Object[4];</span>
<span class="nc" id="L1505">        newChain[0] = this.table[index];</span>
<span class="nc" id="L1506">        newChain[1] = this.table[index + 1];</span>
<span class="nc" id="L1507">        newChain[2] = key;</span>
<span class="nc" id="L1508">        newChain[3] = value;</span>
<span class="nc" id="L1509">        this.table[index] = CHAINED_KEY;</span>
<span class="nc" id="L1510">        this.table[index + 1] = newChain;</span>
<span class="nc" id="L1511">    }</span>

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
    {
<span class="nc" id="L1516">        int size = in.readInt();</span>
<span class="nc" id="L1517">        this.loadFactor = in.readFloat();</span>
<span class="nc" id="L1518">        this.init(Math.max((int) (size / this.loadFactor) + 1,</span>
                DEFAULT_INITIAL_CAPACITY));
<span class="nc bnc" id="L1520" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1522">            this.put((K) in.readObject(), (V) in.readObject());</span>
        }
<span class="nc" id="L1524">    }</span>

    @Override
    public void writeExternal(ObjectOutput out) throws IOException
    {
<span class="nc" id="L1529">        out.writeInt(this.size());</span>
<span class="nc" id="L1530">        out.writeFloat(this.loadFactor);</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1533">            Object o = this.table[i];</span>
<span class="nc bnc" id="L1534" title="All 2 branches missed.">            if (o != null)</span>
            {
<span class="nc bnc" id="L1536" title="All 2 branches missed.">                if (o == CHAINED_KEY)</span>
                {
<span class="nc" id="L1538">                    this.writeExternalChain(out, (Object[]) this.table[i + 1]);</span>
                }
                else
                {
<span class="nc" id="L1542">                    out.writeObject(this.nonSentinel(o));</span>
<span class="nc" id="L1543">                    out.writeObject(this.table[i + 1]);</span>
                }
            }
        }
<span class="nc" id="L1547">    }</span>

    private void writeExternalChain(ObjectOutput out, Object[] chain) throws IOException
    {
<span class="nc bnc" id="L1551" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1553">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1554" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1556">                return;</span>
            }
<span class="nc" id="L1558">            out.writeObject(this.nonSentinel(cur));</span>
<span class="nc" id="L1559">            out.writeObject(chain[i + 1]);</span>
        }
<span class="nc" id="L1561">    }</span>

    @Override
    public void forEachWithIndex(ObjectIntProcedure&lt;? super V&gt; objectIntProcedure)
    {
<span class="nc" id="L1566">        int index = 0;</span>
<span class="nc bnc" id="L1567" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1569">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1572">                index = this.chainedForEachValueWithIndex((Object[]) this.table[i + 1], objectIntProcedure, index);</span>
            }
<span class="nc bnc" id="L1574" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1576">                objectIntProcedure.value((V) this.table[i + 1], index++);</span>
            }
        }
<span class="nc" id="L1579">    }</span>

    private int chainedForEachValueWithIndex(Object[] chain, ObjectIntProcedure&lt;? super V&gt; objectIntProcedure, int index)
    {
<span class="nc bnc" id="L1583" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1585">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1588">                return index;</span>
            }
<span class="nc" id="L1590">            objectIntProcedure.value((V) chain[i + 1], index++);</span>
        }
<span class="nc" id="L1592">        return index;</span>
    }

    @Override
    public &lt;P&gt; void forEachWith(Procedure2&lt;? super V, ? super P&gt; procedure, P parameter)
    {
<span class="nc bnc" id="L1598" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc" id="L1600">            Object cur = this.table[i];</span>
<span class="nc bnc" id="L1601" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L1603">                this.chainedForEachValueWith((Object[]) this.table[i + 1], procedure, parameter);</span>
            }
<span class="nc bnc" id="L1605" title="All 2 branches missed.">            else if (cur != null)</span>
            {
<span class="nc" id="L1607">                procedure.value((V) this.table[i + 1], parameter);</span>
            }
        }
<span class="nc" id="L1610">    }</span>

    private &lt;P&gt; void chainedForEachValueWith(
            Object[] chain,
            Procedure2&lt;? super V, ? super P&gt; procedure,
            P parameter)
    {
<span class="nc bnc" id="L1617" title="All 2 branches missed.">        for (int i = 0; i &lt; chain.length; i += 2)</span>
        {
<span class="nc" id="L1619">            Object cur = chain[i];</span>
<span class="nc bnc" id="L1620" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L1622">                return;</span>
            }
<span class="nc" id="L1624">            procedure.value((V) chain[i + 1], parameter);</span>
        }
<span class="nc" id="L1626">    }</span>

    @Override
    public &lt;R&gt; MutableMap&lt;K, R&gt; collectValues(Function2&lt;? super K, ? super V, ? extends R&gt; function)
    {
<span class="nc" id="L1631">        UnifiedMap&lt;K, R&gt; target = (UnifiedMap&lt;K, R&gt;) this.newEmpty();</span>
<span class="nc" id="L1632">        target.loadFactor = this.loadFactor;</span>
<span class="nc" id="L1633">        target.occupied = this.occupied;</span>
<span class="nc" id="L1634">        target.allocate(this.table.length &gt;&gt; 1);</span>

<span class="nc bnc" id="L1636" title="All 2 branches missed.">        for (int i = 0; i &lt; target.table.length; i += 2)</span>
        {
<span class="nc" id="L1638">            target.table[i] = this.table[i];</span>

<span class="nc bnc" id="L1640" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L1642">                Object[] chainedTable = (Object[]) this.table[i + 1];</span>
<span class="nc" id="L1643">                Object[] chainedTargetTable = new Object[chainedTable.length];</span>
<span class="nc bnc" id="L1644" title="All 2 branches missed.">                for (int j = 0; j &lt; chainedTargetTable.length; j += 2)</span>
                {
<span class="nc bnc" id="L1646" title="All 2 branches missed.">                    if (chainedTable[j] != null)</span>
                    {
<span class="nc" id="L1648">                        chainedTargetTable[j] = chainedTable[j];</span>
<span class="nc" id="L1649">                        chainedTargetTable[j + 1] = function.value(this.nonSentinel(chainedTable[j]), (V) chainedTable[j + 1]);</span>
                    }
                }
<span class="nc" id="L1652">                target.table[i + 1] = chainedTargetTable;</span>
<span class="nc" id="L1653">            }</span>
<span class="nc bnc" id="L1654" title="All 2 branches missed.">            else if (this.table[i] != null)</span>
            {
<span class="nc" id="L1656">                target.table[i + 1] = function.value(this.nonSentinel(this.table[i]), (V) this.table[i + 1]);</span>
            }
        }

<span class="nc" id="L1660">        return target;</span>
    }

    @Override
    public Pair&lt;K, V&gt; detect(Predicate2&lt;? super K, ? super V&gt; predicate)
    {
<span class="nc bnc" id="L1666" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L1668" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L1670">                Object[] chainedTable = (Object[]) this.table[i + 1];</span>
<span class="nc bnc" id="L1671" title="All 2 branches missed.">                for (int j = 0; j &lt; chainedTable.length; j += 2)</span>
                {
<span class="nc bnc" id="L1673" title="All 2 branches missed.">                    if (chainedTable[j] != null)</span>
                    {
<span class="nc" id="L1675">                        K key = this.nonSentinel(chainedTable[j]);</span>
<span class="nc" id="L1676">                        V value = (V) chainedTable[j + 1];</span>
<span class="nc bnc" id="L1677" title="All 2 branches missed.">                        if (predicate.accept(key, value))</span>
                        {
<span class="nc" id="L1679">                            return Tuples.pair(key, value);</span>
                        }
                    }
                }
<span class="nc" id="L1683">            }</span>
<span class="nc bnc" id="L1684" title="All 2 branches missed.">            else if (this.table[i] != null)</span>
            {
<span class="nc" id="L1686">                K key = this.nonSentinel(this.table[i]);</span>
<span class="nc" id="L1687">                V value = (V) this.table[i + 1];</span>

<span class="nc bnc" id="L1689" title="All 2 branches missed.">                if (predicate.accept(key, value))</span>
                {
<span class="nc" id="L1691">                    return Tuples.pair(key, value);</span>
                }
            }
        }

<span class="nc" id="L1696">        return null;</span>
    }

    @Override
    public V detect(Predicate&lt;? super V&gt; predicate)
    {
<span class="nc bnc" id="L1702" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L1704" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L1706">                Object[] chainedTable = (Object[]) this.table[i + 1];</span>
<span class="nc bnc" id="L1707" title="All 2 branches missed.">                for (int j = 0; j &lt; chainedTable.length; j += 2)</span>
                {
<span class="nc bnc" id="L1709" title="All 2 branches missed.">                    if (chainedTable[j] != null)</span>
                    {
<span class="nc" id="L1711">                        V value = (V) chainedTable[j + 1];</span>
<span class="nc bnc" id="L1712" title="All 2 branches missed.">                        if (predicate.accept(value))</span>
                        {
<span class="nc" id="L1714">                            return value;</span>
                        }
                    }
                }
<span class="nc" id="L1718">            }</span>
<span class="nc bnc" id="L1719" title="All 2 branches missed.">            else if (this.table[i] != null)</span>
            {
<span class="nc" id="L1721">                V value = (V) this.table[i + 1];</span>

<span class="nc bnc" id="L1723" title="All 2 branches missed.">                if (predicate.accept(value))</span>
                {
<span class="nc" id="L1725">                    return value;</span>
                }
            }
        }

<span class="nc" id="L1730">        return null;</span>
    }

    @Override
    public &lt;P&gt; V detectWith(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter)
    {
<span class="nc bnc" id="L1736" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L1738" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L1740">                Object[] chainedTable = (Object[]) this.table[i + 1];</span>
<span class="nc bnc" id="L1741" title="All 2 branches missed.">                for (int j = 0; j &lt; chainedTable.length; j += 2)</span>
                {
<span class="nc bnc" id="L1743" title="All 2 branches missed.">                    if (chainedTable[j] != null)</span>
                    {
<span class="nc" id="L1745">                        V value = (V) chainedTable[j + 1];</span>
<span class="nc bnc" id="L1746" title="All 2 branches missed.">                        if (predicate.accept(value, parameter))</span>
                        {
<span class="nc" id="L1748">                            return value;</span>
                        }
                    }
                }
<span class="nc" id="L1752">            }</span>
<span class="nc bnc" id="L1753" title="All 2 branches missed.">            else if (this.table[i] != null)</span>
            {
<span class="nc" id="L1755">                V value = (V) this.table[i + 1];</span>

<span class="nc bnc" id="L1757" title="All 2 branches missed.">                if (predicate.accept(value, parameter))</span>
                {
<span class="nc" id="L1759">                    return value;</span>
                }
            }
        }

<span class="nc" id="L1764">        return null;</span>
    }

    @Override
    public Optional&lt;Pair&lt;K, V&gt;&gt; detectOptional(Predicate2&lt;? super K, ? super V&gt; predicate)
    {
<span class="nc bnc" id="L1770" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L1772" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L1774">                Object[] chainedTable = (Object[]) this.table[i + 1];</span>
<span class="nc bnc" id="L1775" title="All 2 branches missed.">                for (int j = 0; j &lt; chainedTable.length; j += 2)</span>
                {
<span class="nc bnc" id="L1777" title="All 2 branches missed.">                    if (chainedTable[j] != null)</span>
                    {
<span class="nc" id="L1779">                        K key = this.nonSentinel(chainedTable[j]);</span>
<span class="nc" id="L1780">                        V value = (V) chainedTable[j + 1];</span>
<span class="nc bnc" id="L1781" title="All 2 branches missed.">                        if (predicate.accept(key, value))</span>
                        {
<span class="nc" id="L1783">                            return Optional.of(Tuples.pair(key, value));</span>
                        }
                    }
                }
<span class="nc" id="L1787">            }</span>
<span class="nc bnc" id="L1788" title="All 2 branches missed.">            else if (this.table[i] != null)</span>
            {
<span class="nc" id="L1790">                K key = this.nonSentinel(this.table[i]);</span>
<span class="nc" id="L1791">                V value = (V) this.table[i + 1];</span>

<span class="nc bnc" id="L1793" title="All 2 branches missed.">                if (predicate.accept(key, value))</span>
                {
<span class="nc" id="L1795">                    return Optional.of(Tuples.pair(key, value));</span>
                }
            }
        }

<span class="nc" id="L1800">        return Optional.empty();</span>
    }

    @Override
    public Optional&lt;V&gt; detectOptional(Predicate&lt;? super V&gt; predicate)
    {
<span class="nc bnc" id="L1806" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L1808" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L1810">                Object[] chainedTable = (Object[]) this.table[i + 1];</span>
<span class="nc bnc" id="L1811" title="All 2 branches missed.">                for (int j = 0; j &lt; chainedTable.length; j += 2)</span>
                {
<span class="nc bnc" id="L1813" title="All 2 branches missed.">                    if (chainedTable[j] != null)</span>
                    {
<span class="nc" id="L1815">                        V value = (V) chainedTable[j + 1];</span>
<span class="nc bnc" id="L1816" title="All 2 branches missed.">                        if (predicate.accept(value))</span>
                        {
<span class="nc" id="L1818">                            return Optional.of(value);</span>
                        }
                    }
                }
<span class="nc" id="L1822">            }</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">            else if (this.table[i] != null)</span>
            {
<span class="nc" id="L1825">                V value = (V) this.table[i + 1];</span>

<span class="nc bnc" id="L1827" title="All 2 branches missed.">                if (predicate.accept(value))</span>
                {
<span class="nc" id="L1829">                    return Optional.of(value);</span>
                }
            }
        }

<span class="nc" id="L1834">        return Optional.empty();</span>
    }

    @Override
    public &lt;P&gt; Optional&lt;V&gt; detectWithOptional(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter)
    {
<span class="nc bnc" id="L1840" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L1842" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L1844">                Object[] chainedTable = (Object[]) this.table[i + 1];</span>
<span class="nc bnc" id="L1845" title="All 2 branches missed.">                for (int j = 0; j &lt; chainedTable.length; j += 2)</span>
                {
<span class="nc bnc" id="L1847" title="All 2 branches missed.">                    if (chainedTable[j] != null)</span>
                    {
<span class="nc" id="L1849">                        V value = (V) chainedTable[j + 1];</span>
<span class="nc bnc" id="L1850" title="All 2 branches missed.">                        if (predicate.accept(value, parameter))</span>
                        {
<span class="nc" id="L1852">                            return Optional.of(value);</span>
                        }
                    }
                }
<span class="nc" id="L1856">            }</span>
<span class="nc bnc" id="L1857" title="All 2 branches missed.">            else if (this.table[i] != null)</span>
            {
<span class="nc" id="L1859">                V value = (V) this.table[i + 1];</span>

<span class="nc bnc" id="L1861" title="All 2 branches missed.">                if (predicate.accept(value, parameter))</span>
                {
<span class="nc" id="L1863">                    return Optional.of(value);</span>
                }
            }
        }

<span class="nc" id="L1868">        return Optional.empty();</span>
    }

    @Override
    public V detectIfNone(Predicate&lt;? super V&gt; predicate, Function0&lt;? extends V&gt; function)
    {
<span class="nc bnc" id="L1874" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L1876" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L1878">                Object[] chainedTable = (Object[]) this.table[i + 1];</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">                for (int j = 0; j &lt; chainedTable.length; j += 2)</span>
                {
<span class="nc bnc" id="L1881" title="All 2 branches missed.">                    if (chainedTable[j] != null)</span>
                    {
<span class="nc" id="L1883">                        V value = (V) chainedTable[j + 1];</span>
<span class="nc bnc" id="L1884" title="All 2 branches missed.">                        if (predicate.accept(value))</span>
                        {
<span class="nc" id="L1886">                            return value;</span>
                        }
                    }
                }
<span class="nc" id="L1890">            }</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">            else if (this.table[i] != null)</span>
            {
<span class="nc" id="L1893">                V value = (V) this.table[i + 1];</span>

<span class="nc bnc" id="L1895" title="All 2 branches missed.">                if (predicate.accept(value))</span>
                {
<span class="nc" id="L1897">                    return value;</span>
                }
            }
        }

<span class="nc" id="L1902">        return function.value();</span>
    }

    @Override
    public &lt;P&gt; V detectWithIfNone(
            Predicate2&lt;? super V, ? super P&gt; predicate,
            P parameter,
            Function0&lt;? extends V&gt; function)
    {
<span class="nc bnc" id="L1911" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L1913" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L1915">                Object[] chainedTable = (Object[]) this.table[i + 1];</span>
<span class="nc bnc" id="L1916" title="All 2 branches missed.">                for (int j = 0; j &lt; chainedTable.length; j += 2)</span>
                {
<span class="nc bnc" id="L1918" title="All 2 branches missed.">                    if (chainedTable[j] != null)</span>
                    {
<span class="nc" id="L1920">                        V value = (V) chainedTable[j + 1];</span>
<span class="nc bnc" id="L1921" title="All 2 branches missed.">                        if (predicate.accept(value, parameter))</span>
                        {
<span class="nc" id="L1923">                            return value;</span>
                        }
                    }
                }
<span class="nc" id="L1927">            }</span>
<span class="nc bnc" id="L1928" title="All 2 branches missed.">            else if (this.table[i] != null)</span>
            {
<span class="nc" id="L1930">                V value = (V) this.table[i + 1];</span>

<span class="nc bnc" id="L1932" title="All 2 branches missed.">                if (predicate.accept(value, parameter))</span>
                {
<span class="nc" id="L1934">                    return value;</span>
                }
            }
        }

<span class="nc" id="L1939">        return function.value();</span>
    }

    private boolean shortCircuit(
            Predicate&lt;? super V&gt; predicate,
            boolean expected,
            boolean onShortCircuit,
            boolean atEnd)
    {
<span class="nc bnc" id="L1948" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L1950" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L1952">                Object[] chainedTable = (Object[]) this.table[i + 1];</span>
<span class="nc bnc" id="L1953" title="All 2 branches missed.">                for (int j = 0; j &lt; chainedTable.length; j += 2)</span>
                {
<span class="nc bnc" id="L1955" title="All 2 branches missed.">                    if (chainedTable[j] != null)</span>
                    {
<span class="nc" id="L1957">                        V value = (V) chainedTable[j + 1];</span>
<span class="nc bnc" id="L1958" title="All 2 branches missed.">                        if (predicate.accept(value) == expected)</span>
                        {
<span class="nc" id="L1960">                            return onShortCircuit;</span>
                        }
                    }
                }
<span class="nc" id="L1964">            }</span>
<span class="nc bnc" id="L1965" title="All 2 branches missed.">            else if (this.table[i] != null)</span>
            {
<span class="nc" id="L1967">                V value = (V) this.table[i + 1];</span>

<span class="nc bnc" id="L1969" title="All 2 branches missed.">                if (predicate.accept(value) == expected)</span>
                {
<span class="nc" id="L1971">                    return onShortCircuit;</span>
                }
            }
        }

<span class="nc" id="L1976">        return atEnd;</span>
    }

    private &lt;P&gt; boolean shortCircuitWith(
            Predicate2&lt;? super V, ? super P&gt; predicate,
            P parameter,
            boolean expected,
            boolean onShortCircuit,
            boolean atEnd)
    {
<span class="nc bnc" id="L1986" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length; i += 2)</span>
        {
<span class="nc bnc" id="L1988" title="All 2 branches missed.">            if (this.table[i] == CHAINED_KEY)</span>
            {
<span class="nc" id="L1990">                Object[] chainedTable = (Object[]) this.table[i + 1];</span>
<span class="nc bnc" id="L1991" title="All 2 branches missed.">                for (int j = 0; j &lt; chainedTable.length; j += 2)</span>
                {
<span class="nc bnc" id="L1993" title="All 2 branches missed.">                    if (chainedTable[j] != null)</span>
                    {
<span class="nc" id="L1995">                        V value = (V) chainedTable[j + 1];</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">                        if (predicate.accept(value, parameter) == expected)</span>
                        {
<span class="nc" id="L1998">                            return onShortCircuit;</span>
                        }
                    }
                }
<span class="nc" id="L2002">            }</span>
<span class="nc bnc" id="L2003" title="All 2 branches missed.">            else if (this.table[i] != null)</span>
            {
<span class="nc" id="L2005">                V value = (V) this.table[i + 1];</span>

<span class="nc bnc" id="L2007" title="All 2 branches missed.">                if (predicate.accept(value, parameter) == expected)</span>
                {
<span class="nc" id="L2009">                    return onShortCircuit;</span>
                }
            }
        }

<span class="nc" id="L2014">        return atEnd;</span>
    }

    @Override
    public boolean anySatisfy(Predicate&lt;? super V&gt; predicate)
    {
<span class="nc" id="L2020">        return this.shortCircuit(predicate, true, true, false);</span>
    }

    @Override
    public &lt;P&gt; boolean anySatisfyWith(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L2026">        return this.shortCircuitWith(predicate, parameter, true, true, false);</span>
    }

    @Override
    public boolean allSatisfy(Predicate&lt;? super V&gt; predicate)
    {
<span class="nc" id="L2032">        return this.shortCircuit(predicate, false, false, true);</span>
    }

    @Override
    public &lt;P&gt; boolean allSatisfyWith(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L2038">        return this.shortCircuitWith(predicate, parameter, false, false, true);</span>
    }

    @Override
    public boolean noneSatisfy(Predicate&lt;? super V&gt; predicate)
    {
<span class="nc" id="L2044">        return this.shortCircuit(predicate, true, false, true);</span>
    }

    @Override
    public &lt;P&gt; boolean noneSatisfyWith(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L2050">        return this.shortCircuitWith(predicate, parameter, true, false, true);</span>
    }

<span class="nc" id="L2053">    protected class KeySet implements Set&lt;K&gt;, Serializable, BatchIterable&lt;K&gt;</span>
    {
        private static final long serialVersionUID = 1L;

        @Override
        public boolean add(K key)
        {
<span class="nc" id="L2060">            throw new UnsupportedOperationException(&quot;Cannot call add() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public boolean addAll(Collection&lt;? extends K&gt; collection)
        {
<span class="nc" id="L2066">            throw new UnsupportedOperationException(&quot;Cannot call addAll() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public void clear()
        {
<span class="nc" id="L2072">            UnifiedMap.this.clear();</span>
<span class="nc" id="L2073">        }</span>

        @Override
        public boolean contains(Object o)
        {
<span class="nc" id="L2078">            return UnifiedMap.this.containsKey(o);</span>
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; collection)
        {
<span class="nc bnc" id="L2084" title="All 2 branches missed.">            for (Object aCollection : collection)</span>
            {
<span class="nc bnc" id="L2086" title="All 2 branches missed.">                if (!UnifiedMap.this.containsKey(aCollection))</span>
                {
<span class="nc" id="L2088">                    return false;</span>
                }
<span class="nc" id="L2090">            }</span>
<span class="nc" id="L2091">            return true;</span>
        }

        @Override
        public boolean isEmpty()
        {
<span class="nc" id="L2097">            return UnifiedMap.this.isEmpty();</span>
        }

        @Override
        public Iterator&lt;K&gt; iterator()
        {
<span class="nc" id="L2103">            return new KeySetIterator();</span>
        }

        @Override
        public boolean remove(Object key)
        {
<span class="nc" id="L2109">            int oldSize = UnifiedMap.this.occupied;</span>
<span class="nc" id="L2110">            UnifiedMap.this.remove(key);</span>
<span class="nc bnc" id="L2111" title="All 2 branches missed.">            return UnifiedMap.this.occupied != oldSize;</span>
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; collection)
        {
<span class="nc" id="L2117">            int oldSize = UnifiedMap.this.occupied;</span>
<span class="nc bnc" id="L2118" title="All 2 branches missed.">            for (Object object : collection)</span>
            {
<span class="nc" id="L2120">                UnifiedMap.this.remove(object);</span>
<span class="nc" id="L2121">            }</span>
<span class="nc bnc" id="L2122" title="All 2 branches missed.">            return oldSize != UnifiedMap.this.occupied;</span>
        }

        public void putIfFound(Object key, Map&lt;K, V&gt; other)
        {
<span class="nc" id="L2127">            int index = UnifiedMap.this.index(key);</span>
<span class="nc" id="L2128">            Object cur = UnifiedMap.this.table[index];</span>
<span class="nc bnc" id="L2129" title="All 2 branches missed.">            if (cur != null)</span>
            {
<span class="nc" id="L2131">                Object val = UnifiedMap.this.table[index + 1];</span>
<span class="nc bnc" id="L2132" title="All 2 branches missed.">                if (cur == CHAINED_KEY)</span>
                {
<span class="nc" id="L2134">                    this.putIfFoundFromChain((Object[]) val, (K) key, other);</span>
<span class="nc" id="L2135">                    return;</span>
                }
<span class="nc bnc" id="L2137" title="All 2 branches missed.">                if (UnifiedMap.this.nonNullTableObjectEquals(cur, (K) key))</span>
                {
<span class="nc" id="L2139">                    other.put(UnifiedMap.this.nonSentinel(cur), (V) val);</span>
                }
            }
<span class="nc" id="L2142">        }</span>

        private void putIfFoundFromChain(Object[] chain, K key, Map&lt;K, V&gt; other)
        {
<span class="nc bnc" id="L2146" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc" id="L2148">                Object k = chain[i];</span>
<span class="nc bnc" id="L2149" title="All 2 branches missed.">                if (k == null)</span>
                {
<span class="nc" id="L2151">                    return;</span>
                }
<span class="nc bnc" id="L2153" title="All 2 branches missed.">                if (UnifiedMap.this.nonNullTableObjectEquals(k, key))</span>
                {
<span class="nc" id="L2155">                    other.put(UnifiedMap.this.nonSentinel(k), (V) chain[i + 1]);</span>
                }
            }
<span class="nc" id="L2158">        }</span>

        @Override
        public boolean retainAll(Collection&lt;?&gt; collection)
        {
<span class="nc" id="L2163">            int retainedSize = collection.size();</span>
<span class="nc" id="L2164">            UnifiedMap&lt;K, V&gt; retainedCopy = (UnifiedMap&lt;K, V&gt;) UnifiedMap.this.newEmpty(retainedSize);</span>
<span class="nc bnc" id="L2165" title="All 2 branches missed.">            for (Object key : collection)</span>
            {
<span class="nc" id="L2167">                this.putIfFound(key, retainedCopy);</span>
<span class="nc" id="L2168">            }</span>
<span class="nc bnc" id="L2169" title="All 2 branches missed.">            if (retainedCopy.size() &lt; this.size())</span>
            {
<span class="nc" id="L2171">                UnifiedMap.this.maxSize = retainedCopy.maxSize;</span>
<span class="nc" id="L2172">                UnifiedMap.this.occupied = retainedCopy.occupied;</span>
<span class="nc" id="L2173">                UnifiedMap.this.table = retainedCopy.table;</span>
<span class="nc" id="L2174">                return true;</span>
            }
<span class="nc" id="L2176">            return false;</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L2182">            return UnifiedMap.this.size();</span>
        }

        @Override
        public void forEach(Procedure&lt;? super K&gt; procedure)
        {
<span class="nc" id="L2188">            UnifiedMap.this.forEachKey(procedure);</span>
<span class="nc" id="L2189">        }</span>

        @Override
        public int getBatchCount(int batchSize)
        {
<span class="nc" id="L2194">            return UnifiedMap.this.getBatchCount(batchSize);</span>
        }

        @Override
        public void batchForEach(Procedure&lt;? super K&gt; procedure, int sectionIndex, int sectionCount)
        {
<span class="nc" id="L2200">            Object[] map = UnifiedMap.this.table;</span>
<span class="nc" id="L2201">            int sectionSize = map.length / sectionCount;</span>
<span class="nc" id="L2202">            int start = sectionIndex * sectionSize;</span>
<span class="nc bnc" id="L2203" title="All 2 branches missed.">            int end = sectionIndex == sectionCount - 1 ? map.length : start + sectionSize;</span>
<span class="nc bnc" id="L2204" title="All 2 branches missed.">            if (start % 2 != 0)</span>
            {
<span class="nc" id="L2206">                start++;</span>
            }
<span class="nc bnc" id="L2208" title="All 2 branches missed.">            for (int i = start; i &lt; end; i += 2)</span>
            {
<span class="nc" id="L2210">                Object cur = map[i];</span>
<span class="nc bnc" id="L2211" title="All 2 branches missed.">                if (cur == CHAINED_KEY)</span>
                {
<span class="nc" id="L2213">                    UnifiedMap.this.chainedForEachKey((Object[]) map[i + 1], procedure);</span>
                }
<span class="nc bnc" id="L2215" title="All 2 branches missed.">                else if (cur != null)</span>
                {
<span class="nc" id="L2217">                    procedure.value(UnifiedMap.this.nonSentinel(cur));</span>
                }
            }
<span class="nc" id="L2220">        }</span>

        protected void copyKeys(Object[] result)
        {
<span class="nc" id="L2224">            Object[] table = UnifiedMap.this.table;</span>
<span class="nc" id="L2225">            int count = 0;</span>
<span class="nc bnc" id="L2226" title="All 2 branches missed.">            for (int i = 0; i &lt; table.length; i += 2)</span>
            {
<span class="nc" id="L2228">                Object x = table[i];</span>
<span class="nc bnc" id="L2229" title="All 2 branches missed.">                if (x != null)</span>
                {
<span class="nc bnc" id="L2231" title="All 2 branches missed.">                    if (x == CHAINED_KEY)</span>
                    {
<span class="nc" id="L2233">                        Object[] chain = (Object[]) table[i + 1];</span>
<span class="nc bnc" id="L2234" title="All 2 branches missed.">                        for (int j = 0; j &lt; chain.length; j += 2)</span>
                        {
<span class="nc" id="L2236">                            Object cur = chain[j];</span>
<span class="nc bnc" id="L2237" title="All 2 branches missed.">                            if (cur == null)</span>
                            {
<span class="nc" id="L2239">                                break;</span>
                            }
<span class="nc" id="L2241">                            result[count++] = UnifiedMap.this.nonSentinel(cur);</span>
                        }
<span class="nc" id="L2243">                    }</span>
                    else
                    {
<span class="nc" id="L2246">                        result[count++] = UnifiedMap.this.nonSentinel(x);</span>
                    }
                }
            }
<span class="nc" id="L2250">        }</span>

        @Override
        public boolean equals(Object obj)
        {
<span class="nc bnc" id="L2255" title="All 2 branches missed.">            if (obj instanceof Set)</span>
            {
<span class="nc" id="L2257">                Set&lt;?&gt; other = (Set&lt;?&gt;) obj;</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">                if (other.size() == this.size())</span>
                {
<span class="nc" id="L2260">                    return this.containsAll(other);</span>
                }
            }
<span class="nc" id="L2263">            return false;</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L2269">            int hashCode = 0;</span>
<span class="nc" id="L2270">            Object[] table = UnifiedMap.this.table;</span>
<span class="nc bnc" id="L2271" title="All 2 branches missed.">            for (int i = 0; i &lt; table.length; i += 2)</span>
            {
<span class="nc" id="L2273">                Object x = table[i];</span>
<span class="nc bnc" id="L2274" title="All 2 branches missed.">                if (x != null)</span>
                {
<span class="nc bnc" id="L2276" title="All 2 branches missed.">                    if (x == CHAINED_KEY)</span>
                    {
<span class="nc" id="L2278">                        Object[] chain = (Object[]) table[i + 1];</span>
<span class="nc bnc" id="L2279" title="All 2 branches missed.">                        for (int j = 0; j &lt; chain.length; j += 2)</span>
                        {
<span class="nc" id="L2281">                            Object cur = chain[j];</span>
<span class="nc bnc" id="L2282" title="All 2 branches missed.">                            if (cur == null)</span>
                            {
<span class="nc" id="L2284">                                break;</span>
                            }
<span class="nc bnc" id="L2286" title="All 2 branches missed.">                            hashCode += cur == NULL_KEY ? 0 : cur.hashCode();</span>
                        }
<span class="nc" id="L2288">                    }</span>
                    else
                    {
<span class="nc bnc" id="L2291" title="All 2 branches missed.">                        hashCode += x == NULL_KEY ? 0 : x.hashCode();</span>
                    }
                }
            }
<span class="nc" id="L2295">            return hashCode;</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L2301">            return Iterate.makeString(this, &quot;[&quot;, &quot;, &quot;, &quot;]&quot;);</span>
        }

        @Override
        public Object[] toArray()
        {
<span class="nc" id="L2307">            int size = UnifiedMap.this.size();</span>
<span class="nc" id="L2308">            Object[] result = new Object[size];</span>
<span class="nc" id="L2309">            this.copyKeys(result);</span>
<span class="nc" id="L2310">            return result;</span>
        }

        @Override
        public &lt;T&gt; T[] toArray(T[] result)
        {
<span class="nc" id="L2316">            int size = UnifiedMap.this.size();</span>
<span class="nc bnc" id="L2317" title="All 2 branches missed.">            if (result.length &lt; size)</span>
            {
<span class="nc" id="L2319">                result = (T[]) Array.newInstance(result.getClass().getComponentType(), size);</span>
            }
<span class="nc" id="L2321">            this.copyKeys(result);</span>
<span class="nc bnc" id="L2322" title="All 2 branches missed.">            if (size &lt; result.length)</span>
            {
<span class="nc" id="L2324">                result[size] = null;</span>
            }
<span class="nc" id="L2326">            return result;</span>
        }

        protected Object writeReplace()
        {
<span class="nc" id="L2331">            UnifiedSet&lt;K&gt; replace = UnifiedSet.newSet(UnifiedMap.this.size());</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">            for (int i = 0; i &lt; UnifiedMap.this.table.length; i += 2)</span>
            {
<span class="nc" id="L2334">                Object cur = UnifiedMap.this.table[i];</span>
<span class="nc bnc" id="L2335" title="All 2 branches missed.">                if (cur == CHAINED_KEY)</span>
                {
<span class="nc" id="L2337">                    this.chainedAddToSet((Object[]) UnifiedMap.this.table[i + 1], replace);</span>
                }
<span class="nc bnc" id="L2339" title="All 2 branches missed.">                else if (cur != null)</span>
                {
<span class="nc" id="L2341">                    replace.add(UnifiedMap.this.nonSentinel(cur));</span>
                }
            }
<span class="nc" id="L2344">            return replace;</span>
        }

        private void chainedAddToSet(Object[] chain, UnifiedSet&lt;K&gt; replace)
        {
<span class="nc bnc" id="L2349" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc" id="L2351">                Object cur = chain[i];</span>
<span class="nc bnc" id="L2352" title="All 2 branches missed.">                if (cur == null)</span>
                {
<span class="nc" id="L2354">                    return;</span>
                }
<span class="nc" id="L2356">                replace.add(UnifiedMap.this.nonSentinel(cur));</span>
            }
<span class="nc" id="L2358">        }</span>
    }

<span class="nc" id="L2361">    protected abstract class PositionalIterator&lt;T&gt; implements Iterator&lt;T&gt;</span>
    {
        protected int count;
        protected int position;
        protected int chainPosition;
        protected boolean lastReturned;

        @Override
        public boolean hasNext()
        {
<span class="nc bnc" id="L2371" title="All 2 branches missed.">            return this.count &lt; UnifiedMap.this.size();</span>
        }

        @Override
        public void remove()
        {
<span class="nc bnc" id="L2377" title="All 2 branches missed.">            if (!this.lastReturned)</span>
            {
<span class="nc" id="L2379">                throw new IllegalStateException(&quot;next() must be called as many times as remove()&quot;);</span>
            }
<span class="nc" id="L2381">            this.count--;</span>
<span class="nc" id="L2382">            UnifiedMap.this.occupied--;</span>

<span class="nc bnc" id="L2384" title="All 2 branches missed.">            if (this.chainPosition != 0)</span>
            {
<span class="nc" id="L2386">                this.removeFromChain();</span>
<span class="nc" id="L2387">                return;</span>
            }

<span class="nc" id="L2390">            int pos = this.position - 2;</span>
<span class="nc" id="L2391">            Object cur = UnifiedMap.this.table[pos];</span>
<span class="nc bnc" id="L2392" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L2394">                this.removeLastFromChain((Object[]) UnifiedMap.this.table[pos + 1], pos);</span>
<span class="nc" id="L2395">                return;</span>
            }
<span class="nc" id="L2397">            UnifiedMap.this.table[pos] = null;</span>
<span class="nc" id="L2398">            UnifiedMap.this.table[pos + 1] = null;</span>
<span class="nc" id="L2399">            this.position = pos;</span>
<span class="nc" id="L2400">            this.lastReturned = false;</span>
<span class="nc" id="L2401">        }</span>

        protected void removeFromChain()
        {
<span class="nc" id="L2405">            Object[] chain = (Object[]) UnifiedMap.this.table[this.position + 1];</span>
<span class="nc" id="L2406">            int pos = this.chainPosition - 2;</span>
<span class="nc" id="L2407">            int replacePos = this.chainPosition;</span>
<span class="nc bnc" id="L2408" title="All 4 branches missed.">            while (replacePos &lt; chain.length - 2 &amp;&amp; chain[replacePos + 2] != null)</span>
            {
<span class="nc" id="L2410">                replacePos += 2;</span>
            }
<span class="nc" id="L2412">            chain[pos] = chain[replacePos];</span>
<span class="nc" id="L2413">            chain[pos + 1] = chain[replacePos + 1];</span>
<span class="nc" id="L2414">            chain[replacePos] = null;</span>
<span class="nc" id="L2415">            chain[replacePos + 1] = null;</span>
<span class="nc" id="L2416">            this.chainPosition = pos;</span>
<span class="nc" id="L2417">            this.lastReturned = false;</span>
<span class="nc" id="L2418">        }</span>

        protected void removeLastFromChain(Object[] chain, int tableIndex)
        {
<span class="nc" id="L2422">            int pos = chain.length - 2;</span>
<span class="nc bnc" id="L2423" title="All 2 branches missed.">            while (chain[pos] == null)</span>
            {
<span class="nc" id="L2425">                pos -= 2;</span>
            }
<span class="nc bnc" id="L2427" title="All 2 branches missed.">            if (pos == 0)</span>
            {
<span class="nc" id="L2429">                UnifiedMap.this.table[tableIndex] = null;</span>
<span class="nc" id="L2430">                UnifiedMap.this.table[tableIndex + 1] = null;</span>
            }
            else
            {
<span class="nc" id="L2434">                chain[pos] = null;</span>
<span class="nc" id="L2435">                chain[pos + 1] = null;</span>
            }
<span class="nc" id="L2437">            this.lastReturned = false;</span>
<span class="nc" id="L2438">        }</span>
    }

<span class="nc" id="L2441">    protected class KeySetIterator extends PositionalIterator&lt;K&gt;</span>
    {
        protected K nextFromChain()
        {
<span class="nc" id="L2445">            Object[] chain = (Object[]) UnifiedMap.this.table[this.position + 1];</span>
<span class="nc" id="L2446">            Object cur = chain[this.chainPosition];</span>
<span class="nc" id="L2447">            this.chainPosition += 2;</span>
<span class="nc bnc" id="L2448" title="All 4 branches missed.">            if (this.chainPosition &gt;= chain.length</span>
                    || chain[this.chainPosition] == null)
            {
<span class="nc" id="L2451">                this.chainPosition = 0;</span>
<span class="nc" id="L2452">                this.position += 2;</span>
            }
<span class="nc" id="L2454">            this.lastReturned = true;</span>
<span class="nc" id="L2455">            return UnifiedMap.this.nonSentinel(cur);</span>
        }

        @Override
        public K next()
        {
<span class="nc bnc" id="L2461" title="All 2 branches missed.">            if (!this.hasNext())</span>
            {
<span class="nc" id="L2463">                throw new NoSuchElementException(&quot;next() called, but the iterator is exhausted&quot;);</span>
            }
<span class="nc" id="L2465">            this.count++;</span>
<span class="nc" id="L2466">            Object[] table = UnifiedMap.this.table;</span>
<span class="nc bnc" id="L2467" title="All 2 branches missed.">            if (this.chainPosition != 0)</span>
            {
<span class="nc" id="L2469">                return this.nextFromChain();</span>
            }
<span class="nc bnc" id="L2471" title="All 2 branches missed.">            while (table[this.position] == null)</span>
            {
<span class="nc" id="L2473">                this.position += 2;</span>
            }
<span class="nc" id="L2475">            Object cur = table[this.position];</span>
<span class="nc bnc" id="L2476" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L2478">                return this.nextFromChain();</span>
            }
<span class="nc" id="L2480">            this.position += 2;</span>
<span class="nc" id="L2481">            this.lastReturned = true;</span>
<span class="nc" id="L2482">            return UnifiedMap.this.nonSentinel(cur);</span>
        }
    }

    private static boolean nullSafeEquals(Object value, Object other)
    {
<span class="nc bnc" id="L2488" title="All 2 branches missed.">        if (value == null)</span>
        {
<span class="nc bnc" id="L2490" title="All 2 branches missed.">            if (other == null)</span>
            {
<span class="nc" id="L2492">                return true;</span>
            }
        }
<span class="nc bnc" id="L2495" title="All 4 branches missed.">        else if (other == value || value.equals(other))</span>
        {
<span class="nc" id="L2497">            return true;</span>
        }
<span class="nc" id="L2499">        return false;</span>
    }

<span class="nc" id="L2502">    protected class EntrySet implements Set&lt;Entry&lt;K, V&gt;&gt;, Serializable, BatchIterable&lt;Entry&lt;K, V&gt;&gt;</span>
    {
        private static final long serialVersionUID = 1L;
<span class="nc" id="L2505">        private transient WeakReference&lt;UnifiedMap&lt;K, V&gt;&gt; holder = new WeakReference&lt;&gt;(UnifiedMap.this);</span>

        @Override
        public boolean add(Entry&lt;K, V&gt; entry)
        {
<span class="nc" id="L2510">            throw new UnsupportedOperationException(&quot;Cannot call add() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public boolean addAll(Collection&lt;? extends Entry&lt;K, V&gt;&gt; collection)
        {
<span class="nc" id="L2516">            throw new UnsupportedOperationException(&quot;Cannot call addAll() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public void clear()
        {
<span class="nc" id="L2522">            UnifiedMap.this.clear();</span>
<span class="nc" id="L2523">        }</span>

        public boolean containsEntry(Entry&lt;?, ?&gt; entry)
        {
<span class="nc bnc" id="L2527" title="All 2 branches missed.">            return this.getEntry(entry) != null;</span>
        }

        private Entry&lt;K, V&gt; getEntry(Entry&lt;?, ?&gt; entry)
        {
<span class="nc" id="L2532">            K key = (K) entry.getKey();</span>
<span class="nc" id="L2533">            V value = (V) entry.getValue();</span>
<span class="nc" id="L2534">            int index = UnifiedMap.this.index(key);</span>

<span class="nc" id="L2536">            Object cur = UnifiedMap.this.table[index];</span>
<span class="nc" id="L2537">            Object curValue = UnifiedMap.this.table[index + 1];</span>
<span class="nc bnc" id="L2538" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L2540">                return this.chainGetEntry((Object[]) curValue, key, value);</span>
            }
<span class="nc bnc" id="L2542" title="All 2 branches missed.">            if (cur == null)</span>
            {
<span class="nc" id="L2544">                return null;</span>
            }
<span class="nc bnc" id="L2546" title="All 2 branches missed.">            if (UnifiedMap.this.nonNullTableObjectEquals(cur, key))</span>
            {
<span class="nc bnc" id="L2548" title="All 2 branches missed.">                if (UnifiedMap.nullSafeEquals(value, curValue))</span>
                {
<span class="nc" id="L2550">                    return ImmutableEntry.of(UnifiedMap.this.nonSentinel(cur), (V) curValue);</span>
                }
            }
<span class="nc" id="L2553">            return null;</span>
        }

        private Entry&lt;K, V&gt; chainGetEntry(Object[] chain, K key, V value)
        {
<span class="nc bnc" id="L2558" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc" id="L2560">                Object cur = chain[i];</span>
<span class="nc bnc" id="L2561" title="All 2 branches missed.">                if (cur == null)</span>
                {
<span class="nc" id="L2563">                    return null;</span>
                }
<span class="nc bnc" id="L2565" title="All 2 branches missed.">                if (UnifiedMap.this.nonNullTableObjectEquals(cur, key))</span>
                {
<span class="nc" id="L2567">                    Object curValue = chain[i + 1];</span>
<span class="nc bnc" id="L2568" title="All 2 branches missed.">                    if (UnifiedMap.nullSafeEquals(value, curValue))</span>
                    {
<span class="nc" id="L2570">                        return ImmutableEntry.of(UnifiedMap.this.nonSentinel(cur), (V) curValue);</span>
                    }
                }
            }
<span class="nc" id="L2574">            return null;</span>
        }

        @Override
        public boolean contains(Object o)
        {
<span class="nc bnc" id="L2580" title="All 4 branches missed.">            return o instanceof Entry &amp;&amp; this.containsEntry((Entry&lt;?, ?&gt;) o);</span>
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; collection)
        {
<span class="nc bnc" id="L2586" title="All 2 branches missed.">            for (Object obj : collection)</span>
            {
<span class="nc bnc" id="L2588" title="All 2 branches missed.">                if (!this.contains(obj))</span>
                {
<span class="nc" id="L2590">                    return false;</span>
                }
<span class="nc" id="L2592">            }</span>
<span class="nc" id="L2593">            return true;</span>
        }

        @Override
        public boolean isEmpty()
        {
<span class="nc" id="L2599">            return UnifiedMap.this.isEmpty();</span>
        }

        @Override
        public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator()
        {
<span class="nc" id="L2605">            return new EntrySetIterator(this.holder);</span>
        }

        @Override
        public boolean remove(Object e)
        {
<span class="nc bnc" id="L2611" title="All 2 branches missed.">            if (!(e instanceof Entry))</span>
            {
<span class="nc" id="L2613">                return false;</span>
            }
<span class="nc" id="L2615">            Entry&lt;?, ?&gt; entry = (Entry&lt;?, ?&gt;) e;</span>
<span class="nc" id="L2616">            K key = (K) entry.getKey();</span>
<span class="nc" id="L2617">            V value = (V) entry.getValue();</span>

<span class="nc" id="L2619">            int index = UnifiedMap.this.index(key);</span>

<span class="nc" id="L2621">            Object cur = UnifiedMap.this.table[index];</span>
<span class="nc bnc" id="L2622" title="All 2 branches missed.">            if (cur != null)</span>
            {
<span class="nc" id="L2624">                Object val = UnifiedMap.this.table[index + 1];</span>
<span class="nc bnc" id="L2625" title="All 2 branches missed.">                if (cur == CHAINED_KEY)</span>
                {
<span class="nc" id="L2627">                    return this.removeFromChain((Object[]) val, key, value, index);</span>
                }
<span class="nc bnc" id="L2629" title="All 4 branches missed.">                if (UnifiedMap.this.nonNullTableObjectEquals(cur, key) &amp;&amp; UnifiedMap.nullSafeEquals(value, val))</span>
                {
<span class="nc" id="L2631">                    UnifiedMap.this.table[index] = null;</span>
<span class="nc" id="L2632">                    UnifiedMap.this.table[index + 1] = null;</span>
<span class="nc" id="L2633">                    UnifiedMap.this.occupied--;</span>
<span class="nc" id="L2634">                    return true;</span>
                }
            }
<span class="nc" id="L2637">            return false;</span>
        }

        private boolean removeFromChain(Object[] chain, K key, V value, int index)
        {
<span class="nc bnc" id="L2642" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc" id="L2644">                Object k = chain[i];</span>
<span class="nc bnc" id="L2645" title="All 2 branches missed.">                if (k == null)</span>
                {
<span class="nc" id="L2647">                    return false;</span>
                }
<span class="nc bnc" id="L2649" title="All 2 branches missed.">                if (UnifiedMap.this.nonNullTableObjectEquals(k, key))</span>
                {
<span class="nc" id="L2651">                    V val = (V) chain[i + 1];</span>
<span class="nc bnc" id="L2652" title="All 2 branches missed.">                    if (UnifiedMap.nullSafeEquals(val, value))</span>
                    {
<span class="nc" id="L2654">                        UnifiedMap.this.overwriteWithLastElementFromChain(chain, index, i);</span>
<span class="nc" id="L2655">                        return true;</span>
                    }
                }
            }
<span class="nc" id="L2659">            return false;</span>
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; collection)
        {
<span class="nc" id="L2665">            boolean changed = false;</span>
<span class="nc bnc" id="L2666" title="All 2 branches missed.">            for (Object obj : collection)</span>
            {
<span class="nc bnc" id="L2668" title="All 2 branches missed.">                if (this.remove(obj))</span>
                {
<span class="nc" id="L2670">                    changed = true;</span>
                }
<span class="nc" id="L2672">            }</span>
<span class="nc" id="L2673">            return changed;</span>
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; collection)
        {
<span class="nc" id="L2679">            int retainedSize = collection.size();</span>
<span class="nc" id="L2680">            UnifiedMap&lt;K, V&gt; retainedCopy = (UnifiedMap&lt;K, V&gt;) UnifiedMap.this.newEmpty(retainedSize);</span>

<span class="nc bnc" id="L2682" title="All 2 branches missed.">            for (Object obj : collection)</span>
            {
<span class="nc bnc" id="L2684" title="All 2 branches missed.">                if (obj instanceof Entry)</span>
                {
<span class="nc" id="L2686">                    Entry&lt;?, ?&gt; otherEntry = (Entry&lt;?, ?&gt;) obj;</span>
<span class="nc" id="L2687">                    Entry&lt;K, V&gt; thisEntry = this.getEntry(otherEntry);</span>
<span class="nc bnc" id="L2688" title="All 2 branches missed.">                    if (thisEntry != null)</span>
                    {
<span class="nc" id="L2690">                        retainedCopy.put(thisEntry.getKey(), thisEntry.getValue());</span>
                    }
                }
<span class="nc" id="L2693">            }</span>
<span class="nc bnc" id="L2694" title="All 2 branches missed.">            if (retainedCopy.size() &lt; this.size())</span>
            {
<span class="nc" id="L2696">                UnifiedMap.this.maxSize = retainedCopy.maxSize;</span>
<span class="nc" id="L2697">                UnifiedMap.this.occupied = retainedCopy.occupied;</span>
<span class="nc" id="L2698">                UnifiedMap.this.table = retainedCopy.table;</span>
<span class="nc" id="L2699">                return true;</span>
            }
<span class="nc" id="L2701">            return false;</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L2707">            return UnifiedMap.this.size();</span>
        }

        @Override
        public void forEach(Procedure&lt;? super Entry&lt;K, V&gt;&gt; procedure)
        {
<span class="nc bnc" id="L2713" title="All 2 branches missed.">            for (int i = 0; i &lt; UnifiedMap.this.table.length; i += 2)</span>
            {
<span class="nc" id="L2715">                Object cur = UnifiedMap.this.table[i];</span>
<span class="nc bnc" id="L2716" title="All 2 branches missed.">                if (cur == CHAINED_KEY)</span>
                {
<span class="nc" id="L2718">                    this.chainedForEachEntry((Object[]) UnifiedMap.this.table[i + 1], procedure);</span>
                }
<span class="nc bnc" id="L2720" title="All 2 branches missed.">                else if (cur != null)</span>
                {
<span class="nc" id="L2722">                    procedure.value(ImmutableEntry.of(UnifiedMap.this.nonSentinel(cur), (V) UnifiedMap.this.table[i + 1]));</span>
                }
            }
<span class="nc" id="L2725">        }</span>

        private void chainedForEachEntry(Object[] chain, Procedure&lt;? super Entry&lt;K, V&gt;&gt; procedure)
        {
<span class="nc bnc" id="L2729" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc" id="L2731">                Object cur = chain[i];</span>
<span class="nc bnc" id="L2732" title="All 2 branches missed.">                if (cur == null)</span>
                {
<span class="nc" id="L2734">                    return;</span>
                }
<span class="nc" id="L2736">                procedure.value(ImmutableEntry.of(UnifiedMap.this.nonSentinel(cur), (V) chain[i + 1]));</span>
            }
<span class="nc" id="L2738">        }</span>

        @Override
        public int getBatchCount(int batchSize)
        {
<span class="nc" id="L2743">            return UnifiedMap.this.getBatchCount(batchSize);</span>
        }

        @Override
        public void batchForEach(Procedure&lt;? super Entry&lt;K, V&gt;&gt; procedure, int sectionIndex, int sectionCount)
        {
<span class="nc" id="L2749">            Object[] map = UnifiedMap.this.table;</span>
<span class="nc" id="L2750">            int sectionSize = map.length / sectionCount;</span>
<span class="nc" id="L2751">            int start = sectionIndex * sectionSize;</span>
<span class="nc bnc" id="L2752" title="All 2 branches missed.">            int end = sectionIndex == sectionCount - 1 ? map.length : start + sectionSize;</span>
<span class="nc bnc" id="L2753" title="All 2 branches missed.">            if (start % 2 != 0)</span>
            {
<span class="nc" id="L2755">                start++;</span>
            }
<span class="nc bnc" id="L2757" title="All 2 branches missed.">            for (int i = start; i &lt; end; i += 2)</span>
            {
<span class="nc" id="L2759">                Object cur = map[i];</span>
<span class="nc bnc" id="L2760" title="All 2 branches missed.">                if (cur == CHAINED_KEY)</span>
                {
<span class="nc" id="L2762">                    this.chainedForEachEntry((Object[]) map[i + 1], procedure);</span>
                }
<span class="nc bnc" id="L2764" title="All 2 branches missed.">                else if (cur != null)</span>
                {
<span class="nc" id="L2766">                    procedure.value(ImmutableEntry.of(UnifiedMap.this.nonSentinel(cur), (V) map[i + 1]));</span>
                }
            }
<span class="nc" id="L2769">        }</span>

        protected void copyEntries(Object[] result)
        {
<span class="nc" id="L2773">            Object[] table = UnifiedMap.this.table;</span>
<span class="nc" id="L2774">            int count = 0;</span>
<span class="nc bnc" id="L2775" title="All 2 branches missed.">            for (int i = 0; i &lt; table.length; i += 2)</span>
            {
<span class="nc" id="L2777">                Object x = table[i];</span>
<span class="nc bnc" id="L2778" title="All 2 branches missed.">                if (x != null)</span>
                {
<span class="nc bnc" id="L2780" title="All 2 branches missed.">                    if (x == CHAINED_KEY)</span>
                    {
<span class="nc" id="L2782">                        Object[] chain = (Object[]) table[i + 1];</span>
<span class="nc bnc" id="L2783" title="All 2 branches missed.">                        for (int j = 0; j &lt; chain.length; j += 2)</span>
                        {
<span class="nc" id="L2785">                            Object cur = chain[j];</span>
<span class="nc bnc" id="L2786" title="All 2 branches missed.">                            if (cur == null)</span>
                            {
<span class="nc" id="L2788">                                break;</span>
                            }
<span class="nc" id="L2790">                            result[count++] =</span>
<span class="nc" id="L2791">                                    new WeakBoundEntry&lt;&gt;(UnifiedMap.this.nonSentinel(cur), (V) chain[j + 1], this.holder);</span>
                        }
<span class="nc" id="L2793">                    }</span>
                    else
                    {
<span class="nc" id="L2796">                        result[count++] = new WeakBoundEntry&lt;&gt;(UnifiedMap.this.nonSentinel(x), (V) table[i + 1], this.holder);</span>
                    }
                }
            }
<span class="nc" id="L2800">        }</span>

        @Override
        public Object[] toArray()
        {
<span class="nc" id="L2805">            Object[] result = new Object[UnifiedMap.this.size()];</span>
<span class="nc" id="L2806">            this.copyEntries(result);</span>
<span class="nc" id="L2807">            return result;</span>
        }

        @Override
        public &lt;T&gt; T[] toArray(T[] result)
        {
<span class="nc" id="L2813">            int size = UnifiedMap.this.size();</span>
<span class="nc bnc" id="L2814" title="All 2 branches missed.">            if (result.length &lt; size)</span>
            {
<span class="nc" id="L2816">                result = (T[]) Array.newInstance(result.getClass().getComponentType(), size);</span>
            }
<span class="nc" id="L2818">            this.copyEntries(result);</span>
<span class="nc bnc" id="L2819" title="All 2 branches missed.">            if (size &lt; result.length)</span>
            {
<span class="nc" id="L2821">                result[size] = null;</span>
            }
<span class="nc" id="L2823">            return result;</span>
        }

        private void readObject(ObjectInputStream in)
                throws IOException, ClassNotFoundException
        {
<span class="nc" id="L2829">            in.defaultReadObject();</span>
<span class="nc" id="L2830">            this.holder = new WeakReference&lt;&gt;(UnifiedMap.this);</span>
<span class="nc" id="L2831">        }</span>

        @Override
        public boolean equals(Object obj)
        {
<span class="nc bnc" id="L2836" title="All 2 branches missed.">            if (obj instanceof Set)</span>
            {
<span class="nc" id="L2838">                Set&lt;?&gt; other = (Set&lt;?&gt;) obj;</span>
<span class="nc bnc" id="L2839" title="All 2 branches missed.">                if (other.size() == this.size())</span>
                {
<span class="nc" id="L2841">                    return this.containsAll(other);</span>
                }
            }
<span class="nc" id="L2844">            return false;</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L2850">            return UnifiedMap.this.hashCode();</span>
        }
    }

    protected class EntrySetIterator extends PositionalIterator&lt;Entry&lt;K, V&gt;&gt;
    {
        private final WeakReference&lt;UnifiedMap&lt;K, V&gt;&gt; holder;

        protected EntrySetIterator(WeakReference&lt;UnifiedMap&lt;K, V&gt;&gt; holder)
<span class="nc" id="L2859">        {</span>
<span class="nc" id="L2860">            this.holder = holder;</span>
<span class="nc" id="L2861">        }</span>

        protected Entry&lt;K, V&gt; nextFromChain()
        {
<span class="nc" id="L2865">            Object[] chain = (Object[]) UnifiedMap.this.table[this.position + 1];</span>
<span class="nc" id="L2866">            Object cur = chain[this.chainPosition];</span>
<span class="nc" id="L2867">            Object value = chain[this.chainPosition + 1];</span>
<span class="nc" id="L2868">            this.chainPosition += 2;</span>
<span class="nc bnc" id="L2869" title="All 4 branches missed.">            if (this.chainPosition &gt;= chain.length</span>
                    || chain[this.chainPosition] == null)
            {
<span class="nc" id="L2872">                this.chainPosition = 0;</span>
<span class="nc" id="L2873">                this.position += 2;</span>
            }
<span class="nc" id="L2875">            this.lastReturned = true;</span>
<span class="nc" id="L2876">            return new WeakBoundEntry&lt;&gt;(UnifiedMap.this.nonSentinel(cur), (V) value, this.holder);</span>
        }

        @Override
        public Entry&lt;K, V&gt; next()
        {
<span class="nc bnc" id="L2882" title="All 2 branches missed.">            if (!this.hasNext())</span>
            {
<span class="nc" id="L2884">                throw new NoSuchElementException(&quot;next() called, but the iterator is exhausted&quot;);</span>
            }
<span class="nc" id="L2886">            this.count++;</span>
<span class="nc" id="L2887">            Object[] table = UnifiedMap.this.table;</span>
<span class="nc bnc" id="L2888" title="All 2 branches missed.">            if (this.chainPosition != 0)</span>
            {
<span class="nc" id="L2890">                return this.nextFromChain();</span>
            }
<span class="nc bnc" id="L2892" title="All 2 branches missed.">            while (table[this.position] == null)</span>
            {
<span class="nc" id="L2894">                this.position += 2;</span>
            }
<span class="nc" id="L2896">            Object cur = table[this.position];</span>
<span class="nc" id="L2897">            Object value = table[this.position + 1];</span>
<span class="nc bnc" id="L2898" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L2900">                return this.nextFromChain();</span>
            }
<span class="nc" id="L2902">            this.position += 2;</span>
<span class="nc" id="L2903">            this.lastReturned = true;</span>
<span class="nc" id="L2904">            return new WeakBoundEntry&lt;&gt;(UnifiedMap.this.nonSentinel(cur), (V) value, this.holder);</span>
        }
    }

    protected static class WeakBoundEntry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt;
    {
        protected final K key;
        protected V value;
        protected final WeakReference&lt;UnifiedMap&lt;K, V&gt;&gt; holder;

        protected WeakBoundEntry(K key, V value, WeakReference&lt;UnifiedMap&lt;K, V&gt;&gt; holder)
<span class="nc" id="L2915">        {</span>
<span class="nc" id="L2916">            this.key = key;</span>
<span class="nc" id="L2917">            this.value = value;</span>
<span class="nc" id="L2918">            this.holder = holder;</span>
<span class="nc" id="L2919">        }</span>

        @Override
        public K getKey()
        {
<span class="nc" id="L2924">            return this.key;</span>
        }

        @Override
        public V getValue()
        {
<span class="nc" id="L2930">            return this.value;</span>
        }

        @Override
        public V setValue(V value)
        {
<span class="nc" id="L2936">            this.value = value;</span>
<span class="nc" id="L2937">            UnifiedMap&lt;K, V&gt; map = this.holder.get();</span>
<span class="nc bnc" id="L2938" title="All 4 branches missed.">            if (map != null &amp;&amp; map.containsKey(this.key))</span>
            {
<span class="nc" id="L2940">                return map.put(this.key, value);</span>
            }
<span class="nc" id="L2942">            return null;</span>
        }

        @Override
        public boolean equals(Object obj)
        {
<span class="nc bnc" id="L2948" title="All 2 branches missed.">            if (obj instanceof Entry)</span>
            {
<span class="nc" id="L2950">                Entry&lt;?, ?&gt; other = (Entry&lt;?, ?&gt;) obj;</span>
<span class="nc" id="L2951">                K otherKey = (K) other.getKey();</span>
<span class="nc" id="L2952">                V otherValue = (V) other.getValue();</span>
<span class="nc bnc" id="L2953" title="All 2 branches missed.">                return UnifiedMap.nullSafeEquals(this.key, otherKey)</span>
<span class="nc bnc" id="L2954" title="All 2 branches missed.">                        &amp;&amp; UnifiedMap.nullSafeEquals(this.value, otherValue);</span>
            }
<span class="nc" id="L2956">            return false;</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc bnc" id="L2962" title="All 4 branches missed.">            return (this.key == null ? 0 : this.key.hashCode())</span>
<span class="nc" id="L2963">                    ^ (this.value == null ? 0 : this.value.hashCode());</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L2969">            return this.key + &quot;=&quot; + this.value;</span>
        }
    }

<span class="nc" id="L2973">    protected class ValuesCollection extends ValuesCollectionCommon&lt;V&gt;</span>
            implements Serializable, BatchIterable&lt;V&gt;
    {
        private static final long serialVersionUID = 1L;

        @Override
        public void clear()
        {
<span class="nc" id="L2981">            UnifiedMap.this.clear();</span>
<span class="nc" id="L2982">        }</span>

        @Override
        public boolean contains(Object o)
        {
<span class="nc" id="L2987">            return UnifiedMap.this.containsValue(o);</span>
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; collection)
        {
            // todo: this is N^2. if c is large, we should copy the values to a set.
<span class="nc" id="L2994">            return Iterate.allSatisfy(collection, Predicates.in(this));</span>
        }

        @Override
        public boolean isEmpty()
        {
<span class="nc" id="L3000">            return UnifiedMap.this.isEmpty();</span>
        }

        @Override
        public Iterator&lt;V&gt; iterator()
        {
<span class="nc" id="L3006">            return new ValuesIterator();</span>
        }

        @Override
        public boolean remove(Object o)
        {
            // this is so slow that the extra overhead of the iterator won't be noticeable
<span class="nc bnc" id="L3013" title="All 2 branches missed.">            if (o == null)</span>
            {
<span class="nc bnc" id="L3015" title="All 2 branches missed.">                for (Iterator&lt;V&gt; it = this.iterator(); it.hasNext(); )</span>
                {
<span class="nc bnc" id="L3017" title="All 2 branches missed.">                    if (it.next() == null)</span>
                    {
<span class="nc" id="L3019">                        it.remove();</span>
<span class="nc" id="L3020">                        return true;</span>
                    }
                }
            }
            else
            {
<span class="nc bnc" id="L3026" title="All 2 branches missed.">                for (Iterator&lt;V&gt; it = this.iterator(); it.hasNext(); )</span>
                {
<span class="nc" id="L3028">                    V o2 = it.next();</span>
<span class="nc bnc" id="L3029" title="All 4 branches missed.">                    if (o == o2 || o2.equals(o))</span>
                    {
<span class="nc" id="L3031">                        it.remove();</span>
<span class="nc" id="L3032">                        return true;</span>
                    }
<span class="nc" id="L3034">                }</span>
            }
<span class="nc" id="L3036">            return false;</span>
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; collection)
        {
            // todo: this is N^2. if c is large, we should copy the values to a set.
<span class="nc" id="L3043">            boolean changed = false;</span>

<span class="nc bnc" id="L3045" title="All 2 branches missed.">            for (Object obj : collection)</span>
            {
<span class="nc bnc" id="L3047" title="All 2 branches missed.">                if (this.remove(obj))</span>
                {
<span class="nc" id="L3049">                    changed = true;</span>
                }
<span class="nc" id="L3051">            }</span>
<span class="nc" id="L3052">            return changed;</span>
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; collection)
        {
<span class="nc" id="L3058">            boolean modified = false;</span>
<span class="nc" id="L3059">            Iterator&lt;V&gt; e = this.iterator();</span>
<span class="nc bnc" id="L3060" title="All 2 branches missed.">            while (e.hasNext())</span>
            {
<span class="nc bnc" id="L3062" title="All 2 branches missed.">                if (!collection.contains(e.next()))</span>
                {
<span class="nc" id="L3064">                    e.remove();</span>
<span class="nc" id="L3065">                    modified = true;</span>
                }
            }
<span class="nc" id="L3068">            return modified;</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L3074">            return UnifiedMap.this.size();</span>
        }

        @Override
        public void forEach(Procedure&lt;? super V&gt; procedure)
        {
<span class="nc" id="L3080">            UnifiedMap.this.forEachValue(procedure);</span>
<span class="nc" id="L3081">        }</span>

        @Override
        public int getBatchCount(int batchSize)
        {
<span class="nc" id="L3086">            return UnifiedMap.this.getBatchCount(batchSize);</span>
        }

        @Override
        public void batchForEach(Procedure&lt;? super V&gt; procedure, int sectionIndex, int sectionCount)
        {
<span class="nc" id="L3092">            UnifiedMap.this.batchForEach(procedure, sectionIndex, sectionCount);</span>
<span class="nc" id="L3093">        }</span>

        protected void copyValues(Object[] result)
        {
<span class="nc" id="L3097">            int count = 0;</span>
<span class="nc bnc" id="L3098" title="All 2 branches missed.">            for (int i = 0; i &lt; UnifiedMap.this.table.length; i += 2)</span>
            {
<span class="nc" id="L3100">                Object x = UnifiedMap.this.table[i];</span>
<span class="nc bnc" id="L3101" title="All 2 branches missed.">                if (x != null)</span>
                {
<span class="nc bnc" id="L3103" title="All 2 branches missed.">                    if (x == CHAINED_KEY)</span>
                    {
<span class="nc" id="L3105">                        Object[] chain = (Object[]) UnifiedMap.this.table[i + 1];</span>
<span class="nc bnc" id="L3106" title="All 2 branches missed.">                        for (int j = 0; j &lt; chain.length; j += 2)</span>
                        {
<span class="nc" id="L3108">                            Object cur = chain[j];</span>
<span class="nc bnc" id="L3109" title="All 2 branches missed.">                            if (cur == null)</span>
                            {
<span class="nc" id="L3111">                                break;</span>
                            }
<span class="nc" id="L3113">                            result[count++] = chain[j + 1];</span>
                        }
<span class="nc" id="L3115">                    }</span>
                    else
                    {
<span class="nc" id="L3118">                        result[count++] = UnifiedMap.this.table[i + 1];</span>
                    }
                }
            }
<span class="nc" id="L3122">        }</span>

        @Override
        public Object[] toArray()
        {
<span class="nc" id="L3127">            int size = UnifiedMap.this.size();</span>
<span class="nc" id="L3128">            Object[] result = new Object[size];</span>
<span class="nc" id="L3129">            this.copyValues(result);</span>
<span class="nc" id="L3130">            return result;</span>
        }

        @Override
        public &lt;T&gt; T[] toArray(T[] result)
        {
<span class="nc" id="L3136">            int size = UnifiedMap.this.size();</span>
<span class="nc bnc" id="L3137" title="All 2 branches missed.">            if (result.length &lt; size)</span>
            {
<span class="nc" id="L3139">                result = (T[]) Array.newInstance(result.getClass().getComponentType(), size);</span>
            }
<span class="nc" id="L3141">            this.copyValues(result);</span>
<span class="nc bnc" id="L3142" title="All 2 branches missed.">            if (size &lt; result.length)</span>
            {
<span class="nc" id="L3144">                result[size] = null;</span>
            }
<span class="nc" id="L3146">            return result;</span>
        }

        protected Object writeReplace()
        {
<span class="nc" id="L3151">            FastList&lt;V&gt; replace = FastList.newList(UnifiedMap.this.size());</span>
<span class="nc bnc" id="L3152" title="All 2 branches missed.">            for (int i = 0; i &lt; UnifiedMap.this.table.length; i += 2)</span>
            {
<span class="nc" id="L3154">                Object cur = UnifiedMap.this.table[i];</span>
<span class="nc bnc" id="L3155" title="All 2 branches missed.">                if (cur == CHAINED_KEY)</span>
                {
<span class="nc" id="L3157">                    this.chainedAddToList((Object[]) UnifiedMap.this.table[i + 1], replace);</span>
                }
<span class="nc bnc" id="L3159" title="All 2 branches missed.">                else if (cur != null)</span>
                {
<span class="nc" id="L3161">                    replace.add((V) UnifiedMap.this.table[i + 1]);</span>
                }
            }
<span class="nc" id="L3164">            return replace;</span>
        }

        private void chainedAddToList(Object[] chain, FastList&lt;V&gt; replace)
        {
<span class="nc bnc" id="L3169" title="All 2 branches missed.">            for (int i = 0; i &lt; chain.length; i += 2)</span>
            {
<span class="nc" id="L3171">                Object cur = chain[i];</span>
<span class="nc bnc" id="L3172" title="All 2 branches missed.">                if (cur == null)</span>
                {
<span class="nc" id="L3174">                    return;</span>
                }
<span class="nc" id="L3176">                replace.add((V) chain[i + 1]);</span>
            }
<span class="nc" id="L3178">        }</span>

        @Override
        public String toString()
        {
<span class="nc" id="L3183">            return Iterate.makeString(this, &quot;[&quot;, &quot;, &quot;, &quot;]&quot;);</span>
        }
    }

<span class="nc" id="L3187">    protected class ValuesIterator extends PositionalIterator&lt;V&gt;</span>
    {
        protected V nextFromChain()
        {
<span class="nc" id="L3191">            Object[] chain = (Object[]) UnifiedMap.this.table[this.position + 1];</span>
<span class="nc" id="L3192">            V val = (V) chain[this.chainPosition + 1];</span>
<span class="nc" id="L3193">            this.chainPosition += 2;</span>
<span class="nc bnc" id="L3194" title="All 4 branches missed.">            if (this.chainPosition &gt;= chain.length</span>
                    || chain[this.chainPosition] == null)
            {
<span class="nc" id="L3197">                this.chainPosition = 0;</span>
<span class="nc" id="L3198">                this.position += 2;</span>
            }
<span class="nc" id="L3200">            this.lastReturned = true;</span>
<span class="nc" id="L3201">            return val;</span>
        }

        @Override
        public V next()
        {
<span class="nc bnc" id="L3207" title="All 2 branches missed.">            if (!this.hasNext())</span>
            {
<span class="nc" id="L3209">                throw new NoSuchElementException(&quot;next() called, but the iterator is exhausted&quot;);</span>
            }
<span class="nc" id="L3211">            this.count++;</span>
<span class="nc" id="L3212">            Object[] table = UnifiedMap.this.table;</span>
<span class="nc bnc" id="L3213" title="All 2 branches missed.">            if (this.chainPosition != 0)</span>
            {
<span class="nc" id="L3215">                return this.nextFromChain();</span>
            }
<span class="nc bnc" id="L3217" title="All 2 branches missed.">            while (table[this.position] == null)</span>
            {
<span class="nc" id="L3219">                this.position += 2;</span>
            }
<span class="nc" id="L3221">            Object cur = table[this.position];</span>
<span class="nc" id="L3222">            Object val = table[this.position + 1];</span>
<span class="nc bnc" id="L3223" title="All 2 branches missed.">            if (cur == CHAINED_KEY)</span>
            {
<span class="nc" id="L3225">                return this.nextFromChain();</span>
            }
<span class="nc" id="L3227">            this.position += 2;</span>
<span class="nc" id="L3228">            this.lastReturned = true;</span>
<span class="nc" id="L3229">            return (V) val;</span>
        }
    }

    private K nonSentinel(Object key)
    {
<span class="nc bnc" id="L3235" title="All 2 branches missed.">        return key == NULL_KEY ? null : (K) key;</span>
    }

    private static Object toSentinelIfNull(Object key)
    {
<span class="nc bnc" id="L3240" title="All 2 branches missed.">        if (key == null)</span>
        {
<span class="nc" id="L3242">            return NULL_KEY;</span>
        }
<span class="nc" id="L3244">        return key;</span>
    }

    private boolean nonNullTableObjectEquals(Object cur, K key)
    {
<span class="nc bnc" id="L3249" title="All 8 branches missed.">        return cur == key || (cur == NULL_KEY ? key == null : cur.equals(key));</span>
    }

    @Override
    public ImmutableMap&lt;K, V&gt; toImmutable()
    {
<span class="nc" id="L3255">        return Maps.immutable.withAll(this);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>