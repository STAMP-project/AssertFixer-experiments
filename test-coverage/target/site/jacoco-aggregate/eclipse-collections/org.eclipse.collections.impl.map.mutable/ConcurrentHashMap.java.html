<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ConcurrentHashMap.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.impl.map.mutable</a> &gt; <span class="el_source">ConcurrentHashMap.java</span></div><h1>ConcurrentHashMap.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2016 Goldman Sachs.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.impl.map.mutable;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.AbstractCollection;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.Executor;
import java.util.concurrent.FutureTask;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicIntegerArray;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicReferenceArray;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import java.util.function.Predicate;

import org.eclipse.collections.api.block.function.Function;
import org.eclipse.collections.api.block.function.Function0;
import org.eclipse.collections.api.block.function.Function2;
import org.eclipse.collections.api.block.function.Function3;
import org.eclipse.collections.api.block.procedure.Procedure;
import org.eclipse.collections.api.block.procedure.Procedure2;
import org.eclipse.collections.api.block.procedure.primitive.ObjectIntProcedure;
import org.eclipse.collections.api.map.ConcurrentMutableMap;
import org.eclipse.collections.api.map.ImmutableMap;
import org.eclipse.collections.api.map.MutableMap;
import org.eclipse.collections.api.tuple.Pair;
import org.eclipse.collections.impl.block.procedure.MapEntryToProcedure2;
import org.eclipse.collections.impl.factory.Maps;
import org.eclipse.collections.impl.list.mutable.FastList;
import org.eclipse.collections.impl.utility.Iterate;
import org.eclipse.collections.impl.utility.MapIterate;
import org.eclipse.collections.impl.utility.internal.IterableIterate;

@SuppressWarnings({ &quot;rawtypes&quot;, &quot;ObjectEquality&quot; })
public final class ConcurrentHashMap&lt;K, V&gt;
        extends AbstractMutableMap&lt;K, V&gt;
        implements ConcurrentMutableMap&lt;K, V&gt;, Externalizable
{
    private static final long serialVersionUID = 1L;

<span class="nc" id="L61">    private static final Object RESIZE_SENTINEL = new Object();</span>
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    /**
     * The maximum capacity, used if a higher value is implicitly specified
     * by either of the constructors with arguments.
     * MUST be a power of two &lt;= 1&lt;&lt;30.
     */
    private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

<span class="nc" id="L71">    private static final AtomicReferenceFieldUpdater&lt;ConcurrentHashMap, AtomicReferenceArray&gt; TABLE_UPDATER = AtomicReferenceFieldUpdater.newUpdater(ConcurrentHashMap.class, AtomicReferenceArray.class, &quot;table&quot;);</span>
<span class="nc" id="L72">    private static final AtomicIntegerFieldUpdater&lt;ConcurrentHashMap&gt; SIZE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcurrentHashMap.class, &quot;size&quot;);</span>
<span class="nc" id="L73">    private static final Object RESIZED = new Object();</span>
<span class="nc" id="L74">    private static final Object RESIZING = new Object();</span>
    private static final int PARTITIONED_SIZE_THRESHOLD = 4096; // chosen to keep size below 1% of the total size of the map
    private static final int SIZE_BUCKETS = 7;

    /**
     * The table, resized as necessary. Length MUST Always be a power of two.
     */
    private volatile AtomicReferenceArray table;

    private AtomicIntegerArray partitionedSize;

    @SuppressWarnings(&quot;UnusedDeclaration&quot;)
    private volatile int size; // updated via atomic field updater

    public ConcurrentHashMap()
    {
<span class="nc" id="L90">        this(DEFAULT_INITIAL_CAPACITY);</span>
<span class="nc" id="L91">    }</span>

    public ConcurrentHashMap(int initialCapacity)
<span class="nc" id="L94">    {</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (initialCapacity &lt; 0)</span>
        {
<span class="nc" id="L97">            throw new IllegalArgumentException(&quot;Illegal Initial Capacity: &quot; + initialCapacity);</span>
        }
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span>
        {
<span class="nc" id="L101">            initialCapacity = MAXIMUM_CAPACITY;</span>
        }

<span class="nc" id="L104">        int threshold = initialCapacity;</span>
<span class="nc" id="L105">        threshold += threshold &gt;&gt; 1; // threshold = length * 0.75</span>

<span class="nc" id="L107">        int capacity = 1;</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">        while (capacity &lt; threshold)</span>
        {
<span class="nc" id="L110">            capacity &lt;&lt;= 1;</span>
        }
<span class="nc bnc" id="L112" title="All 2 branches missed.">        if (capacity &gt;= PARTITIONED_SIZE_THRESHOLD)</span>
        {
<span class="nc" id="L114">            this.partitionedSize = new AtomicIntegerArray(SIZE_BUCKETS * 16); // we want 7 extra slots and 64 bytes for each slot. int is 4 bytes, so 64 bytes is 16 ints.</span>
        }
<span class="nc" id="L116">        this.table = new AtomicReferenceArray(capacity + 1);</span>
<span class="nc" id="L117">    }</span>

    public static &lt;K, V&gt; ConcurrentHashMap&lt;K, V&gt; newMap()
    {
<span class="nc" id="L121">        return new ConcurrentHashMap&lt;&gt;();</span>
    }

    public static &lt;K, V&gt; ConcurrentHashMap&lt;K, V&gt; newMap(int newSize)
    {
<span class="nc" id="L126">        return new ConcurrentHashMap&lt;&gt;(newSize);</span>
    }

    private static int indexFor(int h, int length)
    {
<span class="nc" id="L131">        return h &amp; length - 2;</span>
    }

    @Override
    public V putIfAbsent(K key, V value)
    {
<span class="nc" id="L137">        int hash = this.hash(key);</span>
<span class="nc" id="L138">        AtomicReferenceArray currentArray = this.table;</span>
        while (true)
        {
<span class="nc" id="L141">            int length = currentArray.length();</span>
<span class="nc" id="L142">            int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L143">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L144" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L146">                currentArray = this.helpWithResizeWhileCurrentIndex(currentArray, index);</span>
            }
            else
            {
<span class="nc" id="L150">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">                while (e != null)</span>
                {
<span class="nc" id="L153">                    K candidate = e.getKey();</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                    if (candidate.equals(key))</span>
                    {
<span class="nc" id="L156">                        return e.getValue();</span>
                    }
<span class="nc" id="L158">                    e = e.getNext();</span>
<span class="nc" id="L159">                }</span>
<span class="nc" id="L160">                Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, value, (Entry&lt;K, V&gt;) o);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">                if (currentArray.compareAndSet(index, o, newEntry))</span>
                {
<span class="nc" id="L163">                    this.incrementSizeAndPossiblyResize(currentArray, length, o);</span>
<span class="nc" id="L164">                    return null; // per the contract of putIfAbsent, we return null when the map didn't have this key before</span>
                }
            }
<span class="nc" id="L167">        }</span>
    }

    private void incrementSizeAndPossiblyResize(AtomicReferenceArray currentArray, int length, Object prev)
    {
<span class="nc" id="L172">        this.addToSize(1);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (prev != null)</span>
        {
<span class="nc" id="L175">            int localSize = this.size();</span>
<span class="nc" id="L176">            int threshold = (length &gt;&gt; 1) + (length &gt;&gt; 2); // threshold = length * 0.75</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            if (localSize + 1 &gt; threshold)</span>
            {
<span class="nc" id="L179">                this.resize(currentArray);</span>
            }
        }
<span class="nc" id="L182">    }</span>

    private int hash(Object key)
    {
<span class="nc" id="L186">        int h = key.hashCode();</span>
<span class="nc" id="L187">        h ^= h &gt;&gt;&gt; 20 ^ h &gt;&gt;&gt; 12;</span>
<span class="nc" id="L188">        h ^= h &gt;&gt;&gt; 7 ^ h &gt;&gt;&gt; 4;</span>
<span class="nc" id="L189">        return h;</span>
    }

    private AtomicReferenceArray helpWithResizeWhileCurrentIndex(AtomicReferenceArray currentArray, int index)
    {
<span class="nc" id="L194">        AtomicReferenceArray newArray = this.helpWithResize(currentArray);</span>
<span class="nc" id="L195">        int helpCount = 0;</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">        while (currentArray.get(index) != RESIZED)</span>
        {
<span class="nc" id="L198">            helpCount++;</span>
<span class="nc" id="L199">            newArray = this.helpWithResize(currentArray);</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            if ((helpCount &amp; 7) == 0)</span>
            {
<span class="nc" id="L202">                Thread.yield();</span>
            }
        }
<span class="nc" id="L205">        return newArray;</span>
    }

    private AtomicReferenceArray helpWithResize(AtomicReferenceArray currentArray)
    {
<span class="nc" id="L210">        ResizeContainer resizeContainer = (ResizeContainer) currentArray.get(currentArray.length() - 1);</span>
<span class="nc" id="L211">        AtomicReferenceArray newTable = resizeContainer.nextArray;</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (resizeContainer.getQueuePosition() &gt; ResizeContainer.QUEUE_INCREMENT)</span>
        {
<span class="nc" id="L214">            resizeContainer.incrementResizer();</span>
<span class="nc" id="L215">            this.reverseTransfer(currentArray, resizeContainer);</span>
<span class="nc" id="L216">            resizeContainer.decrementResizerAndNotify();</span>
        }
<span class="nc" id="L218">        return newTable;</span>
    }

    private void resize(AtomicReferenceArray oldTable)
    {
<span class="nc" id="L223">        this.resize(oldTable, (oldTable.length() - 1 &lt;&lt; 1) + 1);</span>
<span class="nc" id="L224">    }</span>

    // newSize must be a power of 2 + 1
    @SuppressWarnings(&quot;JLM_JSR166_UTILCONCURRENT_MONITORENTER&quot;)
    private void resize(AtomicReferenceArray oldTable, int newSize)
    {
<span class="nc" id="L230">        int oldCapacity = oldTable.length();</span>
<span class="nc" id="L231">        int end = oldCapacity - 1;</span>
<span class="nc" id="L232">        Object last = oldTable.get(end);</span>
<span class="nc bnc" id="L233" title="All 4 branches missed.">        if (this.size() &lt; end &amp;&amp; last == RESIZE_SENTINEL)</span>
        {
<span class="nc" id="L235">            return;</span>
        }
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (oldCapacity &gt;= MAXIMUM_CAPACITY)</span>
        {
<span class="nc" id="L239">            throw new RuntimeException(&quot;index is too large!&quot;);</span>
        }
<span class="nc" id="L241">        ResizeContainer resizeContainer = null;</span>
<span class="nc" id="L242">        boolean ownResize = false;</span>
<span class="nc bnc" id="L243" title="All 4 branches missed.">        if (last == null || last == RESIZE_SENTINEL)</span>
        {
<span class="nc" id="L245">            synchronized (oldTable) // allocating a new array is too expensive to make this an atomic operation</span>
            {
<span class="nc bnc" id="L247" title="All 2 branches missed.">                if (oldTable.get(end) == null)</span>
                {
<span class="nc" id="L249">                    oldTable.set(end, RESIZE_SENTINEL);</span>
<span class="nc bnc" id="L250" title="All 4 branches missed.">                    if (this.partitionedSize == null &amp;&amp; newSize &gt;= PARTITIONED_SIZE_THRESHOLD)</span>
                    {
<span class="nc" id="L252">                        this.partitionedSize = new AtomicIntegerArray(SIZE_BUCKETS * 16);</span>
                    }
<span class="nc" id="L254">                    resizeContainer = new ResizeContainer(new AtomicReferenceArray(newSize), oldTable.length() - 1);</span>
<span class="nc" id="L255">                    oldTable.set(end, resizeContainer);</span>
<span class="nc" id="L256">                    ownResize = true;</span>
                }
<span class="nc" id="L258">            }</span>
        }
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (ownResize)</span>
        {
<span class="nc" id="L262">            this.transfer(oldTable, resizeContainer);</span>
<span class="nc" id="L263">            AtomicReferenceArray src = this.table;</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">            while (!TABLE_UPDATER.compareAndSet(this, oldTable, resizeContainer.nextArray))</span>
            {
                // we're in a double resize situation; we'll have to go help until it's our turn to set the table
<span class="nc bnc" id="L267" title="All 2 branches missed.">                if (src != oldTable)</span>
                {
<span class="nc" id="L269">                    this.helpWithResize(src);</span>
                }
            }
<span class="nc" id="L272">        }</span>
        else
        {
<span class="nc" id="L275">            this.helpWithResize(oldTable);</span>
        }
<span class="nc" id="L277">    }</span>

    /*
     * Transfer all entries from src to dest tables
     */
    private void transfer(AtomicReferenceArray src, ResizeContainer resizeContainer)
    {
<span class="nc" id="L284">        AtomicReferenceArray dest = resizeContainer.nextArray;</span>

<span class="nc bnc" id="L286" title="All 2 branches missed.">        for (int j = 0; j &lt; src.length() - 1; )</span>
        {
<span class="nc" id="L288">            Object o = src.get(j);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">            if (o == null)</span>
            {
<span class="nc bnc" id="L291" title="All 2 branches missed.">                if (src.compareAndSet(j, null, RESIZED))</span>
                {
<span class="nc" id="L293">                    j++;</span>
                }
            }
<span class="nc bnc" id="L296" title="All 4 branches missed.">            else if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L298">                j = (j &amp; ~(ResizeContainer.QUEUE_INCREMENT - 1)) + ResizeContainer.QUEUE_INCREMENT;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">                if (resizeContainer.resizers.get() == 1)</span>
                {
<span class="nc" id="L301">                    break;</span>
                }
            }
            else
            {
<span class="nc" id="L306">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">                if (src.compareAndSet(j, o, RESIZING))</span>
                {
<span class="nc bnc" id="L309" title="All 2 branches missed.">                    while (e != null)</span>
                    {
<span class="nc" id="L311">                        this.unconditionalCopy(dest, e);</span>
<span class="nc" id="L312">                        e = e.getNext();</span>
                    }
<span class="nc" id="L314">                    src.set(j, RESIZED);</span>
<span class="nc" id="L315">                    j++;</span>
                }
            }
<span class="nc" id="L318">        }</span>
<span class="nc" id="L319">        resizeContainer.decrementResizerAndNotify();</span>
<span class="nc" id="L320">        resizeContainer.waitForAllResizers();</span>
<span class="nc" id="L321">    }</span>

    private void reverseTransfer(AtomicReferenceArray src, ResizeContainer resizeContainer)
    {
<span class="nc" id="L325">        AtomicReferenceArray dest = resizeContainer.nextArray;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">        while (resizeContainer.getQueuePosition() &gt; 0)</span>
        {
<span class="nc" id="L328">            int start = resizeContainer.subtractAndGetQueuePosition();</span>
<span class="nc" id="L329">            int end = start + ResizeContainer.QUEUE_INCREMENT;</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">            if (end &gt; 0)</span>
            {
<span class="nc bnc" id="L332" title="All 2 branches missed.">                if (start &lt; 0)</span>
                {
<span class="nc" id="L334">                    start = 0;</span>
                }
<span class="nc bnc" id="L336" title="All 2 branches missed.">                for (int j = end - 1; j &gt;= start; )</span>
                {
<span class="nc" id="L338">                    Object o = src.get(j);</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">                    if (o == null)</span>
                    {
<span class="nc bnc" id="L341" title="All 2 branches missed.">                        if (src.compareAndSet(j, null, RESIZED))</span>
                        {
<span class="nc" id="L343">                            j--;</span>
                        }
                    }
<span class="nc bnc" id="L346" title="All 4 branches missed.">                    else if (o == RESIZED || o == RESIZING)</span>
                    {
<span class="nc" id="L348">                        resizeContainer.zeroOutQueuePosition();</span>
<span class="nc" id="L349">                        return;</span>
                    }
                    else
                    {
<span class="nc" id="L353">                        Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">                        if (src.compareAndSet(j, o, RESIZING))</span>
                        {
<span class="nc bnc" id="L356" title="All 2 branches missed.">                            while (e != null)</span>
                            {
<span class="nc" id="L358">                                this.unconditionalCopy(dest, e);</span>
<span class="nc" id="L359">                                e = e.getNext();</span>
                            }
<span class="nc" id="L361">                            src.set(j, RESIZED);</span>
<span class="nc" id="L362">                            j--;</span>
                        }
                    }
<span class="nc" id="L365">                }</span>
            }
<span class="nc" id="L367">        }</span>
<span class="nc" id="L368">    }</span>

    private void unconditionalCopy(AtomicReferenceArray dest, Entry&lt;K, V&gt; toCopyEntry)
    {
<span class="nc" id="L372">        int hash = this.hash(toCopyEntry.getKey());</span>
<span class="nc" id="L373">        AtomicReferenceArray currentArray = dest;</span>
        while (true)
        {
<span class="nc" id="L376">            int length = currentArray.length();</span>
<span class="nc" id="L377">            int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L378">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L379" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L381">                currentArray = ((ResizeContainer) currentArray.get(length - 1)).nextArray;</span>
            }
            else
            {
                Entry&lt;K, V&gt; newEntry;
<span class="nc bnc" id="L386" title="All 2 branches missed.">                if (o == null)</span>
                {
<span class="nc bnc" id="L388" title="All 2 branches missed.">                    if (toCopyEntry.getNext() == null)</span>
                    {
<span class="nc" id="L390">                        newEntry = toCopyEntry; // no need to duplicate</span>
                    }
                    else
                    {
<span class="nc" id="L394">                        newEntry = new Entry&lt;&gt;(toCopyEntry.getKey(), toCopyEntry.getValue());</span>
                    }
                }
                else
                {
<span class="nc" id="L399">                    newEntry = new Entry&lt;&gt;(toCopyEntry.getKey(), toCopyEntry.getValue(), (Entry&lt;K, V&gt;) o);</span>
                }
<span class="nc bnc" id="L401" title="All 2 branches missed.">                if (currentArray.compareAndSet(index, o, newEntry))</span>
                {
<span class="nc" id="L403">                    return;</span>
                }
            }
<span class="nc" id="L406">        }</span>
    }

    public V getIfAbsentPut(K key, Function&lt;? super K, ? extends V&gt; factory)
    {
<span class="nc" id="L411">        return this.getIfAbsentPutWith(key, factory, key);</span>
    }

    @Override
    public V getIfAbsentPut(K key, Function0&lt;? extends V&gt; factory)
    {
<span class="nc" id="L417">        int hash = this.hash(key);</span>
<span class="nc" id="L418">        AtomicReferenceArray currentArray = this.table;</span>
<span class="nc" id="L419">        V newValue = null;</span>
<span class="nc" id="L420">        boolean createdValue = false;</span>
        while (true)
        {
<span class="nc" id="L423">            int length = currentArray.length();</span>
<span class="nc" id="L424">            int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L425">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L426" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L428">                currentArray = this.helpWithResizeWhileCurrentIndex(currentArray, index);</span>
            }
            else
            {
<span class="nc" id="L432">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">                while (e != null)</span>
                {
<span class="nc" id="L435">                    Object candidate = e.getKey();</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">                    if (candidate.equals(key))</span>
                    {
<span class="nc" id="L438">                        return e.getValue();</span>
                    }
<span class="nc" id="L440">                    e = e.getNext();</span>
<span class="nc" id="L441">                }</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">                if (!createdValue)</span>
                {
<span class="nc" id="L444">                    createdValue = true;</span>
<span class="nc" id="L445">                    newValue = factory.value();</span>
                }
<span class="nc" id="L447">                Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, newValue, (Entry&lt;K, V&gt;) o);</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">                if (currentArray.compareAndSet(index, o, newEntry))</span>
                {
<span class="nc" id="L450">                    this.incrementSizeAndPossiblyResize(currentArray, length, o);</span>
<span class="nc" id="L451">                    return newValue;</span>
                }
            }
<span class="nc" id="L454">        }</span>
    }

    @Override
    public V getIfAbsentPut(K key, V value)
    {
<span class="nc" id="L460">        int hash = this.hash(key);</span>
<span class="nc" id="L461">        AtomicReferenceArray currentArray = this.table;</span>
        while (true)
        {
<span class="nc" id="L464">            int length = currentArray.length();</span>
<span class="nc" id="L465">            int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L466">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L467" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L469">                currentArray = this.helpWithResizeWhileCurrentIndex(currentArray, index);</span>
            }
            else
            {
<span class="nc" id="L473">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">                while (e != null)</span>
                {
<span class="nc" id="L476">                    Object candidate = e.getKey();</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">                    if (candidate.equals(key))</span>
                    {
<span class="nc" id="L479">                        return e.getValue();</span>
                    }
<span class="nc" id="L481">                    e = e.getNext();</span>
<span class="nc" id="L482">                }</span>
<span class="nc" id="L483">                Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, value, (Entry&lt;K, V&gt;) o);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                if (currentArray.compareAndSet(index, o, newEntry))</span>
                {
<span class="nc" id="L486">                    this.incrementSizeAndPossiblyResize(currentArray, length, o);</span>
<span class="nc" id="L487">                    return value;</span>
                }
            }
<span class="nc" id="L490">        }</span>
    }

    /**
     * It puts an object into the map based on the key. It uses a copy of the key converted by transformer.
     *
     * @param key            The &quot;mutable&quot; key, which has the same identity/hashcode as the inserted key, only during this call
     * @param keyTransformer If the record is absent, the transformer will transform the &quot;mutable&quot; key into an immutable copy of the key.
     *                       Note that the transformed key must have the same identity/hashcode as the original &quot;mutable&quot; key.
     * @param factory        It creates an object, if it is not present in the map already.
     */
    public &lt;P1, P2&gt; V putIfAbsentGetIfPresent(K key, Function2&lt;K, V, K&gt; keyTransformer, Function3&lt;P1, P2, K, V&gt; factory, P1 param1, P2 param2)
    {
<span class="nc" id="L503">        int hash = this.hash(key);</span>
<span class="nc" id="L504">        AtomicReferenceArray currentArray = this.table;</span>
<span class="nc" id="L505">        V newValue = null;</span>
<span class="nc" id="L506">        boolean createdValue = false;</span>
        while (true)
        {
<span class="nc" id="L509">            int length = currentArray.length();</span>
<span class="nc" id="L510">            int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L511">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L512" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L514">                currentArray = this.helpWithResizeWhileCurrentIndex(currentArray, index);</span>
            }
            else
            {
<span class="nc" id="L518">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">                while (e != null)</span>
                {
<span class="nc" id="L521">                    Object candidate = e.getKey();</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">                    if (candidate.equals(key))</span>
                    {
<span class="nc" id="L524">                        return e.getValue();</span>
                    }
<span class="nc" id="L526">                    e = e.getNext();</span>
<span class="nc" id="L527">                }</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">                if (!createdValue)</span>
                {
<span class="nc" id="L530">                    createdValue = true;</span>
<span class="nc" id="L531">                    newValue = factory.value(param1, param2, key);</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">                    if (newValue == null)</span>
                    {
<span class="nc" id="L534">                        return null; // null value means no mapping is required</span>
                    }
<span class="nc" id="L536">                    key = keyTransformer.value(key, newValue);</span>
                }
<span class="nc" id="L538">                Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, newValue, (Entry&lt;K, V&gt;) o);</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">                if (currentArray.compareAndSet(index, o, newEntry))</span>
                {
<span class="nc" id="L541">                    this.incrementSizeAndPossiblyResize(currentArray, length, o);</span>
<span class="nc" id="L542">                    return null;</span>
                }
            }
<span class="nc" id="L545">        }</span>
    }

    @Override
    public boolean remove(Object key, Object value)
    {
<span class="nc" id="L551">        int hash = this.hash(key);</span>
<span class="nc" id="L552">        AtomicReferenceArray currentArray = this.table;</span>
        //noinspection LabeledStatement
        outer:
        while (true)
        {
<span class="nc" id="L557">            int length = currentArray.length();</span>
<span class="nc" id="L558">            int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L559">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L560" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L562">                currentArray = this.helpWithResizeWhileCurrentIndex(currentArray, index);</span>
            }
            else
            {
<span class="nc" id="L566">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                while (e != null)</span>
                {
<span class="nc" id="L569">                    Object candidate = e.getKey();</span>
<span class="nc bnc" id="L570" title="All 4 branches missed.">                    if (candidate.equals(key) &amp;&amp; this.nullSafeEquals(e.getValue(), value))</span>
                    {
<span class="nc" id="L572">                        Entry&lt;K, V&gt; replacement = this.createReplacementChainForRemoval((Entry&lt;K, V&gt;) o, e);</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">                        if (currentArray.compareAndSet(index, o, replacement))</span>
                        {
<span class="nc" id="L575">                            this.addToSize(-1);</span>
<span class="nc" id="L576">                            return true;</span>
                        }
                        //noinspection ContinueStatementWithLabel
                        continue outer;
                    }
<span class="nc" id="L581">                    e = e.getNext();</span>
<span class="nc" id="L582">                }</span>
<span class="nc" id="L583">                return false;</span>
            }
<span class="nc" id="L585">        }</span>
    }

    private void addToSize(int value)
    {
<span class="nc bnc" id="L590" title="All 2 branches missed.">        if (this.partitionedSize != null)</span>
        {
<span class="nc bnc" id="L592" title="All 2 branches missed.">            if (this.incrementPartitionedSize(value))</span>
            {
<span class="nc" id="L594">                return;</span>
            }
        }
<span class="nc" id="L597">        this.incrementLocalSize(value);</span>
<span class="nc" id="L598">    }</span>

    private boolean incrementPartitionedSize(int value)
    {
<span class="nc" id="L602">        int h = (int) Thread.currentThread().getId();</span>
<span class="nc" id="L603">        h ^= (h &gt;&gt;&gt; 18) ^ (h &gt;&gt;&gt; 12);</span>
<span class="nc" id="L604">        h = (h ^ (h &gt;&gt;&gt; 10)) &amp; SIZE_BUCKETS;</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">        if (h != 0)</span>
        {
<span class="nc" id="L607">            h = (h - 1) &lt;&lt; 4;</span>
            while (true)
            {
<span class="nc" id="L610">                int localSize = this.partitionedSize.get(h);</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">                if (this.partitionedSize.compareAndSet(h, localSize, localSize + value))</span>
                {
<span class="nc" id="L613">                    return true;</span>
                }
<span class="nc" id="L615">            }</span>
        }
<span class="nc" id="L617">        return false;</span>
    }

    private void incrementLocalSize(int value)
    {
        while (true)
        {
<span class="nc" id="L624">            int localSize = this.size;</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">            if (SIZE_UPDATER.compareAndSet(this, localSize, localSize + value))</span>
            {
<span class="nc" id="L627">                break;</span>
            }
<span class="nc" id="L629">        }</span>
<span class="nc" id="L630">    }</span>

    @Override
    public int size()
    {
<span class="nc" id="L635">        int localSize = this.size;</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">        if (this.partitionedSize != null)</span>
        {
<span class="nc bnc" id="L638" title="All 2 branches missed.">            for (int i = 0; i &lt; SIZE_BUCKETS; i++)</span>
            {
<span class="nc" id="L640">                localSize += this.partitionedSize.get(i &lt;&lt; 4);</span>
            }
        }
<span class="nc" id="L643">        return localSize;</span>
    }

    @Override
    public boolean isEmpty()
    {
<span class="nc bnc" id="L649" title="All 2 branches missed.">        return this.size() == 0;</span>
    }

    @Override
    public boolean containsKey(Object key)
    {
<span class="nc bnc" id="L655" title="All 2 branches missed.">        return this.getEntry(key) != null;</span>
    }

    @Override
    public boolean containsValue(Object value)
    {
<span class="nc" id="L661">        AtomicReferenceArray currentArray = this.table;</span>
        ResizeContainer resizeContainer;
        do
        {
<span class="nc" id="L665">            resizeContainer = null;</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">            for (int i = 0; i &lt; currentArray.length() - 1; i++)</span>
            {
<span class="nc" id="L668">                Object o = currentArray.get(i);</span>
<span class="nc bnc" id="L669" title="All 4 branches missed.">                if (o == RESIZED || o == RESIZING)</span>
                {
<span class="nc" id="L671">                    resizeContainer = (ResizeContainer) currentArray.get(currentArray.length() - 1);</span>
                }
<span class="nc bnc" id="L673" title="All 2 branches missed.">                else if (o != null)</span>
                {
<span class="nc" id="L675">                    Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">                    while (e != null)</span>
                    {
<span class="nc" id="L678">                        Object v = e.getValue();</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">                        if (this.nullSafeEquals(v, value))</span>
                        {
<span class="nc" id="L681">                            return true;</span>
                        }
<span class="nc" id="L683">                        e = e.getNext();</span>
<span class="nc" id="L684">                    }</span>
                }
            }
<span class="nc bnc" id="L687" title="All 2 branches missed.">            if (resizeContainer != null)</span>
            {
<span class="nc bnc" id="L689" title="All 2 branches missed.">                if (resizeContainer.isNotDone())</span>
                {
<span class="nc" id="L691">                    this.helpWithResize(currentArray);</span>
<span class="nc" id="L692">                    resizeContainer.waitForAllResizers();</span>
                }
<span class="nc" id="L694">                currentArray = resizeContainer.nextArray;</span>
            }
        }
<span class="nc bnc" id="L697" title="All 2 branches missed.">        while (resizeContainer != null);</span>
<span class="nc" id="L698">        return false;</span>
    }

    private boolean nullSafeEquals(Object v, Object value)
    {
<span class="nc bnc" id="L703" title="All 6 branches missed.">        return v == value || v != null &amp;&amp; v.equals(value);</span>
    }

    @Override
    public V get(Object key)
    {
<span class="nc" id="L709">        int hash = this.hash(key);</span>
<span class="nc" id="L710">        AtomicReferenceArray currentArray = this.table;</span>
<span class="nc" id="L711">        int index = ConcurrentHashMap.indexFor(hash, currentArray.length());</span>
<span class="nc" id="L712">        Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L713" title="All 4 branches missed.">        if (o == RESIZED || o == RESIZING)</span>
        {
<span class="nc" id="L715">            return this.slowGet(key, hash, index, currentArray);</span>
        }
<span class="nc bnc" id="L717" title="All 2 branches missed.">        for (Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o; e != null; e = e.getNext())</span>
        {
            Object k;
<span class="nc bnc" id="L720" title="All 4 branches missed.">            if ((k = e.key) == key || key.equals(k))</span>
            {
<span class="nc" id="L722">                return e.value;</span>
            }
        }
<span class="nc" id="L725">        return null;</span>
    }

    private V slowGet(Object key, int hash, int index, AtomicReferenceArray currentArray)
    {
        while (true)
        {
<span class="nc" id="L732">            int length = currentArray.length();</span>
<span class="nc" id="L733">            index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L734">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L735" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L737">                currentArray = this.helpWithResizeWhileCurrentIndex(currentArray, index);</span>
            }
            else
            {
<span class="nc" id="L741">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">                while (e != null)</span>
                {
<span class="nc" id="L744">                    Object candidate = e.getKey();</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">                    if (candidate.equals(key))</span>
                    {
<span class="nc" id="L747">                        return e.getValue();</span>
                    }
<span class="nc" id="L749">                    e = e.getNext();</span>
<span class="nc" id="L750">                }</span>
<span class="nc" id="L751">                return null;</span>
            }
<span class="nc" id="L753">        }</span>
    }

    private Entry&lt;K, V&gt; getEntry(Object key)
    {
<span class="nc" id="L758">        int hash = this.hash(key);</span>
<span class="nc" id="L759">        AtomicReferenceArray currentArray = this.table;</span>
        while (true)
        {
<span class="nc" id="L762">            int length = currentArray.length();</span>
<span class="nc" id="L763">            int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L764">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L765" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L767">                currentArray = this.helpWithResizeWhileCurrentIndex(currentArray, index);</span>
            }
            else
            {
<span class="nc" id="L771">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">                while (e != null)</span>
                {
<span class="nc" id="L774">                    Object candidate = e.getKey();</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">                    if (candidate.equals(key))</span>
                    {
<span class="nc" id="L777">                        return e;</span>
                    }
<span class="nc" id="L779">                    e = e.getNext();</span>
<span class="nc" id="L780">                }</span>
<span class="nc" id="L781">                return null;</span>
            }
<span class="nc" id="L783">        }</span>
    }

    @Override
    public V put(K key, V value)
    {
<span class="nc" id="L789">        int hash = this.hash(key);</span>
<span class="nc" id="L790">        AtomicReferenceArray currentArray = this.table;</span>
<span class="nc" id="L791">        int length = currentArray.length();</span>
<span class="nc" id="L792">        int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L793">        Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">        if (o == null)</span>
        {
<span class="nc" id="L796">            Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, value, null);</span>
<span class="nc" id="L797">            this.addToSize(1);</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">            if (currentArray.compareAndSet(index, null, newEntry))</span>
            {
<span class="nc" id="L800">                return null;</span>
            }
<span class="nc" id="L802">            this.addToSize(-1);</span>
        }
<span class="nc" id="L804">        return this.slowPut(key, value, hash, currentArray);</span>
    }

    private V slowPut(K key, V value, int hash, AtomicReferenceArray currentArray)
    {
        //noinspection LabeledStatement
        outer:
        while (true)
        {
<span class="nc" id="L813">            int length = currentArray.length();</span>
<span class="nc" id="L814">            int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L815">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L816" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L818">                currentArray = this.helpWithResizeWhileCurrentIndex(currentArray, index);</span>
            }
            else
            {
<span class="nc" id="L822">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">                while (e != null)</span>
                {
<span class="nc" id="L825">                    Object candidate = e.getKey();</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">                    if (candidate.equals(key))</span>
                    {
<span class="nc" id="L828">                        V oldValue = e.getValue();</span>
<span class="nc" id="L829">                        Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(e.getKey(), value, this.createReplacementChainForRemoval((Entry&lt;K, V&gt;) o, e));</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">                        if (!currentArray.compareAndSet(index, o, newEntry))</span>
                        {
                            //noinspection ContinueStatementWithLabel
<span class="nc" id="L833">                            continue outer;</span>
                        }
<span class="nc" id="L835">                        return oldValue;</span>
                    }
<span class="nc" id="L837">                    e = e.getNext();</span>
<span class="nc" id="L838">                }</span>
<span class="nc" id="L839">                Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, value, (Entry&lt;K, V&gt;) o);</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">                if (currentArray.compareAndSet(index, o, newEntry))</span>
                {
<span class="nc" id="L842">                    this.incrementSizeAndPossiblyResize(currentArray, length, o);</span>
<span class="nc" id="L843">                    return null;</span>
                }
            }
<span class="nc" id="L846">        }</span>
    }

    public void putAllInParallel(Map&lt;K, V&gt; map, int chunks, Executor executor)
    {
<span class="nc bnc" id="L851" title="All 2 branches missed.">        if (this.size() == 0)</span>
        {
<span class="nc" id="L853">            int threshold = map.size();</span>
<span class="nc" id="L854">            threshold += threshold &gt;&gt; 1; // threshold = length * 0.75</span>

<span class="nc" id="L856">            int capacity = 1;</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">            while (capacity &lt; threshold)</span>
            {
<span class="nc" id="L859">                capacity &lt;&lt;= 1;</span>
            }
<span class="nc" id="L861">            this.resize(this.table, capacity + 1);</span>
        }
<span class="nc bnc" id="L863" title="All 6 branches missed.">        if (map instanceof ConcurrentHashMap&lt;?, ?&gt; &amp;&amp; chunks &gt; 1 &amp;&amp; map.size() &gt; 50000)</span>
        {
<span class="nc" id="L865">            ConcurrentHashMap&lt;K, V&gt; incoming = (ConcurrentHashMap&lt;K, V&gt;) map;</span>
<span class="nc" id="L866">            AtomicReferenceArray currentArray = incoming.table;</span>
<span class="nc" id="L867">            FutureTask&lt;?&gt;[] futures = new FutureTask&lt;?&gt;[chunks];</span>
<span class="nc" id="L868">            int chunkSize = currentArray.length() / chunks;</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">            if (currentArray.length() % chunks != 0)</span>
            {
<span class="nc" id="L871">                chunkSize++;</span>
            }
<span class="nc bnc" id="L873" title="All 2 branches missed.">            for (int i = 0; i &lt; chunks; i++)</span>
            {
<span class="nc" id="L875">                int start = i * chunkSize;</span>
<span class="nc" id="L876">                int end = Math.min((i + 1) * chunkSize, currentArray.length());</span>
<span class="nc" id="L877">                futures[i] = new FutureTask(() -&gt; this.sequentialPutAll(currentArray, start, end), null);</span>
<span class="nc" id="L878">                executor.execute(futures[i]);</span>
            }
<span class="nc bnc" id="L880" title="All 2 branches missed.">            for (int i = 0; i &lt; chunks; i++)</span>
            {
                try
                {
<span class="nc" id="L884">                    futures[i].get();</span>
                }
<span class="nc" id="L886">                catch (Exception e)</span>
                {
<span class="nc" id="L888">                    throw new RuntimeException(&quot;parallelForEachKeyValue failed&quot;, e);</span>
<span class="nc" id="L889">                }</span>
            }
<span class="nc" id="L891">        }</span>
        else
        {
<span class="nc" id="L894">            this.putAll(map);</span>
        }
<span class="nc" id="L896">    }</span>

    private void sequentialPutAll(AtomicReferenceArray currentArray, int start, int end)
    {
<span class="nc bnc" id="L900" title="All 2 branches missed.">        for (int i = start; i &lt; end; i++)</span>
        {
<span class="nc" id="L902">            Object o = currentArray.get(i);</span>
<span class="nc bnc" id="L903" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L905">                throw new ConcurrentModificationException(&quot;can't iterate while resizing!&quot;);</span>
            }
<span class="nc" id="L907">            Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">            while (e != null)</span>
            {
<span class="nc" id="L910">                Object key = e.getKey();</span>
<span class="nc" id="L911">                Object value = e.getValue();</span>
<span class="nc" id="L912">                this.put((K) key, (V) value);</span>
<span class="nc" id="L913">                e = e.getNext();</span>
<span class="nc" id="L914">            }</span>
        }
<span class="nc" id="L916">    }</span>

    @Override
    public void putAll(Map&lt;? extends K, ? extends V&gt; map)
    {
<span class="nc" id="L921">        MapIterate.forEachKeyValue(map, this::put);</span>
<span class="nc" id="L922">    }</span>

    @Override
    public void clear()
    {
<span class="nc" id="L927">        AtomicReferenceArray currentArray = this.table;</span>
        ResizeContainer resizeContainer;
        do
        {
<span class="nc" id="L931">            resizeContainer = null;</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">            for (int i = 0; i &lt; currentArray.length() - 1; i++)</span>
            {
<span class="nc" id="L934">                Object o = currentArray.get(i);</span>
<span class="nc bnc" id="L935" title="All 4 branches missed.">                if (o == RESIZED || o == RESIZING)</span>
                {
<span class="nc" id="L937">                    resizeContainer = (ResizeContainer) currentArray.get(currentArray.length() - 1);</span>
                }
<span class="nc bnc" id="L939" title="All 2 branches missed.">                else if (o != null)</span>
                {
<span class="nc" id="L941">                    Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">                    if (currentArray.compareAndSet(i, o, null))</span>
                    {
<span class="nc" id="L944">                        int removedEntries = 0;</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">                        while (e != null)</span>
                        {
<span class="nc" id="L947">                            removedEntries++;</span>
<span class="nc" id="L948">                            e = e.getNext();</span>
                        }
<span class="nc" id="L950">                        this.addToSize(-removedEntries);</span>
                    }
                }
            }
<span class="nc bnc" id="L954" title="All 2 branches missed.">            if (resizeContainer != null)</span>
            {
<span class="nc bnc" id="L956" title="All 2 branches missed.">                if (resizeContainer.isNotDone())</span>
                {
<span class="nc" id="L958">                    this.helpWithResize(currentArray);</span>
<span class="nc" id="L959">                    resizeContainer.waitForAllResizers();</span>
                }
<span class="nc" id="L961">                currentArray = resizeContainer.nextArray;</span>
            }
        }
<span class="nc bnc" id="L964" title="All 2 branches missed.">        while (resizeContainer != null);</span>
<span class="nc" id="L965">    }</span>

    @Override
    public Set&lt;K&gt; keySet()
    {
<span class="nc" id="L970">        return new KeySet();</span>
    }

    @Override
    public Collection&lt;V&gt; values()
    {
<span class="nc" id="L976">        return new Values();</span>
    }

    @Override
    public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()
    {
<span class="nc" id="L982">        return new EntrySet();</span>
    }

    @Override
    public boolean replace(K key, V oldValue, V newValue)
    {
<span class="nc" id="L988">        int hash = this.hash(key);</span>
<span class="nc" id="L989">        AtomicReferenceArray currentArray = this.table;</span>
<span class="nc" id="L990">        int length = currentArray.length();</span>
<span class="nc" id="L991">        int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L992">        Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L993" title="All 4 branches missed.">        if (o == RESIZED || o == RESIZING)</span>
        {
<span class="nc" id="L995">            return this.slowReplace(key, oldValue, newValue, hash, currentArray);</span>
        }
<span class="nc" id="L997">        Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">        while (e != null)</span>
        {
<span class="nc" id="L1000">            Object candidate = e.getKey();</span>
<span class="nc bnc" id="L1001" title="All 4 branches missed.">            if (candidate == key || candidate.equals(key))</span>
            {
<span class="nc bnc" id="L1003" title="All 6 branches missed.">                if (oldValue == e.getValue() || (oldValue != null &amp;&amp; oldValue.equals(e.getValue())))</span>
                {
<span class="nc" id="L1005">                    Entry&lt;K, V&gt; replacement = this.createReplacementChainForRemoval((Entry&lt;K, V&gt;) o, e);</span>
<span class="nc" id="L1006">                    Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, newValue, replacement);</span>
<span class="nc bnc" id="L1007" title="All 4 branches missed.">                    return currentArray.compareAndSet(index, o, newEntry) || this.slowReplace(key, oldValue, newValue, hash, currentArray);</span>
                }
<span class="nc" id="L1009">                return false;</span>
            }
<span class="nc" id="L1011">            e = e.getNext();</span>
<span class="nc" id="L1012">        }</span>
<span class="nc" id="L1013">        return false;</span>
    }

    private boolean slowReplace(K key, V oldValue, V newValue, int hash, AtomicReferenceArray currentArray)
    {
        //noinspection LabeledStatement
        outer:
        while (true)
        {
<span class="nc" id="L1022">            int length = currentArray.length();</span>
<span class="nc" id="L1023">            int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L1024">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L1025" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L1027">                currentArray = this.helpWithResizeWhileCurrentIndex(currentArray, index);</span>
            }
            else
            {
<span class="nc" id="L1031">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">                while (e != null)</span>
                {
<span class="nc" id="L1034">                    Object candidate = e.getKey();</span>
<span class="nc bnc" id="L1035" title="All 4 branches missed.">                    if (candidate == key || candidate.equals(key))</span>
                    {
<span class="nc bnc" id="L1037" title="All 6 branches missed.">                        if (oldValue == e.getValue() || (oldValue != null &amp;&amp; oldValue.equals(e.getValue())))</span>
                        {
<span class="nc" id="L1039">                            Entry&lt;K, V&gt; replacement = this.createReplacementChainForRemoval((Entry&lt;K, V&gt;) o, e);</span>
<span class="nc" id="L1040">                            Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, newValue, replacement);</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">                            if (currentArray.compareAndSet(index, o, newEntry))</span>
                            {
<span class="nc" id="L1043">                                return true;</span>
                            }
                            //noinspection ContinueStatementWithLabel
                            continue outer;
                        }
<span class="nc" id="L1048">                        return false;</span>
                    }
<span class="nc" id="L1050">                    e = e.getNext();</span>
<span class="nc" id="L1051">                }</span>
<span class="nc" id="L1052">                return false;</span>
            }
<span class="nc" id="L1054">        }</span>
    }

    @Override
    public V replace(K key, V value)
    {
<span class="nc" id="L1060">        int hash = this.hash(key);</span>
<span class="nc" id="L1061">        AtomicReferenceArray currentArray = this.table;</span>
<span class="nc" id="L1062">        int length = currentArray.length();</span>
<span class="nc" id="L1063">        int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L1064">        Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        if (o == null)</span>
        {
<span class="nc" id="L1067">            return null;</span>
        }
<span class="nc" id="L1069">        return this.slowReplace(key, value, hash, currentArray);</span>
    }

    private V slowReplace(K key, V value, int hash, AtomicReferenceArray currentArray)
    {
        //noinspection LabeledStatement
        outer:
        while (true)
        {
<span class="nc" id="L1078">            int length = currentArray.length();</span>
<span class="nc" id="L1079">            int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L1080">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L1081" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L1083">                currentArray = this.helpWithResizeWhileCurrentIndex(currentArray, index);</span>
            }
            else
            {
<span class="nc" id="L1087">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">                while (e != null)</span>
                {
<span class="nc" id="L1090">                    Object candidate = e.getKey();</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">                    if (candidate.equals(key))</span>
                    {
<span class="nc" id="L1093">                        V oldValue = e.getValue();</span>
<span class="nc" id="L1094">                        Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(e.getKey(), value, this.createReplacementChainForRemoval((Entry&lt;K, V&gt;) o, e));</span>
<span class="nc bnc" id="L1095" title="All 2 branches missed.">                        if (!currentArray.compareAndSet(index, o, newEntry))</span>
                        {
                            //noinspection ContinueStatementWithLabel
<span class="nc" id="L1098">                            continue outer;</span>
                        }
<span class="nc" id="L1100">                        return oldValue;</span>
                    }
<span class="nc" id="L1102">                    e = e.getNext();</span>
<span class="nc" id="L1103">                }</span>
<span class="nc" id="L1104">                return null;</span>
            }
<span class="nc" id="L1106">        }</span>
    }

    @Override
    public V remove(Object key)
    {
<span class="nc" id="L1112">        int hash = this.hash(key);</span>
<span class="nc" id="L1113">        AtomicReferenceArray currentArray = this.table;</span>
<span class="nc" id="L1114">        int length = currentArray.length();</span>
<span class="nc" id="L1115">        int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L1116">        Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L1117" title="All 4 branches missed.">        if (o == RESIZED || o == RESIZING)</span>
        {
<span class="nc" id="L1119">            return this.slowRemove(key, hash, currentArray);</span>
        }
<span class="nc" id="L1121">        Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">        while (e != null)</span>
        {
<span class="nc" id="L1124">            Object candidate = e.getKey();</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">            if (candidate.equals(key))</span>
            {
<span class="nc" id="L1127">                Entry&lt;K, V&gt; replacement = this.createReplacementChainForRemoval((Entry&lt;K, V&gt;) o, e);</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">                if (currentArray.compareAndSet(index, o, replacement))</span>
                {
<span class="nc" id="L1130">                    this.addToSize(-1);</span>
<span class="nc" id="L1131">                    return e.getValue();</span>
                }
<span class="nc" id="L1133">                return this.slowRemove(key, hash, currentArray);</span>
            }
<span class="nc" id="L1135">            e = e.getNext();</span>
<span class="nc" id="L1136">        }</span>
<span class="nc" id="L1137">        return null;</span>
    }

    private V slowRemove(Object key, int hash, AtomicReferenceArray currentArray)
    {
        //noinspection LabeledStatement
        outer:
        while (true)
        {
<span class="nc" id="L1146">            int length = currentArray.length();</span>
<span class="nc" id="L1147">            int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L1148">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L1149" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L1151">                currentArray = this.helpWithResizeWhileCurrentIndex(currentArray, index);</span>
            }
            else
            {
<span class="nc" id="L1155">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">                while (e != null)</span>
                {
<span class="nc" id="L1158">                    Object candidate = e.getKey();</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">                    if (candidate.equals(key))</span>
                    {
<span class="nc" id="L1161">                        Entry&lt;K, V&gt; replacement = this.createReplacementChainForRemoval((Entry&lt;K, V&gt;) o, e);</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">                        if (currentArray.compareAndSet(index, o, replacement))</span>
                        {
<span class="nc" id="L1164">                            this.addToSize(-1);</span>
<span class="nc" id="L1165">                            return e.getValue();</span>
                        }
                        //noinspection ContinueStatementWithLabel
                        continue outer;
                    }
<span class="nc" id="L1170">                    e = e.getNext();</span>
<span class="nc" id="L1171">                }</span>
<span class="nc" id="L1172">                return null;</span>
            }
<span class="nc" id="L1174">        }</span>
    }

    private Entry&lt;K, V&gt; createReplacementChainForRemoval(Entry&lt;K, V&gt; original, Entry&lt;K, V&gt; toRemove)
    {
<span class="nc bnc" id="L1179" title="All 2 branches missed.">        if (original == toRemove)</span>
        {
<span class="nc" id="L1181">            return original.getNext();</span>
        }
<span class="nc" id="L1183">        Entry&lt;K, V&gt; replacement = null;</span>
<span class="nc" id="L1184">        Entry&lt;K, V&gt; e = original;</span>
<span class="nc bnc" id="L1185" title="All 2 branches missed.">        while (e != null)</span>
        {
<span class="nc bnc" id="L1187" title="All 2 branches missed.">            if (e != toRemove)</span>
            {
<span class="nc" id="L1189">                replacement = new Entry&lt;&gt;(e.getKey(), e.getValue(), replacement);</span>
            }
<span class="nc" id="L1191">            e = e.getNext();</span>
        }
<span class="nc" id="L1193">        return replacement;</span>
    }

    public void parallelForEachKeyValue(List&lt;Procedure2&lt;K, V&gt;&gt; blocks, Executor executor)
    {
<span class="nc" id="L1198">        AtomicReferenceArray currentArray = this.table;</span>
<span class="nc" id="L1199">        int chunks = blocks.size();</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">        if (chunks &gt; 1)</span>
        {
<span class="nc" id="L1202">            FutureTask&lt;?&gt;[] futures = new FutureTask&lt;?&gt;[chunks];</span>
<span class="nc" id="L1203">            int chunkSize = currentArray.length() / chunks;</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">            if (currentArray.length() % chunks != 0)</span>
            {
<span class="nc" id="L1206">                chunkSize++;</span>
            }
<span class="nc bnc" id="L1208" title="All 2 branches missed.">            for (int i = 0; i &lt; chunks; i++)</span>
            {
<span class="nc" id="L1210">                int start = i * chunkSize;</span>
<span class="nc" id="L1211">                int end = Math.min((i + 1) * chunkSize, currentArray.length());</span>
<span class="nc" id="L1212">                Procedure2&lt;K, V&gt; block = blocks.get(i);</span>
<span class="nc" id="L1213">                futures[i] = new FutureTask(() -&gt; this.sequentialForEachKeyValue(block, currentArray, start, end), null);</span>
<span class="nc" id="L1214">                executor.execute(futures[i]);</span>
            }
<span class="nc bnc" id="L1216" title="All 2 branches missed.">            for (int i = 0; i &lt; chunks; i++)</span>
            {
                try
                {
<span class="nc" id="L1220">                    futures[i].get();</span>
                }
<span class="nc" id="L1222">                catch (Exception e)</span>
                {
<span class="nc" id="L1224">                    throw new RuntimeException(&quot;parallelForEachKeyValue failed&quot;, e);</span>
<span class="nc" id="L1225">                }</span>
            }
<span class="nc" id="L1227">        }</span>
        else
        {
<span class="nc" id="L1230">            this.sequentialForEachKeyValue(blocks.get(0), currentArray, 0, currentArray.length());</span>
        }
<span class="nc" id="L1232">    }</span>

    private void sequentialForEachKeyValue(Procedure2&lt;K, V&gt; block, AtomicReferenceArray currentArray, int start, int end)
    {
<span class="nc bnc" id="L1236" title="All 2 branches missed.">        for (int i = start; i &lt; end; i++)</span>
        {
<span class="nc" id="L1238">            Object o = currentArray.get(i);</span>
<span class="nc bnc" id="L1239" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L1241">                throw new ConcurrentModificationException(&quot;can't iterate while resizing!&quot;);</span>
            }
<span class="nc" id="L1243">            Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">            while (e != null)</span>
            {
<span class="nc" id="L1246">                Object key = e.getKey();</span>
<span class="nc" id="L1247">                Object value = e.getValue();</span>
<span class="nc" id="L1248">                block.value((K) key, (V) value);</span>
<span class="nc" id="L1249">                e = e.getNext();</span>
<span class="nc" id="L1250">            }</span>
        }
<span class="nc" id="L1252">    }</span>

    public void parallelForEachValue(List&lt;Procedure&lt;V&gt;&gt; blocks, Executor executor)
    {
<span class="nc" id="L1256">        AtomicReferenceArray currentArray = this.table;</span>
<span class="nc" id="L1257">        int chunks = blocks.size();</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">        if (chunks &gt; 1)</span>
        {
<span class="nc" id="L1260">            FutureTask&lt;?&gt;[] futures = new FutureTask&lt;?&gt;[chunks];</span>
<span class="nc" id="L1261">            int chunkSize = currentArray.length() / chunks;</span>
<span class="nc bnc" id="L1262" title="All 2 branches missed.">            if (currentArray.length() % chunks != 0)</span>
            {
<span class="nc" id="L1264">                chunkSize++;</span>
            }
<span class="nc bnc" id="L1266" title="All 2 branches missed.">            for (int i = 0; i &lt; chunks; i++)</span>
            {
<span class="nc" id="L1268">                int start = i * chunkSize;</span>
<span class="nc" id="L1269">                int end = Math.min((i + 1) * chunkSize, currentArray.length() - 1);</span>
<span class="nc" id="L1270">                Procedure&lt;V&gt; block = blocks.get(i);</span>
<span class="nc" id="L1271">                futures[i] = new FutureTask(() -&gt; this.sequentialForEachValue(block, currentArray, start, end), null);</span>
<span class="nc" id="L1272">                executor.execute(futures[i]);</span>
            }
<span class="nc bnc" id="L1274" title="All 2 branches missed.">            for (int i = 0; i &lt; chunks; i++)</span>
            {
                try
                {
<span class="nc" id="L1278">                    futures[i].get();</span>
                }
<span class="nc" id="L1280">                catch (Exception e)</span>
                {
<span class="nc" id="L1282">                    throw new RuntimeException(&quot;parallelForEachKeyValue failed&quot;, e);</span>
<span class="nc" id="L1283">                }</span>
            }
<span class="nc" id="L1285">        }</span>
        else
        {
<span class="nc" id="L1288">            this.sequentialForEachValue(blocks.get(0), currentArray, 0, currentArray.length());</span>
        }
<span class="nc" id="L1290">    }</span>

    private void sequentialForEachValue(Procedure&lt;V&gt; block, AtomicReferenceArray currentArray, int start, int end)
    {
<span class="nc bnc" id="L1294" title="All 2 branches missed.">        for (int i = start; i &lt; end; i++)</span>
        {
<span class="nc" id="L1296">            Object o = currentArray.get(i);</span>
<span class="nc bnc" id="L1297" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L1299">                throw new ConcurrentModificationException(&quot;can't iterate while resizing!&quot;);</span>
            }
<span class="nc" id="L1301">            Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">            while (e != null)</span>
            {
<span class="nc" id="L1304">                Object value = e.getValue();</span>
<span class="nc" id="L1305">                block.value((V) value);</span>
<span class="nc" id="L1306">                e = e.getNext();</span>
<span class="nc" id="L1307">            }</span>
        }
<span class="nc" id="L1309">    }</span>

    @Override
    public int hashCode()
    {
<span class="nc" id="L1314">        int h = 0;</span>
<span class="nc" id="L1315">        AtomicReferenceArray currentArray = this.table;</span>
<span class="nc bnc" id="L1316" title="All 2 branches missed.">        for (int i = 0; i &lt; currentArray.length() - 1; i++)</span>
        {
<span class="nc" id="L1318">            Object o = currentArray.get(i);</span>
<span class="nc bnc" id="L1319" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L1321">                throw new ConcurrentModificationException(&quot;can't compute hashcode while resizing!&quot;);</span>
            }
<span class="nc" id="L1323">            Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">            while (e != null)</span>
            {
<span class="nc" id="L1326">                Object key = e.getKey();</span>
<span class="nc" id="L1327">                Object value = e.getValue();</span>
<span class="nc bnc" id="L1328" title="All 4 branches missed.">                h += (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode());</span>
<span class="nc" id="L1329">                e = e.getNext();</span>
<span class="nc" id="L1330">            }</span>
        }
<span class="nc" id="L1332">        return h;</span>
    }

    @Override
    public boolean equals(Object o)
    {
<span class="nc bnc" id="L1338" title="All 2 branches missed.">        if (o == this)</span>
        {
<span class="nc" id="L1340">            return true;</span>
        }

<span class="nc bnc" id="L1343" title="All 2 branches missed.">        if (!(o instanceof Map))</span>
        {
<span class="nc" id="L1345">            return false;</span>
        }
<span class="nc" id="L1347">        Map&lt;K, V&gt; m = (Map&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L1348" title="All 2 branches missed.">        if (m.size() != this.size())</span>
        {
<span class="nc" id="L1350">            return false;</span>
        }

<span class="nc" id="L1353">        Iterator&lt;Map.Entry&lt;K, V&gt;&gt; i = this.entrySet().iterator();</span>
<span class="nc bnc" id="L1354" title="All 2 branches missed.">        while (i.hasNext())</span>
        {
<span class="nc" id="L1356">            Map.Entry&lt;K, V&gt; e = i.next();</span>
<span class="nc" id="L1357">            K key = e.getKey();</span>
<span class="nc" id="L1358">            V value = e.getValue();</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">            if (value == null)</span>
            {
<span class="nc bnc" id="L1361" title="All 4 branches missed.">                if (!(m.get(key) == null &amp;&amp; m.containsKey(key)))</span>
                {
<span class="nc" id="L1363">                    return false;</span>
                }
            }
            else
            {
<span class="nc bnc" id="L1368" title="All 2 branches missed.">                if (!value.equals(m.get(key)))</span>
                {
<span class="nc" id="L1370">                    return false;</span>
                }
            }
<span class="nc" id="L1373">        }</span>
<span class="nc" id="L1374">        return true;</span>
    }

    @Override
    public String toString()
    {
<span class="nc bnc" id="L1380" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L1382">            return &quot;{}&quot;;</span>
        }
<span class="nc" id="L1384">        Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator = this.entrySet().iterator();</span>

<span class="nc" id="L1386">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1387">        sb.append('{');</span>
        while (true)
        {
<span class="nc" id="L1390">            Map.Entry&lt;K, V&gt; e = iterator.next();</span>
<span class="nc" id="L1391">            K key = e.getKey();</span>
<span class="nc" id="L1392">            V value = e.getValue();</span>
<span class="nc bnc" id="L1393" title="All 2 branches missed.">            sb.append(key == this ? &quot;(this Map)&quot; : key);</span>
<span class="nc" id="L1394">            sb.append('=');</span>
<span class="nc bnc" id="L1395" title="All 2 branches missed.">            sb.append(value == this ? &quot;(this Map)&quot; : value);</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">            if (!iterator.hasNext())</span>
            {
<span class="nc" id="L1398">                return sb.append('}').toString();</span>
            }
<span class="nc" id="L1400">            sb.append(&quot;, &quot;);</span>
<span class="nc" id="L1401">        }</span>
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
    {
<span class="nc" id="L1407">        int size = in.readInt();</span>
<span class="nc" id="L1408">        int capacity = 1;</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">        while (capacity &lt; size)</span>
        {
<span class="nc" id="L1411">            capacity &lt;&lt;= 1;</span>
        }
<span class="nc" id="L1413">        this.table = new AtomicReferenceArray(capacity + 1);</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1416">            this.put((K) in.readObject(), (V) in.readObject());</span>
        }
<span class="nc" id="L1418">    }</span>

    @Override
    public void writeExternal(ObjectOutput out) throws IOException
    {
<span class="nc" id="L1423">        int size = this.size();</span>
<span class="nc" id="L1424">        out.writeInt(size);</span>
<span class="nc" id="L1425">        int count = 0;</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">        for (int i = 0; i &lt; this.table.length() - 1; i++)</span>
        {
<span class="nc" id="L1428">            Object o = this.table.get(i);</span>
<span class="nc bnc" id="L1429" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L1431">                throw new ConcurrentModificationException(&quot;Can't serialize while resizing!&quot;);</span>
            }
<span class="nc" id="L1433">            Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">            while (e != null)</span>
            {
<span class="nc" id="L1436">                count++;</span>
<span class="nc" id="L1437">                out.writeObject(e.getKey());</span>
<span class="nc" id="L1438">                out.writeObject(e.getValue());</span>
<span class="nc" id="L1439">                e = e.getNext();</span>
            }
        }
<span class="nc bnc" id="L1442" title="All 2 branches missed.">        if (count != size)</span>
        {
<span class="nc" id="L1444">            throw new ConcurrentModificationException(&quot;Map changed while serializing&quot;);</span>
        }
<span class="nc" id="L1446">    }</span>

    private static final class IteratorState
    {
        private AtomicReferenceArray currentTable;
        private int start;
        private int end;

        private IteratorState(AtomicReferenceArray currentTable)
<span class="nc" id="L1455">        {</span>
<span class="nc" id="L1456">            this.currentTable = currentTable;</span>
<span class="nc" id="L1457">            this.end = this.currentTable.length() - 1;</span>
<span class="nc" id="L1458">        }</span>

        private IteratorState(AtomicReferenceArray currentTable, int start, int end)
<span class="nc" id="L1461">        {</span>
<span class="nc" id="L1462">            this.currentTable = currentTable;</span>
<span class="nc" id="L1463">            this.start = start;</span>
<span class="nc" id="L1464">            this.end = end;</span>
<span class="nc" id="L1465">        }</span>
    }

    private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt;
    {
        private List&lt;IteratorState&gt; todo;
        private IteratorState currentState;
        private Entry&lt;K, V&gt; next;
        private int index;
        private Entry&lt;K, V&gt; current;

        protected HashIterator()
<span class="nc" id="L1477">        {</span>
<span class="nc" id="L1478">            this.currentState = new IteratorState(ConcurrentHashMap.this.table);</span>
<span class="nc" id="L1479">            this.findNext();</span>
<span class="nc" id="L1480">        }</span>

        private void findNext()
        {
<span class="nc bnc" id="L1484" title="All 2 branches missed.">            while (this.index &lt; this.currentState.end)</span>
            {
<span class="nc" id="L1486">                Object o = this.currentState.currentTable.get(this.index);</span>
<span class="nc bnc" id="L1487" title="All 4 branches missed.">                if (o == RESIZED || o == RESIZING)</span>
                {
<span class="nc" id="L1489">                    AtomicReferenceArray nextArray = ConcurrentHashMap.this.helpWithResizeWhileCurrentIndex(this.currentState.currentTable, this.index);</span>
<span class="nc" id="L1490">                    int endResized = this.index + 1;</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">                    while (endResized &lt; this.currentState.end)</span>
                    {
<span class="nc bnc" id="L1493" title="All 2 branches missed.">                        if (this.currentState.currentTable.get(endResized) != RESIZED)</span>
                        {
<span class="nc" id="L1495">                            break;</span>
                        }
<span class="nc" id="L1497">                        endResized++;</span>
                    }
<span class="nc bnc" id="L1499" title="All 2 branches missed.">                    if (this.todo == null)</span>
                    {
<span class="nc" id="L1501">                        this.todo = new FastList&lt;&gt;(4);</span>
                    }
<span class="nc bnc" id="L1503" title="All 2 branches missed.">                    if (endResized &lt; this.currentState.end)</span>
                    {
<span class="nc" id="L1505">                        this.todo.add(new IteratorState(this.currentState.currentTable, endResized, this.currentState.end));</span>
                    }
<span class="nc" id="L1507">                    int powerTwoLength = this.currentState.currentTable.length() - 1;</span>
<span class="nc" id="L1508">                    this.todo.add(new IteratorState(nextArray, this.index + powerTwoLength, endResized + powerTwoLength));</span>
<span class="nc" id="L1509">                    this.currentState.currentTable = nextArray;</span>
<span class="nc" id="L1510">                    this.currentState.end = endResized;</span>
<span class="nc" id="L1511">                    this.currentState.start = this.index;</span>
<span class="nc" id="L1512">                }</span>
<span class="nc bnc" id="L1513" title="All 2 branches missed.">                else if (o != null)</span>
                {
<span class="nc" id="L1515">                    this.next = (Entry&lt;K, V&gt;) o;</span>
<span class="nc" id="L1516">                    this.index++;</span>
<span class="nc" id="L1517">                    break;</span>
                }
                else
                {
<span class="nc" id="L1521">                    this.index++;</span>
                }
<span class="nc" id="L1523">            }</span>
<span class="nc bnc" id="L1524" title="All 8 branches missed.">            if (this.next == null &amp;&amp; this.index == this.currentState.end &amp;&amp; this.todo != null &amp;&amp; !this.todo.isEmpty())</span>
            {
<span class="nc" id="L1526">                this.currentState = this.todo.remove(this.todo.size() - 1);</span>
<span class="nc" id="L1527">                this.index = this.currentState.start;</span>
<span class="nc" id="L1528">                this.findNext();</span>
            }
<span class="nc" id="L1530">        }</span>

        @Override
        public final boolean hasNext()
        {
<span class="nc bnc" id="L1535" title="All 2 branches missed.">            return this.next != null;</span>
        }

        final Entry&lt;K, V&gt; nextEntry()
        {
<span class="nc" id="L1540">            Entry&lt;K, V&gt; e = this.next;</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">            if (e == null)</span>
            {
<span class="nc" id="L1543">                throw new NoSuchElementException();</span>
            }

<span class="nc bnc" id="L1546" title="All 2 branches missed.">            if ((this.next = e.getNext()) == null)</span>
            {
<span class="nc" id="L1548">                this.findNext();</span>
            }
<span class="nc" id="L1550">            this.current = e;</span>
<span class="nc" id="L1551">            return e;</span>
        }

        protected void removeByKey()
        {
<span class="nc bnc" id="L1556" title="All 2 branches missed.">            if (this.current == null)</span>
            {
<span class="nc" id="L1558">                throw new IllegalStateException();</span>
            }
<span class="nc" id="L1560">            K key = this.current.key;</span>
<span class="nc" id="L1561">            this.current = null;</span>
<span class="nc" id="L1562">            ConcurrentHashMap.this.remove(key);</span>
<span class="nc" id="L1563">        }</span>

        protected boolean removeByKeyValue()
        {
<span class="nc bnc" id="L1567" title="All 2 branches missed.">            if (this.current == null)</span>
            {
<span class="nc" id="L1569">                throw new IllegalStateException();</span>
            }
<span class="nc" id="L1571">            K key = this.current.key;</span>
<span class="nc" id="L1572">            V val = this.current.value;</span>
<span class="nc" id="L1573">            this.current = null;</span>
<span class="nc" id="L1574">            return ConcurrentHashMap.this.remove(key, val);</span>
        }
    }

<span class="nc" id="L1578">    private final class ValueIterator extends HashIterator&lt;V&gt;</span>
    {
        @Override
        public void remove()
        {
<span class="nc" id="L1583">            this.removeByKeyValue();</span>
<span class="nc" id="L1584">        }</span>

        @Override
        public V next()
        {
<span class="nc" id="L1589">            return this.nextEntry().value;</span>
        }
    }

<span class="nc" id="L1593">    private final class KeyIterator extends HashIterator&lt;K&gt;</span>
    {
        @Override
        public K next()
        {
<span class="nc" id="L1598">            return this.nextEntry().getKey();</span>
        }

        @Override
        public void remove()
        {
<span class="nc" id="L1604">            this.removeByKey();</span>
<span class="nc" id="L1605">        }</span>
    }

<span class="nc" id="L1608">    private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K, V&gt;&gt;</span>
    {
        @Override
        public Map.Entry&lt;K, V&gt; next()
        {
<span class="nc" id="L1613">            return this.nextEntry();</span>
        }

        @Override
        public void remove()
        {
<span class="nc" id="L1619">            this.removeByKeyValue();</span>
<span class="nc" id="L1620">        }</span>
    }

<span class="nc" id="L1623">    private final class KeySet extends AbstractSet&lt;K&gt;</span>
    {
        @Override
        public Iterator&lt;K&gt; iterator()
        {
<span class="nc" id="L1628">            return new KeyIterator();</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L1634">            return ConcurrentHashMap.this.size();</span>
        }

        @Override
        public boolean contains(Object o)
        {
<span class="nc" id="L1640">            return ConcurrentHashMap.this.containsKey(o);</span>
        }

        @Override
        public boolean remove(Object o)
        {
<span class="nc bnc" id="L1646" title="All 2 branches missed.">            return ConcurrentHashMap.this.remove(o) != null;</span>
        }

        @Override
        public void clear()
        {
<span class="nc" id="L1652">            ConcurrentHashMap.this.clear();</span>
<span class="nc" id="L1653">        }</span>
    }

<span class="nc" id="L1656">    private final class Values extends AbstractCollection&lt;V&gt;</span>
    {
        @Override
        public Iterator&lt;V&gt; iterator()
        {
<span class="nc" id="L1661">            return new ValueIterator();</span>
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; col)
        {
<span class="nc" id="L1667">            Objects.requireNonNull(col);</span>
<span class="nc" id="L1668">            boolean removed = false;</span>
<span class="nc" id="L1669">            final ValueIterator itr = new ValueIterator();</span>
<span class="nc bnc" id="L1670" title="All 2 branches missed.">            while (itr.hasNext())</span>
            {
<span class="nc bnc" id="L1672" title="All 2 branches missed.">                if (col.contains(itr.next()))</span>
                {
<span class="nc" id="L1674">                    removed |= itr.removeByKeyValue();</span>
                }
            }
<span class="nc" id="L1677">            return removed;</span>
        }

        @Override
        public boolean removeIf(Predicate&lt;? super V&gt; filter)
        {
<span class="nc" id="L1683">            Objects.requireNonNull(filter);</span>
<span class="nc" id="L1684">            boolean removed = false;</span>
<span class="nc" id="L1685">            final ValueIterator itr = new ValueIterator();</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">            while (itr.hasNext())</span>
            {
<span class="nc bnc" id="L1688" title="All 2 branches missed.">                if (filter.test(itr.next()))</span>
                {
<span class="nc" id="L1690">                    removed |= itr.removeByKeyValue();</span>
                }
            }
<span class="nc" id="L1693">            return removed;</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L1699">            return ConcurrentHashMap.this.size();</span>
        }

        @Override
        public boolean contains(Object o)
        {
<span class="nc" id="L1705">            return ConcurrentHashMap.this.containsValue(o);</span>
        }

        @Override
        public void clear()
        {
<span class="nc" id="L1711">            ConcurrentHashMap.this.clear();</span>
<span class="nc" id="L1712">        }</span>
    }

<span class="nc" id="L1715">    private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K, V&gt;&gt;</span>
    {
        @Override
        public Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator()
        {
<span class="nc" id="L1720">            return new EntryIterator();</span>
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; col)
        {
<span class="nc" id="L1726">            Objects.requireNonNull(col);</span>
<span class="nc" id="L1727">            boolean removed = false;</span>

<span class="nc bnc" id="L1729" title="All 2 branches missed.">            if (this.size() &gt; col.size())</span>
            {
<span class="nc bnc" id="L1731" title="All 2 branches missed.">                for (Iterator&lt;?&gt; itr = col.iterator(); itr.hasNext(); )</span>
                {
<span class="nc" id="L1733">                    removed |= this.remove(itr.next());</span>
                }
            }
            else
            {
<span class="nc bnc" id="L1738" title="All 2 branches missed.">                for (EntryIterator itr = new EntryIterator(); itr.hasNext(); )</span>
                {
<span class="nc bnc" id="L1740" title="All 2 branches missed.">                    if (col.contains(itr.next()))</span>
                    {
<span class="nc" id="L1742">                        removed |= itr.removeByKeyValue();</span>
                    }
                }
            }
<span class="nc" id="L1746">            return removed;</span>
        }

        @Override
        public boolean removeIf(Predicate&lt;? super Map.Entry&lt;K, V&gt;&gt; filter)
        {
<span class="nc" id="L1752">            Objects.requireNonNull(filter);</span>
<span class="nc" id="L1753">            boolean removed = false;</span>
<span class="nc" id="L1754">            final EntryIterator itr = new EntryIterator();</span>
<span class="nc bnc" id="L1755" title="All 2 branches missed.">            while (itr.hasNext())</span>
            {
<span class="nc bnc" id="L1757" title="All 2 branches missed.">                if (filter.test(itr.next()))</span>
                {
<span class="nc" id="L1759">                    removed |= itr.removeByKeyValue();</span>
                }
            }
<span class="nc" id="L1762">            return removed;</span>
        }

        @Override
        public boolean contains(Object o)
        {
<span class="nc bnc" id="L1768" title="All 2 branches missed.">            if (!(o instanceof Map.Entry&lt;?, ?&gt;))</span>
            {
<span class="nc" id="L1770">                return false;</span>
            }
<span class="nc" id="L1772">            Map.Entry&lt;K, V&gt; e = (Map.Entry&lt;K, V&gt;) o;</span>
<span class="nc" id="L1773">            Entry&lt;K, V&gt; candidate = ConcurrentHashMap.this.getEntry(e.getKey());</span>
<span class="nc bnc" id="L1774" title="All 4 branches missed.">            return candidate != null &amp;&amp; candidate.equals(e);</span>
        }

        @Override
        public boolean remove(Object o)
        {
<span class="nc bnc" id="L1780" title="All 2 branches missed.">            if (!(o instanceof Map.Entry&lt;?, ?&gt;))</span>
            {
<span class="nc" id="L1782">                return false;</span>
            }
<span class="nc" id="L1784">            Map.Entry&lt;K, V&gt; e = (Map.Entry&lt;K, V&gt;) o;</span>
<span class="nc" id="L1785">            return ConcurrentHashMap.this.remove(e.getKey(), e.getValue());</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L1791">            return ConcurrentHashMap.this.size();</span>
        }

        @Override
        public void clear()
        {
<span class="nc" id="L1797">            ConcurrentHashMap.this.clear();</span>
<span class="nc" id="L1798">        }</span>
    }

    private static final class Entry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt;
    {
        private final K key;
        private final V value;
        private final Entry&lt;K, V&gt; next;

        private Entry(K key, V value)
<span class="nc" id="L1808">        {</span>
<span class="nc" id="L1809">            this.key = key;</span>
<span class="nc" id="L1810">            this.value = value;</span>
<span class="nc" id="L1811">            this.next = null;</span>
<span class="nc" id="L1812">        }</span>

        private Entry(K key, V value, Entry&lt;K, V&gt; next)
<span class="nc" id="L1815">        {</span>
<span class="nc" id="L1816">            this.key = key;</span>
<span class="nc" id="L1817">            this.value = value;</span>
<span class="nc" id="L1818">            this.next = next;</span>
<span class="nc" id="L1819">        }</span>

        @Override
        public K getKey()
        {
<span class="nc" id="L1824">            return this.key;</span>
        }

        @Override
        public V getValue()
        {
<span class="nc" id="L1830">            return this.value;</span>
        }

        @Override
        public V setValue(V value)
        {
<span class="nc" id="L1836">            throw new RuntimeException(&quot;not implemented&quot;);</span>
        }

        public Entry&lt;K, V&gt; getNext()
        {
<span class="nc" id="L1841">            return this.next;</span>
        }

        @Override
        public boolean equals(Object o)
        {
<span class="nc bnc" id="L1847" title="All 2 branches missed.">            if (!(o instanceof Map.Entry&lt;?, ?&gt;))</span>
            {
<span class="nc" id="L1849">                return false;</span>
            }
<span class="nc" id="L1851">            Map.Entry&lt;K, V&gt; e = (Map.Entry&lt;K, V&gt;) o;</span>
<span class="nc" id="L1852">            K k1 = this.key;</span>
<span class="nc" id="L1853">            Object k2 = e.getKey();</span>
<span class="nc bnc" id="L1854" title="All 6 branches missed.">            if (k1 == k2 || k1 != null &amp;&amp; k1.equals(k2))</span>
            {
<span class="nc" id="L1856">                V v1 = this.value;</span>
<span class="nc" id="L1857">                Object v2 = e.getValue();</span>
<span class="nc bnc" id="L1858" title="All 6 branches missed.">                if (v1 == v2 || v1 != null &amp;&amp; v1.equals(v2))</span>
                {
<span class="nc" id="L1860">                    return true;</span>
                }
            }
<span class="nc" id="L1863">            return false;</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc bnc" id="L1869" title="All 4 branches missed.">            return (this.key == null ? 0 : this.key.hashCode()) ^ (this.value == null ? 0 : this.value.hashCode());</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L1875">            return this.key + &quot;=&quot; + this.value;</span>
        }
    }

    private static final class ResizeContainer
    {
<span class="nc" id="L1881">        private static final int QUEUE_INCREMENT = Math.min(1 &lt;&lt; 10, Integer.highestOneBit(Runtime.getRuntime().availableProcessors()) &lt;&lt; 4);</span>
<span class="nc" id="L1882">        private final AtomicInteger resizers = new AtomicInteger(1);</span>
        private final AtomicReferenceArray nextArray;
        private final AtomicInteger queuePosition;

        private ResizeContainer(AtomicReferenceArray nextArray, int oldSize)
<span class="nc" id="L1887">        {</span>
<span class="nc" id="L1888">            this.nextArray = nextArray;</span>
<span class="nc" id="L1889">            this.queuePosition = new AtomicInteger(oldSize);</span>
<span class="nc" id="L1890">        }</span>

        public void incrementResizer()
        {
<span class="nc" id="L1894">            this.resizers.incrementAndGet();</span>
<span class="nc" id="L1895">        }</span>

        public void decrementResizerAndNotify()
        {
<span class="nc" id="L1899">            int remaining = this.resizers.decrementAndGet();</span>
<span class="nc bnc" id="L1900" title="All 2 branches missed.">            if (remaining == 0)</span>
            {
<span class="nc" id="L1902">                synchronized (this)</span>
                {
<span class="nc" id="L1904">                    this.notifyAll();</span>
<span class="nc" id="L1905">                }</span>
            }
<span class="nc" id="L1907">        }</span>

        public int getQueuePosition()
        {
<span class="nc" id="L1911">            return this.queuePosition.get();</span>
        }

        public int subtractAndGetQueuePosition()
        {
<span class="nc" id="L1916">            return this.queuePosition.addAndGet(-QUEUE_INCREMENT);</span>
        }

        public void waitForAllResizers()
        {
<span class="nc bnc" id="L1921" title="All 2 branches missed.">            if (this.resizers.get() &gt; 0)</span>
            {
<span class="nc bnc" id="L1923" title="All 2 branches missed.">                for (int i = 0; i &lt; 16; i++)</span>
                {
<span class="nc bnc" id="L1925" title="All 2 branches missed.">                    if (this.resizers.get() == 0)</span>
                    {
<span class="nc" id="L1927">                        break;</span>
                    }
                }
<span class="nc bnc" id="L1930" title="All 2 branches missed.">                for (int i = 0; i &lt; 16; i++)</span>
                {
<span class="nc bnc" id="L1932" title="All 2 branches missed.">                    if (this.resizers.get() == 0)</span>
                    {
<span class="nc" id="L1934">                        break;</span>
                    }
<span class="nc" id="L1936">                    Thread.yield();</span>
                }
            }
<span class="nc bnc" id="L1939" title="All 2 branches missed.">            if (this.resizers.get() &gt; 0)</span>
            {
<span class="nc" id="L1941">                synchronized (this)</span>
                {
<span class="nc bnc" id="L1943" title="All 2 branches missed.">                    while (this.resizers.get() &gt; 0)</span>
                    {
                        try
                        {
<span class="nc" id="L1947">                            this.wait();</span>
                        }
<span class="nc" id="L1949">                        catch (InterruptedException e)</span>
                        {
                            // ignore
<span class="nc" id="L1952">                        }</span>
                    }
<span class="nc" id="L1954">                }</span>
            }
<span class="nc" id="L1956">        }</span>

        public boolean isNotDone()
        {
<span class="nc bnc" id="L1960" title="All 2 branches missed.">            return this.resizers.get() &gt; 0;</span>
        }

        public void zeroOutQueuePosition()
        {
<span class="nc" id="L1965">            this.queuePosition.set(0);</span>
<span class="nc" id="L1966">        }</span>
    }

    public static &lt;NK, NV&gt; ConcurrentHashMap&lt;NK, NV&gt; newMap(Map&lt;NK, NV&gt; map)
    {
<span class="nc" id="L1971">        ConcurrentHashMap&lt;NK, NV&gt; result = new ConcurrentHashMap&lt;&gt;(map.size());</span>
<span class="nc" id="L1972">        result.putAll(map);</span>
<span class="nc" id="L1973">        return result;</span>
    }

    @Override
    public ConcurrentHashMap&lt;K, V&gt; withKeyValue(K key, V value)
    {
<span class="nc" id="L1979">        return (ConcurrentHashMap&lt;K, V&gt;) super.withKeyValue(key, value);</span>
    }

    @Override
    public ConcurrentHashMap&lt;K, V&gt; withAllKeyValues(Iterable&lt;? extends Pair&lt;? extends K, ? extends V&gt;&gt; keyValues)
    {
<span class="nc" id="L1985">        return (ConcurrentHashMap&lt;K, V&gt;) super.withAllKeyValues(keyValues);</span>
    }

    @Override
    public ConcurrentHashMap&lt;K, V&gt; withAllKeyValueArguments(Pair&lt;? extends K, ? extends V&gt;... keyValues)
    {
<span class="nc" id="L1991">        return (ConcurrentHashMap&lt;K, V&gt;) super.withAllKeyValueArguments(keyValues);</span>
    }

    @Override
    public ConcurrentHashMap&lt;K, V&gt; withoutKey(K key)
    {
<span class="nc" id="L1997">        return (ConcurrentHashMap&lt;K, V&gt;) super.withoutKey(key);</span>
    }

    @Override
    public ConcurrentHashMap&lt;K, V&gt; withoutAllKeys(Iterable&lt;? extends K&gt; keys)
    {
<span class="nc" id="L2003">        return (ConcurrentHashMap&lt;K, V&gt;) super.withoutAllKeys(keys);</span>
    }

    @Override
    public MutableMap&lt;K, V&gt; clone()
    {
<span class="nc" id="L2009">        return ConcurrentHashMap.newMap(this);</span>
    }

    @Override
    public &lt;K, V&gt; MutableMap&lt;K, V&gt; newEmpty(int capacity)
    {
<span class="nc" id="L2015">        return ConcurrentHashMap.newMap();</span>
    }

    @Override
    public boolean notEmpty()
    {
<span class="nc bnc" id="L2021" title="All 2 branches missed.">        return !this.isEmpty();</span>
    }

    @Override
    public void forEachWithIndex(ObjectIntProcedure&lt;? super V&gt; objectIntProcedure)
    {
<span class="nc" id="L2027">        Iterate.forEachWithIndex(this.values(), objectIntProcedure);</span>
<span class="nc" id="L2028">    }</span>

    @Override
    public Iterator&lt;V&gt; iterator()
    {
<span class="nc" id="L2033">        return this.values().iterator();</span>
    }

    @Override
    public MutableMap&lt;K, V&gt; newEmpty()
    {
<span class="nc" id="L2039">        return ConcurrentHashMap.newMap();</span>
    }

    @Override
    public ConcurrentMutableMap&lt;K, V&gt; tap(Procedure&lt;? super V&gt; procedure)
    {
<span class="nc" id="L2045">        this.each(procedure);</span>
<span class="nc" id="L2046">        return this;</span>
    }

    @Override
    public void forEachValue(Procedure&lt;? super V&gt; procedure)
    {
<span class="nc" id="L2052">        IterableIterate.forEach(this.values(), procedure);</span>
<span class="nc" id="L2053">    }</span>

    @Override
    public void forEachKey(Procedure&lt;? super K&gt; procedure)
    {
<span class="nc" id="L2058">        IterableIterate.forEach(this.keySet(), procedure);</span>
<span class="nc" id="L2059">    }</span>

    @Override
    public void forEachKeyValue(Procedure2&lt;? super K, ? super V&gt; procedure)
    {
<span class="nc" id="L2064">        IterableIterate.forEach(this.entrySet(), new MapEntryToProcedure2&lt;&gt;(procedure));</span>
<span class="nc" id="L2065">    }</span>

    @Override
    public &lt;E&gt; MutableMap&lt;K, V&gt; collectKeysAndValues(
            Iterable&lt;E&gt; iterable,
            Function&lt;? super E, ? extends K&gt; keyFunction,
            Function&lt;? super E, ? extends V&gt; valueFunction)
    {
<span class="nc" id="L2073">        Iterate.addToMap(iterable, keyFunction, valueFunction, this);</span>
<span class="nc" id="L2074">        return this;</span>
    }

    @Override
    public V removeKey(K key)
    {
<span class="nc" id="L2080">        return this.remove(key);</span>
    }

    @Override
    public &lt;P&gt; V getIfAbsentPutWith(K key, Function&lt;? super P, ? extends V&gt; function, P parameter)
    {
<span class="nc" id="L2086">        int hash = this.hash(key);</span>
<span class="nc" id="L2087">        AtomicReferenceArray currentArray = this.table;</span>
<span class="nc" id="L2088">        V newValue = null;</span>
<span class="nc" id="L2089">        boolean createdValue = false;</span>
        while (true)
        {
<span class="nc" id="L2092">            int length = currentArray.length();</span>
<span class="nc" id="L2093">            int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L2094">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L2095" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L2097">                currentArray = this.helpWithResizeWhileCurrentIndex(currentArray, index);</span>
            }
            else
            {
<span class="nc" id="L2101">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">                while (e != null)</span>
                {
<span class="nc" id="L2104">                    Object candidate = e.getKey();</span>
<span class="nc bnc" id="L2105" title="All 2 branches missed.">                    if (candidate.equals(key))</span>
                    {
<span class="nc" id="L2107">                        return e.getValue();</span>
                    }
<span class="nc" id="L2109">                    e = e.getNext();</span>
<span class="nc" id="L2110">                }</span>
<span class="nc bnc" id="L2111" title="All 2 branches missed.">                if (!createdValue)</span>
                {
<span class="nc" id="L2113">                    createdValue = true;</span>
<span class="nc" id="L2114">                    newValue = function.valueOf(parameter);</span>
                }
<span class="nc" id="L2116">                Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, newValue, (Entry&lt;K, V&gt;) o);</span>
<span class="nc bnc" id="L2117" title="All 2 branches missed.">                if (currentArray.compareAndSet(index, o, newEntry))</span>
                {
<span class="nc" id="L2119">                    this.incrementSizeAndPossiblyResize(currentArray, length, o);</span>
<span class="nc" id="L2120">                    return newValue;</span>
                }
            }
<span class="nc" id="L2123">        }</span>
    }

    @Override
    public V getIfAbsent(K key, Function0&lt;? extends V&gt; function)
    {
<span class="nc" id="L2129">        V result = this.get(key);</span>
<span class="nc bnc" id="L2130" title="All 2 branches missed.">        if (result == null)</span>
        {
<span class="nc" id="L2132">            return function.value();</span>
        }
<span class="nc" id="L2134">        return result;</span>
    }

    @Override
    public &lt;P&gt; V getIfAbsentWith(
            K key,
            Function&lt;? super P, ? extends V&gt; function,
            P parameter)
    {
<span class="nc" id="L2143">        V result = this.get(key);</span>
<span class="nc bnc" id="L2144" title="All 2 branches missed.">        if (result == null)</span>
        {
<span class="nc" id="L2146">            return function.valueOf(parameter);</span>
        }
<span class="nc" id="L2148">        return result;</span>
    }

    @Override
    public &lt;A&gt; A ifPresentApply(K key, Function&lt;? super V, ? extends A&gt; function)
    {
<span class="nc" id="L2154">        V result = this.get(key);</span>
<span class="nc bnc" id="L2155" title="All 2 branches missed.">        return result == null ? null : function.valueOf(result);</span>
    }

    @Override
    public &lt;P&gt; void forEachWith(Procedure2&lt;? super V, ? super P&gt; procedure, P parameter)
    {
<span class="nc" id="L2161">        Iterate.forEachWith(this.values(), procedure, parameter);</span>
<span class="nc" id="L2162">    }</span>

    @Override
    public V updateValue(K key, Function0&lt;? extends V&gt; factory, Function&lt;? super V, ? extends V&gt; function)
    {
<span class="nc" id="L2167">        int hash = this.hash(key);</span>
<span class="nc" id="L2168">        AtomicReferenceArray currentArray = this.table;</span>
<span class="nc" id="L2169">        int length = currentArray.length();</span>
<span class="nc" id="L2170">        int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L2171">        Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L2172" title="All 2 branches missed.">        if (o == null)</span>
        {
<span class="nc" id="L2174">            V result = function.valueOf(factory.value());</span>
<span class="nc" id="L2175">            Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, result, null);</span>
<span class="nc bnc" id="L2176" title="All 2 branches missed.">            if (currentArray.compareAndSet(index, null, newEntry))</span>
            {
<span class="nc" id="L2178">                this.addToSize(1);</span>
<span class="nc" id="L2179">                return result;</span>
            }
        }
<span class="nc" id="L2182">        return this.slowUpdateValue(key, factory, function, hash, currentArray);</span>
    }

    private V slowUpdateValue(K key, Function0&lt;? extends V&gt; factory, Function&lt;? super V, ? extends V&gt; function, int hash, AtomicReferenceArray currentArray)
    {
        //noinspection LabeledStatement
        outer:
        while (true)
        {
<span class="nc" id="L2191">            int length = currentArray.length();</span>
<span class="nc" id="L2192">            int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L2193">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L2194" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L2196">                currentArray = this.helpWithResizeWhileCurrentIndex(currentArray, index);</span>
            }
            else
            {
<span class="nc" id="L2200">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L2201" title="All 2 branches missed.">                while (e != null)</span>
                {
<span class="nc" id="L2203">                    Object candidate = e.getKey();</span>
<span class="nc bnc" id="L2204" title="All 2 branches missed.">                    if (candidate.equals(key))</span>
                    {
<span class="nc" id="L2206">                        V oldValue = e.getValue();</span>
<span class="nc" id="L2207">                        V newValue = function.valueOf(oldValue);</span>
<span class="nc" id="L2208">                        Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(e.getKey(), newValue, this.createReplacementChainForRemoval((Entry&lt;K, V&gt;) o, e));</span>
<span class="nc bnc" id="L2209" title="All 2 branches missed.">                        if (!currentArray.compareAndSet(index, o, newEntry))</span>
                        {
                            //noinspection ContinueStatementWithLabel
<span class="nc" id="L2212">                            continue outer;</span>
                        }
<span class="nc" id="L2214">                        return newValue;</span>
                    }
<span class="nc" id="L2216">                    e = e.getNext();</span>
<span class="nc" id="L2217">                }</span>
<span class="nc" id="L2218">                V result = function.valueOf(factory.value());</span>
<span class="nc" id="L2219">                Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, result, (Entry&lt;K, V&gt;) o);</span>
<span class="nc bnc" id="L2220" title="All 2 branches missed.">                if (currentArray.compareAndSet(index, o, newEntry))</span>
                {
<span class="nc" id="L2222">                    this.incrementSizeAndPossiblyResize(currentArray, length, o);</span>
<span class="nc" id="L2223">                    return result;</span>
                }
            }
<span class="nc" id="L2226">        }</span>
    }

    @Override
    public &lt;P&gt; V updateValueWith(K key, Function0&lt;? extends V&gt; factory, Function2&lt;? super V, ? super P, ? extends V&gt; function, P parameter)
    {
<span class="nc" id="L2232">        int hash = this.hash(key);</span>
<span class="nc" id="L2233">        AtomicReferenceArray currentArray = this.table;</span>
<span class="nc" id="L2234">        int length = currentArray.length();</span>
<span class="nc" id="L2235">        int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L2236">        Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L2237" title="All 2 branches missed.">        if (o == null)</span>
        {
<span class="nc" id="L2239">            V result = function.value(factory.value(), parameter);</span>
<span class="nc" id="L2240">            Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, result, null);</span>
<span class="nc bnc" id="L2241" title="All 2 branches missed.">            if (currentArray.compareAndSet(index, null, newEntry))</span>
            {
<span class="nc" id="L2243">                this.addToSize(1);</span>
<span class="nc" id="L2244">                return result;</span>
            }
        }
<span class="nc" id="L2247">        return this.slowUpdateValueWith(key, factory, function, parameter, hash, currentArray);</span>
    }

    private &lt;P&gt; V slowUpdateValueWith(
            K key,
            Function0&lt;? extends V&gt; factory,
            Function2&lt;? super V, ? super P, ? extends V&gt; function,
            P parameter,
            int hash,
            AtomicReferenceArray currentArray)
    {
        //noinspection LabeledStatement
        outer:
        while (true)
        {
<span class="nc" id="L2262">            int length = currentArray.length();</span>
<span class="nc" id="L2263">            int index = ConcurrentHashMap.indexFor(hash, length);</span>
<span class="nc" id="L2264">            Object o = currentArray.get(index);</span>
<span class="nc bnc" id="L2265" title="All 4 branches missed.">            if (o == RESIZED || o == RESIZING)</span>
            {
<span class="nc" id="L2267">                currentArray = this.helpWithResizeWhileCurrentIndex(currentArray, index);</span>
            }
            else
            {
<span class="nc" id="L2271">                Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</span>
<span class="nc bnc" id="L2272" title="All 2 branches missed.">                while (e != null)</span>
                {
<span class="nc" id="L2274">                    Object candidate = e.getKey();</span>
<span class="nc bnc" id="L2275" title="All 2 branches missed.">                    if (candidate.equals(key))</span>
                    {
<span class="nc" id="L2277">                        V oldValue = e.getValue();</span>
<span class="nc" id="L2278">                        V newValue = function.value(oldValue, parameter);</span>
<span class="nc" id="L2279">                        Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(e.getKey(), newValue, this.createReplacementChainForRemoval((Entry&lt;K, V&gt;) o, e));</span>
<span class="nc bnc" id="L2280" title="All 2 branches missed.">                        if (!currentArray.compareAndSet(index, o, newEntry))</span>
                        {
                            //noinspection ContinueStatementWithLabel
<span class="nc" id="L2283">                            continue outer;</span>
                        }
<span class="nc" id="L2285">                        return newValue;</span>
                    }
<span class="nc" id="L2287">                    e = e.getNext();</span>
<span class="nc" id="L2288">                }</span>
<span class="nc" id="L2289">                V result = function.value(factory.value(), parameter);</span>
<span class="nc" id="L2290">                Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, result, (Entry&lt;K, V&gt;) o);</span>
<span class="nc bnc" id="L2291" title="All 2 branches missed.">                if (currentArray.compareAndSet(index, o, newEntry))</span>
                {
<span class="nc" id="L2293">                    this.incrementSizeAndPossiblyResize(currentArray, length, o);</span>
<span class="nc" id="L2294">                    return result;</span>
                }
            }
<span class="nc" id="L2297">        }</span>
    }

    @Override
    public ImmutableMap&lt;K, V&gt; toImmutable()
    {
<span class="nc" id="L2303">        return Maps.immutable.ofMap(this);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>