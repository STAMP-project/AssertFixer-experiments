<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ImmutableTreeSet.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.impl.set.sorted.immutable</a> &gt; <span class="el_source">ImmutableTreeSet.java</span></div><h1>ImmutableTreeSet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Goldman Sachs and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.impl.set.sorted.immutable;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Comparator;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.Set;
import java.util.SortedSet;
import java.util.concurrent.ExecutorService;

import org.eclipse.collections.api.LazyIterable;
import org.eclipse.collections.api.block.function.Function;
import org.eclipse.collections.api.block.function.primitive.ObjectIntToObjectFunction;
import org.eclipse.collections.api.block.predicate.Predicate;
import org.eclipse.collections.api.block.predicate.Predicate2;
import org.eclipse.collections.api.block.procedure.Procedure;
import org.eclipse.collections.api.block.procedure.primitive.ObjectIntProcedure;
import org.eclipse.collections.api.list.ImmutableList;
import org.eclipse.collections.api.map.MapIterable;
import org.eclipse.collections.api.multimap.sortedset.ImmutableSortedSetMultimap;
import org.eclipse.collections.api.ordered.OrderedIterable;
import org.eclipse.collections.api.set.sorted.ImmutableSortedSet;
import org.eclipse.collections.api.set.sorted.MutableSortedSet;
import org.eclipse.collections.api.set.sorted.ParallelSortedSetIterable;
import org.eclipse.collections.api.set.sorted.SortedSetIterable;
import org.eclipse.collections.impl.factory.SortedSets;
import org.eclipse.collections.impl.lazy.AbstractLazyIterable;
import org.eclipse.collections.impl.lazy.parallel.AbstractBatch;
import org.eclipse.collections.impl.lazy.parallel.AbstractParallelIterable;
import org.eclipse.collections.impl.lazy.parallel.list.ListBatch;
import org.eclipse.collections.impl.lazy.parallel.set.sorted.AbstractParallelSortedSetIterable;
import org.eclipse.collections.impl.lazy.parallel.set.sorted.CollectSortedSetBatch;
import org.eclipse.collections.impl.lazy.parallel.set.sorted.FlatCollectSortedSetBatch;
import org.eclipse.collections.impl.lazy.parallel.set.sorted.RootSortedSetBatch;
import org.eclipse.collections.impl.lazy.parallel.set.sorted.SelectSortedSetBatch;
import org.eclipse.collections.impl.lazy.parallel.set.sorted.SortedSetBatch;
import org.eclipse.collections.impl.list.mutable.FastList;
import org.eclipse.collections.impl.map.mutable.ConcurrentHashMap;
import org.eclipse.collections.impl.utility.ArrayIterate;
import org.eclipse.collections.impl.utility.ListIterate;
import org.eclipse.collections.impl.utility.internal.InternalArrayIterate;

final class ImmutableTreeSet&lt;T&gt;
        extends AbstractImmutableSortedSet&lt;T&gt;
        implements Serializable
{
    private static final long serialVersionUID = 2L;

    private final T[] delegate;
    private final Comparator&lt;? super T&gt; comparator;

    private ImmutableTreeSet(T[] input, Comparator&lt;? super T&gt; inputComparator, boolean isSortedAndUnique)
<span class="nc" id="L64">    {</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">        if (ArrayIterate.contains(input, null))</span>
        {
<span class="nc" id="L67">            throw new NullPointerException(&quot;Input array contains nulls!&quot;);</span>
        }

<span class="nc bnc" id="L70" title="All 2 branches missed.">        if (isSortedAndUnique)</span>
        {
<span class="nc bnc" id="L72" title="All 2 branches missed.">            for (int i = input.length - 1; i &gt; 0; i--)</span>
            {
<span class="nc bnc" id="L74" title="All 2 branches missed.">                int compare = inputComparator == null</span>
<span class="nc" id="L75">                        ? ((Comparable&lt;? super T&gt;) input[i - 1]).compareTo(input[i])</span>
<span class="nc" id="L76">                        : inputComparator.compare(input[i - 1], input[i]);</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">                if (compare &gt;= 0)</span>
                {
<span class="nc" id="L79">                    throw new ConcurrentModificationException(&quot;Input Array expected to be sorted, but was not!&quot;);</span>
                }
            }
        }
        else
        {
<span class="nc bnc" id="L85" title="All 2 branches missed.">            if (input.length &gt; 0)</span>
            {
<span class="nc" id="L87">                Arrays.sort(input, inputComparator);</span>
<span class="nc" id="L88">                T[] unique = (T[]) new Object[input.length];</span>
<span class="nc" id="L89">                unique[0] = input[0];</span>

<span class="nc bnc" id="L91" title="All 4 branches missed.">                if (inputComparator == null &amp;&amp; !(input[0] instanceof Comparable))</span>
                {
<span class="nc" id="L93">                    throw new ClassCastException(&quot;Comparator is null and input does not implement Comparable!&quot;);</span>
                }

<span class="nc" id="L96">                int uniqueCount = 1;</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">                for (int i = 1; i &lt; input.length; i++)</span>
                {
<span class="nc bnc" id="L99" title="All 2 branches missed.">                    int compare = inputComparator == null</span>
<span class="nc" id="L100">                            ? ((Comparable&lt;? super T&gt;) unique[uniqueCount - 1]).compareTo(input[i])</span>
<span class="nc" id="L101">                            : inputComparator.compare(unique[uniqueCount - 1], input[i]);</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">                    if (compare &lt; 0)</span>
                    {
<span class="nc" id="L104">                        unique[uniqueCount] = input[i];</span>
<span class="nc" id="L105">                        uniqueCount++;</span>
                    }
                }
<span class="nc bnc" id="L108" title="All 2 branches missed.">                if (uniqueCount &lt; input.length)</span>
                {
<span class="nc" id="L110">                    input = Arrays.copyOf(unique, uniqueCount);</span>
                }
            }
        }

<span class="nc" id="L115">        this.delegate = input;</span>
<span class="nc" id="L116">        this.comparator = inputComparator;</span>
<span class="nc" id="L117">    }</span>

    public static &lt;T&gt; ImmutableSortedSet&lt;T&gt; newSetWith(T... elements)
    {
<span class="nc" id="L121">        return new ImmutableTreeSet&lt;&gt;(elements.clone(), null, false);</span>
    }

    public static &lt;T&gt; ImmutableSortedSet&lt;T&gt; newSetWith(Comparator&lt;? super T&gt; comparator, T... elements)
    {
<span class="nc" id="L126">        return new ImmutableTreeSet&lt;&gt;(elements.clone(), comparator, false);</span>
    }

    public static &lt;T&gt; ImmutableSortedSet&lt;T&gt; newSet(SortedSet&lt;T&gt; set)
    {
<span class="nc" id="L131">        return new ImmutableTreeSet&lt;&gt;((T[]) set.toArray(), set.comparator(), true);</span>
    }

    @Override
    public int size()
    {
<span class="nc" id="L137">        return this.delegate.length;</span>
    }

    private Object writeReplace()
    {
<span class="nc" id="L142">        return new ImmutableSortedSetSerializationProxy&lt;&gt;(this);</span>
    }

    @Override
    public boolean equals(Object obj)
    {
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (obj == this)</span>
        {
<span class="nc" id="L150">            return true;</span>
        }

<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (!(obj instanceof Set))</span>
        {
<span class="nc" id="L155">            return false;</span>
        }
<span class="nc" id="L157">        Set&lt;?&gt; otherSet = (Set&lt;?&gt;) obj;</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (otherSet.size() != this.size())</span>
        {
<span class="nc" id="L160">            return false;</span>
        }
        try
        {
<span class="nc" id="L164">            return this.containsAll(otherSet);</span>
        }
<span class="nc" id="L166">        catch (ClassCastException ignored)</span>
        {
<span class="nc" id="L168">            return false;</span>
        }
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L175">        int result = 0;</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        for (T each : this.delegate)</span>
        {
<span class="nc" id="L178">            result += each.hashCode();</span>
        }

<span class="nc" id="L181">        return result;</span>
    }

    @Override
    public boolean contains(Object object)
    {
<span class="nc bnc" id="L187" title="All 2 branches missed.">        return Arrays.binarySearch(this.delegate, (T) object, this.comparator) &gt;= 0;</span>
    }

    @Override
    public Iterator&lt;T&gt; iterator()
    {
<span class="nc" id="L193">        return FastList.newListWith(this.delegate).asUnmodifiable().iterator();</span>
    }

    @Override
    public void each(Procedure&lt;? super T&gt; procedure)
    {
<span class="nc bnc" id="L199" title="All 2 branches missed.">        for (T t : this.delegate)</span>
        {
<span class="nc" id="L201">            procedure.value(t);</span>
        }
<span class="nc" id="L203">    }</span>

    /**
     * @since 9.1.
     */
    @Override
    public &lt;V&gt; ImmutableList&lt;V&gt; collectWithIndex(ObjectIntToObjectFunction&lt;? super T, ? extends V&gt; function)
    {
<span class="nc" id="L211">        FastList&lt;V&gt; result = FastList.newList(this.size());</span>
<span class="nc" id="L212">        int index = 0;</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">        for (T t : this.delegate)</span>
        {
<span class="nc" id="L215">            result.add(function.valueOf(t, index++));</span>
        }
<span class="nc" id="L217">        return result.toImmutable();</span>
    }

    @Override
    public T first()
    {
<span class="nc" id="L223">        return this.delegate[0];</span>
    }

    @Override
    public T last()
    {
<span class="nc" id="L229">        return this.delegate[this.delegate.length - 1];</span>
    }

    @Override
    public Comparator&lt;? super T&gt; comparator()
    {
<span class="nc" id="L235">        return this.comparator;</span>
    }

    @Override
    public int compareTo(SortedSetIterable&lt;T&gt; otherSet)
    {
<span class="nc" id="L241">        Iterator&lt;T&gt; iterator = otherSet.iterator();</span>

<span class="nc bnc" id="L243" title="All 2 branches missed.">        for (T eachInThis : this.delegate)</span>
        {
<span class="nc bnc" id="L245" title="All 2 branches missed.">            if (!iterator.hasNext())</span>
            {
<span class="nc" id="L247">                return 1;</span>
            }

<span class="nc" id="L250">            T eachInOther = iterator.next();</span>

<span class="nc" id="L252">            int compare = this.compare(eachInThis, eachInOther);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (compare != 0)</span>
            {
<span class="nc" id="L255">                return compare;</span>
            }
        }

<span class="nc bnc" id="L259" title="All 2 branches missed.">        return iterator.hasNext() ? -1 : 0;</span>
    }

    private int compare(T o1, T o2)
    {
<span class="nc bnc" id="L264" title="All 2 branches missed.">        return this.comparator == null</span>
<span class="nc" id="L265">                ? ((Comparable&lt;T&gt;) o1).compareTo(o2)</span>
<span class="nc" id="L266">                : this.comparator.compare(o1, o2);</span>
    }

    @Override
    public ParallelSortedSetIterable&lt;T&gt; asParallel(ExecutorService executorService, int batchSize)
    {
<span class="nc" id="L272">        return new SortedSetIterableParallelIterable(executorService, batchSize);</span>
    }

    private final class SortedSetIterableParallelIterable extends AbstractParallelSortedSetIterable&lt;T, RootSortedSetBatch&lt;T&gt;&gt;
    {
        private final ExecutorService executorService;
        private final int batchSize;

        private SortedSetIterableParallelIterable(ExecutorService executorService, int batchSize)
<span class="nc" id="L281">        {</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">            if (executorService == null)</span>
            {
<span class="nc" id="L284">                throw new NullPointerException();</span>
            }
<span class="nc bnc" id="L286" title="All 2 branches missed.">            if (batchSize &lt; 1)</span>
            {
<span class="nc" id="L288">                throw new IllegalArgumentException();</span>
            }
<span class="nc" id="L290">            this.executorService = executorService;</span>
<span class="nc" id="L291">            this.batchSize = batchSize;</span>
<span class="nc" id="L292">        }</span>

        @Override
        public Comparator&lt;? super T&gt; comparator()
        {
<span class="nc" id="L297">            return ImmutableTreeSet.this.comparator;</span>
        }

        @Override
        public ExecutorService getExecutorService()
        {
<span class="nc" id="L303">            return this.executorService;</span>
        }

        @Override
        public LazyIterable&lt;RootSortedSetBatch&lt;T&gt;&gt; split()
        {
<span class="nc" id="L309">            return new SortedSetIterableParallelBatchLazyIterable();</span>
        }

        @Override
        public void forEach(Procedure&lt;? super T&gt; procedure)
        {
<span class="nc" id="L315">            AbstractParallelIterable.forEach(this, procedure);</span>
<span class="nc" id="L316">        }</span>

        @Override
        public boolean anySatisfy(Predicate&lt;? super T&gt; predicate)
        {
<span class="nc" id="L321">            return AbstractParallelIterable.anySatisfy(this, predicate);</span>
        }

        @Override
        public boolean allSatisfy(Predicate&lt;? super T&gt; predicate)
        {
<span class="nc" id="L327">            return AbstractParallelIterable.allSatisfy(this, predicate);</span>
        }

        @Override
        public T detect(Predicate&lt;? super T&gt; predicate)
        {
<span class="nc" id="L333">            return AbstractParallelIterable.detect(this, predicate);</span>
        }

        @Override
        public Object[] toArray()
        {
            // TODO: Implement in parallel
<span class="nc" id="L340">            return ImmutableTreeSet.this.toArray();</span>
        }

        @Override
        public &lt;E&gt; E[] toArray(E[] array)
        {
            // TODO: Implement in parallel
<span class="nc" id="L347">            return ImmutableTreeSet.this.toArray(array);</span>
        }

        @Override
        public &lt;V&gt; ImmutableSortedSetMultimap&lt;V, T&gt; groupBy(Function&lt;? super T, ? extends V&gt; function)
        {
            // TODO: Implement in parallel
<span class="nc" id="L354">            return ImmutableTreeSet.this.groupBy(function);</span>
        }

        @Override
        public &lt;V&gt; ImmutableSortedSetMultimap&lt;V, T&gt; groupByEach(Function&lt;? super T, ? extends Iterable&lt;V&gt;&gt; function)
        {
            // TODO: Implement in parallel
<span class="nc" id="L361">            return ImmutableTreeSet.this.groupByEach(function);</span>
        }

        @Override
        public &lt;V&gt; MapIterable&lt;V, T&gt; groupByUniqueKey(Function&lt;? super T, ? extends V&gt; function)
        {
            // TODO: Implement in parallel
<span class="nc" id="L368">            return ImmutableTreeSet.this.groupByUniqueKey(function);</span>
        }

        @Override
        public int getBatchSize()
        {
<span class="nc" id="L374">            return this.batchSize;</span>
        }

<span class="nc" id="L377">        private class SortedSetIterableParallelBatchIterator implements Iterator&lt;RootSortedSetBatch&lt;T&gt;&gt;</span>
        {
            protected int chunkIndex;

            @Override
            public boolean hasNext()
            {
<span class="nc bnc" id="L384" title="All 2 branches missed.">                return this.chunkIndex * SortedSetIterableParallelIterable.this.getBatchSize() &lt; ImmutableTreeSet.this.size();</span>
            }

            @Override
            public RootSortedSetBatch&lt;T&gt; next()
            {
<span class="nc" id="L390">                int chunkStartIndex = this.chunkIndex * SortedSetIterableParallelIterable.this.getBatchSize();</span>
<span class="nc" id="L391">                int chunkEndIndex = (this.chunkIndex + 1) * SortedSetIterableParallelIterable.this.getBatchSize();</span>
<span class="nc" id="L392">                int truncatedChunkEndIndex = Math.min(chunkEndIndex, ImmutableTreeSet.this.size());</span>
<span class="nc" id="L393">                this.chunkIndex++;</span>
<span class="nc" id="L394">                return new ImmutableTreeSetBatch(chunkStartIndex, truncatedChunkEndIndex);</span>
            }

            @Override
            public void remove()
            {
<span class="nc" id="L400">                throw new UnsupportedOperationException(&quot;Cannot call remove() on &quot; + ImmutableTreeSet.this.getClass().getSimpleName());</span>
            }
        }

<span class="nc" id="L404">        private class SortedSetIterableParallelBatchLazyIterable</span>
                extends AbstractLazyIterable&lt;RootSortedSetBatch&lt;T&gt;&gt;
        {
            @Override
            public void each(Procedure&lt;? super RootSortedSetBatch&lt;T&gt;&gt; procedure)
            {
<span class="nc bnc" id="L410" title="All 2 branches missed.">                for (RootSortedSetBatch&lt;T&gt; chunk : this)</span>
                {
<span class="nc" id="L412">                    procedure.value(chunk);</span>
<span class="nc" id="L413">                }</span>
<span class="nc" id="L414">            }</span>

            @Override
            public Iterator&lt;RootSortedSetBatch&lt;T&gt;&gt; iterator()
            {
<span class="nc" id="L419">                return new SortedSetIterableParallelBatchIterator();</span>
            }
        }
    }

    private final class ImmutableTreeSetBatch extends AbstractBatch&lt;T&gt; implements RootSortedSetBatch&lt;T&gt;
    {
        private final int chunkStartIndex;
        private final int chunkEndIndex;

        private ImmutableTreeSetBatch(int chunkStartIndex, int chunkEndIndex)
<span class="nc" id="L430">        {</span>
<span class="nc" id="L431">            this.chunkStartIndex = chunkStartIndex;</span>
<span class="nc" id="L432">            this.chunkEndIndex = chunkEndIndex;</span>
<span class="nc" id="L433">        }</span>

        @Override
        public void forEach(Procedure&lt;? super T&gt; procedure)
        {
<span class="nc bnc" id="L438" title="All 2 branches missed.">            for (int i = this.chunkStartIndex; i &lt; this.chunkEndIndex; i++)</span>
            {
<span class="nc" id="L440">                procedure.value(ImmutableTreeSet.this.delegate[i]);</span>
            }
<span class="nc" id="L442">        }</span>

        @Override
        public int count(Predicate&lt;? super T&gt; predicate)
        {
<span class="nc" id="L447">            int count = 0;</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">            for (int i = this.chunkStartIndex; i &lt; this.chunkEndIndex; i++)</span>
            {
<span class="nc bnc" id="L450" title="All 2 branches missed.">                if (predicate.accept(ImmutableTreeSet.this.delegate[i]))</span>
                {
<span class="nc" id="L452">                    count++;</span>
                }
            }
<span class="nc" id="L455">            return count;</span>
        }

        @Override
        public boolean anySatisfy(Predicate&lt;? super T&gt; predicate)
        {
<span class="nc bnc" id="L461" title="All 2 branches missed.">            for (int i = this.chunkStartIndex; i &lt; this.chunkEndIndex; i++)</span>
            {
<span class="nc bnc" id="L463" title="All 2 branches missed.">                if (predicate.accept(ImmutableTreeSet.this.delegate[i]))</span>
                {
<span class="nc" id="L465">                    return true;</span>
                }
            }
<span class="nc" id="L468">            return false;</span>
        }

        @Override
        public boolean allSatisfy(Predicate&lt;? super T&gt; predicate)
        {
<span class="nc bnc" id="L474" title="All 2 branches missed.">            for (int i = this.chunkStartIndex; i &lt; this.chunkEndIndex; i++)</span>
            {
<span class="nc bnc" id="L476" title="All 2 branches missed.">                if (!predicate.accept(ImmutableTreeSet.this.delegate[i]))</span>
                {
<span class="nc" id="L478">                    return false;</span>
                }
            }
<span class="nc" id="L481">            return true;</span>
        }

        @Override
        public T detect(Predicate&lt;? super T&gt; predicate)
        {
<span class="nc bnc" id="L487" title="All 2 branches missed.">            for (int i = this.chunkStartIndex; i &lt; this.chunkEndIndex; i++)</span>
            {
<span class="nc bnc" id="L489" title="All 2 branches missed.">                if (predicate.accept(ImmutableTreeSet.this.delegate[i]))</span>
                {
<span class="nc" id="L491">                    return ImmutableTreeSet.this.delegate[i];</span>
                }
            }
<span class="nc" id="L494">            return null;</span>
        }

        @Override
        public SortedSetBatch&lt;T&gt; select(Predicate&lt;? super T&gt; predicate)
        {
<span class="nc" id="L500">            return new SelectSortedSetBatch&lt;&gt;(this, predicate);</span>
        }

        @Override
        public &lt;V&gt; ListBatch&lt;V&gt; collect(Function&lt;? super T, ? extends V&gt; function)
        {
<span class="nc" id="L506">            return new CollectSortedSetBatch&lt;&gt;(this, function);</span>
        }

        @Override
        public &lt;V&gt; ListBatch&lt;V&gt; flatCollect(Function&lt;? super T, ? extends Iterable&lt;V&gt;&gt; function)
        {
<span class="nc" id="L512">            return new FlatCollectSortedSetBatch&lt;&gt;(this, function);</span>
        }

        @Override
        public SortedSetBatch&lt;T&gt; distinct(ConcurrentHashMap&lt;T, Boolean&gt; distinct)
        {
<span class="nc" id="L518">            return this;</span>
        }
    }

    @Override
    public int detectIndex(Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L525">        return ArrayIterate.detectIndex(this.delegate, predicate);</span>
    }

    @Override
    public &lt;S&gt; boolean corresponds(OrderedIterable&lt;S&gt; other, Predicate2&lt;? super T, ? super S&gt; predicate)
    {
<span class="nc" id="L531">        return InternalArrayIterate.corresponds(this.delegate, this.size(), other, predicate);</span>
    }

    @Override
    public void forEach(int fromIndex, int toIndex, Procedure&lt;? super T&gt; procedure)
    {
<span class="nc" id="L537">        ListIterate.rangeCheck(fromIndex, toIndex, this.size());</span>

<span class="nc bnc" id="L539" title="All 2 branches missed.">        if (fromIndex &gt; toIndex)</span>
        {
<span class="nc" id="L541">            throw new IllegalArgumentException(&quot;fromIndex must not be greater than toIndex&quot;);</span>
        }

<span class="nc bnc" id="L544" title="All 2 branches missed.">        for (int i = fromIndex; i &lt;= toIndex; i++)</span>
        {
<span class="nc" id="L546">            procedure.value(this.delegate[i]);</span>
        }
<span class="nc" id="L548">    }</span>

    @Override
    public void forEachWithIndex(int fromIndex, int toIndex, ObjectIntProcedure&lt;? super T&gt; objectIntProcedure)
    {
<span class="nc" id="L553">        ListIterate.rangeCheck(fromIndex, toIndex, this.size());</span>

<span class="nc bnc" id="L555" title="All 2 branches missed.">        if (fromIndex &gt; toIndex)</span>
        {
<span class="nc" id="L557">            throw new IllegalArgumentException(&quot;fromIndex must not be greater than toIndex&quot;);</span>
        }

<span class="nc bnc" id="L560" title="All 2 branches missed.">        for (int i = fromIndex; i &lt;= toIndex; i++)</span>
        {
<span class="nc" id="L562">            objectIntProcedure.value(this.delegate[i], i);</span>
        }
<span class="nc" id="L564">    }</span>

    @Override
    public int indexOf(Object object)
    {
<span class="nc" id="L569">        return ArrayIterate.indexOf(this.delegate, object);</span>
    }

    @Override
    public ImmutableSortedSet&lt;T&gt; take(int count)
    {
<span class="nc bnc" id="L575" title="All 2 branches missed.">        if (count &lt; 0)</span>
        {
<span class="nc" id="L577">            throw new IllegalArgumentException(&quot;Count must be greater than zero, but was: &quot; + count);</span>
        }
<span class="nc bnc" id="L579" title="All 2 branches missed.">        if (count &gt;= this.size())</span>
        {
<span class="nc" id="L581">            return this;</span>
        }
<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (count == 0)</span>
        {
<span class="nc" id="L585">            return SortedSets.immutable.empty(this.comparator());</span>
        }

<span class="nc" id="L588">        MutableSortedSet&lt;T&gt; output = SortedSets.mutable.of(this.comparator());</span>

<span class="nc bnc" id="L590" title="All 2 branches missed.">        for (int i = 0; i &lt; count; i++)</span>
        {
<span class="nc" id="L592">            output.add(this.delegate[i]);</span>
        }

<span class="nc" id="L595">        return output.toImmutable();</span>
    }

    @Override
    public ImmutableSortedSet&lt;T&gt; drop(int count)
    {
<span class="nc bnc" id="L601" title="All 2 branches missed.">        if (count &lt; 0)</span>
        {
<span class="nc" id="L603">            throw new IllegalArgumentException(&quot;Count must be greater than zero, but was: &quot; + count);</span>
        }

<span class="nc bnc" id="L606" title="All 2 branches missed.">        if (count == 0)</span>
        {
<span class="nc" id="L608">            return this;</span>
        }
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (count &gt;= this.size())</span>
        {
<span class="nc" id="L612">            return SortedSets.immutable.empty(this.comparator());</span>
        }

<span class="nc" id="L615">        MutableSortedSet&lt;T&gt; output = SortedSets.mutable.of(this.comparator());</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        for (int i = 0; i &lt; this.size(); i++)</span>
        {
<span class="nc bnc" id="L618" title="All 2 branches missed.">            if (i &gt;= count)</span>
            {
<span class="nc" id="L620">                output.add(this.delegate[i]);</span>
            }
        }

<span class="nc" id="L624">        return output.toImmutable();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>