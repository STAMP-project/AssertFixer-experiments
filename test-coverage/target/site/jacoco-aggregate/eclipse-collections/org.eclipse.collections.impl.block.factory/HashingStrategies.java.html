<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HashingStrategies.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.impl.block.factory</a> &gt; <span class="el_source">HashingStrategies.java</span></div><h1>HashingStrategies.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2016 Goldman Sachs.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.impl.block.factory;

import java.util.Objects;

import org.eclipse.collections.api.block.HashingStrategy;
import org.eclipse.collections.api.block.function.Function;
import org.eclipse.collections.api.block.function.primitive.BooleanFunction;
import org.eclipse.collections.api.block.function.primitive.ByteFunction;
import org.eclipse.collections.api.block.function.primitive.CharFunction;
import org.eclipse.collections.api.block.function.primitive.DoubleFunction;
import org.eclipse.collections.api.block.function.primitive.FloatFunction;
import org.eclipse.collections.api.block.function.primitive.IntFunction;
import org.eclipse.collections.api.block.function.primitive.LongFunction;
import org.eclipse.collections.api.block.function.primitive.ShortFunction;

public final class HashingStrategies
{
<span class="nc" id="L28">    private static final HashingStrategy&lt;Object&gt; DEFAULT_HASHING_STRATEGY = new DefaultStrategy();</span>
<span class="nc" id="L29">    private static final HashingStrategy&lt;Object&gt; IDENTITY_HASHING_STRATEGY = new IdentityHashingStrategy();</span>

    private HashingStrategies()
<span class="nc" id="L32">    {</span>
<span class="nc" id="L33">        throw new AssertionError(&quot;Suppress default constructor for noninstantiability&quot;);</span>
    }

    public static &lt;T&gt; HashingStrategy&lt;T&gt; defaultStrategy()
    {
<span class="nc" id="L38">        return (HashingStrategy&lt;T&gt;) DEFAULT_HASHING_STRATEGY;</span>
    }

    public static &lt;T&gt; HashingStrategy&lt;T&gt; nullSafeHashingStrategy(HashingStrategy&lt;T&gt; nonNullSafeStrategy)
    {
<span class="nc" id="L43">        return new NullSafeHashingStrategy&lt;&gt;(nonNullSafeStrategy);</span>
    }

    public static &lt;T, V&gt; HashingStrategy&lt;T&gt; nullSafeFromFunction(Function&lt;? super T, ? extends V&gt; function)
    {
<span class="nc" id="L48">        return new NullSafeFunctionHashingStrategy&lt;&gt;(function);</span>
    }

    public static &lt;T, V&gt; HashingStrategy&lt;T&gt; fromFunction(Function&lt;? super T, ? extends V&gt; function)
    {
<span class="nc" id="L53">        return new FunctionHashingStrategy&lt;&gt;(function);</span>
    }

    public static HashingStrategy&lt;Object&gt; identityStrategy()
    {
<span class="nc" id="L58">        return IDENTITY_HASHING_STRATEGY;</span>
    }

    public static &lt;T&gt; HashingStrategy&lt;T&gt; chain(HashingStrategy&lt;T&gt;... hashingStrategies)
    {
<span class="nc bnc" id="L63" title="All 2 branches missed.">        if (hashingStrategies.length == 0)</span>
        {
<span class="nc" id="L65">            throw new IllegalArgumentException(&quot;Nothing to chain&quot;);</span>
        }

<span class="nc" id="L68">        return new ChainedHashingStrategy&lt;&gt;(hashingStrategies);</span>
    }

    public static &lt;T, V1, V2&gt; HashingStrategy&lt;T&gt; fromFunctions(Function&lt;? super T, ? extends V1&gt; one, Function&lt;? super T, ? extends V2&gt; two)
    {
<span class="nc" id="L73">        return HashingStrategies.chain(</span>
<span class="nc" id="L74">                HashingStrategies.fromFunction(one),</span>
<span class="nc" id="L75">                HashingStrategies.fromFunction(two));</span>
    }

    public static &lt;T, V1, V2, V3&gt; HashingStrategy&lt;T&gt; fromFunctions(Function&lt;? super T, ? extends V1&gt; one, Function&lt;? super T, ? extends V2&gt; two, Function&lt;? super T, ? extends V3&gt; three)
    {
<span class="nc" id="L80">        return HashingStrategies.chain(</span>
<span class="nc" id="L81">                HashingStrategies.fromFunction(one),</span>
<span class="nc" id="L82">                HashingStrategies.fromFunction(two),</span>
<span class="nc" id="L83">                HashingStrategies.fromFunction(three));</span>
    }

    public static &lt;T&gt; HashingStrategy&lt;T&gt; fromBooleanFunction(BooleanFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L88">        return new BooleanFunctionHashingStrategy&lt;&gt;(function);</span>
    }

    public static &lt;T&gt; HashingStrategy&lt;T&gt; fromByteFunction(ByteFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L93">        return new ByteFunctionHashingStrategy&lt;&gt;(function);</span>
    }

    public static &lt;T&gt; HashingStrategy&lt;T&gt; fromCharFunction(CharFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L98">        return new CharFunctionHashingStrategy&lt;&gt;(function);</span>
    }

    public static &lt;T&gt; HashingStrategy&lt;T&gt; fromDoubleFunction(DoubleFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L103">        return new DoubleFunctionHashingStrategy&lt;&gt;(function);</span>
    }

    public static &lt;T&gt; HashingStrategy&lt;T&gt; fromFloatFunction(FloatFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L108">        return new FloatFunctionHashingStrategy&lt;&gt;(function);</span>
    }

    public static &lt;T&gt; HashingStrategy&lt;T&gt; fromIntFunction(IntFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L113">        return new IntFunctionHashingStrategy&lt;&gt;(function);</span>
    }

    public static &lt;T&gt; HashingStrategy&lt;T&gt; fromLongFunction(LongFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L118">        return new LongFunctionHashingStrategy&lt;&gt;(function);</span>
    }

    public static &lt;T&gt; HashingStrategy&lt;T&gt; fromShortFunction(ShortFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L123">        return new ShortFunctionHashingStrategy&lt;&gt;(function);</span>
    }

    private static class DefaultStrategy implements HashingStrategy&lt;Object&gt;
    {
        private static final long serialVersionUID = 1L;

        @Override
        public int computeHashCode(Object object)
        {
<span class="nc" id="L133">            return object.hashCode();</span>
        }

        @Override
        public boolean equals(Object object1, Object object2)
        {
<span class="nc" id="L139">            return object1.equals(object2);</span>
        }
    }

    private static final class NullSafeHashingStrategy&lt;T&gt; implements HashingStrategy&lt;T&gt;
    {
        private static final long serialVersionUID = 1L;

        private final HashingStrategy&lt;T&gt; nonNullSafeStrategy;

        private NullSafeHashingStrategy(HashingStrategy&lt;T&gt; nonNullSafeStrategy)
<span class="nc" id="L150">        {</span>
<span class="nc" id="L151">            this.nonNullSafeStrategy = nonNullSafeStrategy;</span>
<span class="nc" id="L152">        }</span>

        @Override
        public int computeHashCode(T object)
        {
<span class="nc bnc" id="L157" title="All 2 branches missed.">            return object == null ? 0 : this.nonNullSafeStrategy.computeHashCode(object);</span>
        }

        @Override
        public boolean equals(T object1, T object2)
        {
<span class="nc bnc" id="L163" title="All 6 branches missed.">            return object1 == null || object2 == null ? object1 == object2 : this.nonNullSafeStrategy.equals(object1, object2);</span>
        }
    }

    private static final class NullSafeFunctionHashingStrategy&lt;T, V&gt; implements HashingStrategy&lt;T&gt;
    {
        private static final long serialVersionUID = 1L;

        private final Function&lt;? super T, ? extends V&gt; function;

        private NullSafeFunctionHashingStrategy(Function&lt;? super T, ? extends V&gt; function)
<span class="nc" id="L174">        {</span>
<span class="nc" id="L175">            this.function = function;</span>
<span class="nc" id="L176">        }</span>

        @Override
        public int computeHashCode(T object)
        {
<span class="nc" id="L181">            return Objects.hashCode(this.function.valueOf(object));</span>
        }

        @Override
        public boolean equals(T object1, T object2)
        {
<span class="nc" id="L187">            return Objects.equals(</span>
<span class="nc" id="L188">                    this.function.valueOf(object1),</span>
<span class="nc" id="L189">                    this.function.valueOf(object2));</span>
        }
    }

    private static final class FunctionHashingStrategy&lt;T, V&gt; implements HashingStrategy&lt;T&gt;
    {
        private static final long serialVersionUID = 1L;

        private final Function&lt;? super T, ? extends V&gt; function;

        private FunctionHashingStrategy(Function&lt;? super T, ? extends V&gt; function)
<span class="nc" id="L200">        {</span>
<span class="nc" id="L201">            this.function = function;</span>
<span class="nc" id="L202">        }</span>

        @Override
        public int computeHashCode(T object)
        {
<span class="nc" id="L207">            return this.function.valueOf(object).hashCode();</span>
        }

        @Override
        public boolean equals(T object1, T object2)
        {
<span class="nc" id="L213">            return this.function.valueOf(object1).equals(this.function.valueOf(object2));</span>
        }
    }

    private static final class BooleanFunctionHashingStrategy&lt;T&gt; implements HashingStrategy&lt;T&gt;
    {
        private static final long serialVersionUID = 1L;

        private final BooleanFunction&lt;? super T&gt; function;

        private BooleanFunctionHashingStrategy(BooleanFunction&lt;? super T&gt; function)
<span class="nc" id="L224">        {</span>
<span class="nc" id="L225">            this.function = function;</span>
<span class="nc" id="L226">        }</span>

        @Override
        public int computeHashCode(T object)
        {
<span class="nc bnc" id="L231" title="All 2 branches missed.">            return this.function.booleanValueOf(object) ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode();</span>
        }

        @Override
        public boolean equals(T object1, T object2)
        {
<span class="nc bnc" id="L237" title="All 2 branches missed.">            return this.function.booleanValueOf(object1) == this.function.booleanValueOf(object2);</span>
        }
    }

    private static final class ByteFunctionHashingStrategy&lt;T&gt; implements HashingStrategy&lt;T&gt;
    {
        private static final long serialVersionUID = 1L;

        private final ByteFunction&lt;? super T&gt; function;

        private ByteFunctionHashingStrategy(ByteFunction&lt;? super T&gt; function)
<span class="nc" id="L248">        {</span>
<span class="nc" id="L249">            this.function = function;</span>
<span class="nc" id="L250">        }</span>

        @Override
        public int computeHashCode(T object)
        {
<span class="nc" id="L255">            return this.function.byteValueOf(object);</span>
        }

        @Override
        public boolean equals(T object1, T object2)
        {
<span class="nc bnc" id="L261" title="All 2 branches missed.">            return this.function.byteValueOf(object1) == this.function.byteValueOf(object2);</span>
        }
    }

    private static final class CharFunctionHashingStrategy&lt;T&gt; implements HashingStrategy&lt;T&gt;
    {
        private static final long serialVersionUID = 1L;

        private final CharFunction&lt;? super T&gt; function;

        private CharFunctionHashingStrategy(CharFunction&lt;? super T&gt; function)
<span class="nc" id="L272">        {</span>
<span class="nc" id="L273">            this.function = function;</span>
<span class="nc" id="L274">        }</span>

        @Override
        public int computeHashCode(T object)
        {
<span class="nc" id="L279">            return this.function.charValueOf(object);</span>
        }

        @Override
        public boolean equals(T object1, T object2)
        {
<span class="nc bnc" id="L285" title="All 2 branches missed.">            return this.function.charValueOf(object1) == this.function.charValueOf(object2);</span>
        }
    }

    private static final class DoubleFunctionHashingStrategy&lt;T&gt; implements HashingStrategy&lt;T&gt;
    {
        private static final long serialVersionUID = 1L;

        private final DoubleFunction&lt;? super T&gt; function;

        private DoubleFunctionHashingStrategy(DoubleFunction&lt;? super T&gt; function)
<span class="nc" id="L296">        {</span>
<span class="nc" id="L297">            this.function = function;</span>
<span class="nc" id="L298">        }</span>

        @Override
        public int computeHashCode(T object)
        {
<span class="nc" id="L303">            return HashingStrategies.longHashCode(Double.doubleToLongBits(this.function.doubleValueOf(object)));</span>
        }

        @Override
        public boolean equals(T object1, T object2)
        {
<span class="nc bnc" id="L309" title="All 2 branches missed.">            return Double.compare(this.function.doubleValueOf(object1), this.function.doubleValueOf(object2)) == 0;</span>
        }
    }

    private static final class FloatFunctionHashingStrategy&lt;T&gt; implements HashingStrategy&lt;T&gt;
    {
        private static final long serialVersionUID = 1L;

        private final FloatFunction&lt;? super T&gt; function;

        private FloatFunctionHashingStrategy(FloatFunction&lt;? super T&gt; function)
<span class="nc" id="L320">        {</span>
<span class="nc" id="L321">            this.function = function;</span>
<span class="nc" id="L322">        }</span>

        @Override
        public int computeHashCode(T object)
        {
<span class="nc" id="L327">            return Float.floatToIntBits(this.function.floatValueOf(object));</span>
        }

        @Override
        public boolean equals(T object1, T object2)
        {
<span class="nc bnc" id="L333" title="All 2 branches missed.">            return Float.compare(this.function.floatValueOf(object1), this.function.floatValueOf(object2)) == 0;</span>
        }
    }

    private static final class IntFunctionHashingStrategy&lt;T&gt; implements HashingStrategy&lt;T&gt;
    {
        private static final long serialVersionUID = 1L;

        private final IntFunction&lt;? super T&gt; function;

        private IntFunctionHashingStrategy(IntFunction&lt;? super T&gt; function)
<span class="nc" id="L344">        {</span>
<span class="nc" id="L345">            this.function = function;</span>
<span class="nc" id="L346">        }</span>

        @Override
        public int computeHashCode(T object)
        {
<span class="nc" id="L351">            return this.function.intValueOf(object);</span>
        }

        @Override
        public boolean equals(T object1, T object2)
        {
<span class="nc bnc" id="L357" title="All 2 branches missed.">            return this.function.intValueOf(object1) == this.function.intValueOf(object2);</span>
        }
    }

    private static final class LongFunctionHashingStrategy&lt;T&gt; implements HashingStrategy&lt;T&gt;
    {
        private static final long serialVersionUID = 1L;

        private final LongFunction&lt;? super T&gt; function;

        private LongFunctionHashingStrategy(LongFunction&lt;? super T&gt; function)
<span class="nc" id="L368">        {</span>
<span class="nc" id="L369">            this.function = function;</span>
<span class="nc" id="L370">        }</span>

        @Override
        public int computeHashCode(T object)
        {
<span class="nc" id="L375">            return HashingStrategies.longHashCode(this.function.longValueOf(object));</span>
        }

        @Override
        public boolean equals(T object1, T object2)
        {
<span class="nc bnc" id="L381" title="All 2 branches missed.">            return this.function.longValueOf(object1) == this.function.longValueOf(object2);</span>
        }
    }

    private static final class ShortFunctionHashingStrategy&lt;T&gt; implements HashingStrategy&lt;T&gt;
    {
        private static final long serialVersionUID = 1L;

        private final ShortFunction&lt;? super T&gt; function;

        private ShortFunctionHashingStrategy(ShortFunction&lt;? super T&gt; function)
<span class="nc" id="L392">        {</span>
<span class="nc" id="L393">            this.function = function;</span>
<span class="nc" id="L394">        }</span>

        @Override
        public int computeHashCode(T object)
        {
<span class="nc" id="L399">            return this.function.shortValueOf(object);</span>
        }

        @Override
        public boolean equals(T object1, T object2)
        {
<span class="nc bnc" id="L405" title="All 2 branches missed.">            return this.function.shortValueOf(object1) == this.function.shortValueOf(object2);</span>
        }
    }

    private static final class IdentityHashingStrategy implements HashingStrategy&lt;Object&gt;
    {
        private static final long serialVersionUID = 1L;

        @Override
        public int computeHashCode(Object object)
        {
<span class="nc" id="L416">            return System.identityHashCode(object);</span>
        }

        @Override
        public boolean equals(Object object1, Object object2)
        {
<span class="nc bnc" id="L422" title="All 2 branches missed.">            return object1 == object2;</span>
        }
    }

    private static final class ChainedHashingStrategy&lt;T&gt; implements HashingStrategy&lt;T&gt;
    {
        private static final long serialVersionUID = 1L;
        private final HashingStrategy&lt;T&gt;[] hashingStrategies;

        private ChainedHashingStrategy(HashingStrategy&lt;T&gt;... hashingStrategies)
<span class="nc" id="L432">        {</span>
<span class="nc" id="L433">            this.hashingStrategies = hashingStrategies;</span>
<span class="nc" id="L434">        }</span>

        @Override
        public int computeHashCode(T object)
        {
<span class="nc" id="L439">            int hashCode = this.hashingStrategies[0].computeHashCode(object);</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">            for (int i = 1; i &lt; this.hashingStrategies.length; i++)</span>
            {
<span class="nc" id="L442">                hashCode = hashCode * 31 + this.hashingStrategies[i].computeHashCode(object);</span>
            }
<span class="nc" id="L444">            return hashCode;</span>
        }

        @Override
        public boolean equals(T object1, T object2)
        {
<span class="nc bnc" id="L450" title="All 2 branches missed.">            for (HashingStrategy&lt;T&gt; hashingStrategy : this.hashingStrategies)</span>
            {
<span class="nc bnc" id="L452" title="All 2 branches missed.">                if (!hashingStrategy.equals(object1, object2))</span>
                {
<span class="nc" id="L454">                    return false;</span>
                }
            }
<span class="nc" id="L457">            return true;</span>
        }
    }

    /**
     * This implementation is equivalent to the JDK Long hashcode because there is no public static hashCode(long value) method on Long.
     * This method will be introduced in Java 1.8, at which point this can be replaced.
     *
     * @param value the long value to hash
     * @return hashcode for long, based on the {@link Long#hashCode()}
     */
    private static int longHashCode(long value)
    {
<span class="nc" id="L470">        return (int) (value ^ (value &gt;&gt;&gt; 32));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>