<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractBag.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.impl.bag</a> &gt; <span class="el_source">AbstractBag.java</span></div><h1>AbstractBag.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2018 Goldman Sachs and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.impl.bag;

import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.StringJoiner;

import org.eclipse.collections.api.bag.Bag;
import org.eclipse.collections.api.bag.MutableBag;
import org.eclipse.collections.api.bag.MutableBagIterable;
import org.eclipse.collections.api.bag.primitive.MutableBooleanBag;
import org.eclipse.collections.api.bag.primitive.MutableByteBag;
import org.eclipse.collections.api.bag.primitive.MutableCharBag;
import org.eclipse.collections.api.bag.primitive.MutableDoubleBag;
import org.eclipse.collections.api.bag.primitive.MutableFloatBag;
import org.eclipse.collections.api.bag.primitive.MutableIntBag;
import org.eclipse.collections.api.bag.primitive.MutableLongBag;
import org.eclipse.collections.api.bag.primitive.MutableShortBag;
import org.eclipse.collections.api.bag.sorted.MutableSortedBag;
import org.eclipse.collections.api.block.function.Function;
import org.eclipse.collections.api.block.function.Function2;
import org.eclipse.collections.api.block.function.Function3;
import org.eclipse.collections.api.block.function.primitive.BooleanFunction;
import org.eclipse.collections.api.block.function.primitive.ByteFunction;
import org.eclipse.collections.api.block.function.primitive.CharFunction;
import org.eclipse.collections.api.block.function.primitive.DoubleFunction;
import org.eclipse.collections.api.block.function.primitive.DoubleObjectToDoubleFunction;
import org.eclipse.collections.api.block.function.primitive.FloatFunction;
import org.eclipse.collections.api.block.function.primitive.FloatObjectToFloatFunction;
import org.eclipse.collections.api.block.function.primitive.IntFunction;
import org.eclipse.collections.api.block.function.primitive.IntObjectToIntFunction;
import org.eclipse.collections.api.block.function.primitive.LongFunction;
import org.eclipse.collections.api.block.function.primitive.LongObjectToLongFunction;
import org.eclipse.collections.api.block.function.primitive.ShortFunction;
import org.eclipse.collections.api.block.predicate.Predicate;
import org.eclipse.collections.api.block.predicate.Predicate2;
import org.eclipse.collections.api.collection.primitive.MutableBooleanCollection;
import org.eclipse.collections.api.collection.primitive.MutableByteCollection;
import org.eclipse.collections.api.collection.primitive.MutableCharCollection;
import org.eclipse.collections.api.collection.primitive.MutableDoubleCollection;
import org.eclipse.collections.api.collection.primitive.MutableFloatCollection;
import org.eclipse.collections.api.collection.primitive.MutableIntCollection;
import org.eclipse.collections.api.collection.primitive.MutableLongCollection;
import org.eclipse.collections.api.collection.primitive.MutableShortCollection;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.api.multimap.MutableMultimap;
import org.eclipse.collections.api.set.MutableSet;
import org.eclipse.collections.api.set.SetIterable;
import org.eclipse.collections.api.set.sorted.MutableSortedSet;
import org.eclipse.collections.api.tuple.primitive.ObjectIntPair;
import org.eclipse.collections.impl.AbstractRichIterable;
import org.eclipse.collections.impl.Counter;
import org.eclipse.collections.impl.bag.mutable.HashBag;
import org.eclipse.collections.impl.bag.sorted.mutable.TreeBag;
import org.eclipse.collections.impl.factory.Sets;
import org.eclipse.collections.impl.factory.SortedSets;
import org.eclipse.collections.impl.list.mutable.FastList;
import org.eclipse.collections.impl.set.mutable.UnifiedSet;
import org.eclipse.collections.impl.tuple.primitive.PrimitiveTuples;
import org.eclipse.collections.impl.utility.Iterate;

/**
 * @since 7.0
 */
<span class="nc" id="L75">public abstract class AbstractBag&lt;T&gt;</span>
        extends AbstractRichIterable&lt;T&gt;
        implements Collection&lt;T&gt;, Bag&lt;T&gt;
{
    @Override
    public &lt;R extends Collection&lt;T&gt;&gt; R select(Predicate&lt;? super T&gt; predicate, R target)
    {
<span class="nc bnc" id="L82" title="All 2 branches missed.">        if (target instanceof MutableBagIterable&lt;?&gt;)</span>
        {
<span class="nc" id="L84">            MutableBagIterable&lt;T&gt; targetBag = (MutableBagIterable&lt;T&gt;) target;</span>

<span class="nc" id="L86">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">                if (predicate.accept(each))</span>
                {
<span class="nc" id="L89">                    targetBag.addOccurrences(each, occurrences);</span>
                }
<span class="nc" id="L91">            });</span>
<span class="nc" id="L92">        }</span>
        else
        {
<span class="nc" id="L95">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">                if (predicate.accept(each))</span>
                {
<span class="nc bnc" id="L98" title="All 2 branches missed.">                    for (int i = 0; i &lt; occurrences; i++)</span>
                    {
<span class="nc" id="L100">                        target.add(each);</span>
                    }
                }
<span class="nc" id="L103">            });</span>
        }
<span class="nc" id="L105">        return target;</span>
    }

    @Override
    public &lt;P, R extends Collection&lt;T&gt;&gt; R selectWith(
            Predicate2&lt;? super T, ? super P&gt; predicate,
            P parameter,
            R target)
    {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (target instanceof MutableBagIterable&lt;?&gt;)</span>
        {
<span class="nc" id="L116">            MutableBagIterable&lt;T&gt; targetBag = (MutableBagIterable&lt;T&gt;) target;</span>

<span class="nc" id="L118">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">                if (predicate.accept(each, parameter))</span>
                {
<span class="nc" id="L121">                    targetBag.addOccurrences(each, occurrences);</span>
                }
<span class="nc" id="L123">            });</span>
<span class="nc" id="L124">        }</span>
        else
        {
<span class="nc" id="L127">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">                if (predicate.accept(each, parameter))</span>
                {
<span class="nc bnc" id="L130" title="All 2 branches missed.">                    for (int i = 0; i &lt; occurrences; i++)</span>
                    {
<span class="nc" id="L132">                        target.add(each);</span>
                    }
                }
<span class="nc" id="L135">            });</span>
        }
<span class="nc" id="L137">        return target;</span>
    }

    @Override
    public &lt;R extends Collection&lt;T&gt;&gt; R reject(Predicate&lt;? super T&gt; predicate, R target)
    {
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (target instanceof MutableBagIterable&lt;?&gt;)</span>
        {
<span class="nc" id="L145">            MutableBagIterable&lt;T&gt; targetBag = (MutableBagIterable&lt;T&gt;) target;</span>

<span class="nc" id="L147">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                if (!predicate.accept(each))</span>
                {
<span class="nc" id="L150">                    targetBag.addOccurrences(each, occurrences);</span>
                }
<span class="nc" id="L152">            });</span>
<span class="nc" id="L153">        }</span>
        else
        {
<span class="nc" id="L156">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">                if (!predicate.accept(each))</span>
                {
<span class="nc bnc" id="L159" title="All 2 branches missed.">                    for (int i = 0; i &lt; occurrences; i++)</span>
                    {
<span class="nc" id="L161">                        target.add(each);</span>
                    }
                }
<span class="nc" id="L164">            });</span>
        }
<span class="nc" id="L166">        return target;</span>
    }

    @Override
    public &lt;P, R extends Collection&lt;T&gt;&gt; R rejectWith(
            Predicate2&lt;? super T, ? super P&gt; predicate,
            P parameter,
            R target)
    {
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (target instanceof MutableBagIterable&lt;?&gt;)</span>
        {
<span class="nc" id="L177">            MutableBagIterable&lt;T&gt; targetBag = (MutableBagIterable&lt;T&gt;) target;</span>

<span class="nc" id="L179">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                if (!predicate.accept(each, parameter))</span>
                {
<span class="nc" id="L182">                    targetBag.addOccurrences(each, occurrences);</span>
                }
<span class="nc" id="L184">            });</span>
<span class="nc" id="L185">        }</span>
        else
        {
<span class="nc" id="L188">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                if (!predicate.accept(each, parameter))</span>
                {
<span class="nc bnc" id="L191" title="All 2 branches missed.">                    for (int i = 0; i &lt; occurrences; i++)</span>
                    {
<span class="nc" id="L193">                        target.add(each);</span>
                    }
                }
<span class="nc" id="L196">            });</span>
        }
<span class="nc" id="L198">        return target;</span>
    }

    @Override
    public int count(Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L204">        Counter result = new Counter();</span>
<span class="nc" id="L205">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            if (predicate.accept(each))</span>
            {
<span class="nc" id="L208">                result.add(occurrences);</span>
            }
<span class="nc" id="L210">        });</span>
<span class="nc" id="L211">        return result.getCount();</span>
    }

    @Override
    public &lt;V, R extends Collection&lt;V&gt;&gt; R collect(Function&lt;? super T, ? extends V&gt; function, R target)
    {
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (target instanceof MutableBagIterable&lt;?&gt;)</span>
        {
<span class="nc" id="L219">            MutableBagIterable&lt;V&gt; targetBag = (MutableBagIterable&lt;V&gt;) target;</span>

<span class="nc" id="L221">            this.forEachWithOccurrences((each, occurrences) -&gt; targetBag.addOccurrences(function.valueOf(each), occurrences));</span>
<span class="nc" id="L222">        }</span>
        else
        {
<span class="nc" id="L225">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L226">                V value = function.valueOf(each);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">                for (int i = 0; i &lt; occurrences; i++)</span>
                {
<span class="nc" id="L229">                    target.add(value);</span>
                }
<span class="nc" id="L231">            });</span>
        }
<span class="nc" id="L233">        return target;</span>
    }

    @Override
    public &lt;P, V, R extends Collection&lt;V&gt;&gt; R collectWith(
            Function2&lt;? super T, ? super P, ? extends V&gt; function,
            P parameter,
            R target)
    {
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (target instanceof MutableBagIterable&lt;?&gt;)</span>
        {
<span class="nc" id="L244">            MutableBagIterable&lt;V&gt; targetBag = (MutableBagIterable&lt;V&gt;) target;</span>

<span class="nc" id="L246">            this.forEachWithOccurrences((each, occurrences) -&gt; targetBag.addOccurrences(function.value(each, parameter), occurrences));</span>
<span class="nc" id="L247">        }</span>
        else
        {
<span class="nc" id="L250">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L251">                V value = function.value(each, parameter);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">                for (int i = 0; i &lt; occurrences; i++)</span>
                {
<span class="nc" id="L254">                    target.add(value);</span>
                }
<span class="nc" id="L256">            });</span>
        }
<span class="nc" id="L258">        return target;</span>
    }

    @Override
    public &lt;V, R extends Collection&lt;V&gt;&gt; R collectIf(
            Predicate&lt;? super T&gt; predicate,
            Function&lt;? super T, ? extends V&gt; function,
            R target)
    {
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (target instanceof MutableBagIterable&lt;?&gt;)</span>
        {
<span class="nc" id="L269">            MutableBagIterable&lt;V&gt; targetBag = (MutableBagIterable&lt;V&gt;) target;</span>

<span class="nc" id="L271">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">                if (predicate.accept(each))</span>
                {
<span class="nc" id="L274">                    targetBag.addOccurrences(function.valueOf(each), occurrences);</span>
                }
<span class="nc" id="L276">            });</span>
<span class="nc" id="L277">        }</span>
        else
        {
<span class="nc" id="L280">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">                if (predicate.accept(each))</span>
                {
<span class="nc" id="L283">                    V value = function.valueOf(each);</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                    for (int i = 0; i &lt; occurrences; i++)</span>
                    {
<span class="nc" id="L286">                        target.add(value);</span>
                    }
                }
<span class="nc" id="L289">            });</span>
        }
<span class="nc" id="L291">        return target;</span>
    }

    @Override
    public &lt;V, R extends Collection&lt;V&gt;&gt; R flatCollect(Function&lt;? super T, ? extends Iterable&lt;V&gt;&gt; function, R target)
    {
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (target instanceof MutableBagIterable&lt;?&gt;)</span>
        {
<span class="nc" id="L299">            MutableBagIterable&lt;V&gt; targetBag = (MutableBagIterable&lt;V&gt;) target;</span>

<span class="nc" id="L301">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L302">                Iterable&lt;V&gt; values = function.valueOf(each);</span>
<span class="nc" id="L303">                Iterate.forEach(values, eachValue -&gt; targetBag.addOccurrences(eachValue, occurrences));</span>
<span class="nc" id="L304">            });</span>
<span class="nc" id="L305">        }</span>
        else
        {
<span class="nc" id="L308">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L309">                Iterable&lt;V&gt; values = function.valueOf(each);</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                for (int i = 0; i &lt; occurrences; i++)</span>
                {
<span class="nc" id="L312">                    Iterate.forEach(values, target::add);</span>
                }
<span class="nc" id="L314">            });</span>
        }
<span class="nc" id="L316">        return target;</span>
    }

    @Override
    public &lt;R extends MutableBooleanCollection&gt; R collectBoolean(BooleanFunction&lt;? super T&gt; booleanFunction, R target)
    {
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (target instanceof MutableBooleanBag)</span>
        {
<span class="nc" id="L324">            MutableBooleanBag targetBag = (MutableBooleanBag) target;</span>
<span class="nc" id="L325">            this.forEachWithOccurrences((each, occurrences) -&gt; targetBag.addOccurrences(booleanFunction.booleanValueOf(each), occurrences));</span>
<span class="nc" id="L326">        }</span>
        else
        {
<span class="nc" id="L329">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L330">                boolean value = booleanFunction.booleanValueOf(each);</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">                for (int i = 0; i &lt; occurrences; i++)</span>
                {
<span class="nc" id="L333">                    target.add(value);</span>
                }
<span class="nc" id="L335">            });</span>
        }
<span class="nc" id="L337">        return target;</span>
    }

    @Override
    public &lt;R extends MutableByteCollection&gt; R collectByte(ByteFunction&lt;? super T&gt; byteFunction, R target)
    {
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (target instanceof MutableByteBag)</span>
        {
<span class="nc" id="L345">            MutableByteBag targetBag = (MutableByteBag) target;</span>
<span class="nc" id="L346">            this.forEachWithOccurrences((each, occurrences) -&gt; targetBag.addOccurrences(byteFunction.byteValueOf(each), occurrences));</span>
<span class="nc" id="L347">        }</span>
        else
        {
<span class="nc" id="L350">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L351">                byte value = byteFunction.byteValueOf(each);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">                for (int i = 0; i &lt; occurrences; i++)</span>
                {
<span class="nc" id="L354">                    target.add(value);</span>
                }
<span class="nc" id="L356">            });</span>
        }
<span class="nc" id="L358">        return target;</span>
    }

    @Override
    public &lt;R extends MutableCharCollection&gt; R collectChar(CharFunction&lt;? super T&gt; charFunction, R target)
    {
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (target instanceof MutableCharBag)</span>
        {
<span class="nc" id="L366">            MutableCharBag targetBag = (MutableCharBag) target;</span>
<span class="nc" id="L367">            this.forEachWithOccurrences((each, occurrences) -&gt; targetBag.addOccurrences(charFunction.charValueOf(each), occurrences));</span>
<span class="nc" id="L368">        }</span>
        else
        {
<span class="nc" id="L371">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L372">                char value = charFunction.charValueOf(each);</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">                for (int i = 0; i &lt; occurrences; i++)</span>
                {
<span class="nc" id="L375">                    target.add(value);</span>
                }
<span class="nc" id="L377">            });</span>
        }
<span class="nc" id="L379">        return target;</span>
    }

    @Override
    public &lt;R extends MutableDoubleCollection&gt; R collectDouble(DoubleFunction&lt;? super T&gt; doubleFunction, R target)
    {
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (target instanceof MutableDoubleBag)</span>
        {
<span class="nc" id="L387">            MutableDoubleBag targetBag = (MutableDoubleBag) target;</span>
<span class="nc" id="L388">            this.forEachWithOccurrences((each, occurrences) -&gt; targetBag.addOccurrences(doubleFunction.doubleValueOf(each), occurrences));</span>
<span class="nc" id="L389">        }</span>
        else
        {
<span class="nc" id="L392">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L393">                double value = doubleFunction.doubleValueOf(each);</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">                for (int i = 0; i &lt; occurrences; i++)</span>
                {
<span class="nc" id="L396">                    target.add(value);</span>
                }
<span class="nc" id="L398">            });</span>
        }
<span class="nc" id="L400">        return target;</span>
    }

    @Override
    public &lt;R extends MutableFloatCollection&gt; R collectFloat(FloatFunction&lt;? super T&gt; floatFunction, R target)
    {
<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (target instanceof MutableFloatBag)</span>
        {
<span class="nc" id="L408">            MutableFloatBag targetBag = (MutableFloatBag) target;</span>
<span class="nc" id="L409">            this.forEachWithOccurrences((each, occurrences) -&gt; targetBag.addOccurrences(floatFunction.floatValueOf(each), occurrences));</span>
<span class="nc" id="L410">        }</span>
        else
        {
<span class="nc" id="L413">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L414">                float value = floatFunction.floatValueOf(each);</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                for (int i = 0; i &lt; occurrences; i++)</span>
                {
<span class="nc" id="L417">                    target.add(value);</span>
                }
<span class="nc" id="L419">            });</span>
        }
<span class="nc" id="L421">        return target;</span>
    }

    @Override
    public &lt;R extends MutableIntCollection&gt; R collectInt(IntFunction&lt;? super T&gt; intFunction, R target)
    {
<span class="nc bnc" id="L427" title="All 2 branches missed.">        if (target instanceof MutableIntBag)</span>
        {
<span class="nc" id="L429">            MutableIntBag targetBag = (MutableIntBag) target;</span>
<span class="nc" id="L430">            this.forEachWithOccurrences((each, occurrences) -&gt; targetBag.addOccurrences(intFunction.intValueOf(each), occurrences));</span>
<span class="nc" id="L431">        }</span>
        else
        {
<span class="nc" id="L434">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L435">                int value = intFunction.intValueOf(each);</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">                for (int i = 0; i &lt; occurrences; i++)</span>
                {
<span class="nc" id="L438">                    target.add(value);</span>
                }
<span class="nc" id="L440">            });</span>
        }
<span class="nc" id="L442">        return target;</span>
    }

    @Override
    public &lt;R extends MutableLongCollection&gt; R collectLong(LongFunction&lt;? super T&gt; longFunction, R target)
    {
<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (target instanceof MutableLongBag)</span>
        {
<span class="nc" id="L450">            MutableLongBag targetBag = (MutableLongBag) target;</span>
<span class="nc" id="L451">            this.forEachWithOccurrences((each, occurrences) -&gt; targetBag.addOccurrences(longFunction.longValueOf(each), occurrences));</span>
<span class="nc" id="L452">        }</span>
        else
        {
<span class="nc" id="L455">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L456">                long value = longFunction.longValueOf(each);</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                for (int i = 0; i &lt; occurrences; i++)</span>
                {
<span class="nc" id="L459">                    target.add(value);</span>
                }
<span class="nc" id="L461">            });</span>
        }
<span class="nc" id="L463">        return target;</span>
    }

    @Override
    public &lt;R extends MutableShortCollection&gt; R collectShort(ShortFunction&lt;? super T&gt; shortFunction, R target)
    {
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (target instanceof MutableShortBag)</span>
        {
<span class="nc" id="L471">            MutableShortBag targetBag = (MutableShortBag) target;</span>
<span class="nc" id="L472">            this.forEachWithOccurrences((each, occurrences) -&gt; targetBag.addOccurrences(shortFunction.shortValueOf(each), occurrences));</span>
<span class="nc" id="L473">        }</span>
        else
        {
<span class="nc" id="L476">            this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L477">                short value = shortFunction.shortValueOf(each);</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">                for (int i = 0; i &lt; occurrences; i++)</span>
                {
<span class="nc" id="L480">                    target.add(value);</span>
                }
<span class="nc" id="L482">            });</span>
        }
<span class="nc" id="L484">        return target;</span>
    }

    @Override
    public &lt;V, R extends MutableMultimap&lt;V, T&gt;&gt; R groupBy(
            Function&lt;? super T, ? extends V&gt; function,
            R target)
    {
<span class="nc" id="L492">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L493">            V value = function.valueOf(each);</span>
<span class="nc" id="L494">            target.putAll(value, Collections.nCopies(occurrences, each));</span>
<span class="nc" id="L495">        });</span>
<span class="nc" id="L496">        return target;</span>
    }

    @Override
    public &lt;V, R extends MutableMultimap&lt;V, T&gt;&gt; R groupByEach(
            Function&lt;? super T, ? extends Iterable&lt;V&gt;&gt; function,
            R target)
    {
<span class="nc" id="L504">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L505">            Iterable&lt;V&gt; values = function.valueOf(each);</span>
<span class="nc" id="L506">            Iterate.forEach(values, value -&gt; target.putAll(value, Collections.nCopies(occurrences, each)));</span>
<span class="nc" id="L507">        });</span>
<span class="nc" id="L508">        return target;</span>
    }

    @Override
    public long sumOfInt(IntFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L514">        long[] sum = {0L};</span>
<span class="nc" id="L515">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L516">            int intValue = function.intValueOf(each);</span>
<span class="nc" id="L517">            sum[0] += (long) intValue * (long) occurrences;</span>
<span class="nc" id="L518">        });</span>
<span class="nc" id="L519">        return sum[0];</span>
    }

    @Override
    public double sumOfFloat(FloatFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L525">        double[] sum = {0.0d};</span>
<span class="nc" id="L526">        double[] compensation = {0.0d};</span>
<span class="nc" id="L527">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L528">            float f = function.floatValueOf(each);</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">            for (int i = 0; i &lt; occurrences; i++)</span>
            {
<span class="nc" id="L531">                double adjustedValue = f - compensation[0];</span>
<span class="nc" id="L532">                double nextSum = sum[0] + adjustedValue;</span>
<span class="nc" id="L533">                compensation[0] = nextSum - sum[0] - adjustedValue;</span>
<span class="nc" id="L534">                sum[0] = nextSum;</span>
            }
<span class="nc" id="L536">        });</span>
<span class="nc" id="L537">        return sum[0];</span>
    }

    @Override
    public long sumOfLong(LongFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L543">        long[] sum = {0L};</span>
<span class="nc" id="L544">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L545">            long longValue = function.longValueOf(each);</span>
<span class="nc" id="L546">            sum[0] += longValue * (long) occurrences;</span>
<span class="nc" id="L547">        });</span>
<span class="nc" id="L548">        return sum[0];</span>
    }

    @Override
    public double sumOfDouble(DoubleFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L554">        double[] sum = {0.0d};</span>
<span class="nc" id="L555">        double[] compensation = {0.0d};</span>
<span class="nc" id="L556">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc" id="L557">            double d = function.doubleValueOf(each);</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">            for (int i = 0; i &lt; occurrences; i++)</span>
            {
<span class="nc" id="L560">                double y = d - compensation[0];</span>
<span class="nc" id="L561">                double t = sum[0] + y;</span>
<span class="nc" id="L562">                compensation[0] = t - sum[0] - y;</span>
<span class="nc" id="L563">                sum[0] = t;</span>
            }
<span class="nc" id="L565">        });</span>
<span class="nc" id="L566">        return sum[0];</span>
    }

    @Override
    public &lt;IV&gt; IV injectInto(IV injectedValue, Function2&lt;? super IV, ? super T, ? extends IV&gt; function)
    {
<span class="nc" id="L572">        IV[] result = (IV[]) new Object[]{injectedValue};</span>
<span class="nc" id="L573">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">            for (int i = 0; i &lt; occurrences; i++)</span>
            {
<span class="nc" id="L576">                result[0] = function.value(result[0], each);</span>
            }
<span class="nc" id="L578">        });</span>
<span class="nc" id="L579">        return result[0];</span>
    }

    @Override
    public int injectInto(int injectedValue, IntObjectToIntFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L585">        int[] result = {injectedValue};</span>
<span class="nc" id="L586">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">            for (int i = 0; i &lt; occurrences; i++)</span>
            {
<span class="nc" id="L589">                result[0] = function.intValueOf(result[0], each);</span>
            }
<span class="nc" id="L591">        });</span>
<span class="nc" id="L592">        return result[0];</span>
    }

    @Override
    public long injectInto(long injectedValue, LongObjectToLongFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L598">        long[] result = {injectedValue};</span>
<span class="nc" id="L599">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">            for (int i = 0; i &lt; occurrences; i++)</span>
            {
<span class="nc" id="L602">                result[0] = function.longValueOf(result[0], each);</span>
            }
<span class="nc" id="L604">        });</span>
<span class="nc" id="L605">        return result[0];</span>
    }

    @Override
    public double injectInto(double injectedValue, DoubleObjectToDoubleFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L611">        double[] result = {injectedValue};</span>
<span class="nc" id="L612">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">            for (int i = 0; i &lt; occurrences; i++)</span>
            {
<span class="nc" id="L615">                result[0] = function.doubleValueOf(result[0], each);</span>
            }
<span class="nc" id="L617">        });</span>
<span class="nc" id="L618">        return result[0];</span>
    }

    @Override
    public float injectInto(float injectedValue, FloatObjectToFloatFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L624">        float[] result = {injectedValue};</span>
<span class="nc" id="L625">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">            for (int i = 0; i &lt; occurrences; i++)</span>
            {
<span class="nc" id="L628">                result[0] = function.floatValueOf(result[0], each);</span>
            }
<span class="nc" id="L630">        });</span>
<span class="nc" id="L631">        return result[0];</span>
    }

    public &lt;IV, P&gt; IV injectIntoWith(IV injectedValue, Function3&lt;? super IV, ? super T, ? super P, ? extends IV&gt; function, P parameter)
    {
<span class="nc" id="L636">        IV[] result = (IV[]) new Object[]{injectedValue};</span>
<span class="nc" id="L637">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">            for (int i = 0; i &lt; occurrences; i++)</span>
            {
<span class="nc" id="L640">                result[0] = function.value(result[0], each, parameter);</span>
            }
<span class="nc" id="L642">        });</span>
<span class="nc" id="L643">        return result[0];</span>
    }

    @Override
    public String toStringOfItemToCount()
    {
<span class="nc" id="L649">        StringJoiner joiner = new StringJoiner(&quot;, &quot;, &quot;{&quot;, &quot;}&quot;);</span>
<span class="nc" id="L650">        this.forEachWithOccurrences((each, occurrences) -&gt; joiner.add(each + &quot;=&quot; + occurrences));</span>
<span class="nc" id="L651">        return joiner.toString();</span>
    }

    protected MutableList&lt;ObjectIntPair&lt;T&gt;&gt; toListWithOccurrences()
    {
<span class="nc" id="L656">        MutableList&lt;ObjectIntPair&lt;T&gt;&gt; result = FastList.newList(this.sizeDistinct());</span>
<span class="nc" id="L657">        this.forEachWithOccurrences((each, count) -&gt; result.add(PrimitiveTuples.pair(each, count)));</span>
<span class="nc" id="L658">        return result;</span>
    }

    @Override
    public MutableList&lt;T&gt; toList()
    {
<span class="nc" id="L664">        MutableList&lt;T&gt; result = FastList.newList(this.size());</span>
<span class="nc" id="L665">        this.forEachWithOccurrences((each, occurrences) -&gt; {</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">            for (int i = 0; i &lt; occurrences; i++)</span>
            {
<span class="nc" id="L668">                result.add(each);</span>
            }
<span class="nc" id="L670">        });</span>
<span class="nc" id="L671">        return result;</span>
    }

    @Override
    public MutableList&lt;T&gt; toSortedList(Comparator&lt;? super T&gt; comparator)
    {
<span class="nc" id="L677">        MutableList&lt;ObjectIntPair&lt;T&gt;&gt; sorted = this.toListWithOccurrences().sortThis((o1, o2) -&gt; comparator.compare(o1.getOne(), o2.getOne()));</span>

<span class="nc" id="L679">        MutableList&lt;T&gt; result = FastList.newList(this.size());</span>
<span class="nc" id="L680">        sorted.each(each -&gt; {</span>
<span class="nc" id="L681">            T object = each.getOne();</span>
<span class="nc" id="L682">            int occurrences = each.getTwo();</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">            for (int i = 0; i &lt; occurrences; i++)</span>
            {
<span class="nc" id="L685">                result.add(object);</span>
            }
<span class="nc" id="L687">        });</span>
<span class="nc" id="L688">        return result;</span>
    }

    @Override
    public MutableSet&lt;T&gt; toSet()
    {
<span class="nc" id="L694">        MutableSet&lt;T&gt; result = UnifiedSet.newSet(this.sizeDistinct());</span>
<span class="nc" id="L695">        this.forEachWithOccurrences((each, occurrences) -&gt; result.add(each));</span>
<span class="nc" id="L696">        return result;</span>
    }

    @Override
    public MutableSortedSet&lt;T&gt; toSortedSet()
    {
<span class="nc" id="L702">        MutableSortedSet&lt;T&gt; result = SortedSets.mutable.empty();</span>
<span class="nc" id="L703">        this.forEachWithOccurrences((each, occurrences) -&gt; result.add(each));</span>
<span class="nc" id="L704">        return result;</span>
    }

    @Override
    public MutableSortedSet&lt;T&gt; toSortedSet(Comparator&lt;? super T&gt; comparator)
    {
<span class="nc" id="L710">        MutableSortedSet&lt;T&gt; result = SortedSets.mutable.with(comparator);</span>
<span class="nc" id="L711">        this.forEachWithOccurrences((each, occurrences) -&gt; result.add(each));</span>
<span class="nc" id="L712">        return result;</span>
    }

    @Override
    public MutableBag&lt;T&gt; toBag()
    {
<span class="nc" id="L718">        MutableBag&lt;T&gt; result = HashBag.newBag(this.sizeDistinct());</span>
<span class="nc" id="L719">        this.forEachWithOccurrences(result::addOccurrences);</span>
<span class="nc" id="L720">        return result;</span>
    }

    @Override
    public MutableSortedBag&lt;T&gt; toSortedBag()
    {
<span class="nc" id="L726">        MutableSortedBag&lt;T&gt; result = TreeBag.newBag();</span>
<span class="nc" id="L727">        this.forEachWithOccurrences(result::addOccurrences);</span>
<span class="nc" id="L728">        return result;</span>
    }

    @Override
    public MutableSortedBag&lt;T&gt; toSortedBag(Comparator&lt;? super T&gt; comparator)
    {
<span class="nc" id="L734">        MutableSortedBag&lt;T&gt; result = TreeBag.newBag(comparator);</span>
<span class="nc" id="L735">        this.forEachWithOccurrences(result::addOccurrences);</span>
<span class="nc" id="L736">        return result;</span>
    }

    protected MutableList&lt;ObjectIntPair&lt;T&gt;&gt; occurrencesSortingBy(int n, IntFunction&lt;ObjectIntPair&lt;T&gt;&gt; function, MutableList&lt;ObjectIntPair&lt;T&gt;&gt; returnWhenEmpty)
    {
<span class="nc bnc" id="L741" title="All 2 branches missed.">        if (n &lt; 0)</span>
        {
<span class="nc" id="L743">            throw new IllegalArgumentException(&quot;Cannot use a value of n &lt; 0&quot;);</span>
        }
<span class="nc bnc" id="L745" title="All 2 branches missed.">        if (n == 0)</span>
        {
<span class="nc" id="L747">            return returnWhenEmpty;</span>
        }
<span class="nc" id="L749">        int keySize = Math.min(n, this.sizeDistinct());</span>
<span class="nc" id="L750">        MutableList&lt;ObjectIntPair&lt;T&gt;&gt; sorted = this.toListWithOccurrences().sortThisByInt(function);</span>
<span class="nc" id="L751">        MutableList&lt;ObjectIntPair&lt;T&gt;&gt; results = sorted.subList(0, keySize).toList();</span>
<span class="nc bnc" id="L752" title="All 4 branches missed.">        while (keySize &lt; sorted.size() &amp;&amp; results.getLast().getTwo() == sorted.get(keySize).getTwo())</span>
        {
<span class="nc" id="L754">            results.add(sorted.get(keySize));</span>
<span class="nc" id="L755">            keySize++;</span>
        }
<span class="nc" id="L757">        return results;</span>
    }

    @Override
    public SetIterable&lt;T&gt; selectUnique()
    {
<span class="nc" id="L763">        MutableSet&lt;T&gt; result = Sets.mutable.empty();</span>
<span class="nc" id="L764">        this.forEachWithOccurrences((each, occurrences) -&gt;</span>
            {
<span class="nc bnc" id="L766" title="All 2 branches missed.">                if (occurrences == 1)</span>
                {
<span class="nc" id="L768">                    result.add(each);</span>
                }
<span class="nc" id="L770">            });</span>
<span class="nc" id="L771">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>