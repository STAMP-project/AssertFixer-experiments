<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ByteObjectHashMap.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.impl.map.mutable.primitive</a> &gt; <span class="el_source">ByteObjectHashMap.java</span></div><h1>ByteObjectHashMap.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2018 Goldman Sachs and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.impl.map.mutable.primitive;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Optional;

import org.eclipse.collections.api.ByteIterable;
import org.eclipse.collections.api.LazyByteIterable;
import org.eclipse.collections.api.LazyIterable;
import org.eclipse.collections.api.RichIterable;
import org.eclipse.collections.api.bag.MutableBag;
import org.eclipse.collections.api.bag.primitive.MutableBooleanBag;
import org.eclipse.collections.api.bag.primitive.MutableByteBag;
import org.eclipse.collections.api.bag.primitive.MutableCharBag;
import org.eclipse.collections.api.bag.primitive.MutableDoubleBag;
import org.eclipse.collections.api.bag.primitive.MutableFloatBag;
import org.eclipse.collections.api.bag.primitive.MutableIntBag;
import org.eclipse.collections.api.bag.primitive.MutableLongBag;
import org.eclipse.collections.api.bag.primitive.MutableShortBag;
import org.eclipse.collections.api.bag.sorted.MutableSortedBag;
import org.eclipse.collections.api.block.function.Function;
import org.eclipse.collections.api.block.function.Function0;
import org.eclipse.collections.api.block.function.Function2;
import org.eclipse.collections.api.block.function.primitive.ByteToObjectFunction;
import org.eclipse.collections.api.block.function.primitive.ObjectByteToObjectFunction;
import org.eclipse.collections.api.block.function.primitive.BooleanFunction;
import org.eclipse.collections.api.block.function.primitive.ByteFunction;
import org.eclipse.collections.api.block.function.primitive.CharFunction;
import org.eclipse.collections.api.block.function.primitive.DoubleFunction;
import org.eclipse.collections.api.block.function.primitive.DoubleObjectToDoubleFunction;
import org.eclipse.collections.api.block.function.primitive.FloatFunction;
import org.eclipse.collections.api.block.function.primitive.FloatObjectToFloatFunction;
import org.eclipse.collections.api.block.function.primitive.IntFunction;
import org.eclipse.collections.api.block.function.primitive.IntObjectToIntFunction;
import org.eclipse.collections.api.block.function.primitive.LongFunction;
import org.eclipse.collections.api.block.function.primitive.LongObjectToLongFunction;
import org.eclipse.collections.api.block.function.primitive.ShortFunction;
import org.eclipse.collections.api.block.predicate.Predicate;
import org.eclipse.collections.api.block.predicate.Predicate2;
import org.eclipse.collections.api.block.predicate.primitive.ByteObjectPredicate;
import org.eclipse.collections.api.block.predicate.primitive.BytePredicate;
import org.eclipse.collections.api.block.procedure.Procedure;
import org.eclipse.collections.api.block.procedure.Procedure2;
import org.eclipse.collections.api.block.procedure.primitive.ByteObjectProcedure;
import org.eclipse.collections.api.block.procedure.primitive.ByteProcedure;
import org.eclipse.collections.api.block.procedure.primitive.ObjectIntProcedure;
import org.eclipse.collections.api.collection.primitive.MutableBooleanCollection;
import org.eclipse.collections.api.collection.primitive.MutableByteCollection;
import org.eclipse.collections.api.collection.primitive.MutableCharCollection;
import org.eclipse.collections.api.collection.primitive.MutableDoubleCollection;
import org.eclipse.collections.api.collection.primitive.MutableFloatCollection;
import org.eclipse.collections.api.collection.primitive.MutableIntCollection;
import org.eclipse.collections.api.collection.primitive.MutableLongCollection;
import org.eclipse.collections.api.collection.primitive.MutableShortCollection;
import org.eclipse.collections.api.iterator.ByteIterator;
import org.eclipse.collections.api.iterator.MutableByteIterator;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.api.list.primitive.MutableByteList;
import org.eclipse.collections.api.map.MutableMap;
import org.eclipse.collections.api.map.primitive.ByteObjectMap;
import org.eclipse.collections.api.map.primitive.ImmutableByteObjectMap;
import org.eclipse.collections.api.map.primitive.MutableObjectDoubleMap;
import org.eclipse.collections.api.map.primitive.MutableObjectLongMap;
import org.eclipse.collections.api.map.primitive.MutableByteObjectMap;
import org.eclipse.collections.api.map.primitive.MutableObjectByteMap;
import org.eclipse.collections.api.map.sorted.MutableSortedMap;
import org.eclipse.collections.api.multimap.MutableMultimap;
import org.eclipse.collections.api.multimap.bag.MutableBagMultimap;
import org.eclipse.collections.api.partition.bag.PartitionMutableBag;
import org.eclipse.collections.api.set.MutableSet;
import org.eclipse.collections.api.set.primitive.ImmutableByteSet;
import org.eclipse.collections.api.set.primitive.ByteSet;
import org.eclipse.collections.api.set.primitive.MutableByteSet;
import org.eclipse.collections.api.set.sorted.MutableSortedSet;
import org.eclipse.collections.api.tuple.Pair;
import org.eclipse.collections.api.tuple.primitive.ByteObjectPair;
import org.eclipse.collections.impl.bag.mutable.HashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.BooleanHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.ByteHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.CharHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.DoubleHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.FloatHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.IntHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.LongHashBag;
import org.eclipse.collections.impl.bag.mutable.primitive.ShortHashBag;
import org.eclipse.collections.impl.bag.sorted.mutable.TreeBag;
import org.eclipse.collections.impl.block.factory.Comparators;
import org.eclipse.collections.impl.block.factory.Functions;
import org.eclipse.collections.impl.block.factory.Functions0;
import org.eclipse.collections.impl.block.factory.Predicates;
import org.eclipse.collections.impl.block.factory.PrimitiveFunctions;
import org.eclipse.collections.impl.block.factory.Procedures2;
import org.eclipse.collections.impl.block.procedure.MapCollectProcedure;
import org.eclipse.collections.impl.block.procedure.MutatingAggregationProcedure;
import org.eclipse.collections.impl.block.procedure.NonMutatingAggregationProcedure;
import org.eclipse.collections.impl.block.procedure.PartitionProcedure;
import org.eclipse.collections.impl.block.procedure.SelectInstancesOfProcedure;
import org.eclipse.collections.impl.block.procedure.primitive.CollectBooleanProcedure;
import org.eclipse.collections.impl.block.procedure.primitive.CollectByteProcedure;
import org.eclipse.collections.impl.block.procedure.primitive.CollectCharProcedure;
import org.eclipse.collections.impl.block.procedure.primitive.CollectDoubleProcedure;
import org.eclipse.collections.impl.block.procedure.primitive.CollectFloatProcedure;
import org.eclipse.collections.impl.block.procedure.primitive.CollectIntProcedure;
import org.eclipse.collections.impl.block.procedure.primitive.CollectLongProcedure;
import org.eclipse.collections.impl.block.procedure.primitive.CollectShortProcedure;
import org.eclipse.collections.impl.factory.Bags;
import org.eclipse.collections.impl.factory.Lists;
import org.eclipse.collections.impl.factory.Sets;
import org.eclipse.collections.impl.factory.primitive.ByteSets;
import org.eclipse.collections.impl.factory.primitive.ByteObjectMaps;
import org.eclipse.collections.impl.factory.primitive.ObjectByteMaps;
import org.eclipse.collections.impl.factory.primitive.ObjectDoubleMaps;
import org.eclipse.collections.impl.factory.primitive.ObjectLongMaps;
import org.eclipse.collections.impl.iterator.UnmodifiableByteIterator;
import org.eclipse.collections.impl.lazy.AbstractLazyIterable;
import org.eclipse.collections.impl.lazy.primitive.AbstractLazyByteIterable;
import org.eclipse.collections.impl.lazy.primitive.LazyByteIterableAdapter;
import org.eclipse.collections.impl.list.mutable.FastList;
import org.eclipse.collections.impl.list.mutable.primitive.ByteArrayList;
import org.eclipse.collections.impl.map.mutable.UnifiedMap;
import org.eclipse.collections.impl.map.sorted.mutable.TreeSortedMap;
import org.eclipse.collections.impl.multimap.bag.HashBagMultimap;
import org.eclipse.collections.impl.partition.bag.PartitionHashBag;
import org.eclipse.collections.impl.set.mutable.UnifiedSet;
import org.eclipse.collections.impl.set.mutable.primitive.ByteHashSet;
import org.eclipse.collections.impl.set.mutable.primitive.SynchronizedByteSet;
import org.eclipse.collections.impl.set.mutable.primitive.UnmodifiableByteSet;
import org.eclipse.collections.impl.set.sorted.mutable.TreeSortedSet;
import org.eclipse.collections.impl.tuple.primitive.PrimitiveTuples;
import org.eclipse.collections.impl.utility.Iterate;
import org.eclipse.collections.impl.utility.LazyIterate;
import org.eclipse.collections.impl.utility.internal.IterableIterate;

/**
 * This file was automatically generated from template file primitiveObjectHashMap.stg.
 *
 * @since 3.0.
 */
public class ByteObjectHashMap&lt;V&gt; implements MutableByteObjectMap&lt;V&gt;, Externalizable
{
    private static final long serialVersionUID = 1L;
    private static final int DEFAULT_INITIAL_CAPACITY = 8;
    private static final byte EMPTY_KEY = (byte) 0;
    private static final byte REMOVED_KEY = (byte) 1;
    private static final int OCCUPIED_DATA_RATIO = 2;
    private static final int OCCUPIED_SENTINEL_RATIO = 4;
    private static final int CACHE_LINE_SIZE = 64;
    private static final int KEY_SIZE = 1;
    private static final int INITIAL_LINEAR_PROBE = CACHE_LINE_SIZE / KEY_SIZE / 2; /* half a cache line */

    private byte[] keys;
    private V[] values;
    private int occupiedWithData;
    private int occupiedWithSentinels;

    private SentinelValues&lt;V&gt; sentinelValues;

<span class="nc" id="L176">    private boolean copyKeysOnWrite = false;</span>

    public ByteObjectHashMap()
<span class="nc" id="L179">    {</span>
<span class="nc" id="L180">        this.allocateTable(DEFAULT_INITIAL_CAPACITY &lt;&lt; 1);</span>
<span class="nc" id="L181">    }</span>

    public ByteObjectHashMap(int initialCapacity)
<span class="nc" id="L184">    {</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (initialCapacity &lt; 0)</span>
        {
<span class="nc" id="L187">            throw new IllegalArgumentException(&quot;initial capacity cannot be less than 0&quot;);</span>
        }
<span class="nc" id="L189">        int capacity = this.smallestPowerOfTwoGreaterThan(this.fastCeil(initialCapacity * OCCUPIED_DATA_RATIO));</span>
<span class="nc" id="L190">        this.allocateTable(capacity);</span>
<span class="nc" id="L191">    }</span>

    public ByteObjectHashMap(ByteObjectMap&lt;? extends V&gt; map)
    {
<span class="nc" id="L195">        this(Math.max(map.size(), DEFAULT_INITIAL_CAPACITY));</span>
<span class="nc" id="L196">        this.putAll(map);</span>
<span class="nc" id="L197">    }</span>

    private int smallestPowerOfTwoGreaterThan(int n)
    {
<span class="nc bnc" id="L201" title="All 2 branches missed.">        return n &gt; 1 ? Integer.highestOneBit(n - 1) &lt;&lt; 1 : 1;</span>
    }

    private int fastCeil(float v)
    {
<span class="nc" id="L206">        int possibleResult = (int) v;</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (v - possibleResult &gt; 0.0F)</span>
        {
<span class="nc" id="L209">            possibleResult++;</span>
        }
<span class="nc" id="L211">        return possibleResult;</span>
    }

    public static &lt;V&gt; ByteObjectHashMap&lt;V&gt; newMap()
    {
<span class="nc" id="L216">        return new ByteObjectHashMap&lt;&gt;();</span>
    }

    public static &lt;V&gt; ByteObjectHashMap&lt;V&gt; newMap(ByteObjectMap&lt;? extends V&gt; map)
    {
<span class="nc" id="L221">        return new ByteObjectHashMap&lt;&gt;(map);</span>
    }

    public static &lt;V&gt; ByteObjectHashMap&lt;V&gt; newWithKeysValues(byte key, V value)
    {
<span class="nc" id="L226">        return new ByteObjectHashMap&lt;V&gt;(1).withKeyValue(key, value);</span>
    }

    public static &lt;V&gt; ByteObjectHashMap&lt;V&gt; newWithKeysValues(byte key1, V value1, byte key2, V value2)
    {
<span class="nc" id="L231">        return new ByteObjectHashMap&lt;V&gt;(2).withKeysValues(key1, value1, key2, value2);</span>
    }

    public static &lt;V&gt; ByteObjectHashMap&lt;V&gt; newWithKeysValues(byte key1, V value1, byte key2, V value2, byte key3, V value3)
    {
<span class="nc" id="L236">        return new ByteObjectHashMap&lt;V&gt;(3).withKeysValues(key1, value1, key2, value2, key3, value3);</span>
    }

    @Override
    public boolean equals(Object obj)
    {
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (this == obj)</span>
        {
<span class="nc" id="L244">            return true;</span>
        }

<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (!(obj instanceof ByteObjectMap))</span>
        {
<span class="nc" id="L249">            return false;</span>
        }

<span class="nc" id="L252">        ByteObjectMap&lt;V&gt; other = (ByteObjectMap&lt;V&gt;) obj;</span>

<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (this.size() != other.size())</span>
        {
<span class="nc" id="L256">            return false;</span>
        }

<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (this.sentinelValues == null)</span>
        {
<span class="nc bnc" id="L261" title="All 4 branches missed.">            if (other.containsKey(EMPTY_KEY) || other.containsKey(REMOVED_KEY))</span>
            {
<span class="nc" id="L263">                return false;</span>
            }
        }
        else
        {
<span class="nc bnc" id="L268" title="All 6 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; (!other.containsKey(EMPTY_KEY) || !nullSafeEquals(this.sentinelValues.zeroValue, other.get(EMPTY_KEY))))</span>
            {
<span class="nc" id="L270">                return false;</span>
            }

<span class="nc bnc" id="L273" title="All 6 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; (!other.containsKey(REMOVED_KEY) || !nullSafeEquals(this.sentinelValues.oneValue, other.get(REMOVED_KEY))))</span>
            {
<span class="nc" id="L275">                return false;</span>
            }
        }

<span class="nc bnc" id="L279" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc" id="L281">            byte key = this.keys[i];</span>
<span class="nc bnc" id="L282" title="All 6 branches missed.">            if (isNonSentinel(key) &amp;&amp; (!other.containsKey(key) || !nullSafeEquals(this.values[i], other.get(key))))</span>
            {
<span class="nc" id="L284">                return false;</span>
            }
        }
<span class="nc" id="L287">        return true;</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L293">        int result = 0;</span>

<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L297" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc bnc" id="L299" title="All 2 branches missed.">                result += (int) EMPTY_KEY ^ (this.sentinelValues.zeroValue == null ? 0 : this.sentinelValues.zeroValue.hashCode());</span>
            }

<span class="nc bnc" id="L302" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc bnc" id="L304" title="All 2 branches missed.">                result += (int) REMOVED_KEY ^ (this.sentinelValues.oneValue == null ? 0 : this.sentinelValues.oneValue.hashCode());</span>
            }
        }

<span class="nc bnc" id="L308" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L310" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc bnc" id="L312" title="All 2 branches missed.">                result += (int) this.keys[i] ^ (this.values[i] == null ? 0 : this.values[i].hashCode());</span>
            }
        }
<span class="nc" id="L315">        return result;</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L321">        StringBuilder appendable = new StringBuilder();</span>

<span class="nc" id="L323">        appendable.append(&quot;{&quot;);</span>

<span class="nc" id="L325">        boolean first = true;</span>

<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L329" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L331">                appendable.append(EMPTY_KEY).append(&quot;=&quot;).append(this.sentinelValues.zeroValue);</span>
<span class="nc" id="L332">                first = false;</span>
            }
<span class="nc bnc" id="L334" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc bnc" id="L336" title="All 2 branches missed.">                if (!first)</span>
                {
<span class="nc" id="L338">                    appendable.append(&quot;, &quot;);</span>
                }
<span class="nc" id="L340">                appendable.append(REMOVED_KEY).append(&quot;=&quot;).append(this.sentinelValues.oneValue);</span>
<span class="nc" id="L341">                first = false;</span>
            }
        }
<span class="nc bnc" id="L344" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc" id="L346">            byte key = this.keys[i];</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            if (isNonSentinel(key))</span>
            {
<span class="nc bnc" id="L349" title="All 2 branches missed.">                if (!first)</span>
                {
<span class="nc" id="L351">                    appendable.append(&quot;, &quot;);</span>
                }
<span class="nc" id="L353">                appendable.append(key).append(&quot;=&quot;).append(this.values[i]);</span>
<span class="nc" id="L354">                first = false;</span>
            }
        }
<span class="nc" id="L357">        appendable.append(&quot;}&quot;);</span>

<span class="nc" id="L359">        return appendable.toString();</span>
    }

    @Override
    public int size()
    {
<span class="nc bnc" id="L365" title="All 2 branches missed.">        return this.occupiedWithData + (this.sentinelValues == null ? 0 : this.sentinelValues.size());</span>
    }

    @Override
    public boolean isEmpty()
    {
<span class="nc bnc" id="L371" title="All 6 branches missed.">        return this.occupiedWithData == 0 &amp;&amp; (this.sentinelValues == null || this.sentinelValues.size() == 0);</span>
    }

    @Override
    public boolean notEmpty()
    {
<span class="nc bnc" id="L377" title="All 6 branches missed.">        return this.occupiedWithData != 0 || (this.sentinelValues != null &amp;&amp; this.sentinelValues.size() != 0);</span>
    }

    @Override
    public String makeString()
    {
<span class="nc" id="L383">        return this.makeString(&quot;, &quot;);</span>
    }

    @Override
    public String makeString(String separator)
    {
<span class="nc" id="L389">        return this.makeString(&quot;&quot;, separator, &quot;&quot;);</span>
    }

    @Override
    public String makeString(String start, String separator, String end)
    {
<span class="nc" id="L395">        Appendable stringBuilder = new StringBuilder();</span>
<span class="nc" id="L396">        this.appendString(stringBuilder, start, separator, end);</span>
<span class="nc" id="L397">        return stringBuilder.toString();</span>
    }

    @Override
    public void appendString(Appendable appendable)
    {
<span class="nc" id="L403">        this.appendString(appendable, &quot;, &quot;);</span>
<span class="nc" id="L404">    }</span>

    @Override
    public void appendString(Appendable appendable, String separator)
    {
<span class="nc" id="L409">        this.appendString(appendable, &quot;&quot;, separator, &quot;&quot;);</span>
<span class="nc" id="L410">    }</span>

    @Override
    public void appendString(Appendable appendable, String start, String separator, String end)
    {
        try
        {
<span class="nc" id="L417">            appendable.append(start);</span>

<span class="nc" id="L419">            boolean first = true;</span>

<span class="nc bnc" id="L421" title="All 2 branches missed.">            if (this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L423" title="All 2 branches missed.">                if (this.sentinelValues.containsZeroKey)</span>
                {
<span class="nc" id="L425">                    appendable.append(String.valueOf(this.sentinelValues.zeroValue));</span>
<span class="nc" id="L426">                    first = false;</span>
                }
<span class="nc bnc" id="L428" title="All 2 branches missed.">                if (this.sentinelValues.containsOneKey)</span>
                {
<span class="nc bnc" id="L430" title="All 2 branches missed.">                    if (!first)</span>
                    {
<span class="nc" id="L432">                        appendable.append(separator);</span>
                    }
<span class="nc" id="L434">                    appendable.append(String.valueOf(this.sentinelValues.oneValue));</span>
<span class="nc" id="L435">                    first = false;</span>
                }
            }
<span class="nc bnc" id="L438" title="All 2 branches missed.">            for (int i = 0; i &lt; this.keys.length; i++)</span>
            {
<span class="nc" id="L440">                byte key = this.keys[i];</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">                if (isNonSentinel(key))</span>
                {
<span class="nc bnc" id="L443" title="All 2 branches missed.">                    if (!first)</span>
                    {
<span class="nc" id="L445">                        appendable.append(separator);</span>
                    }
<span class="nc" id="L447">                    appendable.append(String.valueOf(this.values[i]));</span>
<span class="nc" id="L448">                    first = false;</span>
                }
            }
<span class="nc" id="L451">            appendable.append(end);</span>
        }
<span class="nc" id="L453">        catch (IOException e)</span>
        {
<span class="nc" id="L455">            throw new RuntimeException(e);</span>
<span class="nc" id="L456">        }</span>
<span class="nc" id="L457">    }</span>

    @Override
    public Iterator&lt;V&gt; iterator()
    {
<span class="nc" id="L462">        return new InternalIterator();</span>
    }

    @Override
    public Object[] toArray()
    {
<span class="nc" id="L468">        Object[] result = new Object[this.size()];</span>
<span class="nc" id="L469">        int index = 0;</span>

<span class="nc bnc" id="L471" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L473" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L475">                result[index++] = this.sentinelValues.zeroValue;</span>
            }
<span class="nc bnc" id="L477" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L479">                result[index++] = this.sentinelValues.oneValue;</span>
            }
        }
<span class="nc bnc" id="L482" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L484" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L486">                result[index++] = this.values[i];</span>
            }
        }
<span class="nc" id="L489">        return result;</span>
    }

    @Override
    public &lt;T&gt; T[] toArray(T[] a)
    {
<span class="nc" id="L495">        int size = this.size();</span>

<span class="nc bnc" id="L497" title="All 2 branches missed.">        final T[] result = a.length &lt; size</span>
<span class="nc" id="L498">                ? (T[]) Array.newInstance(a.getClass().getComponentType(), size)</span>
                : a;

<span class="nc" id="L501">        this.forEachWithIndex((Object each, int index) -&gt; result[index] = (T) each);</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        if (result.length &gt; size)</span>
        {
<span class="nc" id="L504">            result[size] = null;</span>
        }
<span class="nc" id="L506">        return result;</span>
    }

    @Override
    public boolean contains(Object object)
    {
<span class="nc" id="L512">        return this.containsValue(object);</span>
    }

    @Override
    public boolean containsAllIterable(Iterable&lt;?&gt; source)
    {
<span class="nc bnc" id="L518" title="All 2 branches missed.">        for (Object item : source)</span>
        {
<span class="nc bnc" id="L520" title="All 2 branches missed.">            if (!this.contains(item))</span>
            {
<span class="nc" id="L522">                return false;</span>
            }
<span class="nc" id="L524">        }</span>
<span class="nc" id="L525">        return true;</span>
    }

    @Override
    public boolean containsAll(Collection&lt;?&gt; source)
    {
<span class="nc" id="L531">        return this.containsAllIterable(source);</span>
    }

    @Override
    public boolean containsAllArguments(Object... elements)
    {
<span class="nc bnc" id="L537" title="All 2 branches missed.">        for (Object item : elements)</span>
        {
<span class="nc bnc" id="L539" title="All 2 branches missed.">            if (!this.contains(item))</span>
            {
<span class="nc" id="L541">                return false;</span>
            }
        }
<span class="nc" id="L544">        return true;</span>
    }

    @Override
    public ByteObjectHashMap&lt;V&gt; tap(Procedure&lt;? super V&gt; procedure)
    {
<span class="nc" id="L550">        this.forEachValue(procedure);</span>
<span class="nc" id="L551">        return this;</span>
    }

    @Override
    public void forEach(Procedure&lt;? super V&gt; procedure)
    {
<span class="nc" id="L557">        this.each(procedure);</span>
<span class="nc" id="L558">    }</span>

    @Override
    public void each(Procedure&lt;? super V&gt; procedure)
    {
<span class="nc" id="L563">        this.forEachValue(procedure);</span>
<span class="nc" id="L564">    }</span>

    @Override
    public void forEachWithIndex(ObjectIntProcedure&lt;? super V&gt; objectIntProcedure)
    {
<span class="nc" id="L569">        int index = 0;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L572" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L574">                objectIntProcedure.value(this.sentinelValues.zeroValue, index++);</span>
            }
<span class="nc bnc" id="L576" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L578">                objectIntProcedure.value(this.sentinelValues.oneValue, index++);</span>
            }
        }
<span class="nc bnc" id="L581" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L583" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L585">                objectIntProcedure.value(this.values[i], index++);</span>
            }
        }
<span class="nc" id="L588">    }</span>

    @Override
    public &lt;P&gt; void forEachWith(Procedure2&lt;? super V, ? super P&gt; procedure, P parameter)
    {
<span class="nc bnc" id="L593" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L595" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L597">                procedure.value(this.sentinelValues.zeroValue, parameter);</span>
            }
<span class="nc bnc" id="L599" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L601">                procedure.value(this.sentinelValues.oneValue, parameter);</span>
            }
        }
<span class="nc bnc" id="L604" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L606" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L608">                procedure.value(this.values[i], parameter);</span>
            }
        }
<span class="nc" id="L611">    }</span>

    @Override
    public void forEachValue(Procedure&lt;? super V&gt; procedure)
    {
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L618" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L620">                procedure.value(this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L622" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L624">                procedure.value(this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L627" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L629" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L631">                procedure.value(this.values[i]);</span>
            }
        }
<span class="nc" id="L634">    }</span>

    @Override
    public void forEachKey(ByteProcedure procedure)
    {
<span class="nc bnc" id="L639" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L641" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L643">                procedure.value(EMPTY_KEY);</span>
            }
<span class="nc bnc" id="L645" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L647">                procedure.value(REMOVED_KEY);</span>
            }
        }
<span class="nc bnc" id="L650" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L652" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L654">                procedure.value(this.keys[i]);</span>
            }
        }
<span class="nc" id="L657">    }</span>

    @Override
    public void forEachKeyValue(ByteObjectProcedure&lt;? super V&gt; procedure)
    {
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L664" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L666">                procedure.value(EMPTY_KEY, this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L668" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L670">                procedure.value(REMOVED_KEY, this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L673" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L675" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L677">                procedure.value(this.keys[i], this.values[i]);</span>
            }
        }
<span class="nc" id="L680">    }</span>

    @Override
    public ByteObjectHashMap&lt;V&gt; select(ByteObjectPredicate&lt;? super V&gt; predicate)
    {
<span class="nc" id="L685">        ByteObjectHashMap&lt;V&gt; result = ByteObjectHashMap.newMap();</span>

<span class="nc bnc" id="L687" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L689" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(EMPTY_KEY, this.sentinelValues.zeroValue))</span>
            {
<span class="nc" id="L691">                result.put(EMPTY_KEY, this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L693" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(REMOVED_KEY, this.sentinelValues.oneValue))</span>
            {
<span class="nc" id="L695">                result.put(REMOVED_KEY, this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L698" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L700" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.keys[i], this.values[i]))</span>
            {
<span class="nc" id="L702">                result.put(this.keys[i], this.values[i]);</span>
            }
        }
<span class="nc" id="L705">        return result;</span>
    }

    @Override
    public ByteObjectHashMap&lt;V&gt; reject(ByteObjectPredicate&lt;? super V&gt; predicate)
    {
<span class="nc" id="L711">        ByteObjectHashMap&lt;V&gt; result = ByteObjectHashMap.newMap();</span>

<span class="nc bnc" id="L713" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L715" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; !predicate.accept(EMPTY_KEY, this.sentinelValues.zeroValue))</span>
            {
<span class="nc" id="L717">                result.put(EMPTY_KEY, this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L719" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; !predicate.accept(REMOVED_KEY, this.sentinelValues.oneValue))</span>
            {
<span class="nc" id="L721">                result.put(REMOVED_KEY, this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L724" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L726" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; !predicate.accept(this.keys[i], this.values[i]))</span>
            {
<span class="nc" id="L728">                result.put(this.keys[i], this.values[i]);</span>
            }
        }
<span class="nc" id="L731">        return result;</span>
    }

    @Override
    public MutableBag&lt;V&gt; select(Predicate&lt;? super V&gt; predicate)
    {
<span class="nc" id="L737">        MutableBag&lt;V&gt; result = new HashBag&lt;&gt;();</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L740" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(this.sentinelValues.zeroValue))</span>
            {
<span class="nc" id="L742">                result.add(this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L744" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(this.sentinelValues.oneValue))</span>
            {
<span class="nc" id="L746">                result.add(this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L749" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L751" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.values[i]))</span>
            {
<span class="nc" id="L753">                result.add(this.values[i]);</span>
            }
        }
<span class="nc" id="L756">        return result;</span>
    }

    @Override
    public &lt;R extends Collection&lt;V&gt;&gt; R select(Predicate&lt;? super V&gt; predicate, R target)
    {
<span class="nc bnc" id="L762" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L764" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(this.sentinelValues.zeroValue))</span>
            {
<span class="nc" id="L766">                target.add(this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L768" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(this.sentinelValues.oneValue))</span>
            {
<span class="nc" id="L770">                target.add(this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L773" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L775" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.values[i]))</span>
            {
<span class="nc" id="L777">                target.add(this.values[i]);</span>
            }
        }
<span class="nc" id="L780">        return target;</span>
    }

    @Override
    public &lt;P&gt; MutableBag&lt;V&gt; selectWith(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L786">        return this.select(Predicates.bind(predicate, parameter));</span>
    }

    @Override
    public &lt;P, R extends Collection&lt;V&gt;&gt; R selectWith(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter, R targetCollection)
    {
<span class="nc bnc" id="L792" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L794" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(this.sentinelValues.zeroValue, parameter))</span>
            {
<span class="nc" id="L796">                targetCollection.add(this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L798" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(this.sentinelValues.oneValue, parameter))</span>
            {
<span class="nc" id="L800">                targetCollection.add(this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L803" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L805" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.values[i], parameter))</span>
            {
<span class="nc" id="L807">                targetCollection.add(this.values[i]);</span>
            }
        }
<span class="nc" id="L810">        return targetCollection;</span>
    }

    @Override
    public MutableBag&lt;V&gt; reject(Predicate&lt;? super V&gt; predicate)
    {
<span class="nc" id="L816">        MutableBag&lt;V&gt; result = new HashBag&lt;&gt;();</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L819" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; !predicate.accept(this.sentinelValues.zeroValue))</span>
            {
<span class="nc" id="L821">                result.add(this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L823" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; !predicate.accept(this.sentinelValues.oneValue))</span>
            {
<span class="nc" id="L825">                result.add(this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L828" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L830" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; !predicate.accept(this.values[i]))</span>
            {
<span class="nc" id="L832">                result.add(this.values[i]);</span>
            }
        }
<span class="nc" id="L835">        return result;</span>
    }

    @Override
    public &lt;R extends Collection&lt;V&gt;&gt; R reject(Predicate&lt;? super V&gt; predicate, R target)
    {
<span class="nc bnc" id="L841" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L843" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; !predicate.accept(this.sentinelValues.zeroValue))</span>
            {
<span class="nc" id="L845">                target.add(this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L847" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; !predicate.accept(this.sentinelValues.oneValue))</span>
            {
<span class="nc" id="L849">                target.add(this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L852" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L854" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; !predicate.accept(this.values[i]))</span>
            {
<span class="nc" id="L856">                target.add(this.values[i]);</span>
            }
        }
<span class="nc" id="L859">        return target;</span>
    }

    @Override
    public &lt;P&gt; MutableBag&lt;V&gt; rejectWith(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L865">        return this.reject(Predicates.bind(predicate, parameter));</span>
    }

    @Override
    public &lt;P, R extends Collection&lt;V&gt;&gt; R rejectWith(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter, R targetCollection)
    {
<span class="nc bnc" id="L871" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L873" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; !predicate.accept(this.sentinelValues.zeroValue, parameter))</span>
            {
<span class="nc" id="L875">                targetCollection.add(this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L877" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; !predicate.accept(this.sentinelValues.oneValue, parameter))</span>
            {
<span class="nc" id="L879">                targetCollection.add(this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L882" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L884" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; !predicate.accept(this.values[i], parameter))</span>
            {
<span class="nc" id="L886">                targetCollection.add(this.values[i]);</span>
            }
        }
<span class="nc" id="L889">        return targetCollection;</span>
    }

    @Override
    public PartitionMutableBag&lt;V&gt; partition(Predicate&lt;? super V&gt; predicate)
    {
<span class="nc" id="L895">        PartitionMutableBag&lt;V&gt; partitionMutableBag = new PartitionHashBag&lt;&gt;();</span>
<span class="nc" id="L896">        this.forEach(new PartitionProcedure&lt;V&gt;(predicate, partitionMutableBag));</span>
<span class="nc" id="L897">        return partitionMutableBag;</span>
    }

    @Override
    public &lt;P&gt; PartitionMutableBag&lt;V&gt; partitionWith(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L903">        PartitionMutableBag&lt;V&gt; partitionMutableBag = new PartitionHashBag&lt;&gt;();</span>
<span class="nc" id="L904">        this.forEach(new PartitionProcedure&lt;V&gt;(Predicates.bind(predicate, parameter), partitionMutableBag));</span>
<span class="nc" id="L905">        return partitionMutableBag;</span>
    }

    @Override
    public &lt;S&gt; MutableBag&lt;S&gt; selectInstancesOf(Class&lt;S&gt; clazz)
    {
<span class="nc" id="L911">        MutableBag&lt;S&gt; result = HashBag.newBag(this.size());</span>
<span class="nc" id="L912">        this.forEach(new SelectInstancesOfProcedure&lt;S&gt;(clazz, result));</span>
<span class="nc" id="L913">        return result;</span>
    }

    @Override
    public &lt;VV&gt; MutableBag&lt;VV&gt; collect(Function&lt;? super V, ? extends VV&gt; function)
    {
<span class="nc" id="L919">        return this.collect(function, new HashBag&lt;VV&gt;());</span>
    }

    @Override
    public MutableBooleanBag collectBoolean(BooleanFunction&lt;? super V&gt; booleanFunction)
    {
<span class="nc" id="L925">        return this.collectBoolean(booleanFunction, new BooleanHashBag());</span>
    }

    @Override
    public &lt;R extends MutableBooleanCollection&gt; R collectBoolean(BooleanFunction&lt;? super V&gt; booleanFunction, R target)
    {
<span class="nc" id="L931">        this.forEach(new CollectBooleanProcedure&lt;V&gt;(booleanFunction, target));</span>
<span class="nc" id="L932">        return target;</span>
    }

    @Override
    public MutableByteBag collectByte(ByteFunction&lt;? super V&gt; byteFunction)
    {
<span class="nc" id="L938">        return this.collectByte(byteFunction, new ByteHashBag());</span>
    }

    @Override
    public &lt;R extends MutableByteCollection&gt; R collectByte(ByteFunction&lt;? super V&gt; byteFunction, R target)
    {
<span class="nc" id="L944">        this.forEach(new CollectByteProcedure&lt;V&gt;(byteFunction, target));</span>
<span class="nc" id="L945">        return target;</span>
    }

    @Override
    public MutableCharBag collectChar(CharFunction&lt;? super V&gt; charFunction)
    {
<span class="nc" id="L951">        return this.collectChar(charFunction, new CharHashBag());</span>
    }

    @Override
    public &lt;R extends MutableCharCollection&gt; R collectChar(CharFunction&lt;? super V&gt; charFunction, R target)
    {
<span class="nc" id="L957">        this.forEach(new CollectCharProcedure&lt;V&gt;(charFunction, target));</span>
<span class="nc" id="L958">        return target;</span>
    }

    @Override
    public MutableDoubleBag collectDouble(DoubleFunction&lt;? super V&gt; doubleFunction)
    {
<span class="nc" id="L964">        return this.collectDouble(doubleFunction, new DoubleHashBag());</span>
    }

    @Override
    public &lt;R extends MutableDoubleCollection&gt; R collectDouble(DoubleFunction&lt;? super V&gt; doubleFunction, R target)
    {
<span class="nc" id="L970">        this.forEach(new CollectDoubleProcedure&lt;V&gt;(doubleFunction, target));</span>
<span class="nc" id="L971">        return target;</span>
    }

    @Override
    public MutableFloatBag collectFloat(FloatFunction&lt;? super V&gt; floatFunction)
    {
<span class="nc" id="L977">        return this.collectFloat(floatFunction, new FloatHashBag());</span>
    }

    @Override
    public &lt;R extends MutableFloatCollection&gt; R collectFloat(FloatFunction&lt;? super V&gt; floatFunction, R target)
    {
<span class="nc" id="L983">        this.forEach(new CollectFloatProcedure&lt;V&gt;(floatFunction, target));</span>
<span class="nc" id="L984">        return target;</span>
    }

    @Override
    public MutableIntBag collectInt(IntFunction&lt;? super V&gt; intFunction)
    {
<span class="nc" id="L990">        return this.collectInt(intFunction, new IntHashBag());</span>
    }

    @Override
    public &lt;R extends MutableIntCollection&gt; R collectInt(IntFunction&lt;? super V&gt; intFunction, R target)
    {
<span class="nc" id="L996">        this.forEach(new CollectIntProcedure&lt;V&gt;(intFunction, target));</span>
<span class="nc" id="L997">        return target;</span>
    }

    @Override
    public MutableLongBag collectLong(LongFunction&lt;? super V&gt; longFunction)
    {
<span class="nc" id="L1003">        return this.collectLong(longFunction, new LongHashBag());</span>
    }

    @Override
    public &lt;R extends MutableLongCollection&gt; R collectLong(LongFunction&lt;? super V&gt; longFunction, R target)
    {
<span class="nc" id="L1009">        this.forEach(new CollectLongProcedure&lt;V&gt;(longFunction, target));</span>
<span class="nc" id="L1010">        return target;</span>
    }

    @Override
    public MutableShortBag collectShort(ShortFunction&lt;? super V&gt; shortFunction)
    {
<span class="nc" id="L1016">        return this.collectShort(shortFunction, new ShortHashBag());</span>
    }

    @Override
    public &lt;R extends MutableShortCollection&gt; R collectShort(ShortFunction&lt;? super V&gt; shortFunction, R target)
    {
<span class="nc" id="L1022">        this.forEach(new CollectShortProcedure&lt;V&gt;(shortFunction, target));</span>
<span class="nc" id="L1023">        return target;</span>
    }

    @Override
    public &lt;P, VV&gt; MutableBag&lt;VV&gt; collectWith(Function2&lt;? super V, ? super P, ? extends VV&gt; function, P parameter)
    {
<span class="nc" id="L1029">        return this.collect(Functions.bind(function, parameter));</span>
    }

    @Override
    public &lt;P, VV, R extends Collection&lt;VV&gt;&gt; R collectWith(Function2&lt;? super V, ? super P, ? extends VV&gt; function, P parameter, R targetCollection)
    {
<span class="nc bnc" id="L1035" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1039">                targetCollection.add(function.value(this.sentinelValues.zeroValue, parameter));</span>
            }
<span class="nc bnc" id="L1041" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L1043">                targetCollection.add(function.value(this.sentinelValues.oneValue, parameter));</span>
            }
        }
<span class="nc bnc" id="L1046" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1048" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L1050">                targetCollection.add(function.value(this.values[i], parameter));</span>
            }
        }
<span class="nc" id="L1053">        return targetCollection;</span>
    }

    @Override
    public &lt;VV, R extends Collection&lt;VV&gt;&gt; R collect(Function&lt;? super V, ? extends VV&gt; function, R target)
    {
<span class="nc bnc" id="L1059" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1061" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1063">                target.add(function.valueOf(this.sentinelValues.zeroValue));</span>
            }
<span class="nc bnc" id="L1065" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L1067">                target.add(function.valueOf(this.sentinelValues.oneValue));</span>
            }
        }
<span class="nc bnc" id="L1070" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1072" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L1074">                target.add(function.valueOf(this.values[i]));</span>
            }
        }
<span class="nc" id="L1077">        return target;</span>
    }

    @Override
    public &lt;VV&gt; MutableBag&lt;VV&gt; collectIf(Predicate&lt;? super V&gt; predicate, Function&lt;? super V, ? extends VV&gt; function)
    {
<span class="nc" id="L1083">        return this.collectIf(predicate, function, HashBag.&lt;VV&gt;newBag());</span>
    }

    @Override
    public &lt;VV, R extends Collection&lt;VV&gt;&gt; R collectIf(Predicate&lt;? super V&gt; predicate, Function&lt;? super V, ? extends VV&gt; function, R target)
    {
<span class="nc bnc" id="L1089" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1091" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(this.sentinelValues.zeroValue))</span>
            {
<span class="nc" id="L1093">                target.add(function.valueOf(this.sentinelValues.zeroValue));</span>
            }
<span class="nc bnc" id="L1095" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(this.sentinelValues.oneValue))</span>
            {
<span class="nc" id="L1097">                target.add(function.valueOf(this.sentinelValues.oneValue));</span>
            }
        }
<span class="nc bnc" id="L1100" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1102" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.values[i]))</span>
            {
<span class="nc" id="L1104">                target.add(function.valueOf(this.values[i]));</span>
            }
        }
<span class="nc" id="L1107">        return target;</span>
    }

    @Override
    public &lt;VV&gt; MutableBag&lt;VV&gt; flatCollect(Function&lt;? super V, ? extends Iterable&lt;VV&gt;&gt; function)
    {
<span class="nc" id="L1113">        return this.flatCollect(function, new HashBag&lt;VV&gt;());</span>
    }

    @Override
    public &lt;VV, R extends Collection&lt;VV&gt;&gt; R flatCollect(Function&lt;? super V, ? extends Iterable&lt;VV&gt;&gt; function, R target)
    {
<span class="nc bnc" id="L1119" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1121" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1123">                Iterate.addAllTo(function.valueOf(this.sentinelValues.zeroValue), target);</span>
            }
<span class="nc bnc" id="L1125" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L1127">                Iterate.addAllTo(function.valueOf(this.sentinelValues.oneValue), target);</span>
            }
        }
<span class="nc bnc" id="L1130" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1132" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L1134">                Iterate.addAllTo(function.valueOf(this.values[i]), target);</span>
            }
        }
<span class="nc" id="L1137">        return target;</span>
    }

    @Override
    public V detect(Predicate&lt;? super V&gt; predicate)
    {
<span class="nc bnc" id="L1143" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1145" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(this.sentinelValues.zeroValue))</span>
            {
<span class="nc" id="L1147">                return this.sentinelValues.zeroValue;</span>
            }
<span class="nc bnc" id="L1149" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(this.sentinelValues.oneValue))</span>
            {
<span class="nc" id="L1151">                return this.sentinelValues.oneValue;</span>
            }
        }
<span class="nc bnc" id="L1154" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1156" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.values[i]))</span>
            {
<span class="nc" id="L1158">                return this.values[i];</span>
            }
        }
<span class="nc" id="L1161">        return null;</span>
    }

    @Override
    public &lt;P&gt; V detectWith(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter)
    {
<span class="nc bnc" id="L1167" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1169" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(this.sentinelValues.zeroValue, parameter))</span>
            {
<span class="nc" id="L1171">                return this.sentinelValues.zeroValue;</span>
            }
<span class="nc bnc" id="L1173" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(this.sentinelValues.oneValue, parameter))</span>
            {
<span class="nc" id="L1175">                return this.sentinelValues.oneValue;</span>
            }
        }
<span class="nc bnc" id="L1178" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1180" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.values[i], parameter))</span>
            {
<span class="nc" id="L1182">                return this.values[i];</span>
            }
        }
<span class="nc" id="L1185">        return null;</span>
    }

    @Override
    public Optional&lt;V&gt; detectOptional(Predicate&lt;? super V&gt; predicate)
    {
<span class="nc" id="L1191">        return Optional.ofNullable(this.detect(predicate));</span>
    }

    @Override
    public &lt;P&gt; Optional&lt;V&gt; detectWithOptional(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L1197">        return Optional.ofNullable(this.detectWith(predicate, parameter));</span>
    }

    @Override
    public V detectIfNone(Predicate&lt;? super V&gt; predicate, Function0&lt;? extends V&gt; function)
    {
<span class="nc bnc" id="L1203" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1205" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(this.sentinelValues.zeroValue))</span>
            {
<span class="nc" id="L1207">                return this.sentinelValues.zeroValue;</span>
            }
<span class="nc bnc" id="L1209" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(this.sentinelValues.oneValue))</span>
            {
<span class="nc" id="L1211">                return this.sentinelValues.oneValue;</span>
            }
        }
<span class="nc bnc" id="L1214" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1216" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.values[i]))</span>
            {
<span class="nc" id="L1218">                return this.values[i];</span>
            }
        }
<span class="nc" id="L1221">        return function.value();</span>
    }

    @Override
    public &lt;P&gt; V detectWithIfNone(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter, Function0&lt;? extends V&gt; function)
    {
<span class="nc bnc" id="L1227" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1229" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(this.sentinelValues.zeroValue, parameter))</span>
            {
<span class="nc" id="L1231">                return this.sentinelValues.zeroValue;</span>
            }
<span class="nc bnc" id="L1233" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(this.sentinelValues.oneValue, parameter))</span>
            {
<span class="nc" id="L1235">                return this.sentinelValues.oneValue;</span>
            }
        }
<span class="nc bnc" id="L1238" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1240" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.values[i], parameter))</span>
            {
<span class="nc" id="L1242">                return this.values[i];</span>
            }
        }
<span class="nc" id="L1245">        return function.value();</span>
    }

    @Override
    public int count(Predicate&lt;? super V&gt; predicate)
    {
<span class="nc" id="L1251">        int count = 0;</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1254" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(this.sentinelValues.zeroValue))</span>
            {
<span class="nc" id="L1256">                count++;</span>
            }
<span class="nc bnc" id="L1258" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(this.sentinelValues.oneValue))</span>
            {
<span class="nc" id="L1260">                count++;</span>
            }
        }
<span class="nc bnc" id="L1263" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1265" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.values[i]))</span>
            {
<span class="nc" id="L1267">                count++;</span>
            }
        }
<span class="nc" id="L1270">        return count;</span>
    }

    @Override
    public &lt;P&gt; int countWith(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L1276">        int count = 0;</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1279" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(this.sentinelValues.zeroValue, parameter))</span>
            {
<span class="nc" id="L1281">                count++;</span>
            }
<span class="nc bnc" id="L1283" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(this.sentinelValues.oneValue, parameter))</span>
            {
<span class="nc" id="L1285">                count++;</span>
            }
        }
<span class="nc bnc" id="L1288" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1290" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.values[i], parameter))</span>
            {
<span class="nc" id="L1292">                count++;</span>
            }
        }
<span class="nc" id="L1295">        return count;</span>
    }

    @Override
    public boolean anySatisfy(Predicate&lt;? super V&gt; predicate)
    {
<span class="nc bnc" id="L1301" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1303" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(this.sentinelValues.zeroValue))</span>
            {
<span class="nc" id="L1305">                return true;</span>
            }
<span class="nc bnc" id="L1307" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(this.sentinelValues.oneValue))</span>
            {
<span class="nc" id="L1309">                return true;</span>
            }
        }
<span class="nc bnc" id="L1312" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1314" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.values[i]))</span>
            {
<span class="nc" id="L1316">                return true;</span>
            }
        }
<span class="nc" id="L1319">        return false;</span>
    }

    @Override
    public &lt;P&gt; boolean anySatisfyWith(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter)
    {
<span class="nc bnc" id="L1325" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1327" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(this.sentinelValues.zeroValue, parameter))</span>
            {
<span class="nc" id="L1329">                return true;</span>
            }
<span class="nc bnc" id="L1331" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(this.sentinelValues.oneValue, parameter))</span>
            {
<span class="nc" id="L1333">                return true;</span>
            }
        }
<span class="nc bnc" id="L1336" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1338" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.values[i], parameter))</span>
            {
<span class="nc" id="L1340">                return true;</span>
            }
        }
<span class="nc" id="L1343">        return false;</span>
    }

    @Override
    public boolean allSatisfy(Predicate&lt;? super V&gt; predicate)
    {
<span class="nc bnc" id="L1349" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1351" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; !predicate.accept(this.sentinelValues.zeroValue))</span>
            {
<span class="nc" id="L1353">                return false;</span>
            }
<span class="nc bnc" id="L1355" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; !predicate.accept(this.sentinelValues.oneValue))</span>
            {
<span class="nc" id="L1357">                return false;</span>
            }
        }
<span class="nc bnc" id="L1360" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1362" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; !predicate.accept(this.values[i]))</span>
            {
<span class="nc" id="L1364">                return false;</span>
            }
        }
<span class="nc" id="L1367">        return true;</span>
    }

    @Override
    public &lt;P&gt; boolean allSatisfyWith(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter)
    {
<span class="nc bnc" id="L1373" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1375" title="All 4 branches missed.">            if (this.sentinelValues.containsZeroKey &amp;&amp; !predicate.accept(this.sentinelValues.zeroValue, parameter))</span>
            {
<span class="nc" id="L1377">                return false;</span>
            }
<span class="nc bnc" id="L1379" title="All 4 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; !predicate.accept(this.sentinelValues.oneValue, parameter))</span>
            {
<span class="nc" id="L1381">                return false;</span>
            }
        }
<span class="nc bnc" id="L1384" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1386" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; !predicate.accept(this.values[i], parameter))</span>
            {
<span class="nc" id="L1388">                return false;</span>
            }
        }
<span class="nc" id="L1391">        return true;</span>
    }

    @Override
    public boolean noneSatisfy(Predicate&lt;? super V&gt; predicate)
    {
<span class="nc bnc" id="L1397" title="All 2 branches missed.">        return !this.anySatisfy(predicate);</span>
    }

    @Override
    public &lt;P&gt; boolean noneSatisfyWith(Predicate2&lt;? super V, ? super P&gt; predicate, P parameter)
    {
<span class="nc bnc" id="L1403" title="All 2 branches missed.">        return !this.anySatisfyWith(predicate, parameter);</span>
    }

    @Override
    public &lt;IV&gt; IV injectInto(IV injectedValue, Function2&lt;? super IV, ? super V, ? extends IV&gt; function)
    {
<span class="nc" id="L1409">        IV result = injectedValue;</span>
<span class="nc bnc" id="L1410" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1412" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1414">                result = function.value(result, this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L1416" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L1418">                result = function.value(result, this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L1421" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1423" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L1425">                result = function.value(result, this.values[i]);</span>
            }
        }
<span class="nc" id="L1428">        return result;</span>
    }

    @Override
    public int injectInto(int injectedValue, IntObjectToIntFunction&lt;? super V&gt; function)
    {
<span class="nc" id="L1434">        int result = injectedValue;</span>
<span class="nc bnc" id="L1435" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1437" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1439">                result = function.intValueOf(result, this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L1441" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L1443">                result = function.intValueOf(result, this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L1446" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1448" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L1450">                result = function.intValueOf(result, this.values[i]);</span>
            }
        }
<span class="nc" id="L1453">        return result;</span>
    }

    @Override
    public long injectInto(long injectedValue, LongObjectToLongFunction&lt;? super V&gt; function)
    {
<span class="nc" id="L1459">        long result = injectedValue;</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1462" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1464">                result = function.longValueOf(result, this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L1466" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L1468">                result = function.longValueOf(result, this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L1471" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1473" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L1475">                result = function.longValueOf(result, this.values[i]);</span>
            }
        }
<span class="nc" id="L1478">        return result;</span>
    }

    @Override
    public float injectInto(float injectedValue, FloatObjectToFloatFunction&lt;? super V&gt; function)
    {
<span class="nc" id="L1484">        float result = injectedValue;</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1487" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1489">                result = function.floatValueOf(result, this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L1491" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L1493">                result = function.floatValueOf(result, this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L1496" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1498" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L1500">                result = function.floatValueOf(result, this.values[i]);</span>
            }
        }
<span class="nc" id="L1503">        return result;</span>
    }

    @Override
    public double injectInto(double injectedValue, DoubleObjectToDoubleFunction&lt;? super V&gt; function)
    {
<span class="nc" id="L1509">        double result = injectedValue;</span>
<span class="nc bnc" id="L1510" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1512" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1514">                result = function.doubleValueOf(result, this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L1516" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L1518">                result = function.doubleValueOf(result, this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L1521" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1523" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L1525">                result = function.doubleValueOf(result, this.values[i]);</span>
            }
        }
<span class="nc" id="L1528">        return result;</span>
    }

    /**
     * @deprecated in 7.0. Use {@link org.eclipse.collections.api.ordered.OrderedIterable#zip(Iterable)} instead.
     */
    @Deprecated
    @Override
    public &lt;S&gt; MutableBag&lt;Pair&lt;V, S&gt;&gt; zip(Iterable&lt;S&gt; that)
    {
<span class="nc bnc" id="L1538" title="All 4 branches missed.">        if (that instanceof Collection || that instanceof RichIterable)</span>
        {
<span class="nc" id="L1540">            int thatSize = Iterate.sizeOf(that);</span>
<span class="nc" id="L1541">            HashBag&lt;Pair&lt;V, S&gt;&gt; target = HashBag.newBag(Math.min(this.size(), thatSize));</span>
<span class="nc" id="L1542">            return this.zip(that, target);</span>
        }
<span class="nc" id="L1544">        return this.zip(that, HashBag.newBag());</span>
    }

    @Override
    public &lt;S, R extends Collection&lt;Pair&lt;V, S&gt;&gt;&gt; R zip(Iterable&lt;S&gt; that, R target)
    {
<span class="nc" id="L1550">        return IterableIterate.zip(this, that, target);</span>
    }

    /**
     * @deprecated in 7.0. Use {@link org.eclipse.collections.api.ordered.OrderedIterable#zipWithIndex()} instead.
     */
    @Deprecated
    @Override
    public MutableSet&lt;Pair&lt;V, Integer&gt;&gt; zipWithIndex()
    {
<span class="nc" id="L1560">        return this.zipWithIndex(UnifiedSet.&lt;Pair&lt;V, Integer&gt;&gt;newSet(this.size()));</span>
    }

    @Override
    public &lt;R extends Collection&lt;Pair&lt;V, Integer&gt;&gt;&gt; R zipWithIndex(R target)
    {
<span class="nc" id="L1566">        return IterableIterate.zipWithIndex(this, target);</span>
    }

    @Override
    public RichIterable&lt;RichIterable&lt;V&gt;&gt; chunk(int size)
    {
<span class="nc bnc" id="L1572" title="All 2 branches missed.">        if (size &lt;= 0)</span>
        {
<span class="nc" id="L1574">            throw new IllegalArgumentException(&quot;Size for groups must be positive but was: &quot; + size);</span>
        }
<span class="nc" id="L1576">        MutableList&lt;RichIterable&lt;V&gt;&gt; result = Lists.mutable.of();</span>
<span class="nc bnc" id="L1577" title="All 2 branches missed.">        if (this.notEmpty())</span>
        {
<span class="nc" id="L1579">            Iterator&lt;V&gt; iterator = this.iterator();</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L1582">                MutableList&lt;V&gt; batch = FastList.newList();</span>
<span class="nc bnc" id="L1583" title="All 4 branches missed.">                for (int i = 0; i &lt; size &amp;&amp; iterator.hasNext(); i++)</span>
                {
<span class="nc" id="L1585">                    batch.add(iterator.next());</span>
                }
<span class="nc" id="L1587">                result.add(batch);</span>
<span class="nc" id="L1588">            }</span>
        }
<span class="nc" id="L1590">        return result;</span>
    }

    @Override
    public &lt;K, VV&gt; MutableMap&lt;K, VV&gt; aggregateInPlaceBy(Function&lt;? super V, ? extends K&gt; groupBy, Function0&lt;? extends VV&gt; zeroValueFactory, Procedure2&lt;? super VV, ? super V&gt; mutatingAggregator)
    {
<span class="nc" id="L1596">        MutableMap&lt;K, VV&gt; map = UnifiedMap.newMap();</span>
<span class="nc" id="L1597">        this.forEach(new MutatingAggregationProcedure&lt;V, K, VV&gt;(map, groupBy, zeroValueFactory, mutatingAggregator));</span>
<span class="nc" id="L1598">        return map;</span>
    }

    @Override
    public &lt;K, VV&gt; MutableMap&lt;K, VV&gt; aggregateBy(Function&lt;? super V, ? extends K&gt; groupBy, Function0&lt;? extends VV&gt; zeroValueFactory, Function2&lt;? super VV, ? super V, ? extends VV&gt; nonMutatingAggregator)
    {
<span class="nc" id="L1604">        MutableMap&lt;K, VV&gt; map = UnifiedMap.newMap();</span>
<span class="nc" id="L1605">        this.forEach(new NonMutatingAggregationProcedure&lt;V, K, VV&gt;(map, groupBy, zeroValueFactory, nonMutatingAggregator));</span>
<span class="nc" id="L1606">        return map;</span>
    }

    @Override
    public &lt;VV&gt; MutableBagMultimap&lt;VV, V&gt; groupBy(Function&lt;? super V, ? extends VV&gt; function)
    {
<span class="nc" id="L1612">        return this.groupBy(function, HashBagMultimap.&lt;VV, V&gt;newMultimap());</span>
    }

    @Override
    public &lt;VV, R extends MutableMultimap&lt;VV, V&gt;&gt; R groupBy(Function&lt;? super V, ? extends VV&gt; function, R target)
    {
<span class="nc bnc" id="L1618" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1620" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1622">                target.put(function.valueOf(this.sentinelValues.zeroValue), this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L1624" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L1626">                target.put(function.valueOf(this.sentinelValues.oneValue), this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L1629" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1631" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L1633">                target.put(function.valueOf(this.values[i]), this.values[i]);</span>
            }
        }
<span class="nc" id="L1636">        return target;</span>
    }

    @Override
    public &lt;VV&gt; MutableBagMultimap&lt;VV, V&gt; groupByEach(Function&lt;? super V, ? extends Iterable&lt;VV&gt;&gt; function)
    {
<span class="nc" id="L1642">        return this.groupByEach(function, HashBagMultimap.&lt;VV, V&gt;newMultimap());</span>
    }

    @Override
    public &lt;VV, R extends MutableMultimap&lt;VV, V&gt;&gt; R groupByEach(
            Function&lt;? super V, ? extends Iterable&lt;VV&gt;&gt; function,
            R target)
    {
<span class="nc bnc" id="L1650" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1652" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1654">                Iterable&lt;VV&gt; iterable  = function.valueOf(this.sentinelValues.zeroValue);</span>
<span class="nc bnc" id="L1655" title="All 2 branches missed.">                for (VV key : iterable)</span>
                {
<span class="nc" id="L1657">                    target.put(key, this.sentinelValues.zeroValue);</span>
<span class="nc" id="L1658">                }</span>
            }
<span class="nc bnc" id="L1660" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L1662">                Iterable&lt;VV&gt; iterable  = function.valueOf(this.sentinelValues.oneValue);</span>
<span class="nc bnc" id="L1663" title="All 2 branches missed.">                for (VV key : iterable)</span>
                {
<span class="nc" id="L1665">                    target.put(key, this.sentinelValues.oneValue);</span>
<span class="nc" id="L1666">                }</span>
            }
        }
<span class="nc bnc" id="L1669" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1671" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L1673">                Iterable&lt;VV&gt; iterable  = function.valueOf(this.values[i]);</span>
<span class="nc bnc" id="L1674" title="All 2 branches missed.">                for (VV key : iterable)</span>
                {
<span class="nc" id="L1676">                    target.put(key, this.values[i]);</span>
<span class="nc" id="L1677">                }</span>
            }
        }
<span class="nc" id="L1680">        return target;</span>
    }

    @Override
    public &lt;VV&gt; MutableMap&lt;VV, V&gt; groupByUniqueKey(Function&lt;? super V, ? extends VV&gt; function)
    {
<span class="nc" id="L1686">        return this.groupByUniqueKey(function, UnifiedMap.&lt;VV, V&gt;newMap(this.size()));</span>
    }

    @Override
    public &lt;VV, R extends MutableMap&lt;VV, V&gt;&gt; R groupByUniqueKey(
                Function&lt;? super V, ? extends VV&gt; function,
                R target)
    {
<span class="nc bnc" id="L1694" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1696" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc bnc" id="L1698" title="All 2 branches missed.">                if (target.put(function.valueOf(this.sentinelValues.zeroValue), this.sentinelValues.zeroValue) != null)</span>
                {
<span class="nc" id="L1700">                    throw new IllegalStateException(&quot;Key &quot; + function.valueOf(this.sentinelValues.zeroValue) + &quot; already exists in map!&quot;);</span>
                }
            }
<span class="nc bnc" id="L1703" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc bnc" id="L1705" title="All 2 branches missed.">                if (target.put(function.valueOf(this.sentinelValues.oneValue), this.sentinelValues.oneValue) != null)</span>
                {
<span class="nc" id="L1707">                    throw new IllegalStateException(&quot;Key &quot; + function.valueOf(this.sentinelValues.oneValue) + &quot; already exists in map!&quot;);</span>
                }
            }
        }
<span class="nc bnc" id="L1711" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1713" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc bnc" id="L1715" title="All 2 branches missed.">                if (target.put(function.valueOf(this.values[i]), this.values[i]) != null)</span>
                {
<span class="nc" id="L1717">                    throw new IllegalStateException(&quot;Key &quot; + function.valueOf(this.values[i]) + &quot; already exists in map!&quot;);</span>
                }
            }
        }
<span class="nc" id="L1721">        return target;</span>
    }

    @Override
    public V getFirst()
    {
<span class="nc bnc" id="L1727" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1729" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1731">                return this.sentinelValues.zeroValue;</span>
            }
<span class="nc bnc" id="L1733" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L1735">                return this.sentinelValues.oneValue;</span>
            }
        }
<span class="nc bnc" id="L1738" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1740" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L1742">                return this.values[i];</span>
            }
        }
<span class="nc" id="L1745">        return null;</span>
    }

    @Override
    public V getLast()
    {
<span class="nc bnc" id="L1751" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1753" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L1755">                return this.values[i];</span>
            }
        }
<span class="nc bnc" id="L1758" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1760" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L1762">                return this.sentinelValues.oneValue;</span>
            }
<span class="nc bnc" id="L1764" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1766">                return this.sentinelValues.zeroValue;</span>
            }
        }
<span class="nc" id="L1769">        return null;</span>
    }

    @Override
    public V getOnly()
    {
<span class="nc bnc" id="L1775" title="All 2 branches missed.">        if (this.size() != 1)</span>
        {
<span class="nc" id="L1777">            throw new IllegalStateException(&quot;Size must be 1 but was &quot; + this.size());</span>
        }

<span class="nc bnc" id="L1780" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1782" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1784">                return this.sentinelValues.zeroValue;</span>
            }
<span class="nc bnc" id="L1786" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L1788">                return this.sentinelValues.oneValue;</span>
            }
        }
<span class="nc bnc" id="L1791" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1793" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L1795">                return this.values[i];</span>
            }
        }

<span class="nc" id="L1799">        return null;</span>
    }

    @Override
    public MutableList&lt;V&gt; toList()
    {
<span class="nc" id="L1805">        MutableList&lt;V&gt; list = Lists.mutable.of();</span>
<span class="nc" id="L1806">        this.forEachWith(Procedures2.&lt;V&gt;addToCollection(), list);</span>
<span class="nc" id="L1807">        return list;</span>
    }

    @Override
    public &lt;R extends Collection&lt;V&gt;&gt; R into(R target)
    {
<span class="nc" id="L1813">        return Iterate.addAllTo(this, target);</span>
    }

    @Override
    public MutableList&lt;V&gt; toSortedList()
    {
<span class="nc" id="L1819">        return this.toList().sortThis();</span>
    }

    @Override
    public MutableList&lt;V&gt; toSortedList(Comparator&lt;? super V&gt; comparator)
    {
<span class="nc" id="L1825">        return this.toList().sortThis(comparator);</span>
    }

    @Override
    public &lt;VV extends Comparable&lt;? super VV&gt;&gt; MutableList&lt;V&gt; toSortedListBy(Function&lt;? super V, ? extends VV&gt; function)
    {
<span class="nc" id="L1831">        return this.toList().sortThis(Comparators.byFunction(function));</span>
    }

    @Override
    public MutableSet&lt;V&gt; toSet()
    {
<span class="nc" id="L1837">        MutableSet&lt;V&gt; set = UnifiedSet.newSet();</span>
<span class="nc" id="L1838">        this.forEachWith(Procedures2.&lt;V&gt;addToCollection(), set);</span>
<span class="nc" id="L1839">        return set;</span>
    }

    @Override
    public MutableSortedSet&lt;V&gt; toSortedSet()
    {
<span class="nc" id="L1845">        MutableSortedSet&lt;V&gt; set = TreeSortedSet.newSet();</span>
<span class="nc" id="L1846">        this.forEachWith(Procedures2.&lt;V&gt;addToCollection(), set);</span>
<span class="nc" id="L1847">        return set;</span>
    }

    @Override
    public MutableSortedSet&lt;V&gt; toSortedSet(Comparator&lt;? super V&gt; comparator)
    {
<span class="nc" id="L1853">        MutableSortedSet&lt;V&gt; set = TreeSortedSet.newSet(comparator);</span>
<span class="nc" id="L1854">        this.forEachWith(Procedures2.&lt;V&gt;addToCollection(), set);</span>
<span class="nc" id="L1855">        return set;</span>
    }

    @Override
    public &lt;VV extends Comparable&lt;? super VV&gt;&gt; MutableSortedSet&lt;V&gt; toSortedSetBy(Function&lt;? super V, ? extends VV&gt; function)
    {
<span class="nc" id="L1861">        MutableSortedSet&lt;V&gt; set = TreeSortedSet.newSet(Comparators.byFunction(function));</span>
<span class="nc" id="L1862">        this.forEachWith(Procedures2.&lt;V&gt;addToCollection(), set);</span>
<span class="nc" id="L1863">        return set;</span>
    }

    @Override
    public MutableBag&lt;V&gt; toBag()
    {
<span class="nc" id="L1869">        MutableBag&lt;V&gt; bag = Bags.mutable.of();</span>
<span class="nc" id="L1870">        this.forEachWith(Procedures2.&lt;V&gt;addToCollection(), bag);</span>
<span class="nc" id="L1871">        return bag;</span>
    }

    @Override
    public MutableSortedBag&lt;V&gt; toSortedBag()
    {
<span class="nc" id="L1877">        MutableSortedBag&lt;V&gt; sortedBag = TreeBag.newBag();</span>
<span class="nc" id="L1878">        this.forEachWith(Procedures2.&lt;V&gt;addToCollection(), sortedBag);</span>
<span class="nc" id="L1879">        return sortedBag;</span>
    }

    @Override
    public MutableSortedBag&lt;V&gt; toSortedBag(Comparator&lt;? super V&gt; comparator)
    {
<span class="nc" id="L1885">        MutableSortedBag&lt;V&gt; sortedBag = TreeBag.newBag(comparator);</span>
<span class="nc" id="L1886">        this.forEachWith(Procedures2.&lt;V&gt;addToCollection(), sortedBag);</span>
<span class="nc" id="L1887">        return sortedBag;</span>
    }

    @Override
    public &lt;VV extends Comparable&lt;? super VV&gt;&gt; MutableSortedBag&lt;V&gt; toSortedBagBy(Function&lt;? super V, ? extends VV&gt; function)
    {
<span class="nc" id="L1893">        return this.toSortedBag(Comparators.byFunction(function));</span>
    }

    @Override
    public &lt;NK, NV&gt; MutableMap&lt;NK, NV&gt; toMap(Function&lt;? super V, ? extends NK&gt; keyFunction, Function&lt;? super V, ? extends NV&gt; valueFunction)
    {
<span class="nc" id="L1899">        UnifiedMap&lt;NK, NV&gt; map = UnifiedMap.newMap();</span>
<span class="nc" id="L1900">        this.forEach(new MapCollectProcedure&lt;V, NK, NV&gt;(map, keyFunction, valueFunction));</span>
<span class="nc" id="L1901">        return map;</span>
    }

    @Override
    public &lt;NK, NV&gt; MutableSortedMap&lt;NK, NV&gt; toSortedMap(Function&lt;? super V, ? extends NK&gt; keyFunction, Function&lt;? super V, ? extends NV&gt; valueFunction)
    {
<span class="nc" id="L1907">        return this.toSortedMap(Comparators.naturalOrder(), keyFunction, valueFunction);</span>
    }

    @Override
    public &lt;NK, NV&gt; MutableSortedMap&lt;NK, NV&gt; toSortedMap(Comparator&lt;? super NK&gt; comparator, Function&lt;? super V, ? extends NK&gt; keyFunction, Function&lt;? super V, ? extends NV&gt; valueFunction)
    {
<span class="nc" id="L1913">        TreeSortedMap&lt;NK, NV&gt; sortedMap = TreeSortedMap.newMap(comparator);</span>
<span class="nc" id="L1914">        this.forEach(new MapCollectProcedure&lt;V, NK, NV&gt;(sortedMap, keyFunction, valueFunction));</span>
<span class="nc" id="L1915">        return sortedMap;</span>
    }

    @Override
    public &lt;KK extends Comparable&lt;? super KK&gt;, NK, NV&gt; MutableSortedMap&lt;NK, NV&gt; toSortedMapBy(Function&lt;? super NK, KK&gt; sortBy, Function&lt;? super V, ? extends NK&gt; keyFunction, Function&lt;? super V, ? extends NV&gt; valueFunction)
    {
<span class="nc" id="L1921">        return this.toSortedMap(Comparators.byFunction(sortBy), keyFunction, valueFunction);</span>
    }

    @Override
    public LazyIterable&lt;V&gt; asLazy()
    {
<span class="nc" id="L1927">        return LazyIterate.adapt(this);</span>
    }

    @Override
    public V min(Comparator&lt;? super V&gt; comparator)
    {
<span class="nc bnc" id="L1933" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L1935">            throw new NoSuchElementException();</span>
        }

<span class="nc" id="L1938">        V min = null;</span>
<span class="nc" id="L1939">        boolean isMinSet = false;</span>

<span class="nc bnc" id="L1941" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1943" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1945">                min = this.sentinelValues.zeroValue;</span>
<span class="nc" id="L1946">                isMinSet = true;</span>
            }
<span class="nc bnc" id="L1948" title="All 6 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; (!isMinSet || comparator.compare(min, this.sentinelValues.oneValue) &gt; 0))</span>
            {
<span class="nc" id="L1950">                min = this.sentinelValues.oneValue;</span>
<span class="nc" id="L1951">                isMinSet = true;</span>
            }
        }
<span class="nc bnc" id="L1954" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1956" title="All 6 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; (!isMinSet || comparator.compare(min, this.values[i]) &gt; 0))</span>
            {
<span class="nc" id="L1958">                min = this.values[i];</span>
<span class="nc" id="L1959">                isMinSet = true;</span>
            }
        }
<span class="nc" id="L1962">        return min;</span>
    }

    @Override
    public V max(Comparator&lt;? super V&gt; comparator)
    {
<span class="nc bnc" id="L1968" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L1970">            throw new NoSuchElementException();</span>
        }

<span class="nc" id="L1973">        V max = null;</span>
<span class="nc" id="L1974">        boolean isMaxSet = false;</span>

<span class="nc bnc" id="L1976" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L1978" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L1980">                max = this.sentinelValues.zeroValue;</span>
<span class="nc" id="L1981">                isMaxSet = true;</span>
            }
<span class="nc bnc" id="L1983" title="All 6 branches missed.">            if (this.sentinelValues.containsOneKey &amp;&amp; (!isMaxSet || comparator.compare(max, this.sentinelValues.oneValue) &lt; 0))</span>
            {
<span class="nc" id="L1985">                max = this.sentinelValues.oneValue;</span>
<span class="nc" id="L1986">                isMaxSet = true;</span>
            }
        }
<span class="nc bnc" id="L1989" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L1991" title="All 6 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; (!isMaxSet || comparator.compare(max, this.values[i]) &lt; 0))</span>
            {
<span class="nc" id="L1993">                max = this.values[i];</span>
<span class="nc" id="L1994">                isMaxSet = true;</span>
            }
        }
<span class="nc" id="L1997">        return max;</span>
    }

    @Override
    public V min()
    {
<span class="nc" id="L2003">        return this.min(Comparators.naturalOrder());</span>
    }

    @Override
    public V max()
    {
<span class="nc" id="L2009">        return this.max(Comparators.naturalOrder());</span>
    }

    @Override
    public &lt;VV extends Comparable&lt;? super VV&gt;&gt; V maxBy(Function&lt;? super V, ? extends VV&gt; function)
    {
<span class="nc bnc" id="L2015" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L2017">            throw new NoSuchElementException();</span>
        }

<span class="nc" id="L2020">        V max = null;</span>
<span class="nc" id="L2021">        boolean isMaxSet = false;</span>
<span class="nc" id="L2022">        VV maxValue = null;</span>

<span class="nc bnc" id="L2024" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L2026" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2028">                max = this.sentinelValues.zeroValue;</span>
<span class="nc" id="L2029">                isMaxSet = true;</span>
<span class="nc" id="L2030">                maxValue = function.valueOf(this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L2032" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2034">                VV nextValue = function.valueOf(this.sentinelValues.oneValue);</span>
<span class="nc bnc" id="L2035" title="All 4 branches missed.">                if (!isMaxSet || nextValue.compareTo(maxValue) &gt; 0)</span>
                {
<span class="nc" id="L2037">                    max = this.sentinelValues.oneValue;</span>
<span class="nc" id="L2038">                    isMaxSet = true;</span>
<span class="nc" id="L2039">                    maxValue = nextValue;</span>
                }
            }
        }
<span class="nc bnc" id="L2043" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L2045" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L2047">                V next = this.values[i];</span>
<span class="nc" id="L2048">                VV nextValue = function.valueOf(next);</span>
<span class="nc bnc" id="L2049" title="All 4 branches missed.">                if (!isMaxSet || nextValue.compareTo(maxValue) &gt; 0)</span>
                {
<span class="nc" id="L2051">                    max = next;</span>
<span class="nc" id="L2052">                    isMaxSet = true;</span>
<span class="nc" id="L2053">                    maxValue = nextValue;</span>
                }
            }
        }
<span class="nc" id="L2057">        return max;</span>
    }

    @Override
    public &lt;VV extends Comparable&lt;? super VV&gt;&gt; V minBy(Function&lt;? super V, ? extends VV&gt; function)
    {
<span class="nc bnc" id="L2063" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L2065">            throw new NoSuchElementException();</span>
        }

<span class="nc" id="L2068">        V min = null;</span>
<span class="nc" id="L2069">        boolean isMinSet = false;</span>
<span class="nc" id="L2070">        VV minValue = null;</span>

<span class="nc bnc" id="L2072" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L2074" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2076">                min = this.sentinelValues.zeroValue;</span>
<span class="nc" id="L2077">                isMinSet = true;</span>
<span class="nc" id="L2078">                minValue = function.valueOf(this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L2080" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2082">                VV nextValue = function.valueOf(this.sentinelValues.oneValue);</span>
<span class="nc bnc" id="L2083" title="All 4 branches missed.">                if (!isMinSet || nextValue.compareTo(minValue) &lt; 0)</span>
                {
<span class="nc" id="L2085">                    min = this.sentinelValues.oneValue;</span>
<span class="nc" id="L2086">                    isMinSet = true;</span>
<span class="nc" id="L2087">                    minValue = nextValue;</span>
                }
            }
        }
<span class="nc bnc" id="L2091" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L2093" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L2095">                V next = this.values[i];</span>
<span class="nc" id="L2096">                VV nextValue = function.valueOf(next);</span>
<span class="nc bnc" id="L2097" title="All 4 branches missed.">                if (!isMinSet || nextValue.compareTo(minValue) &lt; 0)</span>
                {
<span class="nc" id="L2099">                    min = next;</span>
<span class="nc" id="L2100">                    isMinSet = true;</span>
<span class="nc" id="L2101">                    minValue = nextValue;</span>
                }
            }
        }
<span class="nc" id="L2105">        return min;</span>
    }

    @Override
    public long sumOfInt(IntFunction&lt;? super V&gt; function)
    {
<span class="nc" id="L2111">        long sum = 0L;</span>

<span class="nc bnc" id="L2113" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L2115" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2117">                sum += function.intValueOf(this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L2119" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2121">                sum += function.intValueOf(this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L2124" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L2126" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L2128">                sum += function.intValueOf(this.values[i]);</span>
            }
        }
<span class="nc" id="L2131">        return sum;</span>
    }

    @Override
    public double sumOfFloat(FloatFunction&lt;? super V&gt; function)
    {
<span class="nc" id="L2137">        double sum = 0.0;</span>
<span class="nc" id="L2138">        double compensation = 0.0;</span>

<span class="nc bnc" id="L2140" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L2142" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2144">                double adjustedValue = function.floatValueOf(this.sentinelValues.zeroValue) - compensation;</span>
<span class="nc" id="L2145">                double nextSum = sum + adjustedValue;</span>
<span class="nc" id="L2146">                compensation = nextSum - sum - adjustedValue;</span>
<span class="nc" id="L2147">                sum = nextSum;</span>
            }
<span class="nc bnc" id="L2149" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2151">                double adjustedValue = function.floatValueOf(this.sentinelValues.oneValue) - compensation;</span>
<span class="nc" id="L2152">                double nextSum = sum + adjustedValue;</span>
<span class="nc" id="L2153">                compensation = nextSum - sum - adjustedValue;</span>
<span class="nc" id="L2154">                sum = nextSum;</span>
            }
        }
<span class="nc bnc" id="L2157" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L2159" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L2161">                double adjustedValue = function.floatValueOf(this.values[i]) - compensation;</span>
<span class="nc" id="L2162">                double nextSum = sum + adjustedValue;</span>
<span class="nc" id="L2163">                compensation = nextSum - sum - adjustedValue;</span>
<span class="nc" id="L2164">                sum = nextSum;</span>
            }
        }
<span class="nc" id="L2167">        return sum;</span>
    }

    @Override
    public long sumOfLong(LongFunction&lt;? super V&gt; function)
    {
<span class="nc" id="L2173">        long sum = 0L;</span>

<span class="nc bnc" id="L2175" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L2177" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2179">                sum += function.longValueOf(this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L2181" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2183">                sum += function.longValueOf(this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L2186" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L2188" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L2190">                sum += function.longValueOf(this.values[i]);</span>
            }
        }
<span class="nc" id="L2193">        return sum;</span>
    }

    @Override
    public double sumOfDouble(DoubleFunction&lt;? super V&gt; function)
    {
<span class="nc" id="L2199">        double sum = 0.0;</span>
<span class="nc" id="L2200">        double compensation = 0.0;</span>

<span class="nc bnc" id="L2202" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L2204" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2206">                double adjustedValue = function.doubleValueOf(this.sentinelValues.zeroValue) - compensation;</span>
<span class="nc" id="L2207">                double nextSum = sum + adjustedValue;</span>
<span class="nc" id="L2208">                compensation = nextSum - sum - adjustedValue;</span>
<span class="nc" id="L2209">                sum = nextSum;</span>
            }
<span class="nc bnc" id="L2211" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2213">                double adjustedValue = function.doubleValueOf(this.sentinelValues.oneValue) - compensation;</span>
<span class="nc" id="L2214">                double nextSum = sum + adjustedValue;</span>
<span class="nc" id="L2215">                compensation = nextSum - sum - adjustedValue;</span>
<span class="nc" id="L2216">                sum = nextSum;</span>
            }
        }
<span class="nc bnc" id="L2219" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L2221" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L2223">                double adjustedValue = function.doubleValueOf(this.values[i]) - compensation;</span>
<span class="nc" id="L2224">                double nextSum = sum + adjustedValue;</span>
<span class="nc" id="L2225">                compensation = nextSum - sum - adjustedValue;</span>
<span class="nc" id="L2226">                sum = nextSum;</span>
            }
        }
<span class="nc" id="L2229">        return sum;</span>
    }

    @Override
    public &lt;V1&gt; MutableObjectLongMap&lt;V1&gt; sumByInt(Function&lt;? super V, ? extends V1&gt; groupBy, IntFunction&lt;? super V&gt; function)
    {
<span class="nc" id="L2235">        MutableObjectLongMap&lt;V1&gt; result = ObjectLongMaps.mutable.empty();</span>
<span class="nc" id="L2236">        return this.injectInto(result, PrimitiveFunctions.sumByIntFunction(groupBy, function));</span>
    }

    @Override
    public &lt;V1&gt; MutableObjectDoubleMap&lt;V1&gt; sumByFloat(Function&lt;? super V, ? extends V1&gt; groupBy, FloatFunction&lt;? super V&gt; function)
    {
<span class="nc" id="L2242">        MutableObjectDoubleMap&lt;V1&gt; result = ObjectDoubleMaps.mutable.empty();</span>
<span class="nc" id="L2243">        return this.injectInto(result, PrimitiveFunctions.sumByFloatFunction(groupBy, function));</span>
    }

    @Override
    public &lt;V1&gt; MutableObjectLongMap&lt;V1&gt; sumByLong(Function&lt;? super V, ? extends V1&gt; groupBy, LongFunction&lt;? super V&gt; function)
    {
<span class="nc" id="L2249">        MutableObjectLongMap&lt;V1&gt; result = ObjectLongMaps.mutable.empty();</span>
<span class="nc" id="L2250">        return this.injectInto(result, PrimitiveFunctions.sumByLongFunction(groupBy, function));</span>
    }

    @Override
    public &lt;V1&gt; MutableObjectDoubleMap&lt;V1&gt; sumByDouble(Function&lt;? super V, ? extends V1&gt; groupBy, DoubleFunction&lt;? super V&gt; function)
    {
<span class="nc" id="L2256">        MutableObjectDoubleMap&lt;V1&gt; result = ObjectDoubleMaps.mutable.empty();</span>
<span class="nc" id="L2257">        return this.injectInto(result, PrimitiveFunctions.sumByDoubleFunction(groupBy, function));</span>
    }

    @Override
    public void clear()
    {
<span class="nc" id="L2263">        this.sentinelValues = null;</span>
<span class="nc" id="L2264">        this.occupiedWithData = 0;</span>
<span class="nc" id="L2265">        this.occupiedWithSentinels = 0;</span>
<span class="nc bnc" id="L2266" title="All 2 branches missed.">        if (this.copyKeysOnWrite)</span>
        {
<span class="nc" id="L2268">            this.keys = new byte[this.keys.length];</span>
<span class="nc" id="L2269">            this.copyKeysOnWrite = false;</span>
        }
<span class="nc" id="L2271">        Arrays.fill(this.keys, EMPTY_KEY);</span>
<span class="nc" id="L2272">        Arrays.fill(this.values, null);</span>
<span class="nc" id="L2273">    }</span>

    @Override
    public V put(byte key, V value)
    {
<span class="nc bnc" id="L2278" title="All 2 branches missed.">        if (isEmptyKey(key))</span>
        {
<span class="nc bnc" id="L2280" title="All 2 branches missed.">            if (this.sentinelValues == null)</span>
            {
<span class="nc" id="L2282">                this.sentinelValues = new SentinelValues&lt;&gt;();</span>
            }
<span class="nc" id="L2284">            V oldValue = this.sentinelValues.zeroValue;</span>
<span class="nc" id="L2285">            this.sentinelValues.containsZeroKey = true;</span>
<span class="nc" id="L2286">            this.sentinelValues.zeroValue = value;</span>
<span class="nc" id="L2287">            return oldValue;</span>
        }

<span class="nc bnc" id="L2290" title="All 2 branches missed.">        if (isRemovedKey(key))</span>
        {
<span class="nc bnc" id="L2292" title="All 2 branches missed.">            if (this.sentinelValues == null)</span>
            {
<span class="nc" id="L2294">                this.sentinelValues = new SentinelValues&lt;&gt;();</span>
            }
<span class="nc" id="L2296">            V oldValue = this.sentinelValues.oneValue;</span>
<span class="nc" id="L2297">            this.sentinelValues.containsOneKey = true;</span>
<span class="nc" id="L2298">            this.sentinelValues.oneValue = value;</span>
<span class="nc" id="L2299">            return oldValue;</span>
        }

<span class="nc" id="L2302">        int index = this.probe(key);</span>

<span class="nc bnc" id="L2304" title="All 2 branches missed.">        if (this.keys[index] == key)</span>
        {
            // key already present in map
<span class="nc" id="L2307">            V oldValue = this.values[index];</span>
<span class="nc" id="L2308">            this.values[index] = value;</span>
<span class="nc" id="L2309">            return oldValue;</span>
        }

<span class="nc" id="L2312">        this.addKeyValueAtIndex(key, value, index);</span>
<span class="nc" id="L2313">        return null;</span>
    }

    @Override
    public void putAll(ByteObjectMap&lt;? extends V&gt; map)
    {
<span class="nc" id="L2319">        map.forEachKeyValue((byte key, V value) -&gt; ByteObjectHashMap.this.put(key, value));</span>
<span class="nc" id="L2320">    }</span>

    @Override
    public boolean containsKey(byte key)
    {
<span class="nc bnc" id="L2325" title="All 2 branches missed.">        if (isEmptyKey(key))</span>
        {
<span class="nc bnc" id="L2327" title="All 4 branches missed.">            return this.sentinelValues != null &amp;&amp; this.sentinelValues.containsZeroKey;</span>
        }
<span class="nc bnc" id="L2329" title="All 2 branches missed.">        if (isRemovedKey(key))</span>
        {
<span class="nc bnc" id="L2331" title="All 4 branches missed.">            return this.sentinelValues != null &amp;&amp; this.sentinelValues.containsOneKey;</span>
        }
<span class="nc bnc" id="L2333" title="All 2 branches missed.">        return this.keys[this.probe(key)] == key;</span>
    }

    @Override
    public boolean containsValue(Object value)
    {
<span class="nc bnc" id="L2339" title="All 4 branches missed.">        if (this.sentinelValues != null &amp;&amp; this.sentinelValues.containsValue((V) value))</span>
        {
<span class="nc" id="L2341">            return true;</span>
        }
<span class="nc bnc" id="L2343" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L2345" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; nullSafeEquals(this.values[i], value))</span>
            {
<span class="nc" id="L2347">                return true;</span>
            }
        }
<span class="nc" id="L2350">        return false;</span>
    }

    @Override
    public V get(byte key)
    {
<span class="nc" id="L2356">        return this.getIfAbsent(key, Functions0.&lt;V&gt;nullValue());</span>
    }

    @Override
    public V getIfAbsent(byte key, Function0&lt;? extends V&gt; ifAbsent)
    {
<span class="nc bnc" id="L2362" title="All 2 branches missed.">        if (isEmptyKey(key))</span>
        {
<span class="nc bnc" id="L2364" title="All 4 branches missed.">            if (this.sentinelValues == null || !this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2366">                return ifAbsent.value();</span>
            }
<span class="nc" id="L2368">            return this.sentinelValues.zeroValue;</span>
        }
<span class="nc bnc" id="L2370" title="All 2 branches missed.">        if (isRemovedKey(key))</span>
        {
<span class="nc bnc" id="L2372" title="All 4 branches missed.">            if (this.sentinelValues == null || !this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2374">                return ifAbsent.value();</span>
            }
<span class="nc" id="L2376">            return this.sentinelValues.oneValue;</span>
        }
<span class="nc" id="L2378">        int index = this.probe(key);</span>
<span class="nc bnc" id="L2379" title="All 2 branches missed.">        if (this.keys[index] == key)</span>
        {
<span class="nc" id="L2381">            return this.values[index];</span>
        }
<span class="nc" id="L2383">        return ifAbsent.value();</span>
    }

    @Override
    public V getIfAbsentPut(byte key, V value)
    {
<span class="nc bnc" id="L2389" title="All 2 branches missed.">        if (isEmptyKey(key))</span>
        {
<span class="nc bnc" id="L2391" title="All 2 branches missed.">            if (this.sentinelValues == null)</span>
            {
<span class="nc" id="L2393">                this.sentinelValues = new SentinelValues&lt;&gt;();</span>
<span class="nc" id="L2394">                this.sentinelValues.containsZeroKey = true;</span>
<span class="nc" id="L2395">                this.sentinelValues.zeroValue = value;</span>
<span class="nc" id="L2396">                return value;</span>
            }
<span class="nc bnc" id="L2398" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2400">                return this.sentinelValues.zeroValue;</span>
            }
<span class="nc" id="L2402">            this.sentinelValues.containsZeroKey = true;</span>
<span class="nc" id="L2403">            this.sentinelValues.zeroValue = value;</span>
<span class="nc" id="L2404">            return value;</span>
        }
<span class="nc bnc" id="L2406" title="All 2 branches missed.">        if (isRemovedKey(key))</span>
        {
<span class="nc bnc" id="L2408" title="All 2 branches missed.">            if (this.sentinelValues == null)</span>
            {
<span class="nc" id="L2410">                this.sentinelValues = new SentinelValues&lt;&gt;();</span>
<span class="nc" id="L2411">                this.sentinelValues.containsOneKey = true;</span>
<span class="nc" id="L2412">                this.sentinelValues.oneValue = value;</span>
<span class="nc" id="L2413">                return value;</span>
            }
<span class="nc bnc" id="L2415" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2417">                return this.sentinelValues.oneValue;</span>
            }
<span class="nc" id="L2419">            this.sentinelValues.containsOneKey = true;</span>
<span class="nc" id="L2420">            this.sentinelValues.oneValue = value;</span>
<span class="nc" id="L2421">            return value;</span>
        }
<span class="nc" id="L2423">        int index = this.probe(key);</span>
<span class="nc bnc" id="L2424" title="All 2 branches missed.">        if (this.keys[index] == key)</span>
        {
<span class="nc" id="L2426">            return this.values[index];</span>
        }
<span class="nc" id="L2428">        this.addKeyValueAtIndex(key, value, index);</span>
<span class="nc" id="L2429">        return value;</span>
    }

    @Override
    public V getIfAbsentPut(byte key, Function0&lt;? extends V&gt; function)
    {
<span class="nc bnc" id="L2435" title="All 2 branches missed.">        if (isEmptyKey(key))</span>
        {
<span class="nc bnc" id="L2437" title="All 2 branches missed.">            if (this.sentinelValues == null)</span>
            {
<span class="nc" id="L2439">                V value = function.value();</span>
<span class="nc" id="L2440">                this.sentinelValues = new SentinelValues&lt;&gt;();</span>
<span class="nc" id="L2441">                this.sentinelValues.containsZeroKey = true;</span>
<span class="nc" id="L2442">                this.sentinelValues.zeroValue = value;</span>
<span class="nc" id="L2443">                return value;</span>
            }
<span class="nc bnc" id="L2445" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2447">                return this.sentinelValues.zeroValue;</span>
            }
<span class="nc" id="L2449">            V value = function.value();</span>
<span class="nc" id="L2450">            this.sentinelValues.containsZeroKey = true;</span>
<span class="nc" id="L2451">            this.sentinelValues.zeroValue = value;</span>
<span class="nc" id="L2452">            return value;</span>
        }
<span class="nc bnc" id="L2454" title="All 2 branches missed.">        if (isRemovedKey(key))</span>
        {
<span class="nc bnc" id="L2456" title="All 2 branches missed.">            if (this.sentinelValues == null)</span>
            {
<span class="nc" id="L2458">                V value = function.value();</span>
<span class="nc" id="L2459">                this.sentinelValues = new SentinelValues&lt;&gt;();</span>
<span class="nc" id="L2460">                this.sentinelValues.containsOneKey = true;</span>
<span class="nc" id="L2461">                this.sentinelValues.oneValue = value;</span>
<span class="nc" id="L2462">                return value;</span>
            }
<span class="nc bnc" id="L2464" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2466">                return this.sentinelValues.oneValue;</span>
            }
<span class="nc" id="L2468">            V value = function.value();</span>
<span class="nc" id="L2469">            this.sentinelValues.containsOneKey = true;</span>
<span class="nc" id="L2470">            this.sentinelValues.oneValue = value;</span>
<span class="nc" id="L2471">            return value;</span>
        }
<span class="nc" id="L2473">        int index = this.probe(key);</span>
<span class="nc bnc" id="L2474" title="All 2 branches missed.">        if (this.keys[index] == key)</span>
        {
<span class="nc" id="L2476">            return this.values[index];</span>
        }
<span class="nc" id="L2478">        V value = function.value();</span>
<span class="nc" id="L2479">        this.addKeyValueAtIndex(key, value, index);</span>
<span class="nc" id="L2480">        return value;</span>
    }

    @Override
    public &lt;P&gt; V getIfAbsentPutWith(byte key, Function&lt;? super P, ? extends V&gt; function, P parameter)
    {
<span class="nc bnc" id="L2486" title="All 2 branches missed.">        if (isEmptyKey(key))</span>
        {
<span class="nc bnc" id="L2488" title="All 2 branches missed.">            if (this.sentinelValues == null)</span>
            {
<span class="nc" id="L2490">                V value = function.valueOf(parameter);</span>
<span class="nc" id="L2491">                this.sentinelValues = new SentinelValues&lt;&gt;();</span>
<span class="nc" id="L2492">                this.sentinelValues.containsZeroKey = true;</span>
<span class="nc" id="L2493">                this.sentinelValues.zeroValue = value;</span>
<span class="nc" id="L2494">                return value;</span>
            }
<span class="nc bnc" id="L2496" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2498">                return this.sentinelValues.zeroValue;</span>
            }
<span class="nc" id="L2500">            V value = function.valueOf(parameter);</span>
<span class="nc" id="L2501">            this.sentinelValues.containsZeroKey = true;</span>
<span class="nc" id="L2502">            this.sentinelValues.zeroValue = value;</span>
<span class="nc" id="L2503">            return value;</span>
        }
<span class="nc bnc" id="L2505" title="All 2 branches missed.">        if (isRemovedKey(key))</span>
        {
<span class="nc bnc" id="L2507" title="All 2 branches missed.">            if (this.sentinelValues == null)</span>
            {
<span class="nc" id="L2509">                V value = function.valueOf(parameter);</span>
<span class="nc" id="L2510">                this.sentinelValues = new SentinelValues&lt;&gt;();</span>
<span class="nc" id="L2511">                this.sentinelValues.containsOneKey = true;</span>
<span class="nc" id="L2512">                this.sentinelValues.oneValue = value;</span>
<span class="nc" id="L2513">                return value;</span>
            }
<span class="nc bnc" id="L2515" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2517">                return this.sentinelValues.oneValue;</span>
            }
<span class="nc" id="L2519">            V value = function.valueOf(parameter);</span>
<span class="nc" id="L2520">            this.sentinelValues.containsOneKey = true;</span>
<span class="nc" id="L2521">            this.sentinelValues.oneValue = value;</span>
<span class="nc" id="L2522">            return value;</span>
        }
<span class="nc" id="L2524">        int index = this.probe(key);</span>
<span class="nc bnc" id="L2525" title="All 2 branches missed.">        if (this.keys[index] == key)</span>
        {
<span class="nc" id="L2527">            return this.values[index];</span>
        }
<span class="nc" id="L2529">        V value = function.valueOf(parameter);</span>
<span class="nc" id="L2530">        this.addKeyValueAtIndex(key, value, index);</span>
<span class="nc" id="L2531">        return value;</span>
    }

    @Override
    public V getIfAbsentPutWithKey(byte key, ByteToObjectFunction&lt;? extends V&gt; function)
    {
<span class="nc bnc" id="L2537" title="All 2 branches missed.">        if (isEmptyKey(key))</span>
        {
<span class="nc bnc" id="L2539" title="All 2 branches missed.">            if (this.sentinelValues == null)</span>
            {
<span class="nc" id="L2541">                V value = function.valueOf(key);</span>
<span class="nc" id="L2542">                this.sentinelValues = new SentinelValues&lt;&gt;();</span>
<span class="nc" id="L2543">                this.sentinelValues.containsZeroKey = true;</span>
<span class="nc" id="L2544">                this.sentinelValues.zeroValue = value;</span>
<span class="nc" id="L2545">                return value;</span>
            }
<span class="nc bnc" id="L2547" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2549">                return this.sentinelValues.zeroValue;</span>
            }
<span class="nc" id="L2551">            V value = function.valueOf(key);</span>
<span class="nc" id="L2552">            this.sentinelValues.containsZeroKey = true;</span>
<span class="nc" id="L2553">            this.sentinelValues.zeroValue = value;</span>
<span class="nc" id="L2554">            return value;</span>
        }
<span class="nc bnc" id="L2556" title="All 2 branches missed.">        if (isRemovedKey(key))</span>
        {
<span class="nc bnc" id="L2558" title="All 2 branches missed.">            if (this.sentinelValues == null)</span>
            {
<span class="nc" id="L2560">                V value = function.valueOf(key);</span>
<span class="nc" id="L2561">                this.sentinelValues = new SentinelValues&lt;&gt;();</span>
<span class="nc" id="L2562">                this.sentinelValues.containsOneKey = true;</span>
<span class="nc" id="L2563">                this.sentinelValues.oneValue = value;</span>
<span class="nc" id="L2564">                return value;</span>
            }
<span class="nc bnc" id="L2566" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2568">                return this.sentinelValues.oneValue;</span>
            }
<span class="nc" id="L2570">            V value = function.valueOf(key);</span>
<span class="nc" id="L2571">            this.sentinelValues.containsOneKey = true;</span>
<span class="nc" id="L2572">            this.sentinelValues.oneValue = value;</span>
<span class="nc" id="L2573">            return value;</span>
        }
<span class="nc" id="L2575">        int index = this.probe(key);</span>
<span class="nc bnc" id="L2576" title="All 2 branches missed.">        if (this.keys[index] == key)</span>
        {
<span class="nc" id="L2578">            return this.values[index];</span>
        }
<span class="nc" id="L2580">        V value = function.valueOf(key);</span>
<span class="nc" id="L2581">        this.addKeyValueAtIndex(key, value, index);</span>
<span class="nc" id="L2582">        return value;</span>
    }

    @Override
    public V updateValue(byte key, Function0&lt;? extends V&gt; factory, Function&lt;? super V, ? extends V&gt; function)
    {
<span class="nc bnc" id="L2588" title="All 2 branches missed.">        if (isEmptyKey(key))</span>
        {
<span class="nc bnc" id="L2590" title="All 2 branches missed.">            if (this.sentinelValues == null)</span>
            {
<span class="nc" id="L2592">                this.sentinelValues = new SentinelValues&lt;&gt;();</span>
<span class="nc" id="L2593">                this.sentinelValues.containsZeroKey = true;</span>
<span class="nc" id="L2594">                this.sentinelValues.zeroValue = function.valueOf(factory.value());</span>
            }
<span class="nc bnc" id="L2596" title="All 2 branches missed.">            else if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2598">                this.sentinelValues.zeroValue = function.valueOf(this.sentinelValues.zeroValue);</span>
            }
            else
            {
<span class="nc" id="L2602">                this.sentinelValues.containsZeroKey = true;</span>
<span class="nc" id="L2603">                this.sentinelValues.zeroValue = function.valueOf(factory.value());</span>
            }
<span class="nc" id="L2605">            return this.sentinelValues.zeroValue;</span>
        }
<span class="nc bnc" id="L2607" title="All 2 branches missed.">        if (isRemovedKey(key))</span>
        {
<span class="nc bnc" id="L2609" title="All 2 branches missed.">            if (this.sentinelValues == null)</span>
            {
<span class="nc" id="L2611">                this.sentinelValues = new SentinelValues&lt;&gt;();</span>
<span class="nc" id="L2612">                this.sentinelValues.containsOneKey = true;</span>
<span class="nc" id="L2613">                this.sentinelValues.oneValue = function.valueOf(factory.value());</span>
            }
<span class="nc bnc" id="L2615" title="All 2 branches missed.">            else if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2617">                this.sentinelValues.oneValue = function.valueOf(this.sentinelValues.oneValue);</span>
            }
            else
            {
<span class="nc" id="L2621">                this.sentinelValues.containsOneKey = true;</span>
<span class="nc" id="L2622">                this.sentinelValues.oneValue = function.valueOf(factory.value());</span>
            }
<span class="nc" id="L2624">            return this.sentinelValues.oneValue;</span>
        }
<span class="nc" id="L2626">        int index = this.probe(key);</span>
<span class="nc bnc" id="L2627" title="All 2 branches missed.">        if (this.keys[index] == key)</span>
        {
<span class="nc" id="L2629">            this.values[index] = function.valueOf(this.values[index]);</span>
<span class="nc" id="L2630">            return this.values[index];</span>
        }
<span class="nc" id="L2632">        V value = function.valueOf(factory.value());</span>
<span class="nc" id="L2633">        this.addKeyValueAtIndex(key, value, index);</span>
<span class="nc" id="L2634">        return value;</span>
    }

    @Override
    public &lt;P&gt; V updateValueWith(byte key, Function0&lt;? extends V&gt; factory, Function2&lt;? super V, ? super P, ? extends V&gt; function, P parameter)
    {
<span class="nc bnc" id="L2640" title="All 2 branches missed.">        if (isEmptyKey(key))</span>
        {
<span class="nc bnc" id="L2642" title="All 2 branches missed.">            if (this.sentinelValues == null)</span>
            {
<span class="nc" id="L2644">                this.sentinelValues = new SentinelValues&lt;&gt;();</span>
<span class="nc" id="L2645">                this.sentinelValues.containsZeroKey = true;</span>
<span class="nc" id="L2646">                this.sentinelValues.zeroValue = function.value(factory.value(), parameter);</span>
            }
<span class="nc bnc" id="L2648" title="All 2 branches missed.">            else if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2650">                this.sentinelValues.zeroValue = function.value(this.sentinelValues.zeroValue, parameter);</span>
            }
            else
            {
<span class="nc" id="L2654">                this.sentinelValues.containsZeroKey = true;</span>
<span class="nc" id="L2655">                this.sentinelValues.zeroValue = function.value(factory.value(), parameter);</span>
            }
<span class="nc" id="L2657">            return this.sentinelValues.zeroValue;</span>
        }
<span class="nc bnc" id="L2659" title="All 2 branches missed.">        if (isRemovedKey(key))</span>
        {
<span class="nc bnc" id="L2661" title="All 2 branches missed.">            if (this.sentinelValues == null)</span>
            {
<span class="nc" id="L2663">                this.sentinelValues = new SentinelValues&lt;&gt;();</span>
<span class="nc" id="L2664">                this.sentinelValues.containsOneKey = true;</span>
<span class="nc" id="L2665">                this.sentinelValues.oneValue = function.value(factory.value(), parameter);</span>
            }
<span class="nc bnc" id="L2667" title="All 2 branches missed.">            else if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2669">                this.sentinelValues.oneValue = function.value(this.sentinelValues.oneValue, parameter);</span>
            }
            else
            {
<span class="nc" id="L2673">                this.sentinelValues.containsOneKey = true;</span>
<span class="nc" id="L2674">                this.sentinelValues.oneValue = function.value(factory.value(), parameter);</span>
            }
<span class="nc" id="L2676">            return this.sentinelValues.oneValue;</span>
        }
<span class="nc" id="L2678">        int index = this.probe(key);</span>
<span class="nc bnc" id="L2679" title="All 2 branches missed.">        if (this.keys[index] == key)</span>
        {
<span class="nc" id="L2681">            this.values[index] = function.value(this.values[index], parameter);</span>
<span class="nc" id="L2682">            return this.values[index];</span>
        }
<span class="nc" id="L2684">        V value =  function.value(factory.value(), parameter);</span>
<span class="nc" id="L2685">        this.addKeyValueAtIndex(key, value, index);</span>
<span class="nc" id="L2686">        return value;</span>
    }

    @Override
    public V removeKey(byte key)
    {
<span class="nc bnc" id="L2692" title="All 2 branches missed.">        if (isEmptyKey(key))</span>
        {
<span class="nc bnc" id="L2694" title="All 4 branches missed.">            if (this.sentinelValues == null || !this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2696">                return null;</span>
            }
<span class="nc" id="L2698">            V oldValue = this.sentinelValues.zeroValue;</span>
<span class="nc bnc" id="L2699" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2701">                this.sentinelValues.containsZeroKey = false;</span>
<span class="nc" id="L2702">                this.sentinelValues.zeroValue = null;</span>
            }
            else
            {
<span class="nc" id="L2706">                this.sentinelValues = null;</span>
            }
<span class="nc" id="L2708">            return oldValue;</span>
        }
<span class="nc bnc" id="L2710" title="All 2 branches missed.">        if (isRemovedKey(key))</span>
        {
<span class="nc bnc" id="L2712" title="All 4 branches missed.">            if (this.sentinelValues == null || !this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2714">                return null;</span>
            }
<span class="nc" id="L2716">            V oldValue = this.sentinelValues.oneValue;</span>
<span class="nc bnc" id="L2717" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2719">                this.sentinelValues.containsOneKey = false;</span>
<span class="nc" id="L2720">                this.sentinelValues.oneValue = null;</span>
            }
            else
            {
<span class="nc" id="L2724">                this.sentinelValues = null;</span>
            }
<span class="nc" id="L2726">            return oldValue;</span>
        }
<span class="nc" id="L2728">        int index = this.probe(key);</span>
<span class="nc bnc" id="L2729" title="All 2 branches missed.">        if (this.keys[index] == key)</span>
        {
<span class="nc" id="L2731">            V oldValue = this.values[index];</span>
<span class="nc" id="L2732">            this.removeKeyAtIndex(index);</span>
<span class="nc" id="L2733">            return oldValue;</span>
        }
<span class="nc" id="L2735">        return null;</span>
    }

    @Override
    public V remove(byte key)
    {
<span class="nc" id="L2741">        return this.removeKey(key);</span>
    }

    @Override
    public ByteObjectHashMap&lt;V&gt; withKeyValue(byte key, V value)
    {
<span class="nc" id="L2747">        this.put(key, value);</span>
<span class="nc" id="L2748">        return this;</span>
    }

    @Override
    public MutableByteObjectMap&lt;V&gt; withoutKey(byte key)
    {
<span class="nc" id="L2754">        this.removeKey(key);</span>
<span class="nc" id="L2755">        return this;</span>
    }

    @Override
    public MutableByteObjectMap&lt;V&gt; withoutAllKeys(ByteIterable keys)
    {
<span class="nc" id="L2761">        ByteIterator iterator = keys.byteIterator();</span>
<span class="nc bnc" id="L2762" title="All 2 branches missed.">        while (iterator.hasNext())</span>
        {
<span class="nc" id="L2764">            byte item = iterator.next();</span>
<span class="nc" id="L2765">            this.removeKey(item);</span>
<span class="nc" id="L2766">        }</span>
<span class="nc" id="L2767">        return this;</span>
    }

    public ByteObjectHashMap&lt;V&gt; withKeysValues(byte key1, V value1, byte key2, V value2)
    {
<span class="nc" id="L2772">        this.put(key1, value1);</span>
<span class="nc" id="L2773">        this.put(key2, value2);</span>
<span class="nc" id="L2774">        return this;</span>
    }

    public ByteObjectHashMap&lt;V&gt; withKeysValues(byte key1, V value1, byte key2, V value2, byte key3, V value3)
    {
<span class="nc" id="L2779">        this.put(key1, value1);</span>
<span class="nc" id="L2780">        this.put(key2, value2);</span>
<span class="nc" id="L2781">        this.put(key3, value3);</span>
<span class="nc" id="L2782">        return this;</span>
    }

    public ByteObjectHashMap&lt;V&gt; withKeysValues(byte key1, V value1, byte key2, V value2, byte key3, V value3, byte key4, V value4)
    {
<span class="nc" id="L2787">        this.put(key1, value1);</span>
<span class="nc" id="L2788">        this.put(key2, value2);</span>
<span class="nc" id="L2789">        this.put(key3, value3);</span>
<span class="nc" id="L2790">        this.put(key4, value4);</span>
<span class="nc" id="L2791">        return this;</span>
    }

    @Override
    public MutableByteObjectMap&lt;V&gt; asUnmodifiable()
    {
<span class="nc" id="L2797">        return new UnmodifiableByteObjectMap&lt;&gt;(this);</span>
    }

    @Override
    public MutableByteObjectMap&lt;V&gt; asSynchronized()
    {
<span class="nc" id="L2803">        return new SynchronizedByteObjectMap&lt;&gt;(this);</span>
    }

    @Override
    public ImmutableByteObjectMap&lt;V&gt; toImmutable()
    {
<span class="nc" id="L2809">        return ByteObjectMaps.immutable.withAll(this);</span>
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException
    {
<span class="nc" id="L2815">        out.writeInt(this.size());</span>
<span class="nc bnc" id="L2816" title="All 2 branches missed.">        if (this.sentinelValues != null)</span>
        {
<span class="nc bnc" id="L2818" title="All 2 branches missed.">            if (this.sentinelValues.containsZeroKey)</span>
            {
<span class="nc" id="L2820">                out.writeByte(EMPTY_KEY);</span>
<span class="nc" id="L2821">                out.writeObject(this.sentinelValues.zeroValue);</span>
            }
<span class="nc bnc" id="L2823" title="All 2 branches missed.">            if (this.sentinelValues.containsOneKey)</span>
            {
<span class="nc" id="L2825">                out.writeByte(REMOVED_KEY);</span>
<span class="nc" id="L2826">                out.writeObject(this.sentinelValues.oneValue);</span>
            }
        }
<span class="nc bnc" id="L2829" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L2831" title="All 2 branches missed.">            if (isNonSentinel(this.keys[i]))</span>
            {
<span class="nc" id="L2833">                out.writeByte(this.keys[i]);</span>
<span class="nc" id="L2834">                out.writeObject(this.values[i]);</span>
            }
        }
<span class="nc" id="L2837">    }</span>

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
    {
<span class="nc" id="L2842">        int size = in.readInt();</span>
<span class="nc bnc" id="L2843" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L2845">            this.put(in.readByte(), (V) in.readObject());</span>
        }
<span class="nc" id="L2847">    }</span>

    private void addKeyValueAtIndex(byte key, V value, int index)
    {
<span class="nc bnc" id="L2851" title="All 2 branches missed.">        if (this.keys[index] == REMOVED_KEY)</span>
        {
<span class="nc" id="L2853">            this.occupiedWithSentinels--;</span>
        }
<span class="nc bnc" id="L2855" title="All 2 branches missed.">        if (this.copyKeysOnWrite)</span>
        {
<span class="nc" id="L2857">            this.copyKeys();</span>
        }
<span class="nc" id="L2859">        this.keys[index] = key;</span>
<span class="nc" id="L2860">        this.values[index] = value;</span>
<span class="nc" id="L2861">        ++this.occupiedWithData;</span>
<span class="nc bnc" id="L2862" title="All 2 branches missed.">        if (this.occupiedWithData &gt; this.maxOccupiedWithData())</span>
        {
<span class="nc" id="L2864">            this.rehashAndGrow();</span>
        }
<span class="nc" id="L2866">    }</span>

    private void removeKeyAtIndex(int index)
    {
<span class="nc bnc" id="L2870" title="All 2 branches missed.">        if (this.copyKeysOnWrite)</span>
        {
<span class="nc" id="L2872">            this.copyKeys();</span>
        }
<span class="nc" id="L2874">        this.keys[index] = REMOVED_KEY;</span>
<span class="nc" id="L2875">        this.values[index] = null;</span>
<span class="nc" id="L2876">        this.occupiedWithData--;</span>
<span class="nc" id="L2877">        this.occupiedWithSentinels++;</span>
<span class="nc bnc" id="L2878" title="All 2 branches missed.">        if (this.occupiedWithSentinels &gt; this.maxOccupiedWithSentinels())</span>
        {
<span class="nc" id="L2880">            this.rehash();</span>
        }
<span class="nc" id="L2882">    }</span>

    private void copyKeys()
    {
<span class="nc" id="L2886">        byte[] copy = new byte[this.keys.length];</span>
<span class="nc" id="L2887">        System.arraycopy(this.keys, 0, copy, 0, this.keys.length);</span>
<span class="nc" id="L2888">        this.keys = copy;</span>
<span class="nc" id="L2889">        this.copyKeysOnWrite = false;</span>
<span class="nc" id="L2890">    }</span>

    private static final class SentinelValues&lt;V&gt;
    {
        private boolean containsZeroKey;
        private boolean containsOneKey;
        private V zeroValue;
        private V oneValue;

        public int size()
        {
<span class="nc bnc" id="L2901" title="All 4 branches missed.">            return (this.containsZeroKey ? 1 : 0) + (this.containsOneKey ? 1 : 0);</span>
        }

        public boolean containsValue(V value)
        {
<span class="nc bnc" id="L2906" title="All 4 branches missed.">            boolean valueEqualsZeroValue = this.containsZeroKey &amp;&amp; nullSafeEquals(this.zeroValue, value);</span>
<span class="nc bnc" id="L2907" title="All 4 branches missed.">            boolean valueEqualsOneValue = this.containsOneKey &amp;&amp; nullSafeEquals(this.oneValue, value);</span>
<span class="nc bnc" id="L2908" title="All 4 branches missed.">            return valueEqualsZeroValue || valueEqualsOneValue;</span>
        }
    }

    private static boolean nullSafeEquals(Object value, Object other)
    {
<span class="nc bnc" id="L2914" title="All 2 branches missed.">        if (value == null)</span>
        {
<span class="nc bnc" id="L2916" title="All 2 branches missed.">            if (other == null)</span>
            {
<span class="nc" id="L2918">                return true;</span>
            }
        }
<span class="nc bnc" id="L2921" title="All 4 branches missed.">        else if (other == value || value.equals(other))</span>
        {
<span class="nc" id="L2923">            return true;</span>
        }
<span class="nc" id="L2925">        return false;</span>
    }

<span class="nc" id="L2928">    private class InternalIterator implements Iterator&lt;V&gt;</span>
    {
        private int count;
        private int position;
        private byte currentKey;
        private boolean isCurrentKeySet;
        private boolean handledZeroKey;
        private boolean handledOneKey;

        @Override
        public boolean hasNext()
        {
<span class="nc bnc" id="L2940" title="All 2 branches missed.">            return this.count != ByteObjectHashMap.this.size();</span>
        }

        @Override
        public V next()
        {
<span class="nc bnc" id="L2946" title="All 2 branches missed.">            if (!this.hasNext())</span>
            {
<span class="nc" id="L2948">                throw new NoSuchElementException();</span>
            }
<span class="nc" id="L2950">            this.count++;</span>
<span class="nc bnc" id="L2951" title="All 2 branches missed.">            if (!this.handledZeroKey)</span>
            {
<span class="nc" id="L2953">                this.handledZeroKey = true;</span>
<span class="nc bnc" id="L2954" title="All 2 branches missed.">                if (ByteObjectHashMap.this.containsKey(EMPTY_KEY))</span>
                {
<span class="nc" id="L2956">                    this.currentKey = ByteObjectHashMap.EMPTY_KEY;</span>
<span class="nc" id="L2957">                    this.isCurrentKeySet = true;</span>
<span class="nc" id="L2958">                    return ByteObjectHashMap.this.sentinelValues.zeroValue;</span>
                }
            }
<span class="nc bnc" id="L2961" title="All 2 branches missed.">            if (!this.handledOneKey)</span>
            {
<span class="nc" id="L2963">                this.handledOneKey = true;</span>
<span class="nc bnc" id="L2964" title="All 2 branches missed.">                if (ByteObjectHashMap.this.containsKey(REMOVED_KEY))</span>
                {
<span class="nc" id="L2966">                    this.currentKey = ByteObjectHashMap.REMOVED_KEY;</span>
<span class="nc" id="L2967">                    this.isCurrentKeySet = true;</span>
<span class="nc" id="L2968">                    return ByteObjectHashMap.this.sentinelValues.oneValue;</span>
                }
            }
<span class="nc" id="L2971">            byte[] keys = ByteObjectHashMap.this.keys;</span>
<span class="nc bnc" id="L2972" title="All 2 branches missed.">            while (!isNonSentinel(keys[this.position]))</span>
            {
<span class="nc" id="L2974">                this.position++;</span>
            }
<span class="nc" id="L2976">            this.currentKey = ByteObjectHashMap.this.keys[this.position];</span>
<span class="nc" id="L2977">            this.isCurrentKeySet = true;</span>
<span class="nc" id="L2978">            V result = ByteObjectHashMap.this.values[this.position];</span>
<span class="nc" id="L2979">            this.position++;</span>
<span class="nc" id="L2980">            return result;</span>
        }

        @Override
        public void remove()
        {
<span class="nc bnc" id="L2986" title="All 2 branches missed.">            if (!this.isCurrentKeySet)</span>
            {
<span class="nc" id="L2988">                throw new IllegalStateException();</span>
            }

<span class="nc" id="L2991">            this.isCurrentKeySet = false;</span>
<span class="nc" id="L2992">            this.count--;</span>

<span class="nc bnc" id="L2994" title="All 2 branches missed.">            if (isNonSentinel(this.currentKey))</span>
            {
<span class="nc" id="L2996">                int index = this.position - 1;</span>
<span class="nc" id="L2997">                ByteObjectHashMap.this.removeKeyAtIndex(index);</span>
<span class="nc" id="L2998">            }</span>
            else
            {
<span class="nc" id="L3001">                ByteObjectHashMap.this.removeKey(this.currentKey);</span>
            }
<span class="nc" id="L3003">        }</span>
    }

    @Override
    public MutableByteSet keySet()
    {
<span class="nc" id="L3009">        return new KeySet();</span>
    }

    /**
     * Rehashes every element in the set into a new backing table of the smallest possible size and eliminating removed sentinels.
     */
    public void compact()
    {
<span class="nc" id="L3017">        this.rehash(this.smallestPowerOfTwoGreaterThan(this.size()));</span>
<span class="nc" id="L3018">    }</span>

    private void rehash()
    {
<span class="nc" id="L3022">        this.rehash(this.keys.length);</span>
<span class="nc" id="L3023">    }</span>

    private void rehashAndGrow()
    {
<span class="nc" id="L3027">        this.rehash(this.keys.length &lt;&lt; 1);</span>
<span class="nc" id="L3028">    }</span>

    private void rehash(int newCapacity)
    {
<span class="nc" id="L3032">        int oldLength = this.keys.length;</span>
<span class="nc" id="L3033">        byte[] old = this.keys;</span>
<span class="nc" id="L3034">        V[] oldValues = this.values;</span>
<span class="nc" id="L3035">        this.allocateTable(newCapacity);</span>
<span class="nc" id="L3036">        this.occupiedWithData = 0;</span>
<span class="nc" id="L3037">        this.occupiedWithSentinels = 0;</span>

<span class="nc bnc" id="L3039" title="All 2 branches missed.">        for (int i = 0; i &lt; oldLength; i++)</span>
        {
<span class="nc bnc" id="L3041" title="All 2 branches missed.">            if (isNonSentinel(old[i]))</span>
            {
<span class="nc" id="L3043">                this.put(old[i], oldValues[i]);</span>
            }
        }
<span class="nc" id="L3046">        this.copyKeysOnWrite = false;</span>
<span class="nc" id="L3047">    }</span>

    // exposed for testing
    int probe(byte element)
    {
<span class="nc" id="L3052">        int index = this.spreadAndMask(element);</span>
<span class="nc" id="L3053">        byte keyAtIndex = this.keys[index];</span>

<span class="nc bnc" id="L3055" title="All 4 branches missed.">        if (keyAtIndex == element || keyAtIndex == EMPTY_KEY)</span>
        {
<span class="nc" id="L3057">            return index;</span>
        }

<span class="nc bnc" id="L3060" title="All 2 branches missed.">        int removedIndex = keyAtIndex == REMOVED_KEY ? index : -1;</span>
<span class="nc" id="L3061">        int nextIndex = index;</span>
<span class="nc" id="L3062">        int probe = 17;</span>

        // loop until an empty slot is reached
        while (true)
        {
            // Probe algorithm: 17*n*(n+1)/2 where n = number of collisions
<span class="nc" id="L3068">            nextIndex += probe;</span>
<span class="nc" id="L3069">            probe += 17;</span>
<span class="nc" id="L3070">            nextIndex &amp;= this.keys.length - 1;</span>

<span class="nc bnc" id="L3072" title="All 2 branches missed.">            if (this.keys[nextIndex] == element)</span>
            {
<span class="nc" id="L3074">                return nextIndex;</span>
            }
<span class="nc bnc" id="L3076" title="All 2 branches missed.">            if (this.keys[nextIndex] == REMOVED_KEY)</span>
            {
<span class="nc bnc" id="L3078" title="All 2 branches missed.">                if (removedIndex == -1)</span>
                {
<span class="nc" id="L3080">                    removedIndex = nextIndex;</span>
                }
            }
<span class="nc bnc" id="L3083" title="All 2 branches missed.">            else if (this.keys[nextIndex] == EMPTY_KEY)</span>
            {
<span class="nc bnc" id="L3085" title="All 2 branches missed.">                return removedIndex == -1 ? nextIndex : removedIndex;</span>
            }
        }
    }

    // exposed for testing
    int spreadAndMask(byte element)
    {
        // No spreading necessary for 8-bit types
<span class="nc" id="L3094">        return this.mask(element);</span>
    }

    private int mask(int spread)
    {
<span class="nc" id="L3099">        return spread &amp; (this.keys.length - 1);</span>
    }

    private void allocateTable(int sizeToAllocate)
    {
<span class="nc" id="L3104">        this.keys = new byte[sizeToAllocate];</span>
<span class="nc" id="L3105">        this.values = (V[]) new Object[sizeToAllocate];</span>
<span class="nc" id="L3106">    }</span>

    private static boolean isEmptyKey(byte key)
    {
<span class="nc bnc" id="L3110" title="All 2 branches missed.">        return key == EMPTY_KEY;</span>
    }

    private static boolean isRemovedKey(byte key)
    {
<span class="nc bnc" id="L3115" title="All 2 branches missed.">        return key == REMOVED_KEY;</span>
    }

    private static boolean isNonSentinel(byte key)
    {
<span class="nc bnc" id="L3120" title="All 4 branches missed.">        return !isEmptyKey(key) &amp;&amp; !isRemovedKey(key);</span>
    }

    private int maxOccupiedWithData()
    {
<span class="nc" id="L3125">        int capacity = this.keys.length;</span>
        // need at least one free slot for open addressing
<span class="nc" id="L3127">        return Math.min(capacity - 1, capacity / OCCUPIED_DATA_RATIO);</span>
    }

    private int maxOccupiedWithSentinels()
    {
<span class="nc" id="L3132">        return this.keys.length / OCCUPIED_SENTINEL_RATIO;</span>
    }

<span class="nc" id="L3135">    private class KeySet implements MutableByteSet</span>
    {
        @Override
        public MutableByteIterator byteIterator()
        {
<span class="nc" id="L3140">            return new KeysSetIterator();</span>
        }

        @Override
        public void forEach(ByteProcedure procedure)
        {
<span class="nc" id="L3146">            this.each(procedure);</span>
<span class="nc" id="L3147">        }</span>

        /**
         * @since 7.0.
         */
        @Override
        public void each(ByteProcedure procedure)
        {
<span class="nc" id="L3155">            ByteObjectHashMap.this.forEachKey(procedure);</span>
<span class="nc" id="L3156">        }</span>

        @Override
        public int count(BytePredicate predicate)
        {
<span class="nc" id="L3161">            int count = 0;</span>
<span class="nc bnc" id="L3162" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L3164" title="All 4 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(EMPTY_KEY))</span>
                {
<span class="nc" id="L3166">                    count++;</span>
                }
<span class="nc bnc" id="L3168" title="All 4 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(REMOVED_KEY))</span>
                {
<span class="nc" id="L3170">                    count++;</span>
                }
            }
<span class="nc bnc" id="L3173" title="All 2 branches missed.">            for (byte key : ByteObjectHashMap.this.keys)</span>
            {
<span class="nc bnc" id="L3175" title="All 4 branches missed.">                if (isNonSentinel(key) &amp;&amp; predicate.accept(key))</span>
                {
<span class="nc" id="L3177">                    count++;</span>
                }
            }
<span class="nc" id="L3180">            return count;</span>
        }

        @Override
        public boolean anySatisfy(BytePredicate predicate)
        {
<span class="nc bnc" id="L3186" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L3188" title="All 4 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(EMPTY_KEY))</span>
                {
<span class="nc" id="L3190">                    return true;</span>
                }
<span class="nc bnc" id="L3192" title="All 4 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(REMOVED_KEY))</span>
                {
<span class="nc" id="L3194">                    return true;</span>
                }
            }
<span class="nc bnc" id="L3197" title="All 2 branches missed.">            for (byte key : ByteObjectHashMap.this.keys)</span>
            {
<span class="nc bnc" id="L3199" title="All 4 branches missed.">                if (isNonSentinel(key) &amp;&amp; predicate.accept(key))</span>
                {
<span class="nc" id="L3201">                    return true;</span>
                }
            }
<span class="nc" id="L3204">            return false;</span>
        }

        @Override
        public &lt;T&gt; T injectInto(T injectedValue, ObjectByteToObjectFunction&lt;? super T, ? extends T&gt; function)
        {
<span class="nc" id="L3210">            T result = injectedValue;</span>
<span class="nc bnc" id="L3211" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L3213" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey)</span>
                {
<span class="nc" id="L3215">                    result = function.valueOf(result, EMPTY_KEY);</span>
                }
<span class="nc bnc" id="L3217" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey)</span>
                {
<span class="nc" id="L3219">                    result = function.valueOf(result, REMOVED_KEY);</span>
                }
            }
<span class="nc bnc" id="L3222" title="All 2 branches missed.">            for (byte key : ByteObjectHashMap.this.keys)</span>
            {
<span class="nc bnc" id="L3224" title="All 2 branches missed.">                if (isNonSentinel(key))</span>
                {
<span class="nc" id="L3226">                    result = function.valueOf(result, key);</span>
                }
            }
<span class="nc" id="L3229">            return result;</span>
        }

        @Override
        public RichIterable&lt;ByteIterable&gt; chunk(int size)
        {
<span class="nc bnc" id="L3235" title="All 2 branches missed.">            if (size &lt;= 0)</span>
            {
<span class="nc" id="L3237">                throw new IllegalArgumentException(&quot;Size for groups must be positive but was: &quot; + size);</span>
            }
<span class="nc bnc" id="L3239" title="All 2 branches missed.">            if (this.isEmpty())</span>
            {
<span class="nc" id="L3241">                return Lists.mutable.empty();</span>
            }

<span class="nc" id="L3244">            ByteIterator iterator = this.byteIterator();</span>
<span class="nc" id="L3245">            MutableList&lt;ByteIterable&gt; result = Lists.mutable.empty();</span>
<span class="nc bnc" id="L3246" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L3248">                MutableByteSet batch =  ByteSets.mutable.empty();</span>
<span class="nc bnc" id="L3249" title="All 4 branches missed.">                for (int i = 0; i &lt; size &amp;&amp; iterator.hasNext(); i++)</span>
                {
<span class="nc" id="L3251">                    batch.add(iterator.next());</span>
                }
<span class="nc" id="L3253">                result.add(batch);</span>
<span class="nc" id="L3254">            }</span>
<span class="nc" id="L3255">            return result;</span>
        }

        @Override
        public boolean allSatisfy(BytePredicate predicate)
        {
<span class="nc bnc" id="L3261" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L3263" title="All 4 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey &amp;&amp; !predicate.accept(EMPTY_KEY))</span>
                {
<span class="nc" id="L3265">                    return false;</span>
                }
<span class="nc bnc" id="L3267" title="All 4 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey &amp;&amp; !predicate.accept(REMOVED_KEY))</span>
                {
<span class="nc" id="L3269">                    return false;</span>
                }
            }
<span class="nc bnc" id="L3272" title="All 2 branches missed.">            for (byte key : ByteObjectHashMap.this.keys)</span>
            {
<span class="nc bnc" id="L3274" title="All 4 branches missed.">                if (isNonSentinel(key) &amp;&amp; !predicate.accept(key))</span>
                {
<span class="nc" id="L3276">                    return false;</span>
                }
            }
<span class="nc" id="L3279">            return true;</span>
        }

        @Override
        public boolean noneSatisfy(BytePredicate predicate)
        {
<span class="nc bnc" id="L3285" title="All 2 branches missed.">            return !this.anySatisfy(predicate);</span>
        }

        @Override
        public boolean add(byte element)
        {
<span class="nc" id="L3291">            throw new UnsupportedOperationException(&quot;Cannot call add() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public boolean addAll(byte... source)
        {
<span class="nc" id="L3297">            throw new UnsupportedOperationException(&quot;Cannot call addAll() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public boolean addAll(ByteIterable source)
        {
<span class="nc" id="L3303">            throw new UnsupportedOperationException(&quot;Cannot call addAll() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public boolean remove(byte key)
        {
<span class="nc" id="L3309">            int oldSize = ByteObjectHashMap.this.size();</span>
<span class="nc" id="L3310">            ByteObjectHashMap.this.removeKey(key);</span>
<span class="nc bnc" id="L3311" title="All 2 branches missed.">            return oldSize != ByteObjectHashMap.this.size();</span>
        }

        @Override
        public boolean removeAll(ByteIterable source)
        {
<span class="nc" id="L3317">            int oldSize = ByteObjectHashMap.this.size();</span>
<span class="nc" id="L3318">            ByteIterator iterator = source.byteIterator();</span>
<span class="nc bnc" id="L3319" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc" id="L3321">                ByteObjectHashMap.this.removeKey(iterator.next());</span>
            }
<span class="nc bnc" id="L3323" title="All 2 branches missed.">            return oldSize != ByteObjectHashMap.this.size();</span>
        }

        @Override
        public boolean removeAll(byte... source)
        {
<span class="nc" id="L3329">            int oldSize = ByteObjectHashMap.this.size();</span>
<span class="nc bnc" id="L3330" title="All 2 branches missed.">            for (byte item : source)</span>
            {
<span class="nc" id="L3332">                ByteObjectHashMap.this.removeKey(item);</span>
            }
<span class="nc bnc" id="L3334" title="All 2 branches missed.">            return oldSize != ByteObjectHashMap.this.size();</span>
        }

        @Override
        public boolean retainAll(ByteIterable source)
        {
<span class="nc" id="L3340">            int oldSize = this.size();</span>
<span class="nc bnc" id="L3341" title="All 2 branches missed.">            final ByteSet sourceSet = source instanceof ByteSet ? (ByteSet) source : source.toSet();</span>
<span class="nc" id="L3342">            ByteObjectHashMap&lt;V&gt; retained = ByteObjectHashMap.this.select((byte key, V value) -&gt; sourceSet.contains(key));</span>
<span class="nc bnc" id="L3343" title="All 2 branches missed.">            if (retained.size() != oldSize)</span>
            {
<span class="nc" id="L3345">                ByteObjectHashMap.this.keys = retained.keys;</span>
<span class="nc" id="L3346">                ByteObjectHashMap.this.values = retained.values;</span>
<span class="nc" id="L3347">                ByteObjectHashMap.this.sentinelValues = retained.sentinelValues;</span>
<span class="nc" id="L3348">                ByteObjectHashMap.this.occupiedWithData = retained.occupiedWithData;</span>
<span class="nc" id="L3349">                ByteObjectHashMap.this.occupiedWithSentinels = retained.occupiedWithSentinels;</span>
<span class="nc" id="L3350">                return true;</span>
            }
<span class="nc" id="L3352">            return false;</span>
        }

        @Override
        public boolean retainAll(byte... source)
        {
<span class="nc" id="L3358">            return this.retainAll(ByteHashSet.newSetWith(source));</span>
        }

        @Override
        public void clear()
        {
<span class="nc" id="L3364">            ByteObjectHashMap.this.clear();</span>
<span class="nc" id="L3365">        }</span>

        @Override
        public MutableByteSet select(BytePredicate predicate)
        {
<span class="nc" id="L3370">            MutableByteSet result = new ByteHashSet();</span>
<span class="nc bnc" id="L3371" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L3373" title="All 4 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(EMPTY_KEY))</span>
                {
<span class="nc" id="L3375">                    result.add(EMPTY_KEY);</span>
                }
<span class="nc bnc" id="L3377" title="All 4 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(REMOVED_KEY))</span>
                {
<span class="nc" id="L3379">                    result.add(REMOVED_KEY);</span>
                }
            }
<span class="nc bnc" id="L3382" title="All 2 branches missed.">            for (byte key : ByteObjectHashMap.this.keys)</span>
            {
<span class="nc bnc" id="L3384" title="All 4 branches missed.">                if (isNonSentinel(key) &amp;&amp; predicate.accept(key))</span>
                {
<span class="nc" id="L3386">                    result.add(key);</span>
                }
            }
<span class="nc" id="L3389">            return result;</span>
        }

        @Override
        public MutableByteSet reject(BytePredicate predicate)
        {
<span class="nc" id="L3395">            MutableByteSet result = new ByteHashSet();</span>
<span class="nc bnc" id="L3396" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L3398" title="All 4 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey &amp;&amp; !predicate.accept(EMPTY_KEY))</span>
                {
<span class="nc" id="L3400">                    result.add(EMPTY_KEY);</span>
                }
<span class="nc bnc" id="L3402" title="All 4 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey &amp;&amp; !predicate.accept(REMOVED_KEY))</span>
                {
<span class="nc" id="L3404">                    result.add(REMOVED_KEY);</span>
                }
            }
<span class="nc bnc" id="L3407" title="All 2 branches missed.">            for (byte key : ByteObjectHashMap.this.keys)</span>
            {
<span class="nc bnc" id="L3409" title="All 4 branches missed.">                if (isNonSentinel(key) &amp;&amp; !predicate.accept(key))</span>
                {
<span class="nc" id="L3411">                    result.add(key);</span>
                }
            }
<span class="nc" id="L3414">            return result;</span>
        }

        @Override
        public MutableByteSet with(byte element)
        {
<span class="nc" id="L3420">            throw new UnsupportedOperationException(&quot;Cannot call with() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public MutableByteSet without(byte element)
        {
<span class="nc" id="L3426">            throw new UnsupportedOperationException(&quot;Cannot call without() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public MutableByteSet withAll(ByteIterable elements)
        {
<span class="nc" id="L3432">            throw new UnsupportedOperationException(&quot;Cannot call withAll() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public MutableByteSet withoutAll(ByteIterable elements)
        {
<span class="nc" id="L3438">            throw new UnsupportedOperationException(&quot;Cannot call withoutAll() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public byte detectIfNone(BytePredicate predicate, byte ifNone)
        {
<span class="nc bnc" id="L3444" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L3446" title="All 4 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey &amp;&amp; predicate.accept(EMPTY_KEY))</span>
                {
<span class="nc" id="L3448">                    return EMPTY_KEY;</span>
                }
<span class="nc bnc" id="L3450" title="All 4 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey &amp;&amp; predicate.accept(REMOVED_KEY))</span>
                {
<span class="nc" id="L3452">                    return REMOVED_KEY;</span>
                }
            }
<span class="nc bnc" id="L3455" title="All 2 branches missed.">            for (byte key : ByteObjectHashMap.this.keys)</span>
            {
<span class="nc bnc" id="L3457" title="All 4 branches missed.">                if (isNonSentinel(key) &amp;&amp; predicate.accept(key))</span>
                {
<span class="nc" id="L3459">                    return key;</span>
                }
            }
<span class="nc" id="L3462">            return ifNone;</span>
        }

        @Override
        public &lt;V&gt; MutableSet&lt;V&gt; collect(ByteToObjectFunction&lt;? extends V&gt; function)
        {
<span class="nc" id="L3468">            MutableSet&lt;V&gt; result = Sets.mutable.with();</span>
<span class="nc bnc" id="L3469" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L3471" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey)</span>
                {
<span class="nc" id="L3473">                    result.add(function.valueOf(EMPTY_KEY));</span>
                }
<span class="nc bnc" id="L3475" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey)</span>
                {
<span class="nc" id="L3477">                    result.add(function.valueOf(REMOVED_KEY));</span>
                }
            }
<span class="nc bnc" id="L3480" title="All 2 branches missed.">            for (byte key : ByteObjectHashMap.this.keys)</span>
            {
<span class="nc bnc" id="L3482" title="All 2 branches missed.">                if (isNonSentinel(key))</span>
                {
<span class="nc" id="L3484">                    result.add(function.valueOf(key));</span>
                }
            }
<span class="nc" id="L3487">            return result;</span>
        }

        @Override
        public MutableByteSet asUnmodifiable()
        {
<span class="nc" id="L3493">            return UnmodifiableByteSet.of(this);</span>
        }

        @Override
        public MutableByteSet asSynchronized()
        {
<span class="nc" id="L3499">            return SynchronizedByteSet.of(this);</span>
        }

        /**
         * @since 9.2.
         */
        @Override
        public MutableByteSet newEmpty()
        {
<span class="nc" id="L3508">            return new ByteHashSet();</span>
        }

        @Override
        public long sum()
        {
<span class="nc" id="L3514">            long result = 0L;</span>
<span class="nc bnc" id="L3515" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L3517" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey)</span>
                {
<span class="nc" id="L3519">                    result += EMPTY_KEY;</span>
                }
<span class="nc bnc" id="L3521" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey)</span>
                {
<span class="nc" id="L3523">                    result += REMOVED_KEY;</span>
                }
            }
<span class="nc bnc" id="L3526" title="All 2 branches missed.">            for (byte key : ByteObjectHashMap.this.keys)</span>
            {
<span class="nc bnc" id="L3528" title="All 2 branches missed.">                if (isNonSentinel(key))</span>
                {
<span class="nc" id="L3530">                    result += key;</span>
                }
            }
<span class="nc" id="L3533">            return result;</span>
        }

        @Override
        public byte max()
        {
<span class="nc bnc" id="L3539" title="All 2 branches missed.">            if (ByteObjectHashMap.this.isEmpty())</span>
            {
<span class="nc" id="L3541">                throw new NoSuchElementException();</span>
            }

<span class="nc" id="L3544">            byte max = (byte) 0;</span>
<span class="nc" id="L3545">            boolean isMaxSet = false;</span>

<span class="nc bnc" id="L3547" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L3549" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey)</span>
                {
<span class="nc" id="L3551">                    max = EMPTY_KEY;</span>
<span class="nc" id="L3552">                    isMaxSet = true;</span>
                }
<span class="nc bnc" id="L3554" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey)</span>
                {
<span class="nc" id="L3556">                    max = REMOVED_KEY;</span>
<span class="nc" id="L3557">                    isMaxSet = true;</span>
                }
            }
<span class="nc bnc" id="L3560" title="All 2 branches missed.">            for (int i = 0; i &lt; ByteObjectHashMap.this.keys.length; i++)</span>
            {
<span class="nc bnc" id="L3562" title="All 6 branches missed.">                if (isNonSentinel(ByteObjectHashMap.this.keys[i]) &amp;&amp; (!isMaxSet || max &lt; ByteObjectHashMap.this.keys[i]))</span>
                {
<span class="nc" id="L3564">                    max = ByteObjectHashMap.this.keys[i];</span>
<span class="nc" id="L3565">                    isMaxSet = true;</span>
                }
            }
<span class="nc" id="L3568">            return max;</span>
        }

        @Override
        public byte maxIfEmpty(byte defaultValue)
        {
<span class="nc bnc" id="L3574" title="All 2 branches missed.">            if (ByteObjectHashMap.this.isEmpty())</span>
            {
<span class="nc" id="L3576">                return defaultValue;</span>
            }

<span class="nc" id="L3579">            return this.max();</span>
        }

        @Override
        public byte min()
        {
<span class="nc bnc" id="L3585" title="All 2 branches missed.">            if (ByteObjectHashMap.this.isEmpty())</span>
            {
<span class="nc" id="L3587">                throw new NoSuchElementException();</span>
            }

<span class="nc" id="L3590">            byte min = (byte) 0;</span>
<span class="nc" id="L3591">            boolean isMinSet = false;</span>

<span class="nc bnc" id="L3593" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L3595" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey)</span>
                {
<span class="nc" id="L3597">                    min = EMPTY_KEY;</span>
<span class="nc" id="L3598">                    isMinSet = true;</span>
                }
<span class="nc bnc" id="L3600" title="All 4 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey &amp;&amp; !isMinSet)</span>
                {
<span class="nc" id="L3602">                    min = REMOVED_KEY;</span>
<span class="nc" id="L3603">                    isMinSet = true;</span>
                }
            }
<span class="nc bnc" id="L3606" title="All 2 branches missed.">            for (int i = 0; i &lt; ByteObjectHashMap.this.keys.length; i++)</span>
            {
<span class="nc bnc" id="L3608" title="All 6 branches missed.">                if (isNonSentinel(ByteObjectHashMap.this.keys[i]) &amp;&amp; (!isMinSet || ByteObjectHashMap.this.keys[i] &lt; min))</span>
                {
<span class="nc" id="L3610">                    min = ByteObjectHashMap.this.keys[i];</span>
<span class="nc" id="L3611">                    isMinSet = true;</span>
                }
            }
<span class="nc" id="L3614">            return min;</span>
        }

        @Override
        public byte minIfEmpty(byte defaultValue)
        {
<span class="nc bnc" id="L3620" title="All 2 branches missed.">            if (ByteObjectHashMap.this.isEmpty())</span>
            {
<span class="nc" id="L3622">                return defaultValue;</span>
            }

<span class="nc" id="L3625">            return this.min();</span>
        }

        @Override
        public double average()
        {
<span class="nc bnc" id="L3631" title="All 2 branches missed.">            if (ByteObjectHashMap.this.isEmpty())</span>
            {
<span class="nc" id="L3633">                throw new ArithmeticException();</span>
            }
<span class="nc" id="L3635">            return (double) this.sum() / (double) this.size();</span>
        }

        @Override
        public double median()
        {
<span class="nc bnc" id="L3641" title="All 2 branches missed.">            if (ByteObjectHashMap.this.isEmpty())</span>
            {
<span class="nc" id="L3643">                throw new ArithmeticException();</span>
            }
<span class="nc" id="L3645">            byte[] sortedArray = this.toSortedArray();</span>
<span class="nc" id="L3646">            int middleIndex = sortedArray.length &gt;&gt; 1;</span>
<span class="nc bnc" id="L3647" title="All 4 branches missed.">            if (sortedArray.length &gt; 1 &amp;&amp; (sortedArray.length &amp; 1) == 0)</span>
            {
<span class="nc" id="L3649">                byte first = sortedArray[middleIndex];</span>
<span class="nc" id="L3650">                byte second = sortedArray[middleIndex - 1];</span>
<span class="nc" id="L3651">                return ((double) first + (double) second) / 2.0;</span>
            }
<span class="nc" id="L3653">            return (double) sortedArray[middleIndex];</span>
        }

        @Override
        public byte[] toSortedArray()
        {
<span class="nc" id="L3659">            byte[] array = this.toArray();</span>
<span class="nc" id="L3660">            Arrays.sort(array);</span>
<span class="nc" id="L3661">            return array;</span>
        }

        @Override
        public MutableByteList toSortedList()
        {
<span class="nc" id="L3667">            return ByteArrayList.newList(this).sortThis();</span>
        }

        @Override
        public byte[] toArray()
        {
<span class="nc" id="L3673">            int size = ByteObjectHashMap.this.size();</span>
<span class="nc" id="L3674">            final byte[] result = new byte[size];</span>
<span class="nc" id="L3675">            ByteObjectHashMap.this.forEachKey(new ByteProcedure()</span>
<span class="nc" id="L3676">            {</span>
                private int index;

                @Override
                public void value(byte each)
                {
<span class="nc" id="L3682">                    result[this.index] = each;</span>
<span class="nc" id="L3683">                    this.index++;</span>
<span class="nc" id="L3684">                }</span>
            });
<span class="nc" id="L3686">            return result;</span>
        }

        @Override
        public boolean contains(byte value)
        {
<span class="nc" id="L3692">            return ByteObjectHashMap.this.containsKey(value);</span>
        }

        @Override
        public boolean containsAll(byte... source)
        {
<span class="nc bnc" id="L3698" title="All 2 branches missed.">            for (byte item : source)</span>
            {
<span class="nc bnc" id="L3700" title="All 2 branches missed.">                if (!ByteObjectHashMap.this.containsKey(item))</span>
                {
<span class="nc" id="L3702">                    return false;</span>
                }
            }
<span class="nc" id="L3705">            return true;</span>
        }

        @Override
        public boolean containsAll(ByteIterable source)
        {
<span class="nc" id="L3711">            ByteIterator iterator = source.byteIterator();</span>
<span class="nc bnc" id="L3712" title="All 2 branches missed.">            while (iterator.hasNext())</span>
            {
<span class="nc bnc" id="L3714" title="All 2 branches missed.">                if (!ByteObjectHashMap.this.containsKey(iterator.next()))</span>
                {
<span class="nc" id="L3716">                    return false;</span>
                }
            }
<span class="nc" id="L3719">            return true;</span>
        }

        @Override
        public MutableByteList toList()
        {
<span class="nc" id="L3725">            return ByteArrayList.newList(this);</span>
        }

        @Override
        public MutableByteSet toSet()
        {
<span class="nc" id="L3731">            return ByteHashSet.newSet(this);</span>
        }

        @Override
        public MutableByteBag toBag()
        {
<span class="nc" id="L3737">            return ByteHashBag.newBag(this);</span>
        }

        @Override
        public LazyByteIterable asLazy()
        {
<span class="nc" id="L3743">            return new LazyByteIterableAdapter(this);</span>
        }

        @Override
        public ByteSet freeze()
        {
<span class="nc" id="L3749">            ByteObjectHashMap.this.copyKeysOnWrite = true;</span>
<span class="nc" id="L3750">            boolean containsZeroKey = false;</span>
<span class="nc" id="L3751">            boolean containsOneKey = false;</span>
<span class="nc bnc" id="L3752" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc" id="L3754">                containsZeroKey = ByteObjectHashMap.this.sentinelValues.containsZeroKey;</span>
<span class="nc" id="L3755">                containsOneKey = ByteObjectHashMap.this.sentinelValues.containsOneKey;</span>
            }
<span class="nc" id="L3757">            return new ImmutableByteMapKeySet(ByteObjectHashMap.this.keys, ByteObjectHashMap.this.occupiedWithData, containsZeroKey, containsOneKey);</span>
        }

        @Override
        public ImmutableByteSet toImmutable()
        {
<span class="nc" id="L3763">            return ByteSets.immutable.withAll(this);</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L3769">            return ByteObjectHashMap.this.size();</span>
        }

        @Override
        public boolean isEmpty()
        {
<span class="nc" id="L3775">            return ByteObjectHashMap.this.isEmpty();</span>
        }

        @Override
        public boolean notEmpty()
        {
<span class="nc" id="L3781">            return ByteObjectHashMap.this.notEmpty();</span>
        }

        @Override
        public boolean equals(Object obj)
        {
<span class="nc bnc" id="L3787" title="All 2 branches missed.">            if (this == obj)</span>
            {
<span class="nc" id="L3789">                return true;</span>
            }

<span class="nc bnc" id="L3792" title="All 2 branches missed.">            if (!(obj instanceof ByteSet))</span>
            {
<span class="nc" id="L3794">                return false;</span>
            }

<span class="nc" id="L3797">            ByteSet other = (ByteSet) obj;</span>
<span class="nc bnc" id="L3798" title="All 4 branches missed.">            return this.size() == other.size() &amp;&amp; this.containsAll(other.toArray());</span>
        }

        @Override
        public int hashCode()
        {
<span class="nc" id="L3804">            int result = 0;</span>

<span class="nc bnc" id="L3806" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L3808" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey)</span>
                {
<span class="nc" id="L3810">                    result += (int) EMPTY_KEY;</span>
                }
<span class="nc bnc" id="L3812" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey)</span>
                {
<span class="nc" id="L3814">                    result += (int) REMOVED_KEY;</span>
                }
            }
<span class="nc bnc" id="L3817" title="All 2 branches missed.">            for (int i = 0; i &lt; ByteObjectHashMap.this.keys.length; i++)</span>
            {
<span class="nc bnc" id="L3819" title="All 2 branches missed.">                if (isNonSentinel(ByteObjectHashMap.this.keys[i]))</span>
                {
<span class="nc" id="L3821">                    result += (int) ByteObjectHashMap.this.keys[i];</span>
                }
            }

<span class="nc" id="L3825">            return result;</span>
        }

        @Override
        public String toString()
        {
<span class="nc" id="L3831">            return this.makeString(&quot;[&quot;, &quot;, &quot;, &quot;]&quot;);</span>
        }

        @Override
        public String makeString()
        {
<span class="nc" id="L3837">            return this.makeString(&quot;, &quot;);</span>
        }

        @Override
        public String makeString(String separator)
        {
<span class="nc" id="L3843">            return this.makeString(&quot;&quot;, separator, &quot;&quot;);</span>
        }

        @Override
        public String makeString(String start, String separator, String end)
        {
<span class="nc" id="L3849">            Appendable stringBuilder = new StringBuilder();</span>
<span class="nc" id="L3850">            this.appendString(stringBuilder, start, separator, end);</span>
<span class="nc" id="L3851">            return stringBuilder.toString();</span>
        }

        @Override
        public void appendString(Appendable appendable)
        {
<span class="nc" id="L3857">            this.appendString(appendable, &quot;, &quot;);</span>
<span class="nc" id="L3858">        }</span>

        @Override
        public void appendString(Appendable appendable, String separator)
        {
<span class="nc" id="L3863">            this.appendString(appendable, &quot;&quot;, separator, &quot;&quot;);</span>
<span class="nc" id="L3864">        }</span>

        @Override
        public void appendString(Appendable appendable, String start, String separator, String end)
        {
            try
            {
<span class="nc" id="L3871">                appendable.append(start);</span>
<span class="nc" id="L3872">                boolean first = true;</span>
<span class="nc bnc" id="L3873" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues != null)</span>
                {
<span class="nc bnc" id="L3875" title="All 2 branches missed.">                    if (ByteObjectHashMap.this.sentinelValues.containsZeroKey)</span>
                    {
<span class="nc" id="L3877">                        appendable.append(String.valueOf(EMPTY_KEY));</span>
<span class="nc" id="L3878">                        first = false;</span>
                    }
<span class="nc bnc" id="L3880" title="All 2 branches missed.">                    if (ByteObjectHashMap.this.sentinelValues.containsOneKey)</span>
                    {
<span class="nc bnc" id="L3882" title="All 2 branches missed.">                        if (!first)</span>
                        {
<span class="nc" id="L3884">                            appendable.append(separator);</span>
                        }
<span class="nc" id="L3886">                        appendable.append(String.valueOf(REMOVED_KEY));</span>
<span class="nc" id="L3887">                        first = false;</span>
                    }
                }
<span class="nc bnc" id="L3890" title="All 2 branches missed.">                for (byte key : ByteObjectHashMap.this.keys)</span>
                {
<span class="nc bnc" id="L3892" title="All 2 branches missed.">                    if (isNonSentinel(key))</span>
                    {
<span class="nc bnc" id="L3894" title="All 2 branches missed.">                        if (!first)</span>
                        {
<span class="nc" id="L3896">                            appendable.append(separator);</span>
                        }
<span class="nc" id="L3898">                        appendable.append(String.valueOf(key));</span>
<span class="nc" id="L3899">                        first = false;</span>
                    }
                }
<span class="nc" id="L3902">                appendable.append(end);</span>
            }
<span class="nc" id="L3904">            catch (IOException e)</span>
            {
<span class="nc" id="L3906">                throw new RuntimeException(e);</span>
<span class="nc" id="L3907">            }</span>
<span class="nc" id="L3908">        }</span>
    }

<span class="nc" id="L3911">    private class KeysSetIterator implements MutableByteIterator</span>
    {
        private int count;
        private int position;
        private byte lastKey;
        private boolean handledZeroKey;
        private boolean handledOneKey;
        private boolean canRemove;

        @Override
        public boolean hasNext()
        {
<span class="nc bnc" id="L3923" title="All 2 branches missed.">            return this.count != ByteObjectHashMap.this.size();</span>
        }

        @Override
        public byte next()
        {
<span class="nc bnc" id="L3929" title="All 2 branches missed.">            if (!this.hasNext())</span>
            {
<span class="nc" id="L3931">                throw new NoSuchElementException();</span>
            }
<span class="nc" id="L3933">            this.count++;</span>
<span class="nc" id="L3934">            this.canRemove = true;</span>

<span class="nc bnc" id="L3936" title="All 2 branches missed.">            if (!this.handledZeroKey)</span>
            {
<span class="nc" id="L3938">                this.handledZeroKey = true;</span>
<span class="nc bnc" id="L3939" title="All 2 branches missed.">                if (ByteObjectHashMap.this.containsKey(EMPTY_KEY))</span>
                {
<span class="nc" id="L3941">                    this.lastKey = EMPTY_KEY;</span>
<span class="nc" id="L3942">                    return this.lastKey;</span>
                }
            }
<span class="nc bnc" id="L3945" title="All 2 branches missed.">            if (!this.handledOneKey)</span>
            {
<span class="nc" id="L3947">                this.handledOneKey = true;</span>
<span class="nc bnc" id="L3948" title="All 2 branches missed.">                if (ByteObjectHashMap.this.containsKey(REMOVED_KEY))</span>
                {
<span class="nc" id="L3950">                    this.lastKey = REMOVED_KEY;</span>
<span class="nc" id="L3951">                    return this.lastKey;</span>
                }
            }
<span class="nc" id="L3954">            byte[] keys = ByteObjectHashMap.this.keys;</span>
<span class="nc bnc" id="L3955" title="All 2 branches missed.">            while (!isNonSentinel(keys[this.position]))</span>
            {
<span class="nc" id="L3957">                this.position++;</span>
            }
<span class="nc" id="L3959">            this.lastKey = keys[this.position];</span>
<span class="nc" id="L3960">            this.position++;</span>
<span class="nc" id="L3961">            return this.lastKey;</span>
        }

        @Override
        public void remove()
        {
<span class="nc bnc" id="L3967" title="All 2 branches missed.">            if (!this.canRemove)</span>
            {
<span class="nc" id="L3969">                throw new IllegalStateException();</span>
            }
<span class="nc" id="L3971">            ByteObjectHashMap.this.removeKey(this.lastKey);</span>
<span class="nc" id="L3972">            this.count--;</span>
<span class="nc" id="L3973">            this.canRemove = false;</span>
<span class="nc" id="L3974">        }</span>
    }

    @Override
    public Collection&lt;V&gt; values()
    {
<span class="nc" id="L3980">        return new ValuesCollection();</span>
    }

    @Override
    public LazyByteIterable keysView()
    {
<span class="nc" id="L3986">        return new KeysView();</span>
    }

    @Override
    public RichIterable&lt;ByteObjectPair&lt;V&gt;&gt; keyValuesView()
    {
<span class="nc" id="L3992">        return new KeyValuesView();</span>
    }

    @Override
    public MutableObjectByteMap&lt;V&gt; flipUniqueValues()
    {
<span class="nc" id="L3998">        MutableObjectByteMap&lt;V&gt; result = ObjectByteMaps.mutable.empty();</span>
<span class="nc" id="L3999">        this.forEachKeyValue((key, value) -&gt; {</span>
<span class="nc bnc" id="L4000" title="All 2 branches missed.">            if (result.containsKey(value))</span>
            {
<span class="nc" id="L4002">                throw new IllegalStateException(&quot;Duplicate value: &quot; + value + &quot; found at key: &quot; + result.get(value) + &quot; and key: &quot; + key);</span>
            }
<span class="nc" id="L4004">            result.put(value, key);</span>
<span class="nc" id="L4005">        });</span>
<span class="nc" id="L4006">        return result;</span>
    }

<span class="nc" id="L4009">    protected class ValuesCollection implements Collection&lt;V&gt;</span>
    {
        @Override
        public boolean add(V v)
        {
<span class="nc" id="L4014">            throw new UnsupportedOperationException(&quot;Cannot call add() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public boolean addAll(Collection&lt;? extends V&gt; collection)
        {
<span class="nc" id="L4020">            throw new UnsupportedOperationException(&quot;Cannot call addAll() on &quot; + this.getClass().getSimpleName());</span>
        }

        @Override
        public void clear()
        {
<span class="nc" id="L4026">            ByteObjectHashMap.this.clear();</span>
<span class="nc" id="L4027">        }</span>

        @Override
        public boolean contains(Object o)
        {
<span class="nc" id="L4032">            return ByteObjectHashMap.this.containsValue(o);</span>
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; collection)
        {
            // todo: this is N^2. if c is large, we should copy the values to a set.
<span class="nc" id="L4039">            return Iterate.allSatisfy(collection, Predicates.in(this));</span>
        }

        @Override
        public boolean isEmpty()
        {
<span class="nc" id="L4045">            return ByteObjectHashMap.this.isEmpty();</span>
        }

        @Override
        public Iterator&lt;V&gt; iterator()
        {
<span class="nc" id="L4051">            return ByteObjectHashMap.this.iterator();</span>
        }

        @Override
        public boolean remove(Object o)
        {
            // this is so slow that the extra overhead of the iterator won't be noticeable
<span class="nc bnc" id="L4058" title="All 2 branches missed.">            if (o == null)</span>
            {
<span class="nc bnc" id="L4060" title="All 2 branches missed.">                for (Iterator&lt;V&gt; it = this.iterator(); it.hasNext(); )</span>
                {
<span class="nc bnc" id="L4062" title="All 2 branches missed.">                    if (it.next() == null)</span>
                    {
<span class="nc" id="L4064">                        it.remove();</span>
<span class="nc" id="L4065">                        return true;</span>
                    }
                }
            }
            else
            {
<span class="nc bnc" id="L4071" title="All 2 branches missed.">                for (Iterator&lt;V&gt; it = this.iterator(); it.hasNext(); )</span>
                {
<span class="nc" id="L4073">                    V o2 = it.next();</span>
<span class="nc bnc" id="L4074" title="All 4 branches missed.">                    if (o == o2 || o2.equals(o))</span>
                    {
<span class="nc" id="L4076">                        it.remove();</span>
<span class="nc" id="L4077">                        return true;</span>
                    }
<span class="nc" id="L4079">                }</span>
            }
<span class="nc" id="L4081">            return false;</span>
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; collection)
        {
            // todo: this is N^2. if c is large, we should copy the values to a set.
<span class="nc" id="L4088">            boolean changed = false;</span>

<span class="nc bnc" id="L4090" title="All 2 branches missed.">            for (Object obj : collection)</span>
            {
<span class="nc bnc" id="L4092" title="All 2 branches missed.">                if (this.remove(obj))</span>
                {
<span class="nc" id="L4094">                    changed = true;</span>
                }
<span class="nc" id="L4096">            }</span>
<span class="nc" id="L4097">            return changed;</span>
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; collection)
        {
<span class="nc" id="L4103">            boolean modified = false;</span>
<span class="nc" id="L4104">            Iterator&lt;V&gt; e = this.iterator();</span>
<span class="nc bnc" id="L4105" title="All 2 branches missed.">            while (e.hasNext())</span>
            {
<span class="nc bnc" id="L4107" title="All 2 branches missed.">                if (!collection.contains(e.next()))</span>
                {
<span class="nc" id="L4109">                    e.remove();</span>
<span class="nc" id="L4110">                    modified = true;</span>
                }
            }
<span class="nc" id="L4113">            return modified;</span>
        }

        @Override
        public int size()
        {
<span class="nc" id="L4119">            return ByteObjectHashMap.this.size();</span>
        }

        @Override
        public Object[] toArray()
        {
<span class="nc" id="L4125">            return ByteObjectHashMap.this.toArray();</span>
        }

        @Override
        public &lt;T&gt; T[] toArray(T[] result)
        {
<span class="nc" id="L4131">            return ByteObjectHashMap.this.toArray(result);</span>
        }
    }

<span class="nc" id="L4135">    private class KeysView extends AbstractLazyByteIterable</span>
    {
        @Override
        public ByteIterator byteIterator()
        {
<span class="nc" id="L4140">            return new UnmodifiableByteIterator(new KeysSetIterator());</span>
        }

        @Override
        public void forEach(ByteProcedure procedure)
        {
<span class="nc" id="L4146">            this.each(procedure);</span>
<span class="nc" id="L4147">        }</span>

        @Override
        public void each(ByteProcedure procedure)
        {
<span class="nc" id="L4152">            ByteObjectHashMap.this.forEachKey(procedure);</span>
<span class="nc" id="L4153">        }</span>
    }

<span class="nc" id="L4156">    private class KeyValuesView extends AbstractLazyIterable&lt;ByteObjectPair&lt;V&gt;&gt;</span>
    {
        @Override
        public void each(Procedure&lt;? super ByteObjectPair&lt;V&gt;&gt; procedure)
        {
<span class="nc bnc" id="L4161" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L4163" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey)</span>
                {
<span class="nc" id="L4165">                    procedure.value(PrimitiveTuples.pair(EMPTY_KEY, ByteObjectHashMap.this.sentinelValues.zeroValue));</span>
                }
<span class="nc bnc" id="L4167" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey)</span>
                {
<span class="nc" id="L4169">                    procedure.value(PrimitiveTuples.pair(REMOVED_KEY, ByteObjectHashMap.this.sentinelValues.oneValue));</span>
                }
            }
<span class="nc bnc" id="L4172" title="All 2 branches missed.">            for (int i = 0; i &lt; ByteObjectHashMap.this.keys.length; i++)</span>
            {
<span class="nc bnc" id="L4174" title="All 2 branches missed.">                if (isNonSentinel(ByteObjectHashMap.this.keys[i]))</span>
                {
<span class="nc" id="L4176">                    procedure.value(PrimitiveTuples.pair(ByteObjectHashMap.this.keys[i], ByteObjectHashMap.this.values[i]));</span>
                }
            }
<span class="nc" id="L4179">        }</span>

        @Override
        public void forEachWithIndex(ObjectIntProcedure&lt;? super ByteObjectPair&lt;V&gt;&gt; objectIntProcedure)
        {
<span class="nc" id="L4184">            int index = 0;</span>
<span class="nc bnc" id="L4185" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L4187" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey)</span>
                {
<span class="nc" id="L4189">                    objectIntProcedure.value(PrimitiveTuples.pair(EMPTY_KEY, ByteObjectHashMap.this.sentinelValues.zeroValue), index);</span>
<span class="nc" id="L4190">                    index++;</span>
                }
<span class="nc bnc" id="L4192" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey)</span>
                {
<span class="nc" id="L4194">                    objectIntProcedure.value(PrimitiveTuples.pair(REMOVED_KEY, ByteObjectHashMap.this.sentinelValues.oneValue), index);</span>
<span class="nc" id="L4195">                    index++;</span>
                }
            }
<span class="nc bnc" id="L4198" title="All 2 branches missed.">            for (int i = 0; i &lt; ByteObjectHashMap.this.keys.length; i++)</span>
            {
<span class="nc bnc" id="L4200" title="All 2 branches missed.">                if (isNonSentinel(ByteObjectHashMap.this.keys[i]))</span>
                {
<span class="nc" id="L4202">                    objectIntProcedure.value(PrimitiveTuples.pair(ByteObjectHashMap.this.keys[i], ByteObjectHashMap.this.values[i]), index);</span>
<span class="nc" id="L4203">                    index++;</span>
                }
            }
<span class="nc" id="L4206">        }</span>

        @Override
        public &lt;P&gt; void forEachWith(Procedure2&lt;? super ByteObjectPair&lt;V&gt;, ? super P&gt; procedure, P parameter)
        {
<span class="nc bnc" id="L4211" title="All 2 branches missed.">            if (ByteObjectHashMap.this.sentinelValues != null)</span>
            {
<span class="nc bnc" id="L4213" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsZeroKey)</span>
                {
<span class="nc" id="L4215">                    procedure.value(PrimitiveTuples.pair(EMPTY_KEY, ByteObjectHashMap.this.sentinelValues.zeroValue), parameter);</span>
                }
<span class="nc bnc" id="L4217" title="All 2 branches missed.">                if (ByteObjectHashMap.this.sentinelValues.containsOneKey)</span>
                {
<span class="nc" id="L4219">                    procedure.value(PrimitiveTuples.pair(REMOVED_KEY, ByteObjectHashMap.this.sentinelValues.oneValue), parameter);</span>
                }
            }
<span class="nc bnc" id="L4222" title="All 2 branches missed.">            for (int i = 0; i &lt; ByteObjectHashMap.this.keys.length; i++)</span>
            {
<span class="nc bnc" id="L4224" title="All 2 branches missed.">                if (isNonSentinel(ByteObjectHashMap.this.keys[i]))</span>
                {
<span class="nc" id="L4226">                    procedure.value(PrimitiveTuples.pair(ByteObjectHashMap.this.keys[i], ByteObjectHashMap.this.values[i]), parameter);</span>
                }
            }
<span class="nc" id="L4229">        }</span>

        @Override
        public Iterator&lt;ByteObjectPair&lt;V&gt;&gt; iterator()
        {
<span class="nc" id="L4234">            return new InternalKeyValuesIterator();</span>
        }

<span class="nc" id="L4237">        public class InternalKeyValuesIterator implements Iterator&lt;ByteObjectPair&lt;V&gt;&gt;</span>
        {
            private int count;
            private int position;
            private boolean handledZero;
            private boolean handledOne;

            @Override
            public ByteObjectPair&lt;V&gt; next()
            {
<span class="nc bnc" id="L4247" title="All 2 branches missed.">                if (!this.hasNext())</span>
                {
<span class="nc" id="L4249">                    throw new NoSuchElementException(&quot;next() called, but the iterator is exhausted&quot;);</span>
                }
<span class="nc" id="L4251">                this.count++;</span>

<span class="nc bnc" id="L4253" title="All 2 branches missed.">                if (!this.handledZero)</span>
                {
<span class="nc" id="L4255">                    this.handledZero = true;</span>
<span class="nc bnc" id="L4256" title="All 2 branches missed.">                    if (ByteObjectHashMap.this.containsKey(EMPTY_KEY))</span>
                    {
<span class="nc" id="L4258">                        return PrimitiveTuples.pair(EMPTY_KEY, ByteObjectHashMap.this.sentinelValues.zeroValue);</span>
                    }
                }
<span class="nc bnc" id="L4261" title="All 2 branches missed.">                if (!this.handledOne)</span>
                {
<span class="nc" id="L4263">                    this.handledOne = true;</span>
<span class="nc bnc" id="L4264" title="All 2 branches missed.">                    if (ByteObjectHashMap.this.containsKey(REMOVED_KEY))</span>
                    {
<span class="nc" id="L4266">                        return PrimitiveTuples.pair(REMOVED_KEY, ByteObjectHashMap.this.sentinelValues.oneValue);</span>
                    }
                }

<span class="nc" id="L4270">                byte[] keys = ByteObjectHashMap.this.keys;</span>
<span class="nc bnc" id="L4271" title="All 2 branches missed.">                while (!isNonSentinel(keys[this.position]))</span>
                {
<span class="nc" id="L4273">                    this.position++;</span>
                }
<span class="nc" id="L4275">                ByteObjectPair&lt;V&gt; result = PrimitiveTuples.pair(keys[this.position], ByteObjectHashMap.this.values[this.position]);</span>
<span class="nc" id="L4276">                this.position++;</span>
<span class="nc" id="L4277">                return result;</span>
            }

            @Override
            public void remove()
            {
<span class="nc" id="L4283">                throw new UnsupportedOperationException(&quot;Cannot call remove() on &quot; + this.getClass().getSimpleName());</span>
            }

            @Override
            public boolean hasNext()
            {
<span class="nc bnc" id="L4289" title="All 2 branches missed.">                return this.count != ByteObjectHashMap.this.size();</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>