<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ImmutableCharMapKeySet.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.impl.map.mutable.primitive</a> &gt; <span class="el_source">ImmutableCharMapKeySet.java</span></div><h1>ImmutableCharMapKeySet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2018 Goldman Sachs.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.impl.map.mutable.primitive;

import java.io.IOException;
import java.io.Serializable;
import java.util.NoSuchElementException;
import org.eclipse.collections.impl.SpreadFunctions;
import org.eclipse.collections.api.block.function.primitive.CharToObjectFunction;
import org.eclipse.collections.api.block.function.primitive.ObjectCharToObjectFunction;
import org.eclipse.collections.api.block.predicate.primitive.CharPredicate;
import org.eclipse.collections.api.block.procedure.primitive.CharProcedure;
import org.eclipse.collections.api.iterator.CharIterator;
import org.eclipse.collections.api.set.ImmutableSet;
import org.eclipse.collections.api.set.MutableSet;
import org.eclipse.collections.api.set.primitive.ImmutableCharSet;
import org.eclipse.collections.impl.set.immutable.primitive.ImmutableCharSetSerializationProxy;
import org.eclipse.collections.impl.set.immutable.primitive.AbstractImmutableCharSet;
import org.eclipse.collections.impl.set.mutable.UnifiedSet;
import org.eclipse.collections.impl.set.mutable.primitive.CharHashSet;

/**
 * This file was automatically generated from template file immutablePrimitiveMapKeySet.stg
 *
 * @since 6.0.
 */
class ImmutableCharMapKeySet extends AbstractImmutableCharSet implements Serializable
{
    private static final long serialVersionUID = 1L;
    private static final char EMPTY_KEY = (char) 0;
    private static final char REMOVED_KEY = (char) 1;
    private static final int CACHE_LINE_SIZE = 64;
    private static final int KEY_SIZE = 2;
    private static final int INITIAL_LINEAR_PROBE = CACHE_LINE_SIZE / KEY_SIZE / 2; /* half a cache line */

    private final char[] keys;
    private final int occupiedWithData;
    private final boolean containsZeroKey;
    private final boolean containsOneKey;

    ImmutableCharMapKeySet(char[] keys, int occupiedWithData, boolean containsZeroKey, boolean containsOneKey)
<span class="nc" id="L50">    {</span>
<span class="nc" id="L51">        this.keys = keys;</span>
<span class="nc" id="L52">        this.occupiedWithData = occupiedWithData;</span>
<span class="nc" id="L53">        this.containsZeroKey = containsZeroKey;</span>
<span class="nc" id="L54">        this.containsOneKey = containsOneKey;</span>
<span class="nc" id="L55">    }</span>

    private static boolean isEmptyKey(char key)
    {
<span class="nc bnc" id="L59" title="All 2 branches missed.">        return key == EMPTY_KEY;</span>
    }

    private static boolean isRemovedKey(char key)
    {
<span class="nc bnc" id="L64" title="All 2 branches missed.">        return key == REMOVED_KEY;</span>
    }

    private static boolean isNonSentinel(char key)
    {
<span class="nc bnc" id="L69" title="All 4 branches missed.">        return !isEmptyKey(key) &amp;&amp; !isRemovedKey(key);</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L75">        int result = 0;</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">        if (this.containsZeroKey)</span>
        {
<span class="nc" id="L78">            result += (int) EMPTY_KEY;</span>
        }
<span class="nc bnc" id="L80" title="All 2 branches missed.">        if (this.containsOneKey)</span>
        {
<span class="nc" id="L82">            result += (int) REMOVED_KEY;</span>
        }
<span class="nc bnc" id="L84" title="All 2 branches missed.">        if (this.keys != null)</span>
        {
<span class="nc bnc" id="L86" title="All 2 branches missed.">            for (int i = 0; i &lt; this.keys.length; i++)</span>
            {
<span class="nc bnc" id="L88" title="All 2 branches missed.">                if (isNonSentinel(this.keys[i]))</span>
                {
<span class="nc" id="L90">                    result += (int) this.keys[i];</span>
                }
            }
        }
<span class="nc" id="L94">        return result;</span>
    }

    @Override
    public int size()
    {
<span class="nc bnc" id="L100" title="All 4 branches missed.">        return this.occupiedWithData + (this.containsOneKey ? 1 : 0) + (this.containsZeroKey ? 1 : 0);</span>
    }

    @Override
    public void appendString(Appendable appendable, String start, String separator, String end)
    {
        try
        {
<span class="nc" id="L108">            appendable.append(start);</span>
<span class="nc" id="L109">            int count = 0;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            if (this.containsZeroKey)</span>
            {
<span class="nc" id="L112">                appendable.append(String.valueOf(EMPTY_KEY));</span>
<span class="nc" id="L113">                count++;</span>
            }
<span class="nc bnc" id="L115" title="All 2 branches missed.">            if (this.containsOneKey)</span>
            {
<span class="nc bnc" id="L117" title="All 2 branches missed.">                if (count &gt; 0)</span>
                {
<span class="nc" id="L119">                    appendable.append(separator);</span>
                }
<span class="nc" id="L121">                count++;</span>
<span class="nc" id="L122">                appendable.append(String.valueOf(REMOVED_KEY));</span>
            }
<span class="nc bnc" id="L124" title="All 2 branches missed.">            for (int i = 0; i &lt; this.keys.length; i++)</span>
            {
<span class="nc bnc" id="L126" title="All 2 branches missed.">                if (isNonSentinel(this.keys[i]))</span>
                {
<span class="nc bnc" id="L128" title="All 2 branches missed.">                    if (count &gt; 0)</span>
                    {
<span class="nc" id="L130">                        appendable.append(separator);</span>
                    }
<span class="nc" id="L132">                    count++;</span>
<span class="nc" id="L133">                    appendable.append(String.valueOf(this.keys[i]));</span>
                }
            }
<span class="nc" id="L136">            appendable.append(end);</span>
        }
<span class="nc" id="L138">        catch (IOException e)</span>
        {
<span class="nc" id="L140">            throw new RuntimeException(e);</span>
<span class="nc" id="L141">        }</span>
<span class="nc" id="L142">    }</span>

    @Override
    public CharIterator charIterator()
    {
<span class="nc" id="L147">        return new InternalCharIterator();</span>
    }

    @Override
    public char[] toArray()
    {
<span class="nc" id="L153">        char[] array = new char[this.size()];</span>
<span class="nc" id="L154">        int index = 0;</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (this.containsZeroKey)</span>
        {
<span class="nc" id="L157">            array[index] = EMPTY_KEY;</span>
<span class="nc" id="L158">            index++;</span>
        }
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (this.containsOneKey)</span>
        {
<span class="nc" id="L162">            array[index] = REMOVED_KEY;</span>
<span class="nc" id="L163">            index++;</span>
        }
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (this.keys != null)</span>
        {
<span class="nc bnc" id="L167" title="All 2 branches missed.">            for (int i = 0; i &lt; this.keys.length; i++)</span>
            {
<span class="nc bnc" id="L169" title="All 2 branches missed.">                if (isNonSentinel(this.keys[i]))</span>
                {
<span class="nc" id="L171">                    array[index] = this.keys[i];</span>
<span class="nc" id="L172">                    index++;</span>
                }
            }
        }
<span class="nc" id="L176">        return array;</span>
    }

    @Override
    public boolean contains(char value)
    {
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (value == EMPTY_KEY)</span>
        {
<span class="nc" id="L184">            return this.containsZeroKey;</span>
        }
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (value == REMOVED_KEY)</span>
        {
<span class="nc" id="L188">            return this.containsOneKey;</span>
        }
<span class="nc bnc" id="L190" title="All 2 branches missed.">        return this.keys[this.probe(value)] == value;</span>
    }

    @Override
    public void forEach(CharProcedure procedure)
    {
<span class="nc" id="L196">        this.each(procedure);</span>
<span class="nc" id="L197">    }</span>

    /**
     * @since 7.0.
     */
    @Override
    public void each(CharProcedure procedure)
    {
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (this.containsZeroKey)</span>
        {
<span class="nc" id="L207">            procedure.value(EMPTY_KEY);</span>
        }
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (this.containsOneKey)</span>
        {
<span class="nc" id="L211">            procedure.value(REMOVED_KEY);</span>
        }
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (this.keys != null)</span>
        {
<span class="nc bnc" id="L215" title="All 2 branches missed.">            for (int i = 0; i &lt; this.keys.length; i++)</span>
            {
<span class="nc bnc" id="L217" title="All 2 branches missed.">                if (isNonSentinel(this.keys[i]))</span>
                {
<span class="nc" id="L219">                    procedure.value(this.keys[i]);</span>
                }
            }
        }
<span class="nc" id="L223">    }</span>

    @Override
    public ImmutableCharSet select(CharPredicate predicate)
    {
<span class="nc" id="L228">        CharHashSet result = new CharHashSet();</span>
<span class="nc bnc" id="L229" title="All 4 branches missed.">        if (this.containsZeroKey &amp;&amp; predicate.accept(EMPTY_KEY))</span>
        {
<span class="nc" id="L231">            result.add(EMPTY_KEY);</span>
        }
<span class="nc bnc" id="L233" title="All 4 branches missed.">        if (this.containsOneKey &amp;&amp; predicate.accept(REMOVED_KEY))</span>
        {
<span class="nc" id="L235">            result.add(REMOVED_KEY);</span>
        }
<span class="nc bnc" id="L237" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L239" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.keys[i]))</span>
            {
<span class="nc" id="L241">                result.add(this.keys[i]);</span>
            }
        }
<span class="nc" id="L244">        return result.toImmutable();</span>
    }

    @Override
    public ImmutableCharSet reject(CharPredicate predicate)
    {
<span class="nc" id="L250">        CharHashSet result = new CharHashSet();</span>
<span class="nc bnc" id="L251" title="All 4 branches missed.">        if (this.containsZeroKey &amp;&amp; !predicate.accept(EMPTY_KEY))</span>
        {
<span class="nc" id="L253">            result.add(EMPTY_KEY);</span>
        }
<span class="nc bnc" id="L255" title="All 4 branches missed.">        if (this.containsOneKey &amp;&amp; !predicate.accept(REMOVED_KEY))</span>
        {
<span class="nc" id="L257">            result.add(REMOVED_KEY);</span>
        }
<span class="nc bnc" id="L259" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L261" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; !predicate.accept(this.keys[i]))</span>
            {
<span class="nc" id="L263">                result.add(this.keys[i]);</span>
            }
        }
<span class="nc" id="L266">        return result.toImmutable();</span>
    }

    @Override
    public &lt;V&gt; ImmutableSet&lt;V&gt; collect(CharToObjectFunction&lt;? extends V&gt; function)
    {
<span class="nc" id="L272">        MutableSet&lt;V&gt; target = UnifiedSet.newSet(this.size());</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (this.containsZeroKey)</span>
        {
<span class="nc" id="L275">            target.add(function.valueOf(EMPTY_KEY));</span>
        }
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (this.containsOneKey)</span>
        {
<span class="nc" id="L279">            target.add(function.valueOf(REMOVED_KEY));</span>
        }
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (this.keys != null)</span>
        {
<span class="nc bnc" id="L283" title="All 2 branches missed.">            for (int i = 0; i &lt; this.keys.length; i++)</span>
            {
<span class="nc bnc" id="L285" title="All 2 branches missed.">                if (isNonSentinel(this.keys[i]))</span>
                {
<span class="nc" id="L287">                    target.add(function.valueOf(this.keys[i]));</span>
                }
            }
        }
<span class="nc" id="L291">        return target.toImmutable();</span>
    }

    @Override
    public char detectIfNone(CharPredicate predicate, char ifNone)
    {
<span class="nc bnc" id="L297" title="All 4 branches missed.">        if (this.containsZeroKey &amp;&amp; predicate.accept(EMPTY_KEY))</span>
        {
<span class="nc" id="L299">            return EMPTY_KEY;</span>
        }
<span class="nc bnc" id="L301" title="All 4 branches missed.">        if (this.containsOneKey &amp;&amp; predicate.accept(REMOVED_KEY))</span>
        {
<span class="nc" id="L303">            return REMOVED_KEY;</span>
        }
<span class="nc bnc" id="L305" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L307" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.keys[i]))</span>
            {
<span class="nc" id="L309">                return this.keys[i];</span>
            }
        }
<span class="nc" id="L312">        return ifNone;</span>
    }

    @Override
    public int count(CharPredicate predicate)
    {
<span class="nc" id="L318">        int count = 0;</span>
<span class="nc bnc" id="L319" title="All 4 branches missed.">        if (this.containsZeroKey &amp;&amp; predicate.accept(EMPTY_KEY))</span>
        {
<span class="nc" id="L321">            count++;</span>
        }
<span class="nc bnc" id="L323" title="All 4 branches missed.">        if (this.containsOneKey &amp;&amp; predicate.accept(REMOVED_KEY))</span>
        {
<span class="nc" id="L325">            count++;</span>
        }
<span class="nc bnc" id="L327" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L329" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.keys[i]))</span>
            {
<span class="nc" id="L331">                count++;</span>
            }
        }
<span class="nc" id="L334">        return count;</span>
    }

    @Override
    public boolean anySatisfy(CharPredicate predicate)
    {
<span class="nc bnc" id="L340" title="All 4 branches missed.">        if (this.containsZeroKey &amp;&amp; predicate.accept(EMPTY_KEY))</span>
        {
<span class="nc" id="L342">            return true;</span>
        }
<span class="nc bnc" id="L344" title="All 4 branches missed.">        if (this.containsOneKey &amp;&amp; predicate.accept(REMOVED_KEY))</span>
        {
<span class="nc" id="L346">            return true;</span>
        }
<span class="nc bnc" id="L348" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L350" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.keys[i]))</span>
            {
<span class="nc" id="L352">                return true;</span>
            }
        }
<span class="nc" id="L355">        return false;</span>
    }

    @Override
    public boolean allSatisfy(CharPredicate predicate)
    {
<span class="nc bnc" id="L361" title="All 4 branches missed.">        if (this.containsZeroKey &amp;&amp; !predicate.accept(EMPTY_KEY))</span>
        {
<span class="nc" id="L363">            return false;</span>
        }
<span class="nc bnc" id="L365" title="All 4 branches missed.">        if (this.containsOneKey &amp;&amp; !predicate.accept(REMOVED_KEY))</span>
        {
<span class="nc" id="L367">            return false;</span>
        }
<span class="nc bnc" id="L369" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L371" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; !predicate.accept(this.keys[i]))</span>
            {
<span class="nc" id="L373">                return false;</span>
            }
        }
<span class="nc" id="L376">        return true;</span>
    }

    @Override
    public boolean noneSatisfy(CharPredicate predicate)
    {
<span class="nc bnc" id="L382" title="All 4 branches missed.">        if (this.containsZeroKey &amp;&amp; predicate.accept(EMPTY_KEY))</span>
        {
<span class="nc" id="L384">            return false;</span>
        }
<span class="nc bnc" id="L386" title="All 4 branches missed.">        if (this.containsOneKey &amp;&amp; predicate.accept(REMOVED_KEY))</span>
        {
<span class="nc" id="L388">            return false;</span>
        }
<span class="nc bnc" id="L390" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L392" title="All 4 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; predicate.accept(this.keys[i]))</span>
            {
<span class="nc" id="L394">                return false;</span>
            }
        }
<span class="nc" id="L397">        return true;</span>
    }

    @Override
    public long sum()
    {
<span class="nc" id="L403">        long result = 0L;</span>
<span class="nc" id="L404">        long compensation = 0L;</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (this.containsZeroKey)</span>
        {
<span class="nc" id="L407">            long adjustedValue = EMPTY_KEY - compensation;</span>
<span class="nc" id="L408">            long nextSum = result + adjustedValue;</span>
<span class="nc" id="L409">            compensation = nextSum - result - adjustedValue;</span>
<span class="nc" id="L410">            result = nextSum;</span>
        }
<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (this.containsOneKey)</span>
        {
<span class="nc" id="L414">            long adjustedValue = REMOVED_KEY - compensation;</span>
<span class="nc" id="L415">            long nextSum = result + adjustedValue;</span>
<span class="nc" id="L416">            compensation = nextSum - result - adjustedValue;</span>
<span class="nc" id="L417">            result = nextSum;</span>
        }
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (this.keys != null)</span>
        {
<span class="nc bnc" id="L421" title="All 2 branches missed.">            for (int i = 0; i &lt; this.keys.length; i++)</span>
            {
<span class="nc bnc" id="L423" title="All 2 branches missed.">                if (isNonSentinel(this.keys[i]))</span>
                {
<span class="nc" id="L425">                    long adjustedValue = this.keys[i] - compensation;</span>
<span class="nc" id="L426">                    long nextSum = result + adjustedValue;</span>
<span class="nc" id="L427">                    compensation = nextSum - result - adjustedValue;</span>
<span class="nc" id="L428">                    result = nextSum;</span>
                }
            }
        }
<span class="nc" id="L432">        return result;</span>
    }

    @Override
    public char max()
    {
<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L440">            throw new NoSuchElementException();</span>
        }

<span class="nc" id="L443">        char max = 0;</span>
<span class="nc" id="L444">        boolean isMaxSet = false;</span>

<span class="nc bnc" id="L446" title="All 2 branches missed.">        if (this.containsZeroKey)</span>
        {
<span class="nc" id="L448">            max = EMPTY_KEY;</span>
<span class="nc" id="L449">            isMaxSet = true;</span>
        }
<span class="nc bnc" id="L451" title="All 6 branches missed.">        if (this.containsOneKey &amp;&amp; (!isMaxSet || max &lt; REMOVED_KEY))</span>
        {
<span class="nc" id="L453">            max = REMOVED_KEY;</span>
<span class="nc" id="L454">            isMaxSet = true;</span>
        }
<span class="nc bnc" id="L456" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L458" title="All 6 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; (!isMaxSet || max &lt; this.keys[i]))</span>
            {
<span class="nc" id="L460">                max = this.keys[i];</span>
<span class="nc" id="L461">                isMaxSet = true;</span>
            }
        }
<span class="nc" id="L464">        return max;</span>
    }

    @Override
    public char min()
    {
<span class="nc bnc" id="L470" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L472">            throw new NoSuchElementException();</span>
        }

<span class="nc" id="L475">        char min = 0;</span>
<span class="nc" id="L476">        boolean isMinSet = false;</span>

<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (this.containsZeroKey)</span>
        {
<span class="nc" id="L480">            min = EMPTY_KEY;</span>
<span class="nc" id="L481">            isMinSet = true;</span>
        }
<span class="nc bnc" id="L483" title="All 6 branches missed.">        if (this.containsOneKey &amp;&amp; (!isMinSet || REMOVED_KEY &lt; min))</span>
        {
<span class="nc" id="L485">            min = REMOVED_KEY;</span>
<span class="nc" id="L486">            isMinSet = true;</span>
        }

<span class="nc bnc" id="L489" title="All 2 branches missed.">        for (int i = 0; i &lt; this.keys.length; i++)</span>
        {
<span class="nc bnc" id="L491" title="All 6 branches missed.">            if (isNonSentinel(this.keys[i]) &amp;&amp; (!isMinSet || this.keys[i] &lt; min))</span>
            {
<span class="nc" id="L493">                min = this.keys[i];</span>
<span class="nc" id="L494">                isMinSet = true;</span>
            }
        }
<span class="nc" id="L497">        return min;</span>
    }

    @Override
    public &lt;T&gt; T injectInto(T injectedValue, ObjectCharToObjectFunction&lt;? super T, ? extends T&gt; function)
    {
<span class="nc" id="L503">        T result = injectedValue;</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (this.containsZeroKey)</span>
        {
<span class="nc" id="L506">            result = function.valueOf(result, EMPTY_KEY);</span>
        }
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (this.containsOneKey)</span>
        {
<span class="nc" id="L510">            result = function.valueOf(result, REMOVED_KEY);</span>
        }
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (this.keys != null)</span>
        {
<span class="nc bnc" id="L514" title="All 2 branches missed.">            for (int i = 0; i &lt; this.keys.length; i++)</span>
            {
<span class="nc bnc" id="L516" title="All 2 branches missed.">                if (isNonSentinel(this.keys[i]))</span>
                {
<span class="nc" id="L518">                    result = function.valueOf(result, this.keys[i]);</span>
                }
            }
        }
<span class="nc" id="L522">        return result;</span>
    }

    private Object writeReplace()
    {
<span class="nc" id="L527">        return new ImmutableCharSetSerializationProxy(this);</span>
    }

    // exposed for testing
    int probe(char element)
    {
<span class="nc" id="L533">        int index = this.mask((int) element);</span>
<span class="nc" id="L534">        char keyAtIndex = this.keys[index];</span>

<span class="nc bnc" id="L536" title="All 4 branches missed.">        if (keyAtIndex == element || keyAtIndex == EMPTY_KEY)</span>
        {
<span class="nc" id="L538">            return index;</span>
        }

<span class="nc bnc" id="L541" title="All 2 branches missed.">        int removedIndex = keyAtIndex == REMOVED_KEY ? index : -1;</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">        for (int i = 1; i &lt; INITIAL_LINEAR_PROBE; i++)</span>
        {
<span class="nc" id="L544">            int nextIndex = (index + i) &amp; (this.keys.length - 1);</span>
<span class="nc" id="L545">            keyAtIndex = this.keys[nextIndex];</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">            if (keyAtIndex == element)</span>
            {
<span class="nc" id="L548">                return nextIndex;</span>
            }
<span class="nc bnc" id="L550" title="All 2 branches missed.">            if (keyAtIndex == EMPTY_KEY)</span>
            {
<span class="nc bnc" id="L552" title="All 2 branches missed.">                return removedIndex == -1 ? nextIndex : removedIndex;</span>
            }
<span class="nc bnc" id="L554" title="All 4 branches missed.">            if (keyAtIndex == REMOVED_KEY &amp;&amp; removedIndex == -1)</span>
            {
<span class="nc" id="L556">                removedIndex = nextIndex;</span>
            }
        }
<span class="nc" id="L559">        return this.probeTwo(element, removedIndex);</span>
    }

    int probeTwo(char element, int removedIndex)
    {
<span class="nc" id="L564">        int index = this.spreadTwoAndMask(element);</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">        for (int i = 0; i &lt; INITIAL_LINEAR_PROBE; i++)</span>
        {
<span class="nc" id="L567">            int nextIndex = (index + i) &amp; (this.keys.length - 1);</span>
<span class="nc" id="L568">            char keyAtIndex = this.keys[nextIndex];</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">            if (keyAtIndex == element)</span>
            {
<span class="nc" id="L571">                return nextIndex;</span>
            }
<span class="nc bnc" id="L573" title="All 2 branches missed.">            if (keyAtIndex == EMPTY_KEY)</span>
            {
<span class="nc bnc" id="L575" title="All 2 branches missed.">                return removedIndex == -1 ? nextIndex : removedIndex;</span>
            }
<span class="nc bnc" id="L577" title="All 4 branches missed.">            if (keyAtIndex == REMOVED_KEY &amp;&amp; removedIndex == -1)</span>
            {
<span class="nc" id="L579">                removedIndex = nextIndex;</span>
            }
        }
<span class="nc" id="L582">        return this.probeThree(element, removedIndex);</span>
    }

    int probeThree(char element, int removedIndex)
    {
<span class="nc" id="L587">        int nextIndex = (int) SpreadFunctions.charSpreadOne(element);</span>
<span class="nc" id="L588">        int spreadTwo = Integer.reverse(SpreadFunctions.charSpreadTwo(element)) | 1;</span>

        while (true)
        {
<span class="nc" id="L592">            nextIndex = this.mask(nextIndex + spreadTwo);</span>
<span class="nc" id="L593">            char keyAtIndex = this.keys[nextIndex];</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">            if (keyAtIndex == element)</span>
            {
<span class="nc" id="L596">                return nextIndex;</span>
            }
<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (keyAtIndex == EMPTY_KEY)</span>
            {
<span class="nc bnc" id="L600" title="All 2 branches missed.">                return removedIndex == -1 ? nextIndex : removedIndex;</span>
            }
<span class="nc bnc" id="L602" title="All 4 branches missed.">            if (keyAtIndex == REMOVED_KEY &amp;&amp; removedIndex == -1)</span>
            {
<span class="nc" id="L604">                removedIndex = nextIndex;</span>
            }
<span class="nc" id="L606">        }</span>
    }

    // exposed for testing
    int spreadAndMask(char element)
    {
<span class="nc" id="L612">        int code = SpreadFunctions.charSpreadOne(element);</span>
<span class="nc" id="L613">        return this.mask(code);</span>
    }

    int spreadTwoAndMask(char element)
    {
<span class="nc" id="L618">        int code = SpreadFunctions.charSpreadTwo(element);</span>
<span class="nc" id="L619">        return this.mask(code);</span>
    }

    private int mask(int spread)
    {
<span class="nc" id="L624">        return spread &amp; (this.keys.length - 1);</span>
    }

<span class="nc" id="L627">    private class InternalCharIterator implements CharIterator</span>
    {
        private int count;
        private int position;
        private boolean handledZero;
        private boolean handledOne;

        @Override
        public boolean hasNext()
        {
<span class="nc bnc" id="L637" title="All 2 branches missed.">            return this.count &lt; ImmutableCharMapKeySet.this.size();</span>
        }

        @Override
        public char next()
        {
<span class="nc bnc" id="L643" title="All 2 branches missed.">            if (!this.hasNext())</span>
            {
<span class="nc" id="L645">                throw new NoSuchElementException(&quot;next() called, but the iterator is exhausted&quot;);</span>
            }
<span class="nc" id="L647">            this.count++;</span>

<span class="nc bnc" id="L649" title="All 2 branches missed.">            if (!this.handledZero)</span>
            {
<span class="nc" id="L651">                this.handledZero = true;</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">                if (ImmutableCharMapKeySet.this.containsZeroKey)</span>
                {
<span class="nc" id="L654">                    return ImmutableCharMapKeySet.EMPTY_KEY;</span>
                }
            }
<span class="nc bnc" id="L657" title="All 2 branches missed.">            if (!this.handledOne)</span>
            {
<span class="nc" id="L659">                this.handledOne = true;</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">                if (ImmutableCharMapKeySet.this.containsOneKey)</span>
                {
<span class="nc" id="L662">                    return ImmutableCharMapKeySet.REMOVED_KEY;</span>
                }
            }

<span class="nc" id="L666">            char[] keys = ImmutableCharMapKeySet.this.keys;</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">            while (!ImmutableCharMapKeySet.isNonSentinel(keys[this.position]))</span>
            {
<span class="nc" id="L669">                this.position++;</span>
            }
<span class="nc" id="L671">            char result = ImmutableCharMapKeySet.this.keys[this.position];</span>
<span class="nc" id="L672">            this.position++;</span>
<span class="nc" id="L673">            return result;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>