<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RandomAccessListIterate.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.impl.utility.internal</a> &gt; <span class="el_source">RandomAccessListIterate.java</span></div><h1>RandomAccessListIterate.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2018 Goldman Sachs and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.impl.utility.internal;

import java.io.IOException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.RandomAccess;

import org.eclipse.collections.api.RichIterable;
import org.eclipse.collections.api.block.HashingStrategy;
import org.eclipse.collections.api.block.function.Function;
import org.eclipse.collections.api.block.function.Function0;
import org.eclipse.collections.api.block.function.Function2;
import org.eclipse.collections.api.block.function.Function3;
import org.eclipse.collections.api.block.function.primitive.BooleanFunction;
import org.eclipse.collections.api.block.function.primitive.ByteFunction;
import org.eclipse.collections.api.block.function.primitive.CharFunction;
import org.eclipse.collections.api.block.function.primitive.DoubleFunction;
import org.eclipse.collections.api.block.function.primitive.DoubleObjectToDoubleFunction;
import org.eclipse.collections.api.block.function.primitive.FloatFunction;
import org.eclipse.collections.api.block.function.primitive.FloatObjectToFloatFunction;
import org.eclipse.collections.api.block.function.primitive.IntFunction;
import org.eclipse.collections.api.block.function.primitive.IntObjectToIntFunction;
import org.eclipse.collections.api.block.function.primitive.LongFunction;
import org.eclipse.collections.api.block.function.primitive.LongObjectToLongFunction;
import org.eclipse.collections.api.block.function.primitive.ObjectIntToObjectFunction;
import org.eclipse.collections.api.block.function.primitive.ShortFunction;
import org.eclipse.collections.api.block.predicate.Predicate;
import org.eclipse.collections.api.block.predicate.Predicate2;
import org.eclipse.collections.api.block.procedure.Procedure;
import org.eclipse.collections.api.block.procedure.Procedure2;
import org.eclipse.collections.api.block.procedure.primitive.ObjectIntProcedure;
import org.eclipse.collections.api.collection.primitive.MutableBooleanCollection;
import org.eclipse.collections.api.collection.primitive.MutableByteCollection;
import org.eclipse.collections.api.collection.primitive.MutableCharCollection;
import org.eclipse.collections.api.collection.primitive.MutableDoubleCollection;
import org.eclipse.collections.api.collection.primitive.MutableFloatCollection;
import org.eclipse.collections.api.collection.primitive.MutableIntCollection;
import org.eclipse.collections.api.collection.primitive.MutableLongCollection;
import org.eclipse.collections.api.collection.primitive.MutableShortCollection;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.api.list.primitive.MutableBooleanList;
import org.eclipse.collections.api.list.primitive.MutableByteList;
import org.eclipse.collections.api.list.primitive.MutableCharList;
import org.eclipse.collections.api.list.primitive.MutableDoubleList;
import org.eclipse.collections.api.list.primitive.MutableFloatList;
import org.eclipse.collections.api.list.primitive.MutableIntList;
import org.eclipse.collections.api.list.primitive.MutableLongList;
import org.eclipse.collections.api.list.primitive.MutableShortList;
import org.eclipse.collections.api.map.MutableMap;
import org.eclipse.collections.api.map.primitive.ObjectDoubleMap;
import org.eclipse.collections.api.map.primitive.ObjectLongMap;
import org.eclipse.collections.api.multimap.MutableMultimap;
import org.eclipse.collections.api.ordered.OrderedIterable;
import org.eclipse.collections.api.partition.list.PartitionMutableList;
import org.eclipse.collections.api.set.MutableSet;
import org.eclipse.collections.api.tuple.Pair;
import org.eclipse.collections.api.tuple.Twin;
import org.eclipse.collections.impl.block.factory.Functions0;
import org.eclipse.collections.impl.block.procedure.MutatingAggregationProcedure;
import org.eclipse.collections.impl.block.procedure.NonMutatingAggregationProcedure;
import org.eclipse.collections.impl.factory.Lists;
import org.eclipse.collections.impl.list.mutable.FastList;
import org.eclipse.collections.impl.list.mutable.primitive.BooleanArrayList;
import org.eclipse.collections.impl.list.mutable.primitive.ByteArrayList;
import org.eclipse.collections.impl.list.mutable.primitive.CharArrayList;
import org.eclipse.collections.impl.list.mutable.primitive.DoubleArrayList;
import org.eclipse.collections.impl.list.mutable.primitive.FloatArrayList;
import org.eclipse.collections.impl.list.mutable.primitive.IntArrayList;
import org.eclipse.collections.impl.list.mutable.primitive.LongArrayList;
import org.eclipse.collections.impl.list.mutable.primitive.ShortArrayList;
import org.eclipse.collections.impl.map.mutable.UnifiedMap;
import org.eclipse.collections.impl.map.mutable.primitive.ObjectDoubleHashMap;
import org.eclipse.collections.impl.map.mutable.primitive.ObjectLongHashMap;
import org.eclipse.collections.impl.multimap.list.FastListMultimap;
import org.eclipse.collections.impl.partition.list.PartitionFastList;
import org.eclipse.collections.impl.set.mutable.UnifiedSet;
import org.eclipse.collections.impl.set.strategy.mutable.UnifiedSetWithHashingStrategy;
import org.eclipse.collections.impl.tuple.Tuples;
import org.eclipse.collections.impl.utility.Iterate;
import org.eclipse.collections.impl.utility.ListIterate;

/**
 * The ListIterate class provides a few of the methods from the Smalltalk Collection Protocol for use with ArrayLists.
 * This includes do:, select:, reject:, collect:, inject:into:, detect:, detect:ifNone:, anySatisfy: and allSatisfy:
 */
public final class RandomAccessListIterate
{
    private RandomAccessListIterate()
<span class="nc" id="L105">    {</span>
<span class="nc" id="L106">        throw new AssertionError(&quot;Suppress default constructor for noninstantiability&quot;);</span>
    }

    public static &lt;T&gt; void toArray(List&lt;T&gt; list, T[] target, int startIndex, int sourceSize)
    {
<span class="nc bnc" id="L111" title="All 2 branches missed.">        for (int i = 0; i &lt; sourceSize; i++)</span>
        {
<span class="nc" id="L113">            target[startIndex + i] = list.get(i);</span>
        }
<span class="nc" id="L115">    }</span>

    /**
     * @see Iterate#select(Iterable, Predicate)
     */
    public static &lt;T&gt; MutableList&lt;T&gt; select(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L122">        return RandomAccessListIterate.select(list, predicate, FastList.newList());</span>
    }

    /**
     * @see Iterate#selectWith(Iterable, Predicate2, Object)
     */
    public static &lt;T, IV&gt; MutableList&lt;T&gt; selectWith(
            List&lt;T&gt; list,
            Predicate2&lt;? super T, ? super IV&gt; predicate,
            IV injectedValue)
    {
<span class="nc" id="L133">        return RandomAccessListIterate.selectWith(list, predicate, injectedValue, FastList.newList());</span>
    }

    /**
     * @see Iterate#select(Iterable, Predicate, Collection)
     */
    public static &lt;T, R extends Collection&lt;T&gt;&gt; R select(
            List&lt;T&gt; list,
            Predicate&lt;? super T&gt; predicate,
            R targetCollection)
    {
<span class="nc" id="L144">        int size = list.size();</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L147">            T item = list.get(i);</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            if (predicate.accept(item))</span>
            {
<span class="nc" id="L150">                targetCollection.add(item);</span>
            }
        }
<span class="nc" id="L153">        return targetCollection;</span>
    }

    /**
     * @see Iterate#selectWith(Iterable, Predicate2, Object, Collection)
     */
    public static &lt;T, P, R extends Collection&lt;T&gt;&gt; R selectWith(
            List&lt;T&gt; list,
            Predicate2&lt;? super T, ? super P&gt; predicate,
            P parameter,
            R targetCollection)
    {
<span class="nc" id="L165">        int size = list.size();</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L168">            T item = list.get(i);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (predicate.accept(item, parameter))</span>
            {
<span class="nc" id="L171">                targetCollection.add(item);</span>
            }
        }
<span class="nc" id="L174">        return targetCollection;</span>
    }

    /**
     * @see Iterate#selectInstancesOf(Iterable, Class)
     */
    public static &lt;T&gt; MutableList&lt;T&gt; selectInstancesOf(
            List&lt;?&gt; list,
            Class&lt;T&gt; clazz)
    {
<span class="nc" id="L184">        int size = list.size();</span>
<span class="nc" id="L185">        FastList&lt;T&gt; result = FastList.newList(size);</span>

<span class="nc bnc" id="L187" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L189">            Object item = list.get(i);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">            if (clazz.isInstance(item))</span>
            {
<span class="nc" id="L192">                result.add((T) item);</span>
            }
        }
<span class="nc" id="L195">        result.trimToSize();</span>
<span class="nc" id="L196">        return result;</span>
    }

    /**
     * @see Iterate#count(Iterable, Predicate)
     */
    public static &lt;T&gt; int count(
            List&lt;T&gt; list,
            Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L206">        int count = 0;</span>
<span class="nc" id="L207">        int size = list.size();</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc bnc" id="L210" title="All 2 branches missed.">            if (predicate.accept(list.get(i)))</span>
            {
<span class="nc" id="L212">                count++;</span>
            }
        }
<span class="nc" id="L215">        return count;</span>
    }

    public static &lt;T, IV&gt; int countWith(
            List&lt;T&gt; list,
            Predicate2&lt;? super T, ? super IV&gt; predicate,
            IV injectedValue)
    {
<span class="nc" id="L223">        int count = 0;</span>
<span class="nc" id="L224">        int size = list.size();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if (predicate.accept(list.get(i), injectedValue))</span>
            {
<span class="nc" id="L229">                count++;</span>
            }
        }
<span class="nc" id="L232">        return count;</span>
    }

    /**
     * @see Iterate#collectIf(Iterable, Predicate, Function)
     */
    public static &lt;T, A&gt; MutableList&lt;A&gt; collectIf(
            List&lt;T&gt; list,
            Predicate&lt;? super T&gt; predicate,
            Function&lt;? super T, ? extends A&gt; function)
    {
<span class="nc" id="L243">        return RandomAccessListIterate.collectIf(list, predicate, function, FastList.newList());</span>
    }

    /**
     * @see Iterate#collectIf(Iterable, Predicate, Function, Collection)
     */
    public static &lt;T, A, R extends Collection&lt;A&gt;&gt; R collectIf(
            List&lt;T&gt; list,
            Predicate&lt;? super T&gt; predicate,
            Function&lt;? super T, ? extends A&gt; function,
            R targetCollection)
    {
<span class="nc" id="L255">        int size = list.size();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L258">            T item = list.get(i);</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">            if (predicate.accept(item))</span>
            {
<span class="nc" id="L261">                targetCollection.add(function.valueOf(item));</span>
            }
        }
<span class="nc" id="L264">        return targetCollection;</span>
    }

    /**
     * @see Iterate#reject(Iterable, Predicate)
     */
    public static &lt;T&gt; MutableList&lt;T&gt; reject(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L272">        return RandomAccessListIterate.reject(list, predicate, FastList.newList());</span>
    }

    /**
     * @see Iterate#rejectWith(Iterable, Predicate2, Object)
     */
    public static &lt;T, IV&gt; MutableList&lt;T&gt; rejectWith(
            List&lt;T&gt; list,
            Predicate2&lt;? super T, ? super IV&gt; predicate,
            IV injectedValue)
    {
<span class="nc" id="L283">        return RandomAccessListIterate.rejectWith(list, predicate, injectedValue, FastList.newList());</span>
    }

    /**
     * @see Iterate#reject(Iterable, Predicate, Collection)
     */
    public static &lt;T, R extends Collection&lt;T&gt;&gt; R reject(
            List&lt;T&gt; list,
            Predicate&lt;? super T&gt; predicate,
            R targetCollection)
    {
<span class="nc" id="L294">        int size = list.size();</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L297">            T item = list.get(i);</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (!predicate.accept(item))</span>
            {
<span class="nc" id="L300">                targetCollection.add(item);</span>
            }
        }
<span class="nc" id="L303">        return targetCollection;</span>
    }

    /**
     * @see Iterate#reject(Iterable, Predicate, Collection)
     */
    public static &lt;T, P, R extends Collection&lt;T&gt;&gt; R rejectWith(
            List&lt;T&gt; list,
            Predicate2&lt;? super T, ? super P&gt; predicate,
            P parameter,
            R targetCollection)
    {
<span class="nc" id="L315">        int size = list.size();</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L318">            T item = list.get(i);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">            if (!predicate.accept(item, parameter))</span>
            {
<span class="nc" id="L321">                targetCollection.add(item);</span>
            }
        }
<span class="nc" id="L324">        return targetCollection;</span>
    }

    /**
     * @see Iterate#collect(Iterable, Function)
     */
    public static &lt;T, A&gt; MutableList&lt;A&gt; collect(
            List&lt;T&gt; list,
            Function&lt;? super T, ? extends A&gt; function)
    {
<span class="nc" id="L334">        return RandomAccessListIterate.collect(list, function, FastList.newList(list.size()));</span>
    }

    /**
     * @see Iterate#collect(Iterable, Function, Collection)
     */
    public static &lt;T, A, R extends Collection&lt;A&gt;&gt; R collect(
            List&lt;T&gt; list,
            Function&lt;? super T, ? extends A&gt; function,
            R targetCollection)
    {
<span class="nc" id="L345">        int size = list.size();</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L348">            targetCollection.add(function.valueOf(list.get(i)));</span>
        }
<span class="nc" id="L350">        return targetCollection;</span>
    }

    /**
     * @since 9.1
     */
    public static &lt;T, A&gt; MutableList&lt;A&gt; collectWithIndex(List&lt;T&gt; list, ObjectIntToObjectFunction&lt;? super T, ? extends A&gt; function)
    {
<span class="nc" id="L358">        return RandomAccessListIterate.collectWithIndex(list, function, FastList.newList(list.size()));</span>
    }

    /**
     * @since 9.1
     */
    public static &lt;T, A, R extends Collection&lt;A&gt;&gt; R collectWithIndex(List&lt;T&gt; list, ObjectIntToObjectFunction&lt;? super T, ? extends A&gt; function, R targetCollection)
    {
<span class="nc bnc" id="L366" title="All 2 branches missed.">        for (int i = 0; i &lt; list.size(); i++)</span>
        {
<span class="nc" id="L368">            targetCollection.add(function.valueOf(list.get(i), i));</span>
        }
<span class="nc" id="L370">        return targetCollection;</span>
    }

    /**
     * @see Iterate#collectBoolean(Iterable, BooleanFunction)
     */
    public static &lt;T&gt; MutableBooleanList collectBoolean(
            List&lt;T&gt; list,
            BooleanFunction&lt;? super T&gt; booleanFunction)
    {
<span class="nc" id="L380">        return RandomAccessListIterate.collectBoolean(list, booleanFunction, new BooleanArrayList(list.size()));</span>
    }

    /**
     * @see Iterate#collectBoolean(Iterable, BooleanFunction)
     */
    public static &lt;T, R extends MutableBooleanCollection&gt; R collectBoolean(
            List&lt;T&gt; list,
            BooleanFunction&lt;? super T&gt; booleanFunction,
            R target)
    {
<span class="nc" id="L391">        int size = list.size();</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L394">            target.add(booleanFunction.booleanValueOf(list.get(i)));</span>
        }
<span class="nc" id="L396">        return target;</span>
    }

    /**
     * @see Iterate#collectByte(Iterable, ByteFunction)
     */
    public static &lt;T&gt; MutableByteList collectByte(
            List&lt;T&gt; list,
            ByteFunction&lt;? super T&gt; byteFunction)
    {
<span class="nc" id="L406">        return RandomAccessListIterate.collectByte(list, byteFunction, new ByteArrayList(list.size()));</span>
    }

    /**
     * @see Iterate#collectByte(Iterable, ByteFunction)
     */
    public static &lt;T, R extends MutableByteCollection&gt; R collectByte(
            List&lt;T&gt; list,
            ByteFunction&lt;? super T&gt; byteFunction,
            R target)
    {
<span class="nc" id="L417">        int size = list.size();</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L420">            target.add(byteFunction.byteValueOf(list.get(i)));</span>
        }
<span class="nc" id="L422">        return target;</span>
    }

    /**
     * @see Iterate#collectChar(Iterable, CharFunction)
     */
    public static &lt;T&gt; MutableCharList collectChar(
            List&lt;T&gt; list,
            CharFunction&lt;? super T&gt; charFunction)
    {
<span class="nc" id="L432">        return RandomAccessListIterate.collectChar(list, charFunction, new CharArrayList(list.size()));</span>
    }

    /**
     * @see Iterate#collectChar(Iterable, CharFunction)
     */
    public static &lt;T, R extends MutableCharCollection&gt; R collectChar(
            List&lt;T&gt; list,
            CharFunction&lt;? super T&gt; charFunction,
            R target)
    {
<span class="nc" id="L443">        int size = list.size();</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L446">            target.add(charFunction.charValueOf(list.get(i)));</span>
        }
<span class="nc" id="L448">        return target;</span>
    }

    /**
     * @see Iterate#collectDouble(Iterable, DoubleFunction)
     */
    public static &lt;T&gt; MutableDoubleList collectDouble(
            List&lt;T&gt; list,
            DoubleFunction&lt;? super T&gt; doubleFunction)
    {
<span class="nc" id="L458">        return RandomAccessListIterate.collectDouble(list, doubleFunction, new DoubleArrayList(list.size()));</span>
    }

    /**
     * @see Iterate#collectDouble(Iterable, DoubleFunction)
     */
    public static &lt;T, R extends MutableDoubleCollection&gt; R collectDouble(
            List&lt;T&gt; list,
            DoubleFunction&lt;? super T&gt; doubleFunction,
            R target)
    {
<span class="nc" id="L469">        int size = list.size();</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L472">            target.add(doubleFunction.doubleValueOf(list.get(i)));</span>
        }
<span class="nc" id="L474">        return target;</span>
    }

    /**
     * @see Iterate#collectFloat(Iterable, FloatFunction)
     */
    public static &lt;T&gt; MutableFloatList collectFloat(
            List&lt;T&gt; list,
            FloatFunction&lt;? super T&gt; floatFunction)
    {
<span class="nc" id="L484">        return RandomAccessListIterate.collectFloat(list, floatFunction, new FloatArrayList(list.size()));</span>
    }

    /**
     * @see Iterate#collectFloat(Iterable, FloatFunction)
     */
    public static &lt;T, R extends MutableFloatCollection&gt; R collectFloat(
            List&lt;T&gt; list,
            FloatFunction&lt;? super T&gt; floatFunction,
            R target)
    {
<span class="nc" id="L495">        int size = list.size();</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L498">            target.add(floatFunction.floatValueOf(list.get(i)));</span>
        }
<span class="nc" id="L500">        return target;</span>
    }

    /**
     * @see Iterate#collectInt(Iterable, IntFunction)
     */
    public static &lt;T&gt; MutableIntList collectInt(
            List&lt;T&gt; list,
            IntFunction&lt;? super T&gt; intFunction)
    {
<span class="nc" id="L510">        return RandomAccessListIterate.collectInt(list, intFunction, new IntArrayList(list.size()));</span>
    }

    /**
     * @see Iterate#collectInt(Iterable, IntFunction)
     */
    public static &lt;T, R extends MutableIntCollection&gt; R collectInt(
            List&lt;T&gt; list,
            IntFunction&lt;? super T&gt; intFunction,
            R target)
    {
<span class="nc" id="L521">        int size = list.size();</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L524">            target.add(intFunction.intValueOf(list.get(i)));</span>
        }
<span class="nc" id="L526">        return target;</span>
    }

    /**
     * @see Iterate#collectLong(Iterable, LongFunction)
     */
    public static &lt;T&gt; MutableLongList collectLong(
            List&lt;T&gt; list,
            LongFunction&lt;? super T&gt; longFunction)
    {
<span class="nc" id="L536">        return RandomAccessListIterate.collectLong(list, longFunction, new LongArrayList(list.size()));</span>
    }

    /**
     * @see Iterate#collectLong(Iterable, LongFunction)
     */
    public static &lt;T, R extends MutableLongCollection&gt; R collectLong(
            List&lt;T&gt; list,
            LongFunction&lt;? super T&gt; longFunction,
            R target)
    {
<span class="nc" id="L547">        int size = list.size();</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L550">            target.add(longFunction.longValueOf(list.get(i)));</span>
        }
<span class="nc" id="L552">        return target;</span>
    }

    /**
     * @see Iterate#collectShort(Iterable, ShortFunction)
     */
    public static &lt;T&gt; MutableShortList collectShort(
            List&lt;T&gt; list,
            ShortFunction&lt;? super T&gt; shortFunction)
    {
<span class="nc" id="L562">        return RandomAccessListIterate.collectShort(list, shortFunction, new ShortArrayList(list.size()));</span>
    }

    /**
     * @see Iterate#collectShort(Iterable, ShortFunction)
     */
    public static &lt;T, R extends MutableShortCollection&gt; R collectShort(
            List&lt;T&gt; list,
            ShortFunction&lt;? super T&gt; shortFunction,
            R target)
    {
<span class="nc" id="L573">        int size = list.size();</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L576">            target.add(shortFunction.shortValueOf(list.get(i)));</span>
        }
<span class="nc" id="L578">        return target;</span>
    }

    /**
     * @see Iterate#flatCollect(Iterable, Function)
     */
    public static &lt;T, A&gt; MutableList&lt;A&gt; flatCollect(
            List&lt;T&gt; list,
            Function&lt;? super T, ? extends Iterable&lt;A&gt;&gt; function)
    {
<span class="nc" id="L588">        return RandomAccessListIterate.flatCollect(list, function, FastList.newList(list.size()));</span>
    }

    /**
     * @see Iterate#flatCollect(Iterable, Function, Collection)
     */
    public static &lt;T, A, R extends Collection&lt;A&gt;&gt; R flatCollect(
            List&lt;T&gt; list,
            Function&lt;? super T, ? extends Iterable&lt;A&gt;&gt; function,
            R targetCollection)
    {
<span class="nc" id="L599">        int size = list.size();</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L602">            Iterate.addAllTo(function.valueOf(list.get(i)), targetCollection);</span>
        }
<span class="nc" id="L604">        return targetCollection;</span>
    }

    /**
     * Returns the last element of a list.
     */
    public static &lt;T&gt; T getLast(List&lt;T&gt; collection)
    {
<span class="nc bnc" id="L612" title="All 2 branches missed.">        return Iterate.isEmpty(collection) ? null : collection.get(collection.size() - 1);</span>
    }

    /**
     * @see Iterate#forEach(Iterable, Procedure)
     */
    public static &lt;T&gt; void forEach(List&lt;T&gt; list, Procedure&lt;? super T&gt; procedure)
    {
<span class="nc" id="L620">        int size = list.size();</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L623">            procedure.value(list.get(i));</span>
        }
<span class="nc" id="L625">    }</span>

    /**
     * Iterates over the section of the list covered by the specified indexes.  The indexes are both inclusive.  If the
     * from is less than the to, the list is iterated in forward order. If the from is greater than the to, then the
     * list is iterated in the reverse order.
     * &lt;p&gt;
     * &lt;pre&gt;e.g.
     * MutableList&amp;lt;People&amp;gt; people = FastList.newListWith(ted, mary, bob, sally);
     * ListIterate.forEach(people, 0, 1, new Procedure&amp;lt;Person&amp;gt;()
     * {
     *     public void value(Person person)
     *     {
     *          LOGGER.info(person.getName());
     *     }
     * });
     * &lt;/pre&gt;
     * &lt;p&gt;
     * This code would output ted and mary's names.
     */
    public static &lt;T&gt; void forEach(List&lt;T&gt; list, int from, int to, Procedure&lt;? super T&gt; procedure)
    {
<span class="nc" id="L647">        ListIterate.rangeCheck(from, to, list.size());</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">        if (from &lt;= to)</span>
        {
<span class="nc bnc" id="L650" title="All 2 branches missed.">            for (int i = from; i &lt;= to; i++)</span>
            {
<span class="nc" id="L652">                procedure.value(list.get(i));</span>
            }
        }
        else
        {
<span class="nc bnc" id="L657" title="All 2 branches missed.">            for (int i = from; i &gt;= to; i--)</span>
            {
<span class="nc" id="L659">                procedure.value(list.get(i));</span>
            }
        }
<span class="nc" id="L662">    }</span>

    /**
     * Iterates over the section of the list covered by the specified indexes.  The indexes are both inclusive.  If the
     * from is less than the to, the list is iterated in forward order. If the from is greater than the to, then the
     * list is iterated in the reverse order. The index passed into the ObjectIntProcedure is the actual index of the
     * range.
     * &lt;p&gt;
     * &lt;pre&gt;e.g.
     * MutableList&amp;lt;People&amp;gt; people = FastList.newListWith(ted, mary, bob, sally);
     * ListIterate.forEachWithIndex(people, 0, 1, new ObjectIntProcedure&amp;lt;Person&amp;gt;()
     * {
     *     public void value(Person person, int index)
     *     {
     *          LOGGER.info(person.getName() + &quot; at index: &quot; + index);
     *     }
     * });
     * &lt;/pre&gt;
     * &lt;p&gt;
     * This code would output ted and mary's names.
     */
    public static &lt;T&gt; void forEachWithIndex(List&lt;T&gt; list, int from, int to, ObjectIntProcedure&lt;? super T&gt; objectIntProcedure)
    {
<span class="nc" id="L685">        ListIterate.rangeCheck(from, to, list.size());</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">        if (from &lt;= to)</span>
        {
<span class="nc bnc" id="L688" title="All 2 branches missed.">            for (int i = from; i &lt;= to; i++)</span>
            {
<span class="nc" id="L690">                objectIntProcedure.value(list.get(i), i);</span>
            }
        }
        else
        {
<span class="nc bnc" id="L695" title="All 2 branches missed.">            for (int i = from; i &gt;= to; i--)</span>
            {
<span class="nc" id="L697">                objectIntProcedure.value(list.get(i), i);</span>
            }
        }
<span class="nc" id="L700">    }</span>

    /**
     * For each element in both of the Lists, operation is evaluated with both elements as parameters.
     */
    public static &lt;T1, T2&gt; void forEachInBoth(List&lt;T1&gt; list1, List&lt;T2&gt; list2, Procedure2&lt;? super T1, ? super T2&gt; procedure)
    {
<span class="nc bnc" id="L707" title="All 4 branches missed.">        if (list1 != null &amp;&amp; list2 != null)</span>
        {
<span class="nc" id="L709">            int size1 = list1.size();</span>
<span class="nc" id="L710">            int size2 = list2.size();</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">            if (size1 == size2)</span>
            {
<span class="nc bnc" id="L713" title="All 2 branches missed.">                for (int i = 0; i &lt; size1; i++)</span>
                {
<span class="nc" id="L715">                    procedure.value(list1.get(i), list2.get(i));</span>
                }
            }
            else
            {
<span class="nc" id="L720">                throw new IllegalArgumentException(&quot;Attempt to call forEachInBoth with two Lists of different sizes :&quot;</span>
                        + size1
                        + ':'
                        + size2);
            }
        }
<span class="nc" id="L726">    }</span>

    /**
     * Iterates over a collection passing each element and the current relative int index to the specified instance of
     * ObjectIntProcedure.
     */
    public static &lt;T&gt; void forEachWithIndex(List&lt;T&gt; list, ObjectIntProcedure&lt;? super T&gt; objectIntProcedure)
    {
<span class="nc" id="L734">        int size = list.size();</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L737">            objectIntProcedure.value(list.get(i), i);</span>
        }
<span class="nc" id="L739">    }</span>

    public static &lt;T, IV&gt; IV injectInto(IV injectValue, List&lt;T&gt; list, Function2&lt;? super IV, ? super T, ? extends IV&gt; function)
    {
<span class="nc" id="L743">        IV result = injectValue;</span>
<span class="nc" id="L744">        int size = list.size();</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L747">            result = function.value(result, list.get(i));</span>
        }
<span class="nc" id="L749">        return result;</span>
    }

    public static &lt;T&gt; int injectInto(int injectValue, List&lt;T&gt; list, IntObjectToIntFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L754">        int result = injectValue;</span>
<span class="nc" id="L755">        int size = list.size();</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L758">            result = function.intValueOf(result, list.get(i));</span>
        }
<span class="nc" id="L760">        return result;</span>
    }

    public static &lt;T&gt; long injectInto(long injectValue, List&lt;T&gt; list, LongObjectToLongFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L765">        long result = injectValue;</span>
<span class="nc" id="L766">        int size = list.size();</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L769">            result = function.longValueOf(result, list.get(i));</span>
        }
<span class="nc" id="L771">        return result;</span>
    }

    public static &lt;T&gt; double injectInto(double injectValue, List&lt;T&gt; list, DoubleObjectToDoubleFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L776">        double result = injectValue;</span>
<span class="nc" id="L777">        int size = list.size();</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L780">            result = function.doubleValueOf(result, list.get(i));</span>
        }
<span class="nc" id="L782">        return result;</span>
    }

    public static &lt;T&gt; float injectInto(float injectValue, List&lt;T&gt; list, FloatObjectToFloatFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L787">        float result = injectValue;</span>
<span class="nc" id="L788">        int size = list.size();</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L791">            result = function.floatValueOf(result, list.get(i));</span>
        }
<span class="nc" id="L793">        return result;</span>
    }

    public static &lt;T&gt; long sumOfInt(List&lt;T&gt; list, IntFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L798">        long result = 0;</span>
<span class="nc" id="L799">        int size = list.size();</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L802">            result += (long) function.intValueOf(list.get(i));</span>
        }
<span class="nc" id="L804">        return result;</span>
    }

    public static &lt;T&gt; long sumOfLong(List&lt;T&gt; list, LongFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L809">        long result = 0L;</span>
<span class="nc" id="L810">        int size = list.size();</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L813">            result += function.longValueOf(list.get(i));</span>
        }
<span class="nc" id="L815">        return result;</span>
    }

    public static &lt;T&gt; double sumOfFloat(List&lt;T&gt; list, FloatFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L820">        double sum = 0.0d;</span>
<span class="nc" id="L821">        double compensation = 0.0d;</span>
<span class="nc" id="L822">        int size = list.size();</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L825">            double adjustedValue = (double) function.floatValueOf(list.get(i)) - compensation;</span>
<span class="nc" id="L826">            double nextSum = sum + adjustedValue;</span>
<span class="nc" id="L827">            compensation = nextSum - sum - adjustedValue;</span>
<span class="nc" id="L828">            sum = nextSum;</span>
        }
<span class="nc" id="L830">        return sum;</span>
    }

    public static &lt;T&gt; double sumOfDouble(List&lt;T&gt; list, DoubleFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L835">        double sum = 0.0d;</span>
<span class="nc" id="L836">        double compensation = 0.0d;</span>
<span class="nc" id="L837">        int size = list.size();</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L840">            double adjustedValue = function.doubleValueOf(list.get(i)) - compensation;</span>
<span class="nc" id="L841">            double nextSum = sum + adjustedValue;</span>
<span class="nc" id="L842">            compensation = nextSum - sum - adjustedValue;</span>
<span class="nc" id="L843">            sum = nextSum;</span>
        }
<span class="nc" id="L845">        return sum;</span>
    }

    public static &lt;T&gt; BigDecimal sumOfBigDecimal(List&lt;T&gt; list, Function&lt;? super T, BigDecimal&gt; function)
    {
<span class="nc" id="L850">        BigDecimal result = BigDecimal.ZERO;</span>
<span class="nc" id="L851">        int size = list.size();</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L854">            result = result.add(function.valueOf(list.get(i)));</span>
        }
<span class="nc" id="L856">        return result;</span>
    }

    public static &lt;T&gt; BigInteger sumOfBigInteger(List&lt;T&gt; list, Function&lt;? super T, BigInteger&gt; function)
    {
<span class="nc" id="L861">        BigInteger result = BigInteger.ZERO;</span>
<span class="nc" id="L862">        int size = list.size();</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L865">            result = result.add(function.valueOf(list.get(i)));</span>
        }
<span class="nc" id="L867">        return result;</span>
    }

    public static &lt;V, T&gt; MutableMap&lt;V, BigDecimal&gt; sumByBigDecimal(List&lt;T&gt; list, Function&lt;T, V&gt; groupBy, Function&lt;? super T, BigDecimal&gt; function)
    {
<span class="nc" id="L872">        MutableMap&lt;V, BigDecimal&gt; result = UnifiedMap.newMap();</span>
<span class="nc" id="L873">        int size = list.size();</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L876">            T item = list.get(i);</span>
<span class="nc" id="L877">            result.updateValue(groupBy.valueOf(item), Functions0.zeroBigDecimal(), original -&gt; original.add(function.valueOf(item)));</span>
        }
<span class="nc" id="L879">        return result;</span>
    }

    public static &lt;V, T&gt; MutableMap&lt;V, BigInteger&gt; sumByBigInteger(List&lt;T&gt; list, Function&lt;T, V&gt; groupBy, Function&lt;? super T, BigInteger&gt; function)
    {
<span class="nc" id="L884">        MutableMap&lt;V, BigInteger&gt; result = UnifiedMap.newMap();</span>
<span class="nc" id="L885">        int size = list.size();</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L888">            T item = list.get(i);</span>
<span class="nc" id="L889">            result.updateValue(groupBy.valueOf(item), Functions0.zeroBigInteger(), original -&gt; original.add(function.valueOf(item)));</span>
        }
<span class="nc" id="L891">        return result;</span>
    }

    public static &lt;T&gt; boolean shortCircuit(
            List&lt;T&gt; list,
            Predicate&lt;? super T&gt; predicate,
            boolean expected,
            boolean onShortCircuit,
            boolean atEnd)
    {
<span class="nc" id="L901">        int size = list.size();</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc bnc" id="L904" title="All 2 branches missed.">            if (predicate.accept(list.get(i)) == expected)</span>
            {
<span class="nc" id="L906">                return onShortCircuit;</span>
            }
        }
<span class="nc" id="L909">        return atEnd;</span>
    }

    public static &lt;T, P&gt; boolean shortCircuitWith(
            List&lt;T&gt; list,
            Predicate2&lt;? super T, ? super P&gt; predicate2,
            P parameter,
            boolean expected,
            boolean onShortCircuit,
            boolean atEnd)
    {
<span class="nc" id="L920">        int size = list.size();</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc bnc" id="L923" title="All 2 branches missed.">            if (predicate2.accept(list.get(i), parameter) == expected)</span>
            {
<span class="nc" id="L925">                return onShortCircuit;</span>
            }
        }
<span class="nc" id="L928">        return atEnd;</span>
    }

    public static &lt;T, P&gt; boolean corresponds(List&lt;T&gt; list, OrderedIterable&lt;P&gt; other, Predicate2&lt;? super T, ? super P&gt; predicate)
    {
<span class="nc bnc" id="L933" title="All 2 branches missed.">        if (!(list instanceof RandomAccess))</span>
        {
<span class="nc" id="L935">            throw new IllegalArgumentException();</span>
        }

<span class="nc" id="L938">        int size = list.size();</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">        if (size != other.size())</span>
        {
<span class="nc" id="L941">            return false;</span>
        }

<span class="nc bnc" id="L944" title="All 2 branches missed.">        if (other instanceof RandomAccess)</span>
        {
<span class="nc" id="L946">            List&lt;P&gt; otherList = (List&lt;P&gt;) other;</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">            for (int index = 0; index &lt; size; index++)</span>
            {
<span class="nc bnc" id="L949" title="All 2 branches missed.">                if (!predicate.accept(list.get(index), otherList.get(index)))</span>
                {
<span class="nc" id="L951">                    return false;</span>
                }
            }
<span class="nc" id="L954">            return true;</span>
        }

<span class="nc" id="L957">        Iterator&lt;P&gt; iterator = other.iterator();</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">        for (int index = 0; index &lt; size; index++)</span>
        {
<span class="nc bnc" id="L960" title="All 2 branches missed.">            if (!predicate.accept(list.get(index), iterator.next()))</span>
            {
<span class="nc" id="L962">                return false;</span>
            }
        }
<span class="nc" id="L965">        return true;</span>
    }

    public static &lt;T&gt; boolean anySatisfy(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L970">        return RandomAccessListIterate.shortCircuit(list, predicate, true, true, false);</span>
    }

    public static &lt;T, P&gt; boolean anySatisfyWith(List&lt;T&gt; list, Predicate2&lt;? super T, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L975">        return RandomAccessListIterate.shortCircuitWith(list, predicate, parameter, true, true, false);</span>
    }

    public static &lt;T&gt; boolean allSatisfy(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L980">        return RandomAccessListIterate.shortCircuit(list, predicate, false, false, true);</span>
    }

    public static &lt;T, P&gt; boolean allSatisfyWith(List&lt;T&gt; list, Predicate2&lt;? super T, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L985">        return RandomAccessListIterate.shortCircuitWith(list, predicate, parameter, false, false, true);</span>
    }

    public static &lt;T&gt; boolean noneSatisfy(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L990">        return RandomAccessListIterate.shortCircuit(list, predicate, true, false, true);</span>
    }

    public static &lt;T, P&gt; boolean noneSatisfyWith(List&lt;T&gt; list, Predicate2&lt;? super T, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L995">        return RandomAccessListIterate.shortCircuitWith(list, predicate, parameter, true, false, true);</span>
    }

    public static &lt;T&gt; T detect(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L1000">        int size = list.size();</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1003">            T each = list.get(i);</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">            if (predicate.accept(each))</span>
            {
<span class="nc" id="L1006">                return each;</span>
            }
        }
<span class="nc" id="L1009">        return null;</span>
    }

    public static &lt;T, P&gt; T detectWith(List&lt;T&gt; list, Predicate2&lt;? super T, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L1014">        int size = list.size();</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1017">            T each = list.get(i);</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">            if (predicate.accept(each, parameter))</span>
            {
<span class="nc" id="L1020">                return each;</span>
            }
        }
<span class="nc" id="L1023">        return null;</span>
    }

    public static &lt;T&gt; Optional&lt;T&gt; detectOptional(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L1028">        int size = list.size();</span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1031">            T each = list.get(i);</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">            if (predicate.accept(each))</span>
            {
<span class="nc" id="L1034">                return Optional.of(each);</span>
            }
        }
<span class="nc" id="L1037">        return Optional.empty();</span>
    }

    public static &lt;T, P&gt; Optional&lt;T&gt; detectWithOptional(List&lt;T&gt; list, Predicate2&lt;? super T, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L1042">        int size = list.size();</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1045">            T each = list.get(i);</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">            if (predicate.accept(each, parameter))</span>
            {
<span class="nc" id="L1048">                return Optional.of(each);</span>
            }
        }
<span class="nc" id="L1051">        return Optional.empty();</span>
    }

    public static &lt;T, IV&gt; Twin&lt;MutableList&lt;T&gt;&gt; selectAndRejectWith(
            List&lt;T&gt; list,
            Predicate2&lt;? super T, ? super IV&gt; predicate,
            IV injectedValue)
    {
<span class="nc" id="L1059">        MutableList&lt;T&gt; positiveResult = Lists.mutable.empty();</span>
<span class="nc" id="L1060">        MutableList&lt;T&gt; negativeResult = Lists.mutable.empty();</span>
<span class="nc" id="L1061">        int size = list.size();</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1064">            T item = list.get(i);</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">            (predicate.accept(item, injectedValue) ? positiveResult : negativeResult).add(item);</span>
        }
<span class="nc" id="L1067">        return Tuples.twin(positiveResult, negativeResult);</span>
    }

    public static &lt;T&gt; PartitionMutableList&lt;T&gt; partition(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L1072">        PartitionFastList&lt;T&gt; partitionFastList = new PartitionFastList&lt;&gt;();</span>

<span class="nc" id="L1074">        int size = list.size();</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1077">            T each = list.get(i);</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">            MutableList&lt;T&gt; bucket = predicate.accept(each) ? partitionFastList.getSelected() : partitionFastList.getRejected();</span>
<span class="nc" id="L1079">            bucket.add(each);</span>
        }
<span class="nc" id="L1081">        return partitionFastList;</span>
    }

    public static &lt;T, P&gt; PartitionMutableList&lt;T&gt; partitionWith(List&lt;T&gt; list, Predicate2&lt;? super T, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L1086">        PartitionFastList&lt;T&gt; partitionFastList = new PartitionFastList&lt;&gt;();</span>

<span class="nc" id="L1088">        int size = list.size();</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1091">            T each = list.get(i);</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">            MutableList&lt;T&gt; bucket = predicate.accept(each, parameter) ? partitionFastList.getSelected() : partitionFastList.getRejected();</span>
<span class="nc" id="L1093">            bucket.add(each);</span>
        }
<span class="nc" id="L1095">        return partitionFastList;</span>
    }

    public static &lt;T&gt; boolean removeIf(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L1100">        boolean changed = false;</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        for (int i = 0; i &lt; list.size(); i++)</span>
        {
<span class="nc" id="L1103">            T each = list.get(i);</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">            if (predicate.accept(each))</span>
            {
<span class="nc" id="L1106">                list.remove(i--);</span>
<span class="nc" id="L1107">                changed = true;</span>
            }
        }
<span class="nc" id="L1110">        return changed;</span>
    }

    public static &lt;T, P&gt; boolean removeIfWith(List&lt;T&gt; list, Predicate2&lt;? super T, ? super P&gt; predicate, P parameter)
    {
<span class="nc" id="L1115">        boolean changed = false;</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">        for (int i = 0; i &lt; list.size(); i++)</span>
        {
<span class="nc" id="L1118">            T each = list.get(i);</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">            if (predicate.accept(each, parameter))</span>
            {
<span class="nc" id="L1121">                list.remove(i--);</span>
<span class="nc" id="L1122">                changed = true;</span>
            }
        }
<span class="nc" id="L1125">        return changed;</span>
    }

    public static &lt;T&gt; boolean removeIf(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate, Procedure&lt;? super T&gt; procedure)
    {
<span class="nc" id="L1130">        boolean changed = false;</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">        for (int i = 0; i &lt; list.size(); i++)</span>
        {
<span class="nc" id="L1133">            T each = list.get(i);</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">            if (predicate.accept(each))</span>
            {
<span class="nc" id="L1136">                procedure.value(each);</span>
<span class="nc" id="L1137">                list.remove(i--);</span>
<span class="nc" id="L1138">                changed = true;</span>
            }
        }
<span class="nc" id="L1141">        return changed;</span>
    }

    public static &lt;T, P&gt; boolean removeIfWith(List&lt;T&gt; list, Predicate2&lt;? super T, ? super P&gt; predicate, P parameter, Procedure&lt;? super T&gt; procedure)
    {
<span class="nc" id="L1146">        boolean changed = false;</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">        for (int i = 0; i &lt; list.size(); i++)</span>
        {
<span class="nc" id="L1149">            T each = list.get(i);</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">            if (predicate.accept(each, parameter))</span>
            {
<span class="nc" id="L1152">                procedure.value(each);</span>
<span class="nc" id="L1153">                list.remove(i--);</span>
<span class="nc" id="L1154">                changed = true;</span>
            }
        }
<span class="nc" id="L1157">        return changed;</span>
    }

    /**
     * Searches for the first occurrence where the predicate evaluates to true.
     *
     * @see Iterate#detectIndex(Iterable, Predicate)
     */
    public static &lt;T&gt; int detectIndex(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L1167">        int size = list.size();</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc bnc" id="L1170" title="All 2 branches missed.">            if (predicate.accept(list.get(i)))</span>
            {
<span class="nc" id="L1172">                return i;</span>
            }
        }
<span class="nc" id="L1175">        return -1;</span>
    }

    /**
     * Searches for the first occurrence where the predicate evaluates to true.
     *
     * @see Iterate#detectIndexWith(Iterable, Predicate2, Object)
     */
    public static &lt;T, IV&gt; int detectIndexWith(List&lt;T&gt; list, Predicate2&lt;? super T, ? super IV&gt; predicate, IV injectedValue)
    {
<span class="nc" id="L1185">        int size = list.size();</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc bnc" id="L1188" title="All 2 branches missed.">            if (predicate.accept(list.get(i), injectedValue))</span>
            {
<span class="nc" id="L1190">                return i;</span>
            }
        }
<span class="nc" id="L1193">        return -1;</span>
    }

    public static &lt;T&gt; int detectLastIndex(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L1198">        int size = list.size();</span>
<span class="nc bnc" id="L1199" title="All 2 branches missed.">        for (int i = size - 1; i &gt;= 0; i--)</span>
        {
<span class="nc bnc" id="L1201" title="All 2 branches missed.">            if (predicate.accept(list.get(i)))</span>
            {
<span class="nc" id="L1203">                return i;</span>
            }
        }
<span class="nc" id="L1206">        return -1;</span>
    }

    public static &lt;T, IV, P&gt; IV injectIntoWith(
            IV injectedValue,
            List&lt;T&gt; list,
            Function3&lt;? super IV, ? super T, ? super P, ? extends IV&gt; function,
            P parameter)
    {
<span class="nc" id="L1215">        IV result = injectedValue;</span>
<span class="nc" id="L1216">        int size = list.size();</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1219">            result = function.value(result, list.get(i), parameter);</span>
        }
<span class="nc" id="L1221">        return result;</span>
    }

    public static &lt;T, P&gt; void forEachWith(List&lt;T&gt; list, Procedure2&lt;? super T, ? super P&gt; procedure, P parameter)
    {
<span class="nc" id="L1226">        int size = list.size();</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1229">            procedure.value(list.get(i), parameter);</span>
        }
<span class="nc" id="L1231">    }</span>

    public static &lt;T, P, A, R extends Collection&lt;A&gt;&gt; R collectWith(
            List&lt;T&gt; list,
            Function2&lt;? super T, ? super P, ? extends A&gt; function,
            P parameter,
            R targetCollection)
    {
<span class="nc" id="L1239">        int size = list.size();</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1242">            targetCollection.add(function.value(list.get(i), parameter));</span>
        }
<span class="nc" id="L1244">        return targetCollection;</span>
    }

    /**
     * @deprecated in 7.0.
     */
    @Deprecated
    public static &lt;T, R extends List&lt;T&gt;&gt; R distinct(List&lt;T&gt; list, R targetList)
    {
<span class="nc" id="L1253">        MutableSet&lt;T&gt; seenSoFar = UnifiedSet.newSet();</span>
<span class="nc" id="L1254">        int size = list.size();</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1257">            T item = list.get(i);</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">            if (seenSoFar.add(item))</span>
            {
<span class="nc" id="L1260">                targetList.add(item);</span>
            }
        }
<span class="nc" id="L1263">        return targetList;</span>
    }

    /**
     * @since 7.0.
     */
    public static &lt;T&gt; MutableList&lt;T&gt; distinct(List&lt;T&gt; list)
    {
<span class="nc" id="L1271">        return RandomAccessListIterate.distinct(list, FastList.newList());</span>
    }

    /**
     * @since 7.0.
     */
    public static &lt;T&gt; MutableList&lt;T&gt; distinct(List&lt;T&gt; list, HashingStrategy&lt;? super T&gt; hashingStrategy)
    {
<span class="nc" id="L1279">        MutableSet&lt;T&gt; seenSoFar = UnifiedSetWithHashingStrategy.newSet(hashingStrategy);</span>
<span class="nc" id="L1280">        FastList&lt;T&gt; result = FastList.newList();</span>
<span class="nc" id="L1281">        int size = list.size();</span>
<span class="nc bnc" id="L1282" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1284">            T item = list.get(i);</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">            if (seenSoFar.add(item))</span>
            {
<span class="nc" id="L1287">                result.add(item);</span>
            }
        }
<span class="nc" id="L1290">        return result;</span>
    }

    /**
     * @see Iterate#take(Iterable, int)
     */
    public static &lt;T&gt; MutableList&lt;T&gt; take(List&lt;T&gt; list, int count)
    {
<span class="nc bnc" id="L1298" title="All 2 branches missed.">        if (count &lt; 0)</span>
        {
<span class="nc" id="L1300">            throw new IllegalArgumentException(&quot;Count must be greater than zero, but was: &quot; + count);</span>
        }
<span class="nc" id="L1302">        return RandomAccessListIterate.take(list, count, FastList.newList(Math.min(list.size(), count)));</span>
    }

    /**
     * @see Iterate#take(Iterable, int)
     */
    public static &lt;T, R extends Collection&lt;T&gt;&gt; R take(List&lt;T&gt; list, int count, R targetList)
    {
<span class="nc bnc" id="L1310" title="All 2 branches missed.">        if (count &lt; 0)</span>
        {
<span class="nc" id="L1312">            throw new IllegalArgumentException(&quot;Count must be greater than zero, but was: &quot; + count);</span>
        }
<span class="nc" id="L1314">        int end = Math.min(list.size(), count);</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">        for (int i = 0; i &lt; end; i++)</span>
        {
<span class="nc" id="L1317">            targetList.add(list.get(i));</span>
        }
<span class="nc" id="L1319">        return targetList;</span>
    }

    /**
     * @see Iterate#drop(Iterable, int)
     */
    public static &lt;T&gt; MutableList&lt;T&gt; drop(List&lt;T&gt; list, int count)
    {
<span class="nc bnc" id="L1327" title="All 2 branches missed.">        if (count &lt; 0)</span>
        {
<span class="nc" id="L1329">            throw new IllegalArgumentException(&quot;Count must be greater than zero, but was: &quot; + count);</span>
        }
<span class="nc" id="L1331">        return RandomAccessListIterate.drop(list, count, FastList.newList(list.size() - Math.min(list.size(), count)));</span>
    }

    /**
     * @see Iterate#drop(Iterable, int)
     */
    public static &lt;T, R extends Collection&lt;T&gt;&gt; R drop(List&lt;T&gt; list, int count, R targetList)
    {
<span class="nc bnc" id="L1339" title="All 2 branches missed.">        if (count &lt; 0)</span>
        {
<span class="nc" id="L1341">            throw new IllegalArgumentException(&quot;Count must be greater than zero, but was: &quot; + count);</span>
        }
<span class="nc bnc" id="L1343" title="All 2 branches missed.">        if (count &gt;= list.size())</span>
        {
<span class="nc" id="L1345">            return targetList;</span>
        }
<span class="nc" id="L1347">        int start = Math.min(list.size(), count);</span>
<span class="nc" id="L1348">        targetList.addAll(list.subList(start, list.size()));</span>
<span class="nc" id="L1349">        return targetList;</span>
    }

    /**
     * @see RichIterable#appendString(Appendable, String, String, String)
     */
    public static &lt;T&gt; void appendString(
            List&lt;T&gt; list,
            Appendable appendable,
            String start,
            String separator,
            String end)
    {
        try
        {
<span class="nc" id="L1364">            appendable.append(start);</span>

<span class="nc bnc" id="L1366" title="All 2 branches missed.">            if (Iterate.notEmpty(list))</span>
            {
<span class="nc" id="L1368">                appendable.append(IterableIterate.stringValueOfItem(list, list.get(0)));</span>

<span class="nc" id="L1370">                int size = list.size();</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">                for (int i = 1; i &lt; size; i++)</span>
                {
<span class="nc" id="L1373">                    appendable.append(separator);</span>
<span class="nc" id="L1374">                    appendable.append(IterableIterate.stringValueOfItem(list, list.get(i)));</span>
                }
            }

<span class="nc" id="L1378">            appendable.append(end);</span>
        }
<span class="nc" id="L1380">        catch (IOException e)</span>
        {
<span class="nc" id="L1382">            throw new RuntimeException(e);</span>
<span class="nc" id="L1383">        }</span>
<span class="nc" id="L1384">    }</span>

    /**
     * @see Iterate#groupBy(Iterable, Function)
     */
    public static &lt;T, V&gt; FastListMultimap&lt;V, T&gt; groupBy(
            List&lt;T&gt; list,
            Function&lt;? super T, ? extends V&gt; function)
    {
<span class="nc" id="L1393">        return RandomAccessListIterate.groupBy(list, function, FastListMultimap.newMultimap());</span>
    }

    /**
     * @see Iterate#groupBy(Iterable, Function, MutableMultimap)
     */
    public static &lt;T, V, R extends MutableMultimap&lt;V, T&gt;&gt; R groupBy(
            List&lt;T&gt; list,
            Function&lt;? super T, ? extends V&gt; function,
            R target)
    {
<span class="nc" id="L1404">        int size = list.size();</span>
<span class="nc bnc" id="L1405" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1407">            T item = list.get(i);</span>
<span class="nc" id="L1408">            target.put(function.valueOf(item), item);</span>
        }
<span class="nc" id="L1410">        return target;</span>
    }

    public static &lt;T, V&gt; FastListMultimap&lt;V, T&gt; groupByEach(
            List&lt;T&gt; list,
            Function&lt;? super T, ? extends Iterable&lt;V&gt;&gt; function)
    {
<span class="nc" id="L1417">        return RandomAccessListIterate.groupByEach(list, function, FastListMultimap.newMultimap());</span>
    }

    public static &lt;T, V, R extends MutableMultimap&lt;V, T&gt;&gt; R groupByEach(
            List&lt;T&gt; list,
            Function&lt;? super T, ? extends Iterable&lt;V&gt;&gt; function,
            R target)
    {
<span class="nc" id="L1425">        int size = list.size();</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1428">            T item = list.get(i);</span>
<span class="nc" id="L1429">            Iterable&lt;V&gt; iterable = function.valueOf(item);</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">            for (V key : iterable)</span>
            {
<span class="nc" id="L1432">                target.put(key, item);</span>
<span class="nc" id="L1433">            }</span>
        }
<span class="nc" id="L1435">        return target;</span>
    }

    public static &lt;K, T&gt; MutableMap&lt;K, T&gt; groupByUniqueKey(
            List&lt;T&gt; list,
            Function&lt;? super T, ? extends K&gt; function)
    {
<span class="nc" id="L1442">        return RandomAccessListIterate.groupByUniqueKey(list, function, UnifiedMap.newMap(list.size()));</span>
    }

    public static &lt;K, T, R extends MutableMap&lt;K, T&gt;&gt; R groupByUniqueKey(
            List&lt;T&gt; list,
            Function&lt;? super T, ? extends K&gt; function,
            R target)
    {
<span class="nc" id="L1450">        int size = list.size();</span>
<span class="nc bnc" id="L1451" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1453">            T value = list.get(i);</span>
<span class="nc" id="L1454">            K key = function.valueOf(value);</span>
<span class="nc bnc" id="L1455" title="All 2 branches missed.">            if (target.put(key, value) != null)</span>
            {
<span class="nc" id="L1457">                throw new IllegalStateException(&quot;Key &quot; + key + &quot; already exists in map!&quot;);</span>
            }
        }
<span class="nc" id="L1460">        return target;</span>
    }

    public static &lt;T, V extends Comparable&lt;? super V&gt;&gt; T minBy(List&lt;T&gt; list, Function&lt;? super T, ? extends V&gt; function)
    {
<span class="nc bnc" id="L1465" title="All 2 branches missed.">        if (list.isEmpty())</span>
        {
<span class="nc" id="L1467">            throw new NoSuchElementException();</span>
        }

<span class="nc" id="L1470">        T min = list.get(0);</span>
<span class="nc" id="L1471">        V minValue = function.valueOf(min);</span>
<span class="nc" id="L1472">        int size = list.size();</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">        for (int i = 1; i &lt; size; i++)</span>
        {
<span class="nc" id="L1475">            T next = list.get(i);</span>
<span class="nc" id="L1476">            V nextValue = function.valueOf(next);</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">            if (nextValue.compareTo(minValue) &lt; 0)</span>
            {
<span class="nc" id="L1479">                min = next;</span>
<span class="nc" id="L1480">                minValue = nextValue;</span>
            }
        }
<span class="nc" id="L1483">        return min;</span>
    }

    public static &lt;T, V extends Comparable&lt;? super V&gt;&gt; T maxBy(List&lt;T&gt; list, Function&lt;? super T, ? extends V&gt; function)
    {
<span class="nc bnc" id="L1488" title="All 2 branches missed.">        if (list.isEmpty())</span>
        {
<span class="nc" id="L1490">            throw new NoSuchElementException();</span>
        }

<span class="nc" id="L1493">        T max = list.get(0);</span>
<span class="nc" id="L1494">        V maxValue = function.valueOf(max);</span>
<span class="nc" id="L1495">        int size = list.size();</span>
<span class="nc bnc" id="L1496" title="All 2 branches missed.">        for (int i = 1; i &lt; size; i++)</span>
        {
<span class="nc" id="L1498">            T next = list.get(i);</span>
<span class="nc" id="L1499">            V nextValue = function.valueOf(next);</span>
<span class="nc bnc" id="L1500" title="All 2 branches missed.">            if (nextValue.compareTo(maxValue) &gt; 0)</span>
            {
<span class="nc" id="L1502">                max = next;</span>
<span class="nc" id="L1503">                maxValue = nextValue;</span>
            }
        }
<span class="nc" id="L1506">        return max;</span>
    }

    public static &lt;T&gt; T min(List&lt;T&gt; list, Comparator&lt;? super T&gt; comparator)
    {
<span class="nc bnc" id="L1511" title="All 2 branches missed.">        if (list.isEmpty())</span>
        {
<span class="nc" id="L1513">            throw new NoSuchElementException();</span>
        }

<span class="nc" id="L1516">        T min = list.get(0);</span>
<span class="nc" id="L1517">        int size = list.size();</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">        for (int i = 1; i &lt; size; i++)</span>
        {
<span class="nc" id="L1520">            T item = list.get(i);</span>
<span class="nc bnc" id="L1521" title="All 2 branches missed.">            if (comparator.compare(item, min) &lt; 0)</span>
            {
<span class="nc" id="L1523">                min = item;</span>
            }
        }
<span class="nc" id="L1526">        return min;</span>
    }

    public static &lt;T&gt; T max(List&lt;T&gt; list, Comparator&lt;? super T&gt; comparator)
    {
<span class="nc bnc" id="L1531" title="All 2 branches missed.">        if (list.isEmpty())</span>
        {
<span class="nc" id="L1533">            throw new NoSuchElementException();</span>
        }

<span class="nc" id="L1536">        T max = list.get(0);</span>
<span class="nc" id="L1537">        int size = list.size();</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">        for (int i = 1; i &lt; size; i++)</span>
        {
<span class="nc" id="L1540">            T item = list.get(i);</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">            if (comparator.compare(item, max) &gt; 0)</span>
            {
<span class="nc" id="L1543">                max = item;</span>
            }
        }
<span class="nc" id="L1546">        return max;</span>
    }

    public static &lt;T&gt; T min(List&lt;T&gt; list)
    {
<span class="nc bnc" id="L1551" title="All 2 branches missed.">        if (list.isEmpty())</span>
        {
<span class="nc" id="L1553">            throw new NoSuchElementException();</span>
        }

<span class="nc" id="L1556">        T min = list.get(0);</span>
<span class="nc" id="L1557">        int size = list.size();</span>
<span class="nc bnc" id="L1558" title="All 2 branches missed.">        for (int i = 1; i &lt; size; i++)</span>
        {
<span class="nc" id="L1560">            T item = list.get(i);</span>
<span class="nc bnc" id="L1561" title="All 2 branches missed.">            if (((Comparable&lt;? super T&gt;) item).compareTo(min) &lt; 0)</span>
            {
<span class="nc" id="L1563">                min = item;</span>
            }
        }
<span class="nc" id="L1566">        return min;</span>
    }

    public static &lt;T&gt; T max(List&lt;T&gt; list)
    {
<span class="nc bnc" id="L1571" title="All 2 branches missed.">        if (list.isEmpty())</span>
        {
<span class="nc" id="L1573">            throw new NoSuchElementException();</span>
        }

<span class="nc" id="L1576">        T max = list.get(0);</span>
<span class="nc" id="L1577">        int size = list.size();</span>
<span class="nc bnc" id="L1578" title="All 2 branches missed.">        for (int i = 1; i &lt; size; i++)</span>
        {
<span class="nc" id="L1580">            T item = list.get(i);</span>
<span class="nc bnc" id="L1581" title="All 2 branches missed.">            if (((Comparable&lt;T&gt;) item).compareTo(max) &gt; 0)</span>
            {
<span class="nc" id="L1583">                max = item;</span>
            }
        }
<span class="nc" id="L1586">        return max;</span>
    }

    public static &lt;X, Y&gt; MutableList&lt;Pair&lt;X, Y&gt;&gt; zip(
            List&lt;X&gt; list,
            Iterable&lt;Y&gt; iterable)
    {
<span class="nc bnc" id="L1593" title="All 4 branches missed.">        if (iterable instanceof Collection || iterable instanceof RichIterable)</span>
        {
<span class="nc" id="L1595">            int listSize = list.size();</span>
<span class="nc" id="L1596">            int iterableSize = Iterate.sizeOf(iterable);</span>
<span class="nc" id="L1597">            FastList&lt;Pair&lt;X, Y&gt;&gt; target = FastList.newList(Math.min(listSize, iterableSize));</span>
<span class="nc" id="L1598">            return RandomAccessListIterate.zip(list, iterable, target);</span>
        }
<span class="nc" id="L1600">        return RandomAccessListIterate.zip(list, iterable, FastList.newList());</span>
    }

    public static &lt;X, Y, R extends Collection&lt;Pair&lt;X, Y&gt;&gt;&gt; R zip(
            List&lt;X&gt; list,
            Iterable&lt;Y&gt; iterable,
            R target)
    {
<span class="nc" id="L1608">        Iterator&lt;Y&gt; yIterator = iterable.iterator();</span>
<span class="nc" id="L1609">        int size = list.size();</span>
<span class="nc bnc" id="L1610" title="All 4 branches missed.">        for (int i = 0; i &lt; size &amp;&amp; yIterator.hasNext(); i++)</span>
        {
<span class="nc" id="L1612">            target.add(Tuples.pair(list.get(i), yIterator.next()));</span>
        }
<span class="nc" id="L1614">        return target;</span>
    }

    public static &lt;T&gt; MutableList&lt;Pair&lt;T, Integer&gt;&gt; zipWithIndex(List&lt;T&gt; list)
    {
<span class="nc" id="L1619">        return RandomAccessListIterate.zipWithIndex(list, FastList.newList(list.size()));</span>
    }

    public static &lt;T, R extends Collection&lt;Pair&lt;T, Integer&gt;&gt;&gt; R zipWithIndex(
            List&lt;T&gt; list,
            R target)
    {
<span class="nc" id="L1626">        int size = list.size();</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1629">            target.add(Tuples.pair(list.get(i), i));</span>
        }
<span class="nc" id="L1631">        return target;</span>
    }

    public static &lt;T, K, V&gt; MutableMap&lt;K, V&gt; aggregateInPlaceBy(
            List&lt;T&gt; list,
            Function&lt;? super T, ? extends K&gt; groupBy,
            Function0&lt;? extends V&gt; zeroValueFactory,
            Procedure2&lt;? super V, ? super T&gt; mutatingAggregator)
    {
<span class="nc" id="L1640">        MutableMap&lt;K, V&gt; map = UnifiedMap.newMap();</span>
<span class="nc" id="L1641">        RandomAccessListIterate.forEach(list, new MutatingAggregationProcedure&lt;&gt;(map, groupBy, zeroValueFactory, mutatingAggregator));</span>
<span class="nc" id="L1642">        return map;</span>
    }

    public static &lt;T, K, V&gt; MutableMap&lt;K, V&gt; aggregateBy(
            List&lt;T&gt; list,
            Function&lt;? super T, ? extends K&gt; groupBy,
            Function0&lt;? extends V&gt; zeroValueFactory,
            Function2&lt;? super V, ? super T, ? extends V&gt; nonMutatingAggregator)
    {
<span class="nc" id="L1651">        MutableMap&lt;K, V&gt; map = UnifiedMap.newMap();</span>
<span class="nc" id="L1652">        RandomAccessListIterate.forEach(list, new NonMutatingAggregationProcedure&lt;&gt;(map, groupBy, zeroValueFactory, nonMutatingAggregator));</span>
<span class="nc" id="L1653">        return map;</span>
    }

    public static &lt;T&gt; MutableList&lt;T&gt; takeWhile(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L1658">        MutableList&lt;T&gt; result = FastList.newList();</span>
<span class="nc" id="L1659">        int size = list.size();</span>
<span class="nc bnc" id="L1660" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1662">            T each = list.get(i);</span>
<span class="nc bnc" id="L1663" title="All 2 branches missed.">            if (predicate.accept(each))</span>
            {
<span class="nc" id="L1665">                result.add(each);</span>
            }
            else
            {
<span class="nc" id="L1669">                return result;</span>
            }
        }
<span class="nc" id="L1672">        return result;</span>
    }

    public static &lt;T&gt; MutableList&lt;T&gt; dropWhile(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L1677">        MutableList&lt;T&gt; result = FastList.newList();</span>
<span class="nc" id="L1678">        int size = list.size();</span>
<span class="nc bnc" id="L1679" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1681">            T each = list.get(i);</span>
<span class="nc bnc" id="L1682" title="All 2 branches missed.">            if (!predicate.accept(each))</span>
            {
<span class="nc" id="L1684">                result.add(each);</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">                for (int j = i + 1; j &lt; size; j++)</span>
                {
<span class="nc" id="L1687">                    T eachNotDropped = list.get(j);</span>
<span class="nc" id="L1688">                    result.add(eachNotDropped);</span>
                }
<span class="nc" id="L1690">                return result;</span>
            }
        }
<span class="nc" id="L1693">        return result;</span>
    }

    public static &lt;T&gt; PartitionMutableList&lt;T&gt; partitionWhile(List&lt;T&gt; list, Predicate&lt;? super T&gt; predicate)
    {
<span class="nc" id="L1698">        PartitionMutableList&lt;T&gt; result = new PartitionFastList&lt;&gt;();</span>
<span class="nc" id="L1699">        MutableList&lt;T&gt; selected = result.getSelected();</span>

<span class="nc" id="L1701">        int size = list.size();</span>
<span class="nc bnc" id="L1702" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1704">            T each = list.get(i);</span>
<span class="nc bnc" id="L1705" title="All 2 branches missed.">            if (predicate.accept(each))</span>
            {
<span class="nc" id="L1707">                selected.add(each);</span>
            }
            else
            {
<span class="nc" id="L1711">                MutableList&lt;T&gt; rejected = result.getRejected();</span>
<span class="nc" id="L1712">                rejected.add(each);</span>
<span class="nc bnc" id="L1713" title="All 2 branches missed.">                for (int j = i + 1; j &lt; size; j++)</span>
                {
<span class="nc" id="L1715">                    T eachRejected = list.get(j);</span>
<span class="nc" id="L1716">                    rejected.add(eachRejected);</span>
                }
<span class="nc" id="L1718">                return result;</span>
            }
        }
<span class="nc" id="L1721">        return result;</span>
    }

    public static &lt;V, T&gt; ObjectLongMap&lt;V&gt; sumByInt(List&lt;T&gt; list, Function&lt;T, V&gt; groupBy, IntFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L1726">        ObjectLongHashMap&lt;V&gt; result = ObjectLongHashMap.newMap();</span>
<span class="nc bnc" id="L1727" title="All 2 branches missed.">        for (int i = 0; i &lt; list.size(); i++)</span>
        {
<span class="nc" id="L1729">            T item = list.get(i);</span>
<span class="nc" id="L1730">            result.addToValue(groupBy.valueOf(item), function.intValueOf(item));</span>
        }
<span class="nc" id="L1732">        return result;</span>
    }

    public static &lt;V, T&gt; ObjectLongMap&lt;V&gt; sumByLong(List&lt;T&gt; list, Function&lt;T, V&gt; groupBy, LongFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L1737">        ObjectLongHashMap&lt;V&gt; result = ObjectLongHashMap.newMap();</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">        for (int i = 0; i &lt; list.size(); i++)</span>
        {
<span class="nc" id="L1740">            T item = list.get(i);</span>
<span class="nc" id="L1741">            result.addToValue(groupBy.valueOf(item), function.longValueOf(item));</span>
        }
<span class="nc" id="L1743">        return result;</span>
    }

    public static &lt;V, T&gt; ObjectDoubleMap&lt;V&gt; sumByFloat(List&lt;T&gt; list, Function&lt;T, V&gt; groupBy, FloatFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L1748">        ObjectDoubleHashMap&lt;V&gt; result = ObjectDoubleHashMap.newMap();</span>
<span class="nc bnc" id="L1749" title="All 2 branches missed.">        for (int i = 0; i &lt; list.size(); i++)</span>
        {
<span class="nc" id="L1751">            T item = list.get(i);</span>
<span class="nc" id="L1752">            result.addToValue(groupBy.valueOf(item), function.floatValueOf(item));</span>
        }
<span class="nc" id="L1754">        return result;</span>
    }

    public static &lt;V, T&gt; ObjectDoubleMap&lt;V&gt; sumByDouble(List&lt;T&gt; list, Function&lt;T, V&gt; groupBy, DoubleFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L1759">        ObjectDoubleHashMap&lt;V&gt; result = ObjectDoubleHashMap.newMap();</span>
<span class="nc bnc" id="L1760" title="All 2 branches missed.">        for (int i = 0; i &lt; list.size(); i++)</span>
        {
<span class="nc" id="L1762">            T item = list.get(i);</span>
<span class="nc" id="L1763">            result.addToValue(groupBy.valueOf(item), function.doubleValueOf(item));</span>
        }
<span class="nc" id="L1765">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>