<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RichIterable.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Eclipse Collections Test Coverage Aggregation</a> &gt; <a href="../index.html" class="el_bundle">eclipse-collections-api</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.collections.api</a> &gt; <span class="el_source">RichIterable.java</span></div><h1>RichIterable.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2018 Goldman Sachs and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v. 1.0 which accompany this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 */

package org.eclipse.collections.api;

import java.util.Collection;
import java.util.Comparator;
import java.util.DoubleSummaryStatistics;
import java.util.IntSummaryStatistics;
import java.util.LongSummaryStatistics;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Stream;

import org.eclipse.collections.api.bag.Bag;
import org.eclipse.collections.api.bag.MutableBag;
import org.eclipse.collections.api.bag.MutableBagIterable;
import org.eclipse.collections.api.bag.sorted.MutableSortedBag;
import org.eclipse.collections.api.block.function.Function;
import org.eclipse.collections.api.block.function.Function0;
import org.eclipse.collections.api.block.function.Function2;
import org.eclipse.collections.api.block.function.primitive.BooleanFunction;
import org.eclipse.collections.api.block.function.primitive.ByteFunction;
import org.eclipse.collections.api.block.function.primitive.CharFunction;
import org.eclipse.collections.api.block.function.primitive.DoubleFunction;
import org.eclipse.collections.api.block.function.primitive.DoubleObjectToDoubleFunction;
import org.eclipse.collections.api.block.function.primitive.FloatFunction;
import org.eclipse.collections.api.block.function.primitive.FloatObjectToFloatFunction;
import org.eclipse.collections.api.block.function.primitive.IntFunction;
import org.eclipse.collections.api.block.function.primitive.IntObjectToIntFunction;
import org.eclipse.collections.api.block.function.primitive.LongFunction;
import org.eclipse.collections.api.block.function.primitive.LongObjectToLongFunction;
import org.eclipse.collections.api.block.function.primitive.ShortFunction;
import org.eclipse.collections.api.block.predicate.Predicate;
import org.eclipse.collections.api.block.predicate.Predicate2;
import org.eclipse.collections.api.block.procedure.Procedure;
import org.eclipse.collections.api.block.procedure.Procedure2;
import org.eclipse.collections.api.collection.primitive.MutableBooleanCollection;
import org.eclipse.collections.api.collection.primitive.MutableByteCollection;
import org.eclipse.collections.api.collection.primitive.MutableCharCollection;
import org.eclipse.collections.api.collection.primitive.MutableDoubleCollection;
import org.eclipse.collections.api.collection.primitive.MutableFloatCollection;
import org.eclipse.collections.api.collection.primitive.MutableIntCollection;
import org.eclipse.collections.api.collection.primitive.MutableLongCollection;
import org.eclipse.collections.api.collection.primitive.MutableShortCollection;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.api.map.MapIterable;
import org.eclipse.collections.api.map.MutableMap;
import org.eclipse.collections.api.map.primitive.ObjectDoubleMap;
import org.eclipse.collections.api.map.primitive.ObjectLongMap;
import org.eclipse.collections.api.map.sorted.MutableSortedMap;
import org.eclipse.collections.api.multimap.Multimap;
import org.eclipse.collections.api.multimap.MutableMultimap;
import org.eclipse.collections.api.ordered.OrderedIterable;
import org.eclipse.collections.api.partition.PartitionIterable;
import org.eclipse.collections.api.set.MutableSet;
import org.eclipse.collections.api.set.sorted.MutableSortedSet;
import org.eclipse.collections.api.tuple.Pair;

/**
 * RichIterable is an interface which extends the InternalIterable interface with several internal iterator methods, from
 * the Smalltalk Collection protocol.  These include select, reject, detect, collect, injectInto, anySatisfy,
 * allSatisfy. The API also includes converter methods to convert a RichIterable to a List (toList), to a sorted
 * List (toSortedList), to a Set (toSet), and to a Map (toMap).
 *
 * @since 1.0
 */
public interface RichIterable&lt;T&gt;
        extends InternalIterable&lt;T&gt;
{
    /**
     * Returns the number of items in this iterable.
     *
     * @since 1.0
     */
    int size();

    /**
     * Returns true if this iterable has zero items.
     *
     * @since 1.0
     */
    boolean isEmpty();

    /**
     * The English equivalent of !this.isEmpty()
     *
     * @since 1.0
     */
    default boolean notEmpty()
    {
<span class="nc bnc" id="L103" title="All 2 branches missed.">        return !this.isEmpty();</span>
    }

    /**
     * Returns the first element of an iterable.  In the case of a List it is the element at the first index.  In the
     * case of any other Collection, it is the first element that would be returned during an iteration.  If the
     * iterable is empty, null is returned.  If null is a valid element of the container, then a developer would need to
     * check to see if the iterable is empty to validate that a null result was not due to the container being empty.
     * &lt;p&gt;
     * The order of Sets are not guaranteed (except for TreeSets and other Ordered Set implementations), so if you use
     * this method, the first element could be any element from the Set.
     *
     * @since 1.0
     * @deprecated in 6.0. Use {@link OrderedIterable#getFirst()} instead.
     */
    @Deprecated
    T getFirst();

    /**
     * Returns the last element of an iterable.  In the case of a List it is the element at the last index.  In the case
     * of any other Collection, it is the last element that would be returned during an iteration.  If the iterable is
     * empty, null is returned.  If null is a valid element of the container, then a developer would need to check to
     * see if the iterable is empty to validate that a null result was not due to the container being empty.
     * &lt;p&gt;
     * The order of Sets are not guaranteed (except for TreeSets and other Ordered Set implementations), so if you use
     * this method, the last element could be any element from the Set.
     *
     * @since 1.0
     * @deprecated in 6.0. Use {@link OrderedIterable#getLast()} instead.
     */
    @Deprecated
    T getLast();

    /**
     * Returns the element if the iterable has exactly one element. Otherwise, throw {@link IllegalStateException}.
     *
     * @return an element of an iterable.
     * @throws IllegalStateException if iterable is empty or has multiple elements.
     * @since 8.0
     */
    default T getOnly()
    {
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (this.size() == 1)</span>
        {
<span class="nc" id="L147">            return this.getFirst();</span>
        }

<span class="nc" id="L150">        throw new IllegalStateException(&quot;Size must be 1 but was &quot; + this.size());</span>
    }

    /**
     * Returns true if the iterable has an element which responds true to element.equals(object).
     *
     * @since 1.0
     */
    boolean contains(Object object);

    /**
     * Returns true if all elements in source are contained in this collection.
     *
     * @since 1.0
     */
    boolean containsAllIterable(Iterable&lt;?&gt; source);

    /**
     * Returns true if all elements in source are contained in this collection.
     *
     * @see Collection#containsAll(Collection)
     * @since 1.0
     */
    boolean containsAll(Collection&lt;?&gt; source);

    /**
     * Returns true if all elements in the specified var arg array are contained in this collection.
     *
     * @since 1.0
     */
    boolean containsAllArguments(Object... elements);

    /**
     * Executes the Procedure for each element in the iterable and returns {@code this}.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * RichIterable&amp;lt;Person&amp;gt; tapped =
     *     people.&lt;b&gt;tap&lt;/b&gt;(person -&gt; LOGGER.info(person.getName()));
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * RichIterable&amp;lt;Person&amp;gt; tapped =
     *     people.&lt;b&gt;tap&lt;/b&gt;(new Procedure&amp;lt;Person&amp;gt;()
     *     {
     *         public void value(Person person)
     *         {
     *             LOGGER.info(person.getName());
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @see #each(Procedure)
     * @see #forEach(Procedure)
     * @since 6.0
     */
    RichIterable&lt;T&gt; tap(Procedure&lt;? super T&gt; procedure);

    /**
     * The procedure is executed for each element in the iterable.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * people.each(person -&gt; LOGGER.info(person.getName()));
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * people.each(new Procedure&amp;lt;Person&amp;gt;()
     * {
     *     public void value(Person person)
     *     {
     *         LOGGER.info(person.getName());
     *     }
     * });
     * &lt;/pre&gt;
     * This method is a variant of {@link InternalIterable#forEach(Procedure)}
     * that has a signature conflict with {@link Iterable#forEach(java.util.function.Consumer)}.
     *
     * @see InternalIterable#forEach(Procedure)
     * @see Iterable#forEach(java.util.function.Consumer)
     * @since 6.0
     */
    @SuppressWarnings(&quot;UnnecessaryFullyQualifiedName&quot;)
    void each(Procedure&lt;? super T&gt; procedure);

    /**
     * Returns all elements of the source collection that return true when evaluating the predicate.  This method is also
     * commonly called filter.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * RichIterable&amp;lt;Person&amp;gt; selected =
     *     people.&lt;b&gt;select&lt;/b&gt;(person -&gt; person.getAddress().getCity().equals(&quot;London&quot;));
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * RichIterable&amp;lt;Person&amp;gt; selected =
     *     people.&lt;b&gt;select&lt;/b&gt;(new Predicate&amp;lt;Person&amp;gt;()
     *     {
     *         public boolean accept(Person person)
     *         {
     *             return person.getAddress().getCity().equals(&quot;London&quot;);
     *         }
     *     });
     *
     * @since 1.0
     */
    RichIterable&lt;T&gt; select(Predicate&lt;? super T&gt; predicate);

    /**
     * Same as the select method with one parameter but uses the specified target collection for the results.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * MutableList&amp;lt;Person&amp;gt; selected =
     *     people.select(person -&gt; person.person.getLastName().equals(&quot;Smith&quot;), Lists.mutable.empty());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * MutableList&amp;lt;Person&amp;gt; selected =
     *     people.select(new Predicate&amp;lt;Person&amp;gt;()
     *     {
     *         public boolean accept(Person person)
     *         {
     *             return person.person.getLastName().equals(&quot;Smith&quot;);
     *         }
     *     }, Lists.mutable.empty());
     * &lt;/pre&gt;
     * &lt;p&gt;
     *
     * @param predicate a {@link Predicate} to use as the select criteria
     * @param target    the Collection to append to for all elements in this {@code RichIterable} that meet select criteria {@code predicate}
     * @return {@code target}, which contains appended elements as a result of the select criteria
     * @see #select(Predicate)
     * @since 1.0
     */
    &lt;R extends Collection&lt;T&gt;&gt; R select(Predicate&lt;? super T&gt; predicate, R target);

    /**
     * Similar to {@link #select(Predicate)}, except with an evaluation parameter for the second generic argument in {@link Predicate2}.
     * &lt;p&gt;
     * E.g. return a {@link Collection} of Person elements where the person has an age &lt;b&gt;greater than or equal to&lt;/b&gt; 18 years
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * RichIterable&amp;lt;Person&amp;gt; selected =
     *     people.selectWith((Person person, Integer age) -&gt; person.getAge() &gt;= age, Integer.valueOf(18));
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * RichIterable&amp;lt;Person&amp;gt; selected =
     *     people.selectWith(new Predicate2&amp;lt;Person, Integer&amp;gt;()
     *     {
     *         public boolean accept(Person person, Integer age)
     *         {
     *             return person.getAge() &gt;= age;
     *         }
     *     }, Integer.valueOf(18));
     * &lt;/pre&gt;
     *
     * @param predicate a {@link Predicate2} to use as the select criteria
     * @param parameter a parameter to pass in for evaluation of the second argument {@code P} in {@code predicate}
     * @see #select(Predicate)
     * @since 5.0
     */
    &lt;P&gt; RichIterable&lt;T&gt; selectWith(Predicate2&lt;? super T, ? super P&gt; predicate, P parameter);

    /**
     * Similar to {@link #select(Predicate, Collection)}, except with an evaluation parameter for the second generic argument in {@link Predicate2}.
     * &lt;p&gt;
     * E.g. return a {@link Collection} of Person elements where the person has an age &lt;b&gt;greater than or equal to&lt;/b&gt; 18 years
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * MutableList&amp;lt;Person&amp;gt; selected =
     *     people.selectWith((Person person, Integer age) -&gt; person.getAge() &gt;= age, Integer.valueOf(18), Lists.mutable.empty());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * MutableList&amp;lt;Person&amp;gt; selected =
     *     people.selectWith(new Predicate2&amp;lt;Person, Integer&amp;gt;()
     *     {
     *         public boolean accept(Person person, Integer age)
     *         {
     *             return person.getAge() &gt;= age;
     *         }
     *     }, Integer.valueOf(18), Lists.mutable.empty());
     * &lt;/pre&gt;
     *
     * @param predicate        a {@link Predicate2} to use as the select criteria
     * @param parameter        a parameter to pass in for evaluation of the second argument {@code P} in {@code predicate}
     * @param targetCollection the Collection to append to for all elements in this {@code RichIterable} that meet select criteria {@code predicate}
     * @return {@code targetCollection}, which contains appended elements as a result of the select criteria
     * @see #select(Predicate)
     * @see #select(Predicate, Collection)
     * @since 1.0
     */
    &lt;P, R extends Collection&lt;T&gt;&gt; R selectWith(
            Predicate2&lt;? super T, ? super P&gt; predicate,
            P parameter,
            R targetCollection);

    /**
     * Returns all elements of the source collection that return false when evaluating of the predicate.  This method is also
     * sometimes called filterNot and is the equivalent of calling iterable.select(Predicates.not(predicate)).
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * RichIterable&amp;lt;Person&amp;gt; rejected =
     *     people.reject(person -&gt; person.person.getLastName().equals(&quot;Smith&quot;));
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * RichIterable&amp;lt;Person&amp;gt; rejected =
     *     people.reject(new Predicate&amp;lt;Person&amp;gt;()
     *     {
     *         public boolean accept(Person person)
     *         {
     *             return person.person.getLastName().equals(&quot;Smith&quot;);
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @param predicate a {@link Predicate} to use as the reject criteria
     * @return a RichIterable that contains elements that cause {@link Predicate#accept(Object)} method to evaluate to false
     * @since 1.0
     */
    RichIterable&lt;T&gt; reject(Predicate&lt;? super T&gt; predicate);

    /**
     * Similar to {@link #reject(Predicate)}, except with an evaluation parameter for the second generic argument in {@link Predicate2}.
     * &lt;p&gt;
     * E.g. return a {@link Collection} of Person elements where the person has an age &lt;b&gt;greater than or equal to&lt;/b&gt; 18 years
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * RichIterable&amp;lt;Person&amp;gt; rejected =
     *     people.rejectWith((Person person, Integer age) -&gt; person.getAge() &lt; age, Integer.valueOf(18));
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * MutableList&amp;lt;Person&amp;gt; rejected =
     *     people.rejectWith(new Predicate2&amp;lt;Person, Integer&amp;gt;()
     *     {
     *         public boolean accept(Person person, Integer age)
     *         {
     *             return person.getAge() &lt; age;
     *         }
     *     }, Integer.valueOf(18));
     * &lt;/pre&gt;
     *
     * @param predicate a {@link Predicate2} to use as the select criteria
     * @param parameter a parameter to pass in for evaluation of the second argument {@code P} in {@code predicate}
     * @see #select(Predicate)
     * @since 5.0
     */
    &lt;P&gt; RichIterable&lt;T&gt; rejectWith(Predicate2&lt;? super T, ? super P&gt; predicate, P parameter);

    /**
     * Same as the reject method with one parameter but uses the specified target collection for the results.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * MutableList&amp;lt;Person&amp;gt; rejected =
     *     people.reject(person -&gt; person.person.getLastName().equals(&quot;Smith&quot;), Lists.mutable.empty());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * MutableList&amp;lt;Person&amp;gt; rejected =
     *     people.reject(new Predicate&amp;lt;Person&amp;gt;()
     *     {
     *         public boolean accept(Person person)
     *         {
     *             return person.person.getLastName().equals(&quot;Smith&quot;);
     *         }
     *     }, Lists.mutable.empty());
     * &lt;/pre&gt;
     *
     * @param predicate a {@link Predicate} to use as the reject criteria
     * @param target    the Collection to append to for all elements in this {@code RichIterable} that cause {@code Predicate#accept(Object)} method to evaluate to false
     * @return {@code target}, which contains appended elements as a result of the reject criteria
     * @since 1.0
     */
    &lt;R extends Collection&lt;T&gt;&gt; R reject(Predicate&lt;? super T&gt; predicate, R target);

    /**
     * Similar to {@link #reject(Predicate, Collection)}, except with an evaluation parameter for the second generic argument in {@link Predicate2}.
     * &lt;p&gt;
     * E.g. return a {@link Collection} of Person elements where the person has an age &lt;b&gt;greater than or equal to&lt;/b&gt; 18 years
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * MutableList&amp;lt;Person&amp;gt; rejected =
     *     people.rejectWith((Person person, Integer age) -&gt; person.getAge() &lt; age, Integer.valueOf(18), Lists.mutable.empty());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * MutableList&amp;lt;Person&amp;gt; rejected =
     *     people.rejectWith(new Predicate2&amp;lt;Person, Integer&amp;gt;()
     *     {
     *         public boolean accept(Person person, Integer age)
     *         {
     *             return person.getAge() &lt; age;
     *         }
     *     }, Integer.valueOf(18), Lists.mutable.empty());
     * &lt;/pre&gt;
     *
     * @param predicate        a {@link Predicate2} to use as the reject criteria
     * @param parameter        a parameter to pass in for evaluation of the second argument {@code P} in {@code predicate}
     * @param targetCollection the Collection to append to for all elements in this {@code RichIterable} that cause {@code Predicate#accept(Object)} method to evaluate to false
     * @return {@code targetCollection}, which contains appended elements as a result of the reject criteria
     * @see #reject(Predicate)
     * @see #reject(Predicate, Collection)
     * @since 1.0
     */
    &lt;P, R extends Collection&lt;T&gt;&gt; R rejectWith(
            Predicate2&lt;? super T, ? super P&gt; predicate,
            P parameter,
            R targetCollection);

    /**
     * Filters a collection into a PartitionedIterable based on the evaluation of the predicate.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * PartitionIterable&amp;lt;Person&amp;gt; newYorkersAndNonNewYorkers =
     *     people.&lt;b&gt;partition&lt;/b&gt;(person -&gt; person.getAddress().getState().getName().equals(&quot;New York&quot;));
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * PartitionIterable&amp;lt;Person&amp;gt; newYorkersAndNonNewYorkers =
     *     people.&lt;b&gt;partition&lt;/b&gt;(new Predicate&amp;lt;Person&amp;gt;()
     *     {
     *         public boolean accept(Person person)
     *         {
     *             return person.getAddress().getState().getName().equals(&quot;New York&quot;);
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @since 1.0.
     */
    PartitionIterable&lt;T&gt; partition(Predicate&lt;? super T&gt; predicate);

    /**
     * Filters a collection into a PartitionIterable based on the evaluation of the predicate.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * PartitionIterable&amp;lt;Person&gt;&amp;gt newYorkersAndNonNewYorkers =
     *     people.&lt;b&gt;partitionWith&lt;/b&gt;((Person person, String state) -&gt; person.getAddress().getState().getName().equals(state), &quot;New York&quot;);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * PartitionIterable&amp;lt;Person&gt;&amp;gt newYorkersAndNonNewYorkers =
     *     people.&lt;b&gt;partitionWith&lt;/b&gt;(new Predicate2&amp;lt;Person, String&amp;gt;()
     *     {
     *         public boolean accept(Person person, String state)
     *         {
     *             return person.getAddress().getState().getName().equals(state);
     *         }
     *     }, &quot;New York&quot;);
     * &lt;/pre&gt;
     *
     * @since 5.0.
     */
    &lt;P&gt; PartitionIterable&lt;T&gt; partitionWith(Predicate2&lt;? super T, ? super P&gt; predicate, P parameter);

    /**
     * Returns all elements of the source collection that are instances of the Class {@code clazz}.
     * &lt;p&gt;
     * &lt;pre&gt;
     * RichIterable&amp;lt;Integer&amp;gt; integers =
     *     List.mutable.with(new Integer(0), new Long(0L), new Double(0.0)).selectInstancesOf(Integer.class);
     * &lt;/pre&gt;
     *
     * @since 2.0
     */
    &lt;S&gt; RichIterable&lt;S&gt; selectInstancesOf(Class&lt;S&gt; clazz);

    /**
     * Returns a new collection with the results of applying the specified function on each element of the source
     * collection.  This method is also commonly called transform or map.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * RichIterable&amp;lt;String&amp;gt; names =
     *     people.collect(person -&gt; person.getFirstName() + &quot; &quot; + person.getLastName());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * RichIterable&amp;lt;String&amp;gt; names =
     *     people.collect(new Function&amp;lt;Person, String&amp;gt;()
     *     {
     *         public String valueOf(Person person)
     *         {
     *             return person.getFirstName() + &quot; &quot; + person.getLastName();
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @since 1.0
     */
    &lt;V&gt; RichIterable&lt;V&gt; collect(Function&lt;? super T, ? extends V&gt; function);

    /**
     * Same as {@link #collect(Function)}, except that the results are gathered into the specified {@code target}
     * collection.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * MutableList&amp;lt;String&amp;gt; names =
     *     people.collect(person -&gt; person.getFirstName() + &quot; &quot; + person.getLastName(), Lists.mutable.empty());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * MutableList&amp;lt;String&amp;gt; names =
     *     people.collect(new Function&amp;lt;Person, String&amp;gt;()
     *     {
     *         public String valueOf(Person person)
     *         {
     *             return person.getFirstName() + &quot; &quot; + person.getLastName();
     *         }
     *     }, Lists.mutable.empty());
     * &lt;/pre&gt;
     *
     * @param function a {@link Function} to use as the collect transformation function
     * @param target   the Collection to append to for all elements in this {@code RichIterable} that meet select criteria {@code function}
     * @return {@code target}, which contains appended elements as a result of the collect transformation
     * @see #collect(Function)
     * @since 1.0
     */
    &lt;V, R extends Collection&lt;V&gt;&gt; R collect(Function&lt;? super T, ? extends V&gt; function, R target);

    /**
     * Returns a new primitive {@code boolean} iterable with the results of applying the specified function on each element
     * of the source collection.  This method is also commonly called transform or map.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * BooleanIterable licenses =
     *     people.collectBoolean(person -&gt; person.hasDrivingLicense());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * BooleanIterable licenses =
     *     people.collectBoolean(new BooleanFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public boolean booleanValueOf(Person person)
     *         {
     *             return person.hasDrivingLicense();
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @since 4.0
     */
    BooleanIterable collectBoolean(BooleanFunction&lt;? super T&gt; booleanFunction);

    /**
     * Same as {@link #collectBoolean(BooleanFunction)}, except that the results are gathered into the specified {@code target}
     * collection.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * BooleanArrayList licenses =
     *     people.collectBoolean(person -&gt; person.hasDrivingLicense(), new BooleanArrayList());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * BooleanArrayList licenses =
     *     people.collectBoolean(new BooleanFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public boolean booleanValueOf(Person person)
     *         {
     *             return person.hasDrivingLicense();
     *         }
     *     }, new BooleanArrayList());
     * &lt;/pre&gt;
     *
     * @param booleanFunction a {@link BooleanFunction} to use as the collect transformation function
     * @param target          the MutableBooleanCollection to append to for all elements in this {@code RichIterable}
     * @return {@code target}, which contains appended elements as a result of the collect transformation
     * @since 5.0
     */
    &lt;R extends MutableBooleanCollection&gt; R collectBoolean(BooleanFunction&lt;? super T&gt; booleanFunction, R target);

    /**
     * Returns a new primitive {@code byte} iterable with the results of applying the specified function on each element
     * of the source collection.  This method is also commonly called transform or map.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * ByteIterable bytes =
     *     people.collectByte(person -&gt; person.getCode());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * ByteIterable bytes =
     *     people.collectByte(new ByteFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public byte byteValueOf(Person person)
     *         {
     *             return person.getCode();
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @since 4.0
     */
    ByteIterable collectByte(ByteFunction&lt;? super T&gt; byteFunction);

    /**
     * Same as {@link #collectByte(ByteFunction)}, except that the results are gathered into the specified {@code target}
     * collection.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * ByteArrayList bytes =
     *     people.collectByte(person -&gt; person.getCode(), new ByteArrayList());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * ByteArrayList bytes =
     *     people.collectByte(new ByteFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public byte byteValueOf(Person person)
     *         {
     *             return person.getCode();
     *         }
     *     }, new ByteArrayList());
     * &lt;/pre&gt;
     *
     * @param byteFunction a {@link ByteFunction} to use as the collect transformation function
     * @param target       the MutableByteCollection to append to for all elements in this {@code RichIterable}
     * @return {@code target}, which contains appended elements as a result of the collect transformation
     * @since 5.0
     */
    &lt;R extends MutableByteCollection&gt; R collectByte(ByteFunction&lt;? super T&gt; byteFunction, R target);

    /**
     * Returns a new primitive {@code char} iterable with the results of applying the specified function on each element
     * of the source collection.  This method is also commonly called transform or map.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * CharIterable chars =
     *     people.collectChar(person -&gt; person.getMiddleInitial());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * CharIterable chars =
     *     people.collectChar(new CharFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public char charValueOf(Person person)
     *         {
     *             return person.getMiddleInitial();
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @since 4.0
     */
    CharIterable collectChar(CharFunction&lt;? super T&gt; charFunction);

    /**
     * Same as {@link #collectChar(CharFunction)}, except that the results are gathered into the specified {@code target}
     * collection.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * CharArrayList chars =
     *     people.collectChar(person -&gt; person.getMiddleInitial(), new CharArrayList());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * CharArrayList chars =
     *     people.collectChar(new CharFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public char charValueOf(Person person)
     *         {
     *             return person.getMiddleInitial();
     *         }
     *     }, new CharArrayList());
     * &lt;/pre&gt;
     *
     * @param charFunction a {@link CharFunction} to use as the collect transformation function
     * @param target       the MutableCharCollection to append to for all elements in this {@code RichIterable}
     * @return {@code target}, which contains appended elements as a result of the collect transformation
     * @since 5.0
     */
    &lt;R extends MutableCharCollection&gt; R collectChar(CharFunction&lt;? super T&gt; charFunction, R target);

    /**
     * Returns a new primitive {@code double} iterable with the results of applying the specified function on each element
     * of the source collection.  This method is also commonly called transform or map.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * DoubleIterable doubles =
     *     people.collectDouble(person -&gt; person.getMilesFromNorthPole());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * DoubleIterable doubles =
     *     people.collectDouble(new DoubleFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public double doubleValueOf(Person person)
     *         {
     *             return person.getMilesFromNorthPole();
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @since 4.0
     */
    DoubleIterable collectDouble(DoubleFunction&lt;? super T&gt; doubleFunction);

    /**
     * Same as {@link #collectDouble(DoubleFunction)}, except that the results are gathered into the specified {@code target}
     * collection.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * DoubleArrayList doubles =
     *     people.collectDouble(person -&gt; person.getMilesFromNorthPole(), new DoubleArrayList());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * DoubleArrayList doubles =
     *     people.collectDouble(new DoubleFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public double doubleValueOf(Person person)
     *         {
     *             return person.getMilesFromNorthPole();
     *         }
     *     }, new DoubleArrayList());
     * &lt;/pre&gt;
     *
     * @param doubleFunction a {@link DoubleFunction} to use as the collect transformation function
     * @param target         the MutableDoubleCollection to append to for all elements in this {@code RichIterable}
     * @return {@code target}, which contains appended elements as a result of the collect transformation
     * @since 5.0
     */
    &lt;R extends MutableDoubleCollection&gt; R collectDouble(DoubleFunction&lt;? super T&gt; doubleFunction, R target);

    /**
     * Returns a new primitive {@code float} iterable with the results of applying the specified function on each element
     * of the source collection.  This method is also commonly called transform or map.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * FloatIterable floats =
     *     people.collectFloat(person -&gt; person.getHeightInInches());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * FloatIterable floats =
     *     people.collectFloat(new FloatFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public float floatValueOf(Person person)
     *         {
     *             return person.getHeightInInches();
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @since 4.0
     */
    FloatIterable collectFloat(FloatFunction&lt;? super T&gt; floatFunction);

    /**
     * Same as {@link #collectFloat(FloatFunction)}, except that the results are gathered into the specified {@code target}
     * collection.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * FloatArrayList floats =
     *     people.collectFloat(person -&gt; person.getHeightInInches(), new FloatArrayList());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * FloatArrayList floats =
     *     people.collectFloat(new FloatFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public float floatValueOf(Person person)
     *         {
     *             return person.getHeightInInches();
     *         }
     *     }, new FloatArrayList());
     * &lt;/pre&gt;
     *
     * @param floatFunction a {@link FloatFunction} to use as the collect transformation function
     * @param target        the MutableFloatCollection to append to for all elements in this {@code RichIterable}
     * @return {@code target}, which contains appended elements as a result of the collect transformation
     * @since 5.0
     */
    &lt;R extends MutableFloatCollection&gt; R collectFloat(FloatFunction&lt;? super T&gt; floatFunction, R target);

    /**
     * Returns a new primitive {@code int} iterable with the results of applying the specified function on each element
     * of the source collection.  This method is also commonly called transform or map.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * IntIterable ints =
     *     people.collectInt(person -&gt; person.getAge());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * IntIterable ints =
     *     people.collectInt(new IntFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public int intValueOf(Person person)
     *         {
     *             return person.getAge();
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @since 4.0
     */
    IntIterable collectInt(IntFunction&lt;? super T&gt; intFunction);

    /**
     * Same as {@link #collectInt(IntFunction)}, except that the results are gathered into the specified {@code target}
     * collection.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * IntArrayList ints =
     *     people.collectInt(person -&gt; person.getAge(), new IntArrayList());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * IntArrayList ints =
     *     people.collectInt(new IntFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public int intValueOf(Person person)
     *         {
     *             return person.getAge();
     *         }
     *     }, new IntArrayList());
     * &lt;/pre&gt;
     *
     * @param intFunction a {@link IntFunction} to use as the collect transformation function
     * @param target      the MutableIntCollection to append to for all elements in this {@code RichIterable}
     * @return {@code target}, which contains appended elements as a result of the collect transformation
     * @since 5.0
     */
    &lt;R extends MutableIntCollection&gt; R collectInt(IntFunction&lt;? super T&gt; intFunction, R target);

    /**
     * Returns a new primitive {@code long} iterable with the results of applying the specified function on each element
     * of the source collection.  This method is also commonly called transform or map.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * LongIterable longs =
     *     people.collectLong(person -&gt; person.getGuid());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * LongIterable longs =
     *     people.collectLong(new LongFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public long longValueOf(Person person)
     *         {
     *             return person.getGuid();
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @since 4.0
     */
    LongIterable collectLong(LongFunction&lt;? super T&gt; longFunction);

    /**
     * Same as {@link #collectLong(LongFunction)}, except that the results are gathered into the specified {@code target}
     * collection.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * LongArrayList longs =
     *     people.collectLong(person -&gt; person.getGuid(), new LongArrayList());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * LongArrayList longs =
     *     people.collectLong(new LongFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public long longValueOf(Person person)
     *         {
     *             return person.getGuid();
     *         }
     *     }, new LongArrayList());
     * &lt;/pre&gt;
     *
     * @param longFunction a {@link LongFunction} to use as the collect transformation function
     * @param target       the MutableLongCollection to append to for all elements in this {@code RichIterable}
     * @return {@code target}, which contains appended elements as a result of the collect transformation
     * @since 5.0
     */
    &lt;R extends MutableLongCollection&gt; R collectLong(LongFunction&lt;? super T&gt; longFunction, R target);

    /**
     * Returns a new primitive {@code short} iterable with the results of applying the specified function on each element
     * of the source collection.  This method is also commonly called transform or map.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * ShortIterable shorts =
     *     people.collectShort(person -&gt; person.getNumberOfJunkMailItemsReceivedPerMonth());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * ShortIterable shorts =
     *     people.collectShort(new ShortFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public short shortValueOf(Person person)
     *         {
     *             return person.getNumberOfJunkMailItemsReceivedPerMonth();
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @since 4.0
     */
    ShortIterable collectShort(ShortFunction&lt;? super T&gt; shortFunction);

    /**
     * Same as {@link #collectShort(ShortFunction)}, except that the results are gathered into the specified {@code target}
     * collection.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * ShortArrayList shorts =
     *     people.collectShort(person -&gt; person.getNumberOfJunkMailItemsReceivedPerMonth, new ShortArrayList());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * ShortArrayList shorts =
     *     people.collectShort(new ShortFunction&amp;lt;Person&amp;gt;()
     *     {
     *         public short shortValueOf(Person person)
     *         {
     *             return person.getNumberOfJunkMailItemsReceivedPerMonth;
     *         }
     *     }, new ShortArrayList());
     * &lt;/pre&gt;
     *
     * @param shortFunction a {@link ShortFunction} to use as the collect transformation function
     * @param target        the MutableShortCollection to append to for all elements in this {@code RichIterable}
     * @return {@code target}, which contains appended elements as a result of the collect transformation
     * @since 5.0
     */
    &lt;R extends MutableShortCollection&gt; R collectShort(ShortFunction&lt;? super T&gt; shortFunction, R target);

    /**
     * Same as {@link #collect(Function)} with a {@code Function2} and specified parameter which is passed to the block.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * RichIterable&amp;lt;Integer&amp;gt; integers =
     *     Lists.mutable.with(1, 2, 3).collectWith((each, parameter) -&gt; each + parameter, Integer.valueOf(1));
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * Function2&amp;lt;Integer, Integer, Integer&amp;gt; addParameterFunction =
     *     new Function2&amp;lt;Integer, Integer, Integer&amp;gt;()
     *     {
     *         public Integer value(Integer each, Integer parameter)
     *         {
     *             return each + parameter;
     *         }
     *     };
     * RichIterable&amp;lt;Integer&amp;gt; integers =
     *     Lists.mutable.with(1, 2, 3).collectWith(addParameterFunction, Integer.valueOf(1));
     * &lt;/pre&gt;
     *
     * @param function  A {@link Function2} to use as the collect transformation function
     * @param parameter A parameter to pass in for evaluation of the second argument {@code P} in {@code function}
     * @return A new {@code RichIterable} that contains the transformed elements returned by {@link Function2#value(Object, Object)}
     * @see #collect(Function)
     * @since 5.0
     */
    &lt;P, V&gt; RichIterable&lt;V&gt; collectWith(Function2&lt;? super T, ? super P, ? extends V&gt; function, P parameter);

    /**
     * Same as collectWith but with a targetCollection parameter to gather the results.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * MutableSet&amp;lt;Integer&amp;gt; integers =
     *     Lists.mutable.with(1, 2, 3).collectWith((each, parameter) -&gt; each + parameter, Integer.valueOf(1), Sets.mutable.empty());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * Function2&amp;lt;Integer, Integer, Integer&amp;gt; addParameterFunction =
     *     new Function2&amp;lt;Integer, Integer, Integer&amp;gt;()
     *     {
     *         public Integer value(final Integer each, final Integer parameter)
     *         {
     *             return each + parameter;
     *         }
     *     };
     * MutableSet&amp;lt;Integer&amp;gt; integers =
     *     Lists.mutable.with(1, 2, 3).collectWith(addParameterFunction, Integer.valueOf(1), Sets.mutable.empty());
     * &lt;/pre&gt;
     *
     * @param function         a {@link Function2} to use as the collect transformation function
     * @param parameter        a parameter to pass in for evaluation of the second argument {@code P} in {@code function}
     * @param targetCollection the Collection to append to for all elements in this {@code RichIterable} that meet select criteria {@code function}
     * @return {@code targetCollection}, which contains appended elements as a result of the collect transformation
     * @since 1.0
     */
    &lt;P, V, R extends Collection&lt;V&gt;&gt; R collectWith(
            Function2&lt;? super T, ? super P, ? extends V&gt; function,
            P parameter,
            R targetCollection);

    /**
     * Returns a new collection with the results of applying the specified function on each element of the source
     * collection, but only for those elements which return true upon evaluation of the predicate.  This is the
     * the optimized equivalent of calling iterable.select(predicate).collect(function).
     * &lt;p&gt;
     * Example using a Java 8 lambda and method reference:
     * &lt;pre&gt;
     * RichIterable&amp;lt;String&amp;gt; strings = Lists.mutable.with(1, 2, 3).collectIf(e -&gt; e != null, Object::toString);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using Predicates factory:
     * &lt;pre&gt;
     * RichIterable&amp;lt;String&amp;gt; strings = Lists.mutable.with(1, 2, 3).collectIf(Predicates.notNull(), Functions.getToString());
     * &lt;/pre&gt;
     *
     * @since 1.0
     */
    &lt;V&gt; RichIterable&lt;V&gt; collectIf(Predicate&lt;? super T&gt; predicate, Function&lt;? super T, ? extends V&gt; function);

    /**
     * Same as the collectIf method with two parameters but uses the specified target collection for the results.
     *
     * @param predicate a {@link Predicate} to use as the select criteria
     * @param function  a {@link Function} to use as the collect transformation function
     * @param target    the Collection to append to for all elements in this {@code RichIterable} that meet the collect criteria {@code predicate}
     * @return {@code targetCollection}, which contains appended elements as a result of the collect criteria and transformation
     * @see #collectIf(Predicate, Function)
     * @since 1.0
     */
    &lt;V, R extends Collection&lt;V&gt;&gt; R collectIf(
            Predicate&lt;? super T&gt; predicate,
            Function&lt;? super T, ? extends V&gt; function,
            R target);

    /**
     * {@code flatCollect} is a special case of {@link #collect(Function)}. With {@code collect}, when the {@link Function} returns
     * a collection, the result is a collection of collections. {@code flatCollect} outputs a single &quot;flattened&quot; collection
     * instead.  This method is commonly called flatMap.
     * &lt;p&gt;
     * Consider the following example where we have a {@code Person} class, and each {@code Person} has a list of {@code Address} objects.  Take the following {@link Function}:
     * &lt;pre&gt;
     * Function&amp;lt;Person, List&amp;lt;Address&amp;gt;&amp;gt; addressFunction = Person::getAddresses;
     * RichIterable&amp;lt;Person&amp;gt; people = ...;
     * &lt;/pre&gt;
     * Using {@code collect} returns a collection of collections of addresses.
     * &lt;pre&gt;
     * RichIterable&amp;lt;List&amp;lt;Address&amp;gt;&amp;gt; addresses = people.collect(addressFunction);
     * &lt;/pre&gt;
     * Using {@code flatCollect} returns a single flattened list of addresses.
     * &lt;pre&gt;
     * RichIterable&amp;lt;Address&amp;gt; addresses = people.flatCollect(addressFunction);
     * &lt;/pre&gt;
     *
     * @param function The {@link Function} to apply
     * @return a new flattened collection produced by applying the given {@code function}
     * @since 1.0
     */
    &lt;V&gt; RichIterable&lt;V&gt; flatCollect(Function&lt;? super T, ? extends Iterable&lt;V&gt;&gt; function);

    /**
     * @since 9.2
     */
    default &lt;P, V&gt; RichIterable&lt;V&gt; flatCollectWith(Function2&lt;? super T, ? super P, ? extends Iterable&lt;V&gt;&gt; function, P parameter)
    {
<span class="nc" id="L1167">        return this.flatCollect(each -&gt; function.apply(each, parameter));</span>
    }

    /**
     * Same as flatCollect, only the results are collected into the target collection.
     *
     * @param function The {@link Function} to apply
     * @param target   The collection into which results should be added.
     * @return {@code target}, which will contain a flattened collection of results produced by applying the given {@code function}
     * @see #flatCollect(Function)
     */
    &lt;V, R extends Collection&lt;V&gt;&gt; R flatCollect(Function&lt;? super T, ? extends Iterable&lt;V&gt;&gt; function, R target);

    /**
     * @since 9.2
     */
    default &lt;P, V, R extends Collection&lt;V&gt;&gt; R flatCollectWith(Function2&lt;? super T, ? super P, ? extends Iterable&lt;V&gt;&gt; function, P parameter, R target)
    {
<span class="nc" id="L1185">        return this.flatCollect(each -&gt; function.apply(each, parameter), target);</span>
    }

    /**
     * Returns the first element of the iterable for which the predicate evaluates to true or null in the case where no
     * element returns true.  This method is commonly called find.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * Person person =
     *     people.detect(person -&gt; person.getFirstName().equals(&quot;John&quot;) &amp;&amp; person.getLastName().equals(&quot;Smith&quot;));
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * Person person =
     *     people.detect(new Predicate&amp;lt;Person&amp;gt;()
     *     {
     *         public boolean accept(Person person)
     *         {
     *             return person.getFirstName().equals(&quot;John&quot;) &amp;&amp; person.getLastName().equals(&quot;Smith&quot;);
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @since 1.0
     */
    T detect(Predicate&lt;? super T&gt; predicate);

    /**
     * Returns the first element that evaluates to true for the specified predicate2 and parameter, or null if none
     * evaluate to true.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * Person person =
     *     people.detectWith((person, fullName) -&gt; person.getFullName().equals(fullName), &quot;John Smith&quot;);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * Person person =
     *     people.detectWith(new Predicate2&amp;lt;Person, String&amp;gt;()
     *     {
     *         public boolean accept(Person person, String fullName)
     *         {
     *             return person.getFullName().equals(fullName);
     *         }
     *     }, &quot;John Smith&quot;);
     * &lt;/pre&gt;
     *
     * @since 5.0
     */
    &lt;P&gt; T detectWith(Predicate2&lt;? super T, ? super P&gt; predicate, P parameter);

    /**
     * Returns the first element of the iterable for which the predicate evaluates to true as an Optional.  This method is commonly called find.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * Person person =
     *     people.detectOptional(person -&gt; person.getFirstName().equals(&quot;John&quot;) &amp;&amp; person.getLastName().equals(&quot;Smith&quot;));
     * &lt;/pre&gt;
     * &lt;p&gt;
     *
     * @throws NullPointerException if the element selected is null
     * @since 8.0
     */
    Optional&lt;T&gt; detectOptional(Predicate&lt;? super T&gt; predicate);

    /**
     * Returns the first element that evaluates to true for the specified predicate2 and parameter as an Optional.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * Optional&amp;lt;Person&amp;gt; person =
     *     people.detectWithOptional((person, fullName) -&gt; person.getFullName().equals(fullName), &quot;John Smith&quot;);
     * &lt;/pre&gt;
     * &lt;p&gt;
     *
     * @throws NullPointerException if the element selected is null
     * @since 8.0
     */
    &lt;P&gt; Optional&lt;T&gt; detectWithOptional(Predicate2&lt;? super T, ? super P&gt; predicate, P parameter);

    /**
     * Returns the first element of the iterable for which the predicate evaluates to true.  If no element matches
     * the predicate, then returns the value of applying the specified function.
     *
     * @since 1.0
     */
    default T detectIfNone(Predicate&lt;? super T&gt; predicate, Function0&lt;? extends T&gt; function)
    {
<span class="nc" id="L1278">        T result = this.detect(predicate);</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">        return result == null ? function.value() : result;</span>
    }

    /**
     * Returns the first element of the iterable that evaluates to true for the specified predicate2 and parameter, or
     * returns the value of evaluating the specified function.
     *
     * @since 5.0
     */
    &lt;P&gt; T detectWithIfNone(
            Predicate2&lt;? super T, ? super P&gt; predicate,
            P parameter,
            Function0&lt;? extends T&gt; function);

    /**
     * Return the total number of elements that answer true to the specified predicate.
     * &lt;p&gt;
     * Example using a Java 8 lambda expression:
     * &lt;pre&gt;
     * int count =
     *     people.&lt;b&gt;count&lt;/b&gt;(person -&gt; person.getAddress().getState().getName().equals(&quot;New York&quot;));
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * int count =
     *     people.&lt;b&gt;count&lt;/b&gt;(new Predicate&amp;lt;Person&amp;gt;()
     *     {
     *         public boolean accept(Person person)
     *         {
     *             return person.getAddress().getState().getName().equals(&quot;New York&quot;);
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @since 1.0
     */
    int count(Predicate&lt;? super T&gt; predicate);

    /**
     * Returns the total number of elements that evaluate to true for the specified predicate.
     * &lt;p&gt;
     * &lt;pre&gt;e.g.
     * return lastNames.&lt;b&gt;countWith&lt;/b&gt;(Predicates2.equal(), &quot;Smith&quot;);
     * &lt;/pre&gt;
     */
    &lt;P&gt; int countWith(Predicate2&lt;? super T, ? super P&gt; predicate, P parameter);

    /**
     * Returns true if the predicate evaluates to true for any element of the iterable.
     * Returns false if the iterable is empty, or if no element returned true when evaluating the predicate.
     *
     * @since 1.0
     */
    boolean anySatisfy(Predicate&lt;? super T&gt; predicate);

    /**
     * Returns true if the predicate evaluates to true for any element of the collection, or return false.
     * Returns false if the collection is empty.
     *
     * @since 5.0
     */
    &lt;P&gt; boolean anySatisfyWith(Predicate2&lt;? super T, ? super P&gt; predicate, P parameter);

    /**
     * Returns true if the predicate evaluates to true for every element of the iterable or if the iterable is empty.
     * Otherwise, returns false.
     *
     * @since 1.0
     */
    boolean allSatisfy(Predicate&lt;? super T&gt; predicate);

    /**
     * Returns true if the predicate evaluates to true for every element of the collection, or returns false.
     *
     * @since 5.0
     */
    &lt;P&gt; boolean allSatisfyWith(Predicate2&lt;? super T, ? super P&gt; predicate, P parameter);

    /**
     * Returns true if the predicate evaluates to false for every element of the iterable or if the iterable is empty.
     * Otherwise, returns false.
     *
     * @since 3.0
     */
    boolean noneSatisfy(Predicate&lt;? super T&gt; predicate);

    /**
     * Returns true if the predicate evaluates to false for every element of the collection, or return false.
     * Returns true if the collection is empty.
     *
     * @since 5.0
     */
    &lt;P&gt; boolean noneSatisfyWith(Predicate2&lt;? super T, ? super P&gt; predicate, P parameter);

    /**
     * Returns the final result of evaluating function using each element of the iterable and the previous evaluation
     * result as the parameters. The injected value is used for the first parameter of the first evaluation, and the current
     * item in the iterable is used as the second parameter.  This method is commonly called fold or sometimes reduce.
     *
     * @since 1.0
     */
    &lt;IV&gt; IV injectInto(IV injectedValue, Function2&lt;? super IV, ? super T, ? extends IV&gt; function);

    /**
     * Returns the final int result of evaluating function using each element of the iterable and the previous evaluation
     * result as the parameters. The injected value is used for the first parameter of the first evaluation, and the current
     * item in the iterable is used as the second parameter.
     *
     * @since 1.0
     */
    int injectInto(int injectedValue, IntObjectToIntFunction&lt;? super T&gt; function);

    /**
     * Returns the final long result of evaluating function using each element of the iterable and the previous evaluation
     * result as the parameters. The injected value is used for the first parameter of the first evaluation, and the current
     * item in the iterable is used as the second parameter.
     *
     * @since 1.0
     */
    long injectInto(long injectedValue, LongObjectToLongFunction&lt;? super T&gt; function);

    /**
     * Returns the final float result of evaluating function using each element of the iterable and the previous evaluation
     * result as the parameters. The injected value is used for the first parameter of the first evaluation, and the current
     * item in the iterable is used as the second parameter.
     *
     * @since 2.0
     */
    float injectInto(float injectedValue, FloatObjectToFloatFunction&lt;? super T&gt; function);

    /**
     * Returns the final double result of evaluating function using each element of the iterable and the previous evaluation
     * result as the parameters. The injected value is used for the first parameter of the first evaluation, and the current
     * item in the iterable is used as the second parameter.
     *
     * @since 1.0
     */
    double injectInto(double injectedValue, DoubleObjectToDoubleFunction&lt;? super T&gt; function);

    /**
     * Adds all the elements in this iterable to the specific target Collection.
     *
     * @since 8.0
     */
    &lt;R extends Collection&lt;T&gt;&gt; R into(R target);

    /**
     * Converts the collection to a MutableList implementation.
     *
     * @since 1.0
     */
    MutableList&lt;T&gt; toList();

    /**
     * Converts the collection to a MutableList implementation and sorts it using the natural order of the elements.
     *
     * @since 1.0
     */
    default MutableList&lt;T&gt; toSortedList()
    {
<span class="nc" id="L1440">        return this.toList().sortThis();</span>
    }

    /**
     * Converts the collection to a MutableList implementation and sorts it using the specified comparator.
     *
     * @since 1.0
     */
    default MutableList&lt;T&gt; toSortedList(Comparator&lt;? super T&gt; comparator)
    {
<span class="nc" id="L1450">        return this.toList().sortThis(comparator);</span>
    }

    /**
     * Converts the collection to a MutableList implementation and sorts it based on the natural order of the
     * attribute returned by {@code function}.
     *
     * @since 1.0
     */
    &lt;V extends Comparable&lt;? super V&gt;&gt; MutableList&lt;T&gt; toSortedListBy(Function&lt;? super T, ? extends V&gt; function);

    /**
     * Converts the collection to a MutableSet implementation.
     *
     * @since 1.0
     */
    MutableSet&lt;T&gt; toSet();

    /**
     * Converts the collection to a MutableSortedSet implementation and sorts it using the natural order of the
     * elements.
     *
     * @since 1.0
     */
    MutableSortedSet&lt;T&gt; toSortedSet();

    /**
     * Converts the collection to a MutableSortedSet implementation and sorts it using the specified comparator.
     *
     * @since 1.0
     */
    MutableSortedSet&lt;T&gt; toSortedSet(Comparator&lt;? super T&gt; comparator);

    /**
     * Converts the collection to a MutableSortedSet implementation and sorts it based on the natural order of the
     * attribute returned by {@code function}.
     *
     * @since 1.0
     */
    &lt;V extends Comparable&lt;? super V&gt;&gt; MutableSortedSet&lt;T&gt; toSortedSetBy(Function&lt;? super T, ? extends V&gt; function);

    /**
     * Converts the collection to the default MutableBag implementation.
     *
     * @since 1.0
     */
    MutableBag&lt;T&gt; toBag();

    /**
     * Converts the collection to a MutableSortedBag implementation and sorts it using the natural order of the
     * elements.
     *
     * @since 6.0
     */
    MutableSortedBag&lt;T&gt; toSortedBag();

    /**
     * Converts the collection to the MutableSortedBag implementation and sorts it using the specified comparator.
     *
     * @since 6.0
     */
    MutableSortedBag&lt;T&gt; toSortedBag(Comparator&lt;? super T&gt; comparator);

    /**
     * Converts the collection to a MutableSortedBag implementation and sorts it based on the natural order of the
     * attribute returned by {@code function}.
     *
     * @since 6.0
     */
    &lt;V extends Comparable&lt;? super V&gt;&gt; MutableSortedBag&lt;T&gt; toSortedBagBy(Function&lt;? super T, ? extends V&gt; function);

    /**
     * Converts the collection to a MutableMap implementation using the specified key and value functions.
     *
     * @since 1.0
     */
    &lt;NK, NV&gt; MutableMap&lt;NK, NV&gt; toMap(
            Function&lt;? super T, ? extends NK&gt; keyFunction,
            Function&lt;? super T, ? extends NV&gt; valueFunction);

    /**
     * Converts the collection to a MutableSortedMap implementation using the specified key and value functions
     * sorted by the key elements' natural ordering.
     *
     * @since 1.0
     */
    &lt;NK, NV&gt; MutableSortedMap&lt;NK, NV&gt; toSortedMap(
            Function&lt;? super T, ? extends NK&gt; keyFunction,
            Function&lt;? super T, ? extends NV&gt; valueFunction);

    /**
     * Converts the collection to a MutableSortedMap implementation using the specified key and value functions
     * sorted by the given comparator.
     *
     * @since 1.0
     */
    &lt;NK, NV&gt; MutableSortedMap&lt;NK, NV&gt; toSortedMap(
            Comparator&lt;? super NK&gt; comparator,
            Function&lt;? super T, ? extends NK&gt; keyFunction,
            Function&lt;? super T, ? extends NV&gt; valueFunction);

    /**
     * Converts the collection to a MutableSortedMap implementation using the specified key and value functions
     * and sorts it based on the natural order of the attribute returned by {@code sortBy} function.
     */
    default &lt;KK extends Comparable&lt;? super KK&gt;, NK, NV&gt; MutableSortedMap&lt;NK, NV&gt; toSortedMapBy(
            Function&lt;? super NK, KK&gt; sortBy,
            Function&lt;? super T, ? extends NK&gt; keyFunction,
            Function&lt;? super T, ? extends NV&gt; valueFunction)
    {
<span class="nc" id="L1560">        throw new UnsupportedOperationException(&quot;Adding default implementation so as to not break compatibility&quot;);</span>
    }

    /**
     * Returns a lazy (deferred) iterable, most likely implemented by calling LazyIterate.adapt(this).
     *
     * @since 1.0.
     */
    LazyIterable&lt;T&gt; asLazy();

    /**
     * Converts this iterable to an array.
     *
     * @see Collection#toArray()
     * @since 1.0
     */
    Object[] toArray();

    /**
     * Converts this iterable to an array using the specified target array, assuming the target array is as long
     * or longer than the iterable.
     *
     * @see Collection#toArray(Object[])
     * @since 1.0
     */
    &lt;T&gt; T[] toArray(T[] target);

    /**
     * Returns the minimum element out of this container based on the comparator.
     *
     * @throws NoSuchElementException if the RichIterable is empty
     * @since 1.0
     */
    T min(Comparator&lt;? super T&gt; comparator);

    /**
     * Returns the maximum element out of this container based on the comparator.
     *
     * @throws NoSuchElementException if the RichIterable is empty
     * @since 1.0
     */
    T max(Comparator&lt;? super T&gt; comparator);

    /**
     * Returns the minimum element out of this container based on the comparator as an Optional.
     * If the container is empty {@link Optional#empty()} is returned.
     *
     * @throws NullPointerException if the minimum element is null
     * @since 8.2
     */
    default Optional&lt;T&gt; minOptional(Comparator&lt;? super T&gt; comparator)
    {
<span class="nc bnc" id="L1612" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L1614">            return Optional.empty();</span>
        }
<span class="nc" id="L1616">        return Optional.of(this.min(comparator));</span>
    }

    /**
     * Returns the maximum element out of this container based on the comparator as an Optional.
     * If the container is empty {@link Optional#empty()} is returned.
     *
     * @throws NullPointerException if the maximum element is null
     * @since 8.2
     */
    default Optional&lt;T&gt; maxOptional(Comparator&lt;? super T&gt; comparator)
    {
<span class="nc bnc" id="L1628" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L1630">            return Optional.empty();</span>
        }
<span class="nc" id="L1632">        return Optional.of(this.max(comparator));</span>
    }

    /**
     * Returns the minimum element out of this container based on the natural order.
     *
     * @throws ClassCastException     if the elements are not {@link Comparable}
     * @throws NoSuchElementException if the RichIterable is empty
     * @since 1.0
     */
    T min();

    /**
     * Returns the maximum element out of this container based on the natural order.
     *
     * @throws ClassCastException     if the elements are not {@link Comparable}
     * @throws NoSuchElementException if the RichIterable is empty
     * @since 1.0
     */
    T max();

    /**
     * Returns the minimum element out of this container based on the natural order as an Optional.
     * If the container is empty {@link Optional#empty()} is returned.
     *
     * @throws ClassCastException   if the elements are not {@link Comparable}
     * @throws NullPointerException if the minimum element is null
     * @since 8.2
     */
    default Optional&lt;T&gt; minOptional()
    {
<span class="nc bnc" id="L1663" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L1665">            return Optional.empty();</span>
        }
<span class="nc" id="L1667">        return Optional.of(this.min());</span>
    }

    /**
     * Returns the maximum element out of this container based on the natural order as an Optional.
     * If the container is empty {@link Optional#empty()} is returned.
     *
     * @throws ClassCastException   if the elements are not {@link Comparable}
     * @throws NullPointerException if the maximum element is null
     * @since 8.2
     */
    default Optional&lt;T&gt; maxOptional()
    {
<span class="nc bnc" id="L1680" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L1682">            return Optional.empty();</span>
        }
<span class="nc" id="L1684">        return Optional.of(this.max());</span>
    }

    /**
     * Returns the minimum elements out of this container based on the natural order of the attribute returned by Function.
     *
     * @throws NoSuchElementException if the RichIterable is empty
     * @since 1.0
     */
    &lt;V extends Comparable&lt;? super V&gt;&gt; T minBy(Function&lt;? super T, ? extends V&gt; function);

    /**
     * Returns the maximum elements out of this container based on the natural order of the attribute returned by Function.
     *
     * @throws NoSuchElementException if the RichIterable is empty
     * @since 1.0
     */
    &lt;V extends Comparable&lt;? super V&gt;&gt; T maxBy(Function&lt;? super T, ? extends V&gt; function);

    /**
     * Returns the minimum elements out of this container based on the natural order of the attribute returned by Function as an Optional.
     * If the container is empty {@link Optional#empty()} is returned.
     *
     * @throws NullPointerException if the minimum element is null
     * @since 8.2
     */
    default &lt;V extends Comparable&lt;? super V&gt;&gt; Optional&lt;T&gt; minByOptional(Function&lt;? super T, ? extends V&gt; function)
    {
<span class="nc bnc" id="L1712" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L1714">            return Optional.empty();</span>
        }
<span class="nc" id="L1716">        return Optional.of(this.minBy(function));</span>
    }

    /**
     * Returns the maximum elements out of this container based on the natural order of the attribute returned by Function as an Optional.
     * If the container is empty {@link Optional#empty()} is returned.
     *
     * @throws NullPointerException if the maximum element is null
     * @since 8.2
     */
    default &lt;V extends Comparable&lt;? super V&gt;&gt; Optional&lt;T&gt; maxByOptional(Function&lt;? super T, ? extends V&gt; function)
    {
<span class="nc bnc" id="L1728" title="All 2 branches missed.">        if (this.isEmpty())</span>
        {
<span class="nc" id="L1730">            return Optional.empty();</span>
        }
<span class="nc" id="L1732">        return Optional.of(this.maxBy(function));</span>
    }

    /**
     * Returns the final long result of evaluating function for each element of the iterable and adding the results
     * together.
     *
     * @since 2.0
     */
    long sumOfInt(IntFunction&lt;? super T&gt; function);

    /**
     * Returns the final double result of evaluating function for each element of the iterable and adding the results
     * together. It uses Kahan summation algorithm to reduce numerical error.
     *
     * @since 2.0
     */
    double sumOfFloat(FloatFunction&lt;? super T&gt; function);

    /**
     * Returns the final long result of evaluating function for each element of the iterable and adding the results
     * together.
     *
     * @since 2.0
     */
    long sumOfLong(LongFunction&lt;? super T&gt; function);

    /**
     * Returns the final double result of evaluating function for each element of the iterable and adding the results
     * together. It uses Kahan summation algorithm to reduce numerical error.
     *
     * @since 2.0
     */
    double sumOfDouble(DoubleFunction&lt;? super T&gt; function);

    /**
     * Returns the result of summarizing the value returned from applying the IntFunction to
     * each element of the iterable.
     * &lt;p&gt;
     * &lt;pre&gt;
     * IntSummaryStatistics stats =
     *     Lists.mutable.with(1, 2, 3).summarizeInt(Integer::intValue);
     * &lt;/pre&gt;
     *
     * @since 8.0
     */
    default IntSummaryStatistics summarizeInt(IntFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L1780">        IntSummaryStatistics stats = new IntSummaryStatistics();</span>
<span class="nc" id="L1781">        this.each(each -&gt; stats.accept(function.intValueOf(each)));</span>
<span class="nc" id="L1782">        return stats;</span>
    }

    /**
     * Returns the result of summarizing the value returned from applying the FloatFunction to
     * each element of the iterable.
     * &lt;p&gt;
     * &lt;pre&gt;
     * DoubleSummaryStatistics stats =
     *     Lists.mutable.with(1, 2, 3).summarizeFloat(Integer::floatValue);
     * &lt;/pre&gt;
     *
     * @since 8.0
     */
    default DoubleSummaryStatistics summarizeFloat(FloatFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L1798">        DoubleSummaryStatistics stats = new DoubleSummaryStatistics();</span>
<span class="nc" id="L1799">        this.each(each -&gt; stats.accept(function.floatValueOf(each)));</span>
<span class="nc" id="L1800">        return stats;</span>
    }

    /**
     * Returns the result of summarizing the value returned from applying the LongFunction to
     * each element of the iterable.
     * &lt;p&gt;
     * &lt;pre&gt;
     * LongSummaryStatistics stats =
     *     Lists.mutable.with(1, 2, 3).summarizeLong(Integer::longValue);
     * &lt;/pre&gt;
     *
     * @since 8.0
     */
    default LongSummaryStatistics summarizeLong(LongFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L1816">        LongSummaryStatistics stats = new LongSummaryStatistics();</span>
<span class="nc" id="L1817">        this.each(each -&gt; stats.accept(function.longValueOf(each)));</span>
<span class="nc" id="L1818">        return stats;</span>
    }

    /**
     * Returns the result of summarizing the value returned from applying the DoubleFunction to
     * each element of the iterable.
     * &lt;p&gt;
     * &lt;pre&gt;
     * DoubleSummaryStatistics stats =
     *     Lists.mutable.with(1, 2, 3).summarizeDouble(Integer::doubleValue);
     * &lt;/pre&gt;
     *
     * @since 8.0
     */
    default DoubleSummaryStatistics summarizeDouble(DoubleFunction&lt;? super T&gt; function)
    {
<span class="nc" id="L1834">        DoubleSummaryStatistics stats = new DoubleSummaryStatistics();</span>
<span class="nc" id="L1835">        this.each(each -&gt; stats.accept(function.doubleValueOf(each)));</span>
<span class="nc" id="L1836">        return stats;</span>
    }

    /**
     * This method produces the equivalent result as {@link Stream#collect(Collector)}.
     * &lt;p&gt;
     * &lt;pre&gt;
     * MutableObjectLongMap&amp;lt;Integer&amp;gt; map2 =
     *     Lists.mutable.with(1, 2, 3, 4, 5).reduceInPlace(Collectors2.sumByInt(i -&gt; Integer.valueOf(i % 2), Integer::intValue));
     * &lt;/pre&gt;
     *
     * @since 8.0
     */
    default &lt;R, A&gt; R reduceInPlace(Collector&lt;? super T, A, R&gt; collector)
    {
<span class="nc" id="L1851">        A mutableResult = collector.supplier().get();</span>
<span class="nc" id="L1852">        BiConsumer&lt;A, ? super T&gt; accumulator = collector.accumulator();</span>
<span class="nc" id="L1853">        this.each(each -&gt; accumulator.accept(mutableResult, each));</span>
<span class="nc" id="L1854">        return collector.finisher().apply(mutableResult);</span>
    }

    /**
     * This method produces the equivalent result as {@link Stream#collect(Supplier, BiConsumer, BiConsumer)}.
     * The combiner used in collect is unnecessary in the serial case, so is not included in the API.
     *
     * @since 8.0
     */
    default &lt;R&gt; R reduceInPlace(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator)
    {
<span class="nc" id="L1865">        R result = supplier.get();</span>
<span class="nc" id="L1866">        this.each(each -&gt; accumulator.accept(result, each));</span>
<span class="nc" id="L1867">        return result;</span>
    }

    /**
     * This method produces the equivalent result as {@link Stream#reduce(BinaryOperator)}.
     *
     * @since 8.0
     */
    default Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)
    {
<span class="nc" id="L1877">        boolean[] seenOne = new boolean[1];</span>
<span class="nc" id="L1878">        T[] result = (T[]) new Object[1];</span>
<span class="nc" id="L1879">        this.each(each -&gt;</span>
        {
<span class="nc bnc" id="L1881" title="All 2 branches missed.">            if (seenOne[0])</span>
            {
<span class="nc" id="L1883">                result[0] = accumulator.apply(result[0], each);</span>
            }
            else
            {
<span class="nc" id="L1887">                seenOne[0] = true;</span>
<span class="nc" id="L1888">                result[0] = each;</span>
            }
<span class="nc" id="L1890">        });</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">        return seenOne[0] ? Optional.of(result[0]) : Optional.empty();</span>
    }

    /**
     * Groups and sums the values using the two specified functions.
     *
     * @since 6.0
     */
    &lt;V&gt; ObjectLongMap&lt;V&gt; sumByInt(Function&lt;? super T, ? extends V&gt; groupBy, IntFunction&lt;? super T&gt; function);

    /**
     * Groups and sums the values using the two specified functions.
     *
     * @since 6.0
     */
    &lt;V&gt; ObjectDoubleMap&lt;V&gt; sumByFloat(Function&lt;? super T, ? extends V&gt; groupBy, FloatFunction&lt;? super T&gt; function);

    /**
     * Groups and sums the values using the two specified functions.
     *
     * @since 6.0
     */
    &lt;V&gt; ObjectLongMap&lt;V&gt; sumByLong(Function&lt;? super T, ? extends V&gt; groupBy, LongFunction&lt;? super T&gt; function);

    /**
     * Groups and sums the values using the two specified functions.
     *
     * @since 6.0
     */
    &lt;V&gt; ObjectDoubleMap&lt;V&gt; sumByDouble(Function&lt;? super T, ? extends V&gt; groupBy, DoubleFunction&lt;? super T&gt; function);

    /**
     * Returns a string representation of this collection by delegating to {@link #makeString(String)} and defaulting
     * the separator parameter to the characters &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (comma and space).
     *
     * @return a string representation of this collection.
     * @since 1.0
     */
    default String makeString()
    {
<span class="nc" id="L1931">        return this.makeString(&quot;, &quot;);</span>
    }

    /**
     * Returns a string representation of this collection by delegating to {@link #makeString(String, String, String)}
     * and defaulting the start and end parameters to &lt;tt&gt;&quot;&quot;&lt;/tt&gt; (the empty String).
     *
     * @return a string representation of this collection.
     * @since 1.0
     */
    default String makeString(String separator)
    {
<span class="nc" id="L1943">        return this.makeString(&quot;&quot;, separator, &quot;&quot;);</span>
    }

    /**
     * Returns a string representation of this collection with the elements separated by the specified
     * separator and enclosed between the start and end strings.
     *
     * @return a string representation of this collection.
     * @since 1.0
     */
    default String makeString(String start, String separator, String end)
    {
<span class="nc" id="L1955">        Appendable stringBuilder = new StringBuilder();</span>
<span class="nc" id="L1956">        this.appendString(stringBuilder, start, separator, end);</span>
<span class="nc" id="L1957">        return stringBuilder.toString();</span>
    }

    /**
     * Prints a string representation of this collection onto the given {@code Appendable}.  Prints the string returned
     * by {@link #makeString()}.
     *
     * @since 1.0
     */
    default void appendString(Appendable appendable)
    {
<span class="nc" id="L1968">        this.appendString(appendable, &quot;, &quot;);</span>
<span class="nc" id="L1969">    }</span>

    /**
     * Prints a string representation of this collection onto the given {@code Appendable}.  Prints the string returned
     * by {@link #makeString(String)}.
     *
     * @since 1.0
     */
    default void appendString(Appendable appendable, String separator)
    {
<span class="nc" id="L1979">        this.appendString(appendable, &quot;&quot;, separator, &quot;&quot;);</span>
<span class="nc" id="L1980">    }</span>

    /**
     * Prints a string representation of this collection onto the given {@code Appendable}.  Prints the string returned
     * by {@link #makeString(String, String, String)}.
     *
     * @since 1.0
     */
    void appendString(Appendable appendable, String start, String separator, String end);

    /**
     * For each element of the iterable, the function is evaluated and the results of these evaluations are collected
     * into a new multimap, where the transformed value is the key and the original values are added to the same (or similar)
     * species of collection as the source iterable.
     * &lt;p&gt;
     * Example using a Java 8 method reference:
     * &lt;pre&gt;
     * Multimap&amp;lt;String, Person&amp;gt; peopleByLastName =
     *     people.groupBy(Person::getLastName);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * Multimap&amp;lt;String, Person&amp;gt; peopleByLastName =
     *     people.groupBy(new Function&amp;lt;Person, String&amp;gt;()
     *     {
     *         public String valueOf(Person person)
     *         {
     *             return person.getLastName();
     *         }
     *     });
     * &lt;/pre&gt;
     *
     * @since 1.0
     */
    &lt;V&gt; Multimap&lt;V, T&gt; groupBy(Function&lt;? super T, ? extends V&gt; function);

    /**
     * This method will count the number of occurrences of each value calculated by applying the
     * function to each element of the collection.
     *
     * @since 9.0
     */
    default &lt;V&gt; Bag&lt;V&gt; countBy(Function&lt;? super T, ? extends V&gt; function)
    {
<span class="nc" id="L2025">        return this.asLazy().&lt;V&gt;collect(function).toBag();</span>
    }

    /**
     * This method will count the number of occurrences of each value calculated by applying the
     * function to each element of the collection.
     *
     * @since 9.0
     */
    default &lt;V, R extends MutableBagIterable&lt;V&gt;&gt; R countBy(Function&lt;? super T, ? extends V&gt; function, R target)
    {
<span class="nc" id="L2036">        return this.collect(function, target);</span>
    }

    /**
     * This method will count the number of occurrences of each value calculated by applying the
     * function to each element of the collection with the specified parameter as the second argument.
     *
     * @since 9.0
     */
    default &lt;V, P&gt; Bag&lt;V&gt; countByWith(Function2&lt;? super T, ? super P, ? extends V&gt; function, P parameter)
    {
<span class="nc" id="L2047">        return this.asLazy().&lt;P, V&gt;collectWith(function, parameter).toBag();</span>
    }

    /**
     * This method will count the number of occurrences of each value calculated by applying the
     * function to each element of the collection with the specified parameter as the second argument.
     *
     * @since 9.0
     */
    default &lt;V, P, R extends MutableBagIterable&lt;V&gt;&gt; R countByWith(Function2&lt;? super T, ? super P, ? extends V&gt; function, P parameter, R target)
    {
<span class="nc" id="L2058">        return this.collectWith(function, parameter, target);</span>
    }

    /**
     * This method will count the number of occurrences of each value calculated by applying the
     * function to each element of the collection.
     *
     * @since 10.0.0
     */
    default &lt;V&gt; Bag&lt;V&gt; countByEach(Function&lt;? super T, ? extends Iterable&lt;V&gt;&gt; function)
    {
<span class="nc" id="L2069">        return this.asLazy().&lt;V&gt;flatCollect(function).toBag();</span>
    }

    /**
     * This method will count the number of occurrences of each value calculated by applying the
     * function to each element of the collection.
     *
     * @since 10.0.0
     */
    default &lt;V, R extends MutableBagIterable&lt;V&gt;&gt; R countByEach(Function&lt;? super T, ? extends Iterable&lt;V&gt;&gt; function, R target)
    {
<span class="nc" id="L2080">        return this.&lt;V, R&gt;flatCollect(function, target);</span>
    }

    /**
     * Same as {@link #groupBy(Function)}, except that the results are gathered into the specified {@code target}
     * multimap.
     * &lt;p&gt;
     * Example using a Java 8 method reference:
     * &lt;pre&gt;
     * FastListMultimap&amp;lt;String, Person&amp;gt; peopleByLastName =
     *     people.groupBy(Person::getLastName, new FastListMultimap&amp;lt;String, Person&amp;gt;());
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Example using an anonymous inner class:
     * &lt;pre&gt;
     * FastListMultimap&amp;lt;String, Person&amp;gt; peopleByLastName =
     *     people.groupBy(new Function&amp;lt;Person, String&amp;gt;()
     *     {
     *         public String valueOf(Person person)
     *         {
     *             return person.getLastName();
     *         }
     *     }, new FastListMultimap&amp;lt;String, Person&amp;gt;());
     * &lt;/pre&gt;
     *
     * @since 1.0
     */
    &lt;V, R extends MutableMultimap&lt;V, T&gt;&gt; R groupBy(Function&lt;? super T, ? extends V&gt; function, R target);

    /**
     * Similar to {@link #groupBy(Function)}, except the result of evaluating function will return a collection of keys
     * for each value.
     *
     * @since 1.0
     */
    &lt;V&gt; Multimap&lt;V, T&gt; groupByEach(Function&lt;? super T, ? extends Iterable&lt;V&gt;&gt; function);

    /**
     * Same as {@link #groupByEach(Function)}, except that the results are gathered into the specified {@code target}
     * multimap.
     *
     * @since 1.0
     */
    &lt;V, R extends MutableMultimap&lt;V, T&gt;&gt; R groupByEach(
            Function&lt;? super T, ? extends Iterable&lt;V&gt;&gt; function,
            R target);

    /**
     * For each element of the iterable, the function is evaluated and he results of these evaluations are collected
     * into a new map, where the transformed value is the key. The generated keys must each be unique, or else an
     * exception is thrown.
     *
     * @throws IllegalStateException if the keys returned by the function are not unique
     * @see #groupBy(Function)
     * @since 5.0
     */
    &lt;V&gt; MapIterable&lt;V, T&gt; groupByUniqueKey(Function&lt;? super T, ? extends V&gt; function);

    /**
     * Same as {@link #groupByUniqueKey(Function)}, except that the results are gathered into the specified {@code target}
     * map.
     *
     * @throws IllegalStateException if the keys returned by the function are not unique
     * @see #groupByUniqueKey(Function)
     * @since 6.0
     */
    &lt;V, R extends MutableMap&lt;V, T&gt;&gt; R groupByUniqueKey(
            Function&lt;? super T, ? extends V&gt; function,
            R target);

    /**
     * Returns a string with the elements of this iterable separated by commas with spaces and
     * enclosed in square brackets.
     * &lt;p&gt;
     * &lt;pre&gt;
     * Assert.assertEquals(&quot;[]&quot;, Lists.mutable.empty().toString());
     * Assert.assertEquals(&quot;[1]&quot;, Lists.mutable.with(1).toString());
     * Assert.assertEquals(&quot;[1, 2, 3]&quot;, Lists.mutable.with(1, 2, 3).toString());
     * &lt;/pre&gt;
     *
     * @return a string representation of this RichIterable
     * @see java.util.AbstractCollection#toString()
     * @since 1.0
     */
    @Override
    String toString();

    /**
     * Returns a {@code RichIterable} formed from this {@code RichIterable} and another {@code RichIterable} by
     * combining corresponding elements in pairs. If one of the two {@code RichIterable}s is longer than the other, its
     * remaining elements are ignored.
     *
     * @param that The {@code RichIterable} providing the second half of each result pair
     * @param &lt;S&gt;  the type of the second half of the returned pairs
     * @return A new {@code RichIterable} containing pairs consisting of corresponding elements of this {@code
     * RichIterable} and that. The length of the returned {@code RichIterable} is the minimum of the lengths of
     * this {@code RichIterable} and that.
     * @since 1.0
     * @deprecated in 6.0. Use {@link OrderedIterable#zip(Iterable)} instead.
     */
    @Deprecated
    &lt;S&gt; RichIterable&lt;Pair&lt;T, S&gt;&gt; zip(Iterable&lt;S&gt; that);

    /**
     * Same as {@link #zip(Iterable)} but uses {@code target} for output.
     *
     * @since 1.0
     * @deprecated in 6.0. Use {@link OrderedIterable#zip(Iterable, Collection)} instead;
     */
    @Deprecated
    &lt;S, R extends Collection&lt;Pair&lt;T, S&gt;&gt;&gt; R zip(Iterable&lt;S&gt; that, R target);

    /**
     * Zips this {@code RichIterable} with its indices.
     *
     * @return A new {@code RichIterable} containing pairs consisting of all elements of this {@code RichIterable}
     * paired with their index. Indices start at 0.
     * @see #zip(Iterable)
     * @since 1.0
     * @deprecated in 6.0. Use {@link OrderedIterable#zipWithIndex()} instead.
     */
    @Deprecated
    RichIterable&lt;Pair&lt;T, Integer&gt;&gt; zipWithIndex();

    /**
     * Same as {@link #zipWithIndex()} but uses {@code target} for output.
     *
     * @since 1.0
     * @deprecated in 6.0. Use {@link OrderedIterable#zipWithIndex(Collection)} instead.
     */
    @Deprecated
    &lt;R extends Collection&lt;Pair&lt;T, Integer&gt;&gt;&gt; R zipWithIndex(R target);

    /**
     * Partitions elements in fixed size chunks.
     *
     * @param size the number of elements per chunk
     * @return A {@code RichIterable} containing {@code RichIterable}s of size {@code size}, except the last will be
     * truncated if the elements don't divide evenly.
     * @since 1.0
     */
    RichIterable&lt;RichIterable&lt;T&gt;&gt; chunk(int size);

    /**
     * Applies an aggregate procedure over the iterable grouping results into a Map based on the specific groupBy function.
     * Aggregate results are required to be mutable as they will be changed in place by the procedure.  A second function
     * specifies the initial &quot;zero&quot; aggregate value to work with (i.e. new AtomicInteger(0)).
     *
     * @since 3.0
     */
    &lt;K, V&gt; MapIterable&lt;K, V&gt; aggregateInPlaceBy(Function&lt;? super T, ? extends K&gt; groupBy, Function0&lt;? extends V&gt; zeroValueFactory, Procedure2&lt;? super V, ? super T&gt; mutatingAggregator);

    /**
     * Applies an aggregate function over the iterable grouping results into a map based on the specific groupBy function.
     * Aggregate results are allowed to be immutable as they will be replaced in place in the map.  A second function
     * specifies the initial &quot;zero&quot; aggregate value to work with (i.e. Integer.valueOf(0)).
     *
     * @since 3.0
     */
    &lt;K, V&gt; MapIterable&lt;K, V&gt; aggregateBy(Function&lt;? super T, ? extends K&gt; groupBy, Function0&lt;? extends V&gt; zeroValueFactory, Function2&lt;? super V, ? super T, ? extends V&gt; nonMutatingAggregator);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>