// code by mg
package ch.ethz.idsc.demo.mg.slam.vis;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;

import ch.ethz.idsc.demo.mg.slam.config.SlamCoreConfig;
import ch.ethz.idsc.retina.util.img.ImageReflect;
import ch.ethz.idsc.retina.util.math.Magnitude;
import ch.ethz.idsc.tensor.Tensor;
import ch.ethz.idsc.tensor.io.Primitives;

/** gives an image of the maps generated by the SLAM algorithm */
/* package */ class SlamMapFrame {
  private final BufferedImage bufferedImage;
  private final Graphics2D graphics;
  private final byte[] bytes;
  private final double cellDim;
  private final double waypointRadius;
  private final double kartLength;
  private final int mapWidth;
  private final int mapHeight;
  // ---
  // TODO MG talk to jan
  private static double cornerX;
  private static double cornerY;

  SlamMapFrame() {
    mapWidth = SlamCoreConfig.GLOBAL.mapWidth();
    mapHeight = SlamCoreConfig.GLOBAL.mapHeight();
    cornerX = Magnitude.METER.toDouble(SlamCoreConfig.GLOBAL.corner.Get(0));
    cornerY = Magnitude.METER.toDouble(SlamCoreConfig.GLOBAL.corner.Get(1));
    cellDim = Magnitude.METER.toDouble(SlamCoreConfig.GLOBAL.cellDim);
    kartLength = SlamCoreConfig.GLOBAL.kartLength();
    waypointRadius = SlamCoreConfig.GLOBAL.waypointRadius();
    bufferedImage = new BufferedImage(mapWidth, mapHeight, BufferedImage.TYPE_BYTE_INDEXED);
    graphics = bufferedImage.createGraphics();
    DataBufferByte dataBufferByte = (DataBufferByte) bufferedImage.getRaster().getDataBuffer();
    bytes = dataBufferByte.getData();
  }

  public static void setCorners(double cornerXNew, double cornerYNew) {
    cornerX = cornerXNew;
    cornerY = cornerYNew;
  }

  /** draws an ellipse representing the vehicle pose onto the map frame
   * 
   * @param pose with or without units
   * @param color in which ellipse representing vehicle is filled */
  public void addGokartPose(Tensor pose, Color color) {
    SlamMapFrameUtil.addGokartPose(pose, color, graphics, cornerX, cornerY, cellDim, kartLength);
  }

  /** draws the way points in different color according to their validities
   * 
   * @param worldWaypoints in world frame
   * @param validities */
  public void drawSlamWaypoints(Tensor worldWaypoints, boolean[] validities) {
    for (int i = 0; i < worldWaypoints.length(); ++i) {
      Color color = validities[i] ? Color.GREEN : Color.ORANGE;
      SlamMapFrameUtil.drawPoint(graphics, Primitives.toDoubleArray(worldWaypoints.get(i)), color, waypointRadius, cornerX, cornerY, cellDim);
    }
  }

  /** @param pointCoord world frame
   * @param color
   * @param radius [m] */
  public void drawPoint(double[] pointCoord, Color color, double radius) {
    radius /= cellDim;
    SlamMapFrameUtil.drawPoint(graphics, pointCoord, color, radius, cornerX, cornerY, cellDim);
  }

  /** @return frame such that x axis points right and y axis points upwards of underlying map object */
  public BufferedImage getFrame() {
    return ImageReflect.flipHorizontal(bufferedImage);
  }

  public byte[] getBytes() {
    return bytes;
  }
}